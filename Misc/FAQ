Subject: FAQ: Python -- an object-oriented language
Newsgroups: comp.lang.python,comp.answers,news.answers
Followup-to: comp.lang.python
From: guido@cwi.nl (Guido van Rossum)
Reply-to: guido@cwi.nl (Guido van Rossum)
Approved: news-answers-request@MIT.Edu

Archive-name: python-faq/part1
Version: 1.12
Last-modified: 25 July 1994

This article contains answers to Frequently Asked Questions about
Python (an object-oriented interpreted programming language -- see
the answer to question 1.1 for a short overview).

Copyright 1993, 1994 Guido van Rossum.  Unchanged electronic
redistribution of this FAQ is allowed.  Printed redistribution only
with permission of the author.  No warranties.

Author's address:
	Guido van Rossum
	CWI, dept. CST
	Kruislaan 413
	P.O. Box 94079
	1090 GB  Amsterdam
	The Netherlands
Email:	guido@cwi.nl

The latest version of this FAQ is available by anonymous ftp from
ftp.cwi.nl [192.16.191.128] in the directory /pub/python, with
filename python-FAQ.  It will also be posted regularly to the
newsgroups comp.answers and comp.lang.python.

Many FAQs, including this one, are available by anonymous ftp from
rtfm.mit.edu [18.181.0.24] in the directory pub/usenet/news.answers.  
The name under which a FAQ is archived appears in the Archive-name line 
at the top of the article.  This FAQ is archived as python-faq/part1.

There's a mail server on that machine which will send you files from
the archive by e-mail if you have no ftp access.  You send a e-mail
message to mail-server@rtfm.mit.edu containing the single word help in
the message body to receive instructions.

This FAQ is divided in the following chapters:

 1. General information and availability
 2. Python in the real world
 3. Building Python
 4. Programming in Python
 5. Extending Python
 6. Python's design
 7. Using Python on non-UNIX platforms

To find the start of a particular chapter, search for the chapter number
followed by a dot and a space at the beginning of a line (e.g. to
find chapter 4 in vi, type /^4\. /).

Here's an overview of the questions per chapter:

 1. General information and availability
  1.1. Q. What is Python?
  1.2. Q. Why is it called Python?
  1.3. Q. How do I obtain a copy of the Python source?
  1.4. Q. How do I get documentation on Python?
  1.5. Q. Are there other ftp sites that mirror the Python distribution?
  1.6. Q. Is there a newsgroup or mailing list devoted to Python?
  1.7. Q. Is there a book on Python, or will there be one out soon?
  1.8. Q. Are there any published articles about Python that I can quote?
  1.9. Q. How does the Python version numbering scheme work?
  1.10. Q. Are there other ftp sites that carry Python related material?
  1.11. Q. Are there copyright restrictions on the use of Python?

 2. Python in the real world
  2.1. Q. How many people are using Python?
  2.2. Q. Have any significant projects been done in Python?
  2.3. Q. Are there any commercial projects going on using Python?
  2.4. Q. How stable is Python?
  2.5. Q. What new developments are expected for Python in the future?
  2.6. Q. Is it reasonable to propose incompatible changes to Python?

 3. Building Python
  3.1. Q. Is there a test set?
  3.2. Q. When running the test set, I get complaints about floating point
       operations, but when playing with floating point operations I cannot
       find anything wrong with them.
  3.3. Q. Link errors building Python with STDWIN on SGI IRIX.
  3.4. Q. Link errors after rerunning the configure script.
  3.5. Q. The python interpreter complains about options passed to a
       script (after the script name).
  3.6. Q. When building on the SGI, make tries to run python to create
       glmodule.c, but python hasn't been built or installed yet.
  3.7. Q. Python built with gcc for the DEC Alpha doesn't work.
  3.8. Q. Other trouble building Python on platform X.

 4. Programming in Python
  4.1. Q. Is there a source code level debugger with breakpoints, step,
       etc.?
  4.2. Q. Can I create an object class with some methods implemented in
       C and others in Python (e.g. through inheritance)?  (Also phrased as:
       Can I use a built-in type as base class?)
  4.3. Q. Is there a curses/termcap package for Python?
  4.4. Q. Is there an equivalent to C's onexit() in Python?
  4.5. Q. When I define a function nested inside another function, the
       nested function seemingly can't access the local variables of the
       outer function.  What is going on?  How do I pass local data to a
       nested function?
  4.6. Q. How do I iterate over a sequence in reverse order?
  4.7. Q. My program is too slow.  How do I speed it up?
  4.8. Q. When I have imported a module, then edit it, and import it
       again (into the same Python process), the changes don't seem to take
       place.  What is going on?
  4.9. Q. I have a module in which I want to execute some extra code when it
       is run as a script.  How do I find out whether I am running as a
       script?
  4.10. Q. I try to run a program from the Demo directory but it fails with
        ImportError: No module named ...; what gives?
  4.11. Q. What GUI toolkits exist for Python?
  4.12. Q. Are there any interfaces to commercial database in Python?

 5. Extending Python
  5.1. Q. Can I create my own functions in C?
  5.2. Q. Can I create my own functions in C++?
  5.3. Q. How can I execute arbitrary Python statements from C?
  5.4. Q. How can I evaluate an arbitrary Python expression from C?
  5.5. Q. How do I extract C values from a Python object?
  5.6. Q. How do I use mkvalue() to create a tuple of arbitrary length?

 6. Python's design
  6.1. Q. Why isn't there a generic copying operation for objects in
       Python?
  6.2. Q. Why isn't there a generic way to implement persistent objects
       in Python?  (Persistent == automatically saved to and restored from
       disk.)
  6.3. Q. Why isn't there a switch or case statement in Python?
  6.4. Q. Why does Python use indentation for grouping of statements?
  6.5. Q. Why are Python strings immutable?
  6.6. Q. Why don't strings have methods like index() or sort(), like
       lists?
  6.7. Q. Why does Python use methods for some functionality
       (e.g. list.index()) but functions for other (e.g. len(list))?
  6.8. Q. Why can't I derive a class from built-in types (e.g. lists or
       files)?
  6.9. Q. Why must 'self' be declared and used explicitly in method
       definitions and calls?

 7. Using Python on non-UNIX platforms
  7.1. Q. Is there a Mac version of Python?
  7.2. Q. Is there a DOS version of Python?
  7.3. Q. Is there a Windows version of Python?
  7.4. Q. Is there a Windows NT version of Python?
  7.5. Q. Is there an OS/2 version of Python?
  7.6. Q. I have the PC version but it appears to be only a binary.
       Where's the library?
  7.7. Q. Where's the documentation for the Mac or PC version?
  7.8. Q. The Mac (PC) version doesn't seem to have any facilities for
       creating or editing programs apart from entering it interactively, and
       there seems to be no way to save code that was entered interactively.
       How do I create a Python program on the Mac (PC)?

To find a particular question, search for the question number followed
by a dot, a space, and a Q at the beginning of a line (e.g. to find
question 4.2 in vi, type /^4\.2\. Q/).


1. General information and availability
=======================================

1.1. Q. What is Python?

A. Python is an interpreted, interactive, object-oriented programming
language.  It incorporates modules, exceptions, dynamic typing, very
high level dynamic data types, and classes.  Python combines
remarkable power with very clear syntax.  It has interfaces to many
system calls and libraries, as well as to various window systems, and
is extensible in C or C++.  It is also usable as an extension language
for applications that need a programmable interface.  Finally, Python
is portable: it runs on many brands of UNIX, on the Mac, and on
MS-DOS.

To find out more, the best thing to do is to start reading the
tutorial from the documentation set (see a few questions further
down).

1.2. Q. Why is it called Python?

A. Apart from being a computer wizard, I'm also a fan of "Monty
Python's Flying Circus" (a BBC comedy series from the seventies, in
the -- unlikely -- case you didn't know).  It occurred to me one day
that I needed a name that was short, unique, and slightly mysterious.
And I happened to be reading some scripts from the series at the
time...  So then I decided to call my language Python.  But Python is
not a joke.  And don't you associate it with dangerous reptiles
either!

1.3. Q. How do I obtain a copy of the Python source?

A. The latest Python source distribution is always available by
anonymous ftp from ftp.cwi.nl [192.16.191.128] in the directory
/pub/python, with filename python<version>.tar.gz.  (Old versions may
have an extension of .Z, indicating use of "compress" compression.)
It is a gzip'ed tar file containing the complete C source, LaTeX
documentation, Python library modules, example programs, and several
useful pieces of freely distributable software.  This will compile and
run out of the box on most UNIX platforms.  (See section 7 for
non-UNIX information.)

1.4. Q. How do I get documentation on Python?

A. The latest Python documentation set is always available by
anonymous ftp from ftp.cwi.nl [192.16.191.128] in the directory
/pub/python, with filename pythondoc-ps<version>.tar.gz.  It is a
gzip'ed tar file containing PostScript files of the reference manual,
the library manual, and the tutorial.  Note that the library manual is
the most important one of the set, as much of Python's power stems
from the standard or built-in types, functions and modules, all of
which are described here.  PostScript for a high-level description of
Python is in the file nluug-paper.ps.

1.5. Q. Are there other ftp sites that mirror the Python distribution?

A. The following sites keep mirrors of the Python distribution:

Site			IP address 	Directory

gatekeeper.dec.com	16.1.0.2	/pub/plan/python
ftp.uu.net		192.48.96.9	/languages/python
ftp.wustl.edu		128.252.135.4	/graphics/graphics/sgi-stuff/python
ftp.funet.fi		128.214.6.100	/pub/languages/python
ftp.fu-berlin.de	130.133.1.18	/unix/languages/python (*python* only)
ftp.sunet.se		130.238.127.3	/pub/lang/python
unix.hensa.ac.uk	129.12.43.16	/uunet/languages/python

Or try archie on e.g. python1.0 to locate the nearest copy of that
version...

1.6. Q. Is there a newsgroup or mailing list devoted to Python?

A. There is a newsgroup, comp.lang.python, and a mailing list.  The
newsgroup and mailing list are gatewayed into each other -- if you can
read news it is not necessary to subscribe to the mailing list.  Send
e-mail to python-list-request@cwi.nl to (un)subscribe to the mailing
list.  Once you're on, send e-mail tp python-list@cwi.nl to send mail
to the entire mailing list and newsgroup.

1.7. Q. Is there a book on Python, or will there be one out soon?

A. Unfortunately, not yet.  Mark Lutz and I are planning to write one,
but we are still a in very preliminary stage.  If you would like to
beat us at it and get rich from book royalties, go ahead!

1.8. Q. Are there any published articles about Python that I can quote?

A. So far the only refereed and published article that describes
Python in some detail is:

    Guido van Rossum and Jelke de Boer, "Interactively Testing Remote
    Servers Using the Python Programming Language", CWI Quarterly, Volume
    4, Issue 4 (December 1991), Amsterdam, pp 283-303.

LaTeX source for this paper is available as part of the Python source
distribution.

A more recent high-level description of Python is:

    Guido van Rossum, "An Introduction to Python for UNIX/C
    Programmers", in the proceedings of the NLUUG najaarsconferentie
    1993 (dutch UNIX users group meeting november 1993).
    
PostScript for this paper and for the slides used for the accompanying
presentation can be found in the ftp directory mentioned a few
questions earlier, with filenames nluug-paper.ps and nluug-slides.ps,
respectively.

1.9. Q. How does the Python version numbering scheme work?

A. Python versions are numbered A.B.C.  A is the major version number
-- it is only incremented for major changes in functionality or source
structure.  B is the minor version number, incremented for less
earth-shattering changes to a release.  C is the patchlevel -- it is
incremented for each new release.  Note that in the past, patches have
added significant changes; in fact the changeover from 0.9.9 to 1.0.0
was the first time that either A or B changed!

1.10. Q. Are there other ftp sites that carry Python related material?

A. An interesting ftp site for Python users is ftp.markv.com
(192.122.251.1); the directory pub/python contains a growing
collection of interesting Python scripts.  To submit a script for
inclusion, place it together with a readme file (with extension
.readme) in the publicly writable directory /incoming/python.  This
service is maintained by Lance Ellinghouse <lance@markv.com>.

1.11. Q. Are there copyright restrictions on the use of Python?

A. Hardly.  You can do anything you want with the source, as long as
you leave the copyrights in, display those copyrights in any
documentation about Python that you produce, don't use the author's
institute's name in publicity without prior written permission, and
don't hold them responsible for anything (read the actual copyright
for a precise legal wording).


2. Python in the real world
===========================

2.1. Q. How many people are using Python?

A. I don't know, but the maximum number of simultaneous subscriptions
to the Python mailing list before it was gatewayed into the newsgroup
was about 180 (several of which were local redistribution lists).  I
believe that many active Python users don't bother to subscribe to the
list, and now that there's a newsgroup the mailing list subscription
is even less meaningful.  I see new names on the newsgroup all the
time and my best guess is that there are currently at least several
thousands of users.

2.2. Q. Have any significant projects been done in Python?

A. Here at CWI (the home of Python), we have written a 20,000 line
authoring environment for transportable hypermedia presentations, a
5,000 line multimedia teleconferencing tool, as well as many many
smaller programs.

The University of Virginia uses Python to control a virtual reality
engine.  Contact: Matt Conway <conway@virginia.edu>.

See also the next question.

2.3. Q. Are there any commercial projects going on using Python?

A. Several companies have revealed to me that they are planning or
considering to use Python in a future product.  The furthest is
Sunrise Software, who already have a product out using Python -- they
use Python for a GUI management application and an SNMP network
manangement application.  Contact: <info@sunrise.com>.

Infoseek is using python to implement their commercial WWW information
retrieval service.  Contact: <info@infoseek.com>.

Individuals at many other companies are using Python for
internal development (witness their contributions to the Python
mailing list or newsgroup).

Python has also been elected as an extension language by MADE, a
consortium supported by the European Committee's ESPRIT program and
consisting of Bull, CWI and some other European companies.  Contact:
Ivan Herman <ivan@cwi.nl>.

2.4. Q. How stable is Python?

A. Very stable.  While the current version number would suggest it is
in the early stages of development, in fact new, stable releases
(numbered 0.9.x and 1.0.x) have been coming out roughly every 3 to 6
months for the past four years.

2.5. Q. What new developments are expected for Python in the future?

A.  A proposal is being worked out to change the semantics of operator
overloading (__add__, __mul__ etc.) to make them more useful for
implementing types that don't resemble numbers.  Additions will be
__call__ (to call an instance as if it were a function) and __eq__,
_lt__ etc. (to override individual comparisons).  A (new) pthreads
interface has been submitted which will be integrated in the next
release.  The X11/Motif interface will be improved.  There are ideas
about built-in help using strings placed into function objects, and
possibly a switch statement.

There will be better ports to the Mac, DOS, Windows, Windows NT, and
OS/2.  The Windows ports will support dynamically loaded modules using
DLLs.  There may be a Windows version of STDWIN (someone has actually
written one and contributed it but it's not robust enough at the
moment).

Also planned is improved support for embedding Python in other
applications, e.g. by renaming most global symbols to have a "Py"
prefix and providing more documentation and threading support.

2.6. Q. Is it reasonable to propose incompatible changes to Python?

A. In general, no.  There are already millions of lines of Python code
around the world, so any changes in the language that invalidates more
than a very small fraction of existing programs has to be frowned
upon.  Even if you can provide a conversion program, there still is
the problem of updating all documentation.  Providing a gradual
upgrade path is the only way if a feature has to be changed.


3. Building Python
==================

3.1. Q. Is there a test set?

A. Yes, simply do "import testall" (or "import autotest" if you aren't
interested in the output).  The standard modules whose name begins
with "test" together comprise the test.  The test set doesn't test
*all* features of Python but it goes a long way to confirm that a new
port is actually working.  The Makefile contains an entry "make test"
which runs the autotest module.

3.2. Q. When running the test set, I get complaints about floating point
operations, but when playing with floating point operations I cannot
find anything wrong with them.

A. The test set makes occasional unwarranted assumptions about the
semantics of C floating point operations.  Until someone donates a
better floating point test set, you will have to comment out the
offending floating point tests and execute similar tests manually.

3.3. Q. Link errors building Python with STDWIN on SGI IRIX.

A. Rebuild STDWIN, specifying "CC=cc -cckr" in the Makefile.

3.4. Q. Link errors after rerunning the configure script.

A. It is generally necessary to run "make clean" after a configuration
change.

3.5. Q. The python interpreter complains about options passed to a
script (after the script name).

A. You are probably linking with GNU getopt, e.g. through -liberty.
Don't.  The reason for the complaint is that GNU getopt, unlike System
V getopt and other getopt implementations, doesn't consider a
non-option to be the end of the option list.  A quick (and compatible)
fix for scripts is to add "--" to the interpreter, like this:

	#! /usr/local/bin/python --

You can also use this interactively:

	python -- script.py [options]

3.6. Q. When building on the SGI, make tries to run python to create
glmodule.c, but python hasn't been built or installed yet.

A. Comment out the line mentioning glmodule.c in Setup and build a
python without gl first; install it or make sure it is in your $PATH,
then edit the Setup file again to turn on the gl module, and make
again.  You don't need to do "make clean"; you do need to run "make
Makefile" in the Modules subdirectory (or just run "make" at the
toplevel).

3.7. Q. Python built with gcc for the DEC Alpha doesn't work.

People have reported problems with both gcc 2.5.8 and 2.6.0.  The DEC
OSF/1 cc compiler does not have these problems so it's probably gcc's
fault.  One person reported that the problem went away when using -g
instead of -O so this may be an option if you insist on using gcc.  If
someone tracks it down more completely I'd like to hear about it!

3.8. Q. Other trouble building Python on platform X.

A. Please email the details to <guido@cwi.nl> and I'll look into it.


4. Programming in Python
========================

4.1. Q. Is there a source code level debugger with breakpoints, step,
etc.?

A. Yes.  Check out module pdb; pdb.help() prints the documentation (or
you can read it as Lib/pdb.doc).  If you use the STDWIN option,
there's also a windowing interface, wdb.  You can write your own
debugger by using the code for pdb or wdb as an example.

4.2. Q. Can I create an object class with some methods implemented in
C and others in Python (e.g. through inheritance)?  (Also phrased as:
Can I use a built-in type as base class?)

A. No, but you can easily create a Python class which serves as a
wrapper around a built-in object, e.g. (for dictionaries):

	# A user-defined class behaving almost identical
	# to a built-in dictionary.
	class UserDict:
		def __init__(self): self.data = {}
		def __repr__(self): return repr(self.data)
		def __cmp__(self, dict):
			if type(dict) == type(self.data):
				return cmp(self.data, dict)
			else:
				return cmp(self.data, dict.data)
		def __len__(self): return len(self.data)
		def __getitem__(self, key): return self.data[key]
		def __setitem__(self, key, item): self.data[key] = item
		def __delitem__(self, key): del self.data[key]
		def keys(self): return self.data.keys()
		def items(self): return self.data.items()
		def values(self): return self.data.values()
		def has_key(self, key): return self.data.has_key(key)

4.3. Q. Is there a curses/termcap package for Python?

A. No, but you can use the "alfa" (== character cell) version of
STDWIN.  (STDWIN == Standard Windows, a portable windowing system
interface by the same author, URL: ftp://ftp.cwi.nl/pub/stdwin.)
This will also prepare your program for porting to windowing
environments such as X11 or the Macintosh.

4.4. Q. Is there an equivalent to C's onexit() in Python?

A. Yes, if you import sys and assign a function to sys.exitfunc, it
will be called when your program exits, is killed by an unhandled
exception, or (on UNIX) receives a SIGHUP or SIGTERM signal.

4.5. Q. When I define a function nested inside another function, the
nested function seemingly can't access the local variables of the
outer function.  What is going on?  How do I pass local data to a
nested function?

A. Python does not have arbitrarily nested scopes.  When you need to
create a function that needs to access some data which you have
available locally, create a new class to hold the data and return a
method of an instance of that class, e.g.:

	class MultiplierClass:
		def __init__(self, factor):
			self.factor = factor
		def multiplier(self, argument):
			return argument * self.factor

	def generate_multiplier(factor):
		return MultiplierClass(factor).multiplier

	twice = generate_multiplier(2)
	print twice(10)
	# Output: 20

4.6. Q. How do I iterate over a sequence in reverse order?

A. If it is a list, the fastest solution is

	list.reverse()
	try:
		for x in list:
			"do something with x"
	finally:
		list.reverse()

This has the disadvantage that while you are in the loop, the list
is temporarily reversed.  If you don't like this, you can make a copy.
This appears expensive but is actually faster than other solutions:

	rev = list[:]
	rev.reverse()
	for x in rev:
		<do something with x>

If it isn't a list, a more general but slower solution is:

	i = len(list)
	while i > 0:
		i = i-1
		x = list[i]
		<do something with x>

A more elegant solution, is to define a class which acts as a sequence
and yields the elements in reverse order (solution due to Steve
Majewski):

	class Rev:
		def __init__(self, seq):
			self.forw = seq
		def __len__(self):
			return len(self.forw)
		def __getitem__(self, i):
			return self.forw[-(i + 1)]

You can now simply write:

	for x in Rev(list):
		<do something with x>

Unfortunately, this solution is slowest of all, due the the method
call overhead...

4.7. Q. My program is too slow.  How do I speed it up?

A. That's a tough one, in general.  There are many tricks to speed up
Python code; I would consider rewriting parts in C only as a last
resort.  One thing to notice is that function and (especially) method
calls are rather expensive; if you have designed a purely OO interface
with lots of tiny functions that don't do much more than get or set an
instance variable or call another method, you may consider using a
more direct way, e.g. directly accessing instance variables.  Also see
the standard module "profile" (described in the file
"python/lib/profile.doc") which makes it possible to find out where
your program is spending most of its time (if you have some patience
-- the profiling itself can slow your program down by an order of
magnitude).

4.8. Q. When I have imported a module, then edit it, and import it
again (into the same Python process), the changes don't seem to take
place.  What is going on?

A. For efficiency reasons, Python only reads the module file on the
first time a module is imported (otherwise a program consisting of
many modules, each of which imports the same basic module, would read
the basic module over and over again).  To force a changed module
being read again, do this:

	import modname
	reload(modname)

Warning: this technique is not 100% fool-proof.  In particular,
modules containing statements like

	from modname import some_objects

will continue to work with the old version of the objects imported
thus.

4.9. Q. I have a module in which I want to execute some extra code when it
is run as a script.  How do I find out whether I am running as a
script?

A. A module can find out its own module name by alooking at the
(predefined) global variable __name__.  If this has the value
'__main__' you are running as a script.  E.g. if you put the following
on the last line of your module, main() is called only when your
module is running as a script:

	if __name__ == '__main__': main()

4.10. Q. I try to run a program from the Demo directory but it fails with
ImportError: No module named ...; what gives?

A. This is probably an optional module which hasn't been configured on
your system.  This especially happens with modules like "stdwin",
"gl", "Xt" or "Xm".  For stdwin and many other modules, see
Modules/Setup.in for info on how to add these modules to your Python,
if it is possible at all.  Sometimes you will have to ftp and build
another package first (e.g. stdwin).  Sometimes the module only works
on specific platforms (e.g. gl only works on SGI machines).  For
X-related modules (Xt and Xm) you will have to do more work: they are
currently not part of the standard Python distribution.  You will have
to ftp the file "extensions.tar.gz" file from a Python ftp repository
(e.g. ftp.cwi.nl) and follow the instructions there.  Note: the X
related modules are still somewhat flakey, so don't try this unless
you know a bit or two about building X applications on your platform.

4.11. Q. What GUI toolkits exist for Python?

A. Depending on what platform(s) you are aiming at, there are several.

- The standard Python distribution comes with an interface to STDWIN,
a platform-independent low-level windowing interface (you have to ftp
the source for stdwin separately, e.g. from ftp.cwi.nl in pub/stdwin
or gatekeeper.dec.com in pub/misc/stdwin).  STDWIN runs under X11 or
the Mac; a Windows port is about to be released.

- For SGI only, there's an interface to the complete GL (Graphics
Library -- low level but very good 3D capabilities) as well as to
FORMS (a buttons-and-sliders-etc package built on top of GL by Mark
Overmars -- ftp'able from ftp.cs.ruu.nl in pub/SGI/FORMS).

- There's an interface to X11, including the Athena and Motif widget
sets (and a few individual widgets, like Mosaic's HTML widget and
SGI's GL widget) in the Extensions set, which is separately ftp'able
from ftp.cwi.nl as pub/python/extensions.tar.gz.

- There's an interface to SUIT, the U of Virginia's Simple User
Interface Toolkit; it can be ftp'ed from uvacs.cs.virginia.edu as
pub/suit/python/SUIT_python.tar.Z.  A PC binary of Python 1.0.2
compiled with DJGPP and with SUIT support built-in has been made
available by Antonio Costa on ftp site asterix.inescn.pt, directory
pub/PC/python, file pyt102su.exe (a self-extracting archive).

- There's a neat interface to the Tcl/Tk widget set; ftp it from
ftp.cwi.nl as pub/python/tkinter.tar.gz.

- There's an interface to WAFE, a Tcl interface to the X11 Motif and
Athena widget sets.  Last I heard about it it was included in the
WAFE 1.0 prerelease, ftp'able from ftp.wu-wien.ac.at as
pub/src/X11/wafe/wafe-1.0.tar.gz-prerelease.

4.12. Q. Are there any interfaces to commercial database in Python?

A. There's an interface to SYBASE by John Redford
<jredford@lehman.com>.

There's also an interface to metalbase by Lance Ellinghouse
<lance@markv.com>.


5. Extending Python
===================

5.1. Q. Can I create my own functions in C?

A. Yes, you can create built-in modules containing functions,
variables, exceptions and even new types in C.  This is explained in
the document "Extending and Embedding the Python Interpreter" (the
LaTeX file Doc/ext.tex).  Also read the chapter on dynamic loading.

5.2. Q. Can I create my own functions in C++?

A. Yes, using the C-compatibility features found in C++.  Basically
you place extern "C" { ... } around the Python include files and put
extern "C" before each function that is going to be called by the
Python interpreter.  Global or static C++ objects with constructors
are probably not a good idea.

5.3. Q. How can I execute arbitrary Python statements from C?

A. The highest-level function to do this is run_command() which takes
a single string argument which is executed in the context of module
__main__ and returns 0 for success and -1 when an exception occurred
(including SyntaxError).  If you want more control, use run_string();
see the source for run_command() in Python/pythonrun.c.

5.4. Q. How can I evaluate an arbitrary Python expression from C?

A. Call the function run_string() from the previous question with the
start symbol eval_input; it then parses an expression, evaluates it
and returns its value.  See exec_eval() in Python/bltinmodule.c.

5.5. Q. How do I extract C values from a Python object?

A. That depends on the object's type.  If it's a tuple,
gettuplesize(o) returns its length and gettupleitem(o, i) returns its
i'th item; similar for lists with getlistsize(o) and getlistitem(o,
i).  For strings, getstringsize(o) returns its length and
getstringvalue(o) a pointer to its value (note that Python strings may
contain null bytes so strlen() is not safe).  To test which type an
object is, first make sure it isn't NULL, and then use
is_stringobject(o), is_tupleobject(o), is_listobject(o) etc.

5.6. Q. How do I use mkvalue() to create a tuple of arbitrary length?

A. You can't.  Use t = newtupleobject(n) instead, and fill it with
objects using settupleitem(t, i, o) -- note that this "eats" a
reference count of o.  Similar for lists with newlistobject(n) and
setlistitem(l, i, o).


6. Python's design
==================

6.1. Q. Why isn't there a generic copying operation for objects in
Python?

A. Hmm.  Maybe there should be one, but it's difficult to assign a
useful meaning to copying of open files, sockets and windows, or
recursive data structures.  As long as you design all your classes
yourself you are of course free to define a standard base class that
defines an overridable copying operation for all the objects you care
about.  (One practical point: it would have to be a built-in function,
not a standard method name, since not all built-in object types have
methods; e.g. strings, integers and tuples don't.)

6.2. Q. Why isn't there a generic way to implement persistent objects
in Python?  (Persistent == automatically saved to and restored from
disk.)

A. Hmm, hmm.  Basically for the same reasons as why there is no
generic copying operation.

6.3. Q. Why isn't there a switch or case statement in Python?

A. You can do this easily enough with a sequence of
if... elif... elif... else.  There have been some proposals for switch
statement syntax, but there is no concensus (yet) on whether and how
to do range tests.

6.4. Q. Why does Python use indentation for grouping of statements?

A. Basically I believe that using indentation for grouping is
extremely elegant and contributes a lot to the clarity of the average
Python program.  Most people learn to love this feature after a while.
Some arguments for it:

- Since there are no begin/end brackets there cannot be a disagreement
between grouping perceived by the parser and the human reader.  I
remember long ago seeing a C fragment like this:

	if (x <= y)
		x++;
		y--;
	z++;

and staring a long time at it wondering why y was being decremented
even for x > y...  (And I wasn't a C newbie then either.)

- Since there are no begin/end brackets there can be no conflicting
coding styles.  In C there are loads of different ways to place the
braces (including the choice whether to place braces around single
statements in certain cases, for consistency).  If you're used to
reading (and writing) code that uses one style, you will feel at least
slightly uneasy when reading (or being required to write) another
style.

- Many coding styles place begin/end brackets on a line by themself.
This makes programs considerably longer and wastes valuable screen
space, making it harder to get a good overview over a program.
Ideally, a function should fit on one basic tty screen (say, 20
lines).  20 lines of Python are worth a LOT more than 20 lines of C.
This is not solely due to the lack of begin/end brackets (the lack of
declarations also helps, and the powerful operations of course), but
it certainly helps!

6.5. Q. Why are Python strings immutable?

A. There are two advantages.  One is performance: knowing that a
string is immutable makes it easy to lay it out at construction time
-- fixed and unchanging storage requirements.  (This is also one of
the reasons for the the distinction between tuples and lists.)  The
other is that strings in Python are considered as "elemental" as
numbers.  No amount of activity will change the value 8 to anything
else, and in Python, no amount of activity will change the string
"eight" to anything else.  (Adapted from Jim Roskind)

6.6. Q. Why don't strings have methods like index() or sort(), like
lists?

A. Good question.  Strings currently don't have methods at all
(likewise tuples and numbers).  Long ago, it seemed unnecessary to
implement any of these functions in C, so a standard library module
"string" written in Python was created that performs string related
operations.  Since then, the cry for performance has moved most of
them into the built-in module strop (this is imported by module
string, which is still the preferred interface, without loss of
performance except during initialization).  Some of these functions
(e.g. index()) could easily be implemented as string methods instead,
but others (e.g. sort()) can't, since their interface prescribes that
they modify the object, while strings are immutable (see the previous
question).

6.7. Q. Why does Python use methods for some functionality
(e.g. list.index()) but functions for other (e.g. len(list))?

A. Functions are used for those operations that are generic for a
group of types and which should work even for objects that don't have
methods at all (e.g. numbers, strings, tuples).  Also, implementing
len(), max(), min() as a built-in function is actually less code than
implementing them as methods for each type.  One can quibble about
individual cases but it's really too late to change such things
fundamentally now.

6.8. Q. Why can't I derive a class from built-in types (e.g. lists or
files)?

A. This is caused by the relatively late addition of (user-defined)
classes to the language -- the implementation framework doesn't easily
allow it.  See the answer to question 4.2 for a work-around.  This
*may* be fixed in the (distant) future.

6.9. Q. Why must 'self' be declared and used explicitly in method
definitions and calls?

A. By asking this question you reveal your C++ background. :-)
When I added classes, this was (again) the simplest way of
implementing methods without too many changes to the interpreter.  I
borrowed the idea from Modula-3.  It turns out to be very useful, for
a variety of reasons.

First, it makes it more obvious that you are using a method or
instance attribute instead of a local variable.  Reading "self.x" or
"self.meth()" makes it absolutely clear that an instance variable or
method is used even if you don't know the class definition by heart.
In C++, you can sort of tell by the lack of a local variable
declaration (assuming globals are rare or reasily recognizable) -- but
in Python, there are no local variable declarations, so you'd have to
look up the class definition to be sure.

Second, it means that no special syntax is necessary if you want to
explicitly reference or call the method from a particular class.  In
C++, if you want to use a method from base class that is overridden in
a derived class, you have to use the :: operator -- in Python you can
write baseclass.methodname(self, <argument list>).  This is
particularly useful for __init__() methods, and in general in cases
where a derived class method wants to extend the base class method of
the same name and thus has to call the base class method somehow.

Lastly, for instance variables, it solves a syntactic problem with
assignment: since local variables in Python are (by definition!) those
variables to which a value assigned in a function body (and that
aren't explicitly declared global), there has to be some way to tell
the interpreter that an assignment was meant to assign to an instance
variable instead of to a local variable, and it should preferably be
syntactic (for efficiency reasons).  C++ does this through
declarations, but Python doesn't have declarations and it would be a
pity having to introduce them just for this purpose.  Using the
explicit "self.var" solves this nicely.  Similarly, for using instance
variables, having to write "self.var" means that references to
unqualified names inside a method don't have to search the instance's
directories.


7. Using Python on non-UNIX platforms
=====================================

7.1. Q. Is there a Mac version of Python?

A. Yes.  It is on most ftp sites carrying Python as python.sea.hqx --
this is a self-extracting archive containing the application binary as
well as the Lib modules.

7.2. Q. Is there a DOS version of Python?

A. Yes.  More than one, actually: 16python.exe runs in standard DOS
mode on 186 CPUs or higher; 32python.exe uses a DOS extender and only
runs on a 386 or higher CPUs.  Although 16python.exe does not pass the
test set because test_grammar is too big for the parser, it actually
has about 270 kbyte of allocatable heap space, which is sufficient for
fairly large programs.  32python.exe is distributed as a tar file
containing the required DOS extended and 387 emulator.  Both are on
most ftp sites carrying Python.

7.3. Q. Is there a Windows version of Python?

A. Yes.  Use qwpython.exe.  The only problem with it: ^C
unconditionally kills the entire program -- it does not raise
KeyboardInterrupt.  You can also run 16python.exe or 32python.exe in a
"DOS box", but qwpython.exe appears to be slightly faster.

7.4. Q. Is there a Windows NT version of Python?

A. Yes.  Use ntpython.exe.  This is for Intel CPUs.  If you want a
Windows user interface, use qwpython.exe.

7.5. Q. Is there an OS/2 version of Python?

A. Yes.  You can ftp it (from ftp.cwi.nl in pub/python, or from the
mirror sites) as pyth_os2.zip.  This contains both an executable and
Makefiles for those fortunate enough to have a C compiler.

7.6. Q. I have the PC version but it appears to be only a binary.
Where's the library?

A. You still need to copy the files from the distribution directory
"python/Lib" to your system.  If you don't have the full distribution,
you can get the file pythonlib<version>.tar.gz from most ftp sites
carrying Python; this is a subset of the distribution containing just
those file.

Once you have installed the library, you need to point sys.path to it.
Assuming the library is in C:\misc\python\lib, the following commands
will point your Python interpreter to it (note the doubled backslashes
-- you can also use single forward slashes instead):

	>>> import sys
	>>> sys.path.insert(0, 'C:\\misc\\python\\lib')
	>>>

For a more permanent effect, set the environment variable PYTHONPATH,
as follows (talking to a DOS prompt):

	C> SET PYTHONPATH=C:\misc\python\lib

7.7. Q. Where's the documentation for the Mac or PC version?

A. There isn't any.  The documentation for the Unix version also
applies to the Mac and PC versions.  Where applicable, differences
are indicated in the text.

7.8. Q. The Mac (PC) version doesn't seem to have any facilities for
creating or editing programs apart from entering it interactively, and
there seems to be no way to save code that was entered interactively.
How do I create a Python program on the Mac (PC)?

A. Use an external editor.  On the Mac, I am quite happy with the Desk
Accessory called Sigma Edit; this doesn't require Multifinder or
System 7.  I work like this: start the interpreter; edit a module file
using Sigma Edit; import and test it in the interpreter; edit again in
Sigma Edit; then use the built-in function reload() to re-read the
imported module; etc.

Regarding the same question for the PC, Kurt Wm. Hemr writes: "While
anyone with a pulse could certainly figure out how to do the same on
MS-Windows, I would recommend the NotGNU Emacs clone for MS-Windows.
Not only can you easily resave and "reload()" from Python after making
changes, but since WinNot auto-copies to the clipboard any text you
select, you can simply select the entire procedure (function) which
you changed in WinNot, switch to QWPython, and shift-ins to reenter
the changed program unit."
