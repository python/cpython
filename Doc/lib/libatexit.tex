\section{\module{atexit} ---
         exit handlers}

\declaremodule{standard}{atexit}
\moduleauthor{Skip Montanaro}{skip@mojam.com}
\sectionauthor{Skip Montanaro}{skip@mojam.com}
\modulesynopsis{Register and execute cleanup functions.}

The \module{atexit} module defines a single function to register
cleanup functions.  Functions thus registered are automatically
executed upon normal interpreter termination.

Note: the functions registered via this module are not called when the program is killed by a
signal, when a Python fatal internal error is detected, or when
\code{os._exit()} is called.

This is an alternate interface to the functionality provided by the
\code{sys.exitfunc} variable.
\withsubitem{(in sys)}{\ttindex{exitfunc}}

\begin{funcdesc}{register}{func\optional{, *args\optional{, **kargs}}}
Register \var{func} as a function to be executed at termination.  Any
optional arguments that are to be passed to \var{func} must be passed
as arguments to \function{register()}.

At normal program termination (for instance, if
\function{sys.exit()} is called or the main module's execution
completes), all functions registered are called in last in, first out
order.  The assumption is that lower level modules will normally be
imported before higher level modules and thus must be cleaned up
later.
\end{funcdesc}


\subsection{\module{atexit} Example \label{atexit-example}}

The following simple example demonstrates how a module can initialize
a counter from a file when it is imported and save the counter's
updated value automatically when the program terminates without
relying on the application making an explicit call into this module at
termination.

\begin{verbatim}
try:
    _count = int(open("/tmp/counter").read())
except IOError:
    _count = 0

def incrcounter(n):
    global _count
    _count = _count + n

def savecounter():
    open("/tmp/counter", "w").write("%d" % _count)

import atexit
atexit.register(savecounter)
\end{verbatim}

