#LaTeX2HTML Version 96.1 : dot.latex2html-init		-*- perl -*-
#

$INFO = 1;              # 0 = do not make a "About this document..." section
$MAX_LINK_DEPTH = 3;

# Python documentation uses section numbers to support references to match
# in the printed and online versions.
#
$SHOW_SECTION_NUMBERS = 1;

$HTML_VERSION = '3.0';
$ICONSERVER = '../icons';

# This replacement adds the "BORDER=0" attribute to the generated icon
# markup.  This is done for no better reason than that it looks better.
#
sub img_tag {
    local($icon) = @_;
    ( ($icon =~ /(gif)/) ?
     do {
         $icon =~ /(up|next|previous|next_page|previous_page|change_begin|change_end|change_delete|contents|index)/;
         join('','<img ',$iconsizes{$1},' align=bottom alt="',$1,
	      '" src="',$ICONSERVER,"/$icon",'" border=0>')
         } :
     $icon);
}

# This replacement for process_command() is needed to add the case for
# "\,"; it is unfortunate we need to do it this way.
#
sub process_command {
    local ($cmd_rx, *ref_contents) = @_;
    local($ref_before, $cmd, $after);
    local($cmd_sub, $cmd_msub, $cmd_trans, $mathentity);
    local (@open_font_tags,@open_size_tags);
    $ref_contents = &convert_iso_latin_chars($ref_contents);
    for (;;) {	# Do NOT use the o option
	last unless ($ref_contents =~ /$cmd_rx/ );
	($ref_before, $cmd, $after) = ($`, $1, "$2$'");
	print(".");
#	$after =~ s/^[ ]+/ /o;	 Collapse all spaces that follow a command
	if ($cmd =~ /[a-zA-Z]$/) { # Eat redundant spaces that follow a command
	    $after =~ s/^[ \t]+//o; }
	else {
	    $after =~ s/^[ \t]+/ /o; }
	if ( $cmd = &normalize($cmd) ) {
	    ($cmd_sub, $cmd_msub, $cmd_trans, $mathentity) =
		("do_cmd_$cmd", "do_math_cmd_$cmd",
		 $declarations{$cmd}, $mathentities{$cmd});
	    if (defined &$cmd_sub) {
		# $ref_before may also be modified ...
		if ($cmd =~ /$sizechange_rx/o) {
		    $after = &$cmd_sub($after, @open_size_tags);
		} else {
		    $after = &$cmd_sub($after, @open_font_tags);
		};
	    }
	    elsif (defined &$cmd_msub) {
		# $ref_before may also be modified ...
		$after = &$cmd_msub($after, @open_font_tags);
		if ( !$math_mode ) {
		    $after = "<math>" . $after . "</math>";
		    ++$commands_outside_math{$cmd};
		};
	    }
	    elsif ($cmd_trans) {	# One to one transform
		$cmd_trans =~ m|</.*$|;
		$after = $` . $after . $&;
		push(@open_font_tags, $cmd) if ($cmd =~ /$fontchange_rx/o);
		push(@open_size_tags, $cmd) if ($cmd =~ /$sizechange_rx/o);}
	    elsif ($mathentity) {
		if ( $math_mode ) {
		    $after = "&$mathentity;" . $after;
		} else {
		    $after = "<math>&$mathentity;</math>" . $after;
		    ++$commands_outside_math{$cmd};
		}; }
	    # Here's the hack:
	    elsif ($cmd == ',' && ! $AUX_FILE) {
		$ref_before = $ref_before . ",";
	    }
	    elsif ($ignore{$cmd}) { # Ignored command
		print "."}
	    elsif ($cmd =~ /^the(.+)$/) { # Counter
		$counter = $1;
		$after = &do_cmd_thecounter($after);}
	    else {
		# Do not add if reading an auxiliary file
		++$unknown_commands{$cmd} unless $AUX_FILE;
	    }
	}
	$ref_contents = join('', $ref_before, $after);
    }
    $ref_contents;
}

sub top_navigation_panel {

    # Now add a few buttons with a space between them
    "<div class=navigation>\n" .
    "$NEXT\n$UP\n$PREVIOUS\n$CONTENTS\n$INDEX $CUSTOM_BUTTONS" .

    "<br>\n" .		# Line break

    # If ``next'' section exists, add its title to the navigation panel
    ($NEXT_TITLE ? "<b> Next:</b> $NEXT_TITLE\n" : undef) .

    # Similarly with the ``up'' title ...
    ($UP_TITLE ? "<b>Up:</b> $UP_TITLE\n" : undef) .

    # ... and the ``previous'' title
    ($PREVIOUS_TITLE ? "<b> Previous:</b> $PREVIOUS_TITLE\n" : undef) .

    #  Line Break, horizontal rule (3-d dividing line) and new paragraph
    "<br><hr><p></div>\n"
}

sub bot_navigation_panel {

    #  Start with a horizontal rule (3-d dividing line)
    "\n<div class=navigation><hr>".

    # Now add a few buttons with a space between them
    "$NEXT\n$UP\n$PREVIOUS\n$CONTENTS\n$INDEX $CUSTOM_BUTTONS" .

    "<br>\n" .		# Line break

    # If ``next'' section exists, add its title to the navigation panel
    ($NEXT_TITLE ? "<b> Next:</b> $NEXT_TITLE\n" : undef) .

    # Similarly with the ``up'' title ...
    ($UP_TITLE ? "<b>Up:</b> $UP_TITLE\n" : undef) .

    # ... and the ``previous'' title
    ($PREVIOUS_TITLE ? "<b> Previous:</b> $PREVIOUS_TITLE\n" : undef) .

    "</div>\n"
}


sub gen_index_id {
    # this is used to ensure common index key generation and a stable sort
    local($str,$extra) = @_;
    sprintf("%s###%s%010d", $str, $extra, ++$global{'max_id'});
}

sub make_index_entry {
    local($br_id,$str) = @_;
    # If TITLE is not yet available (i.e the \index command is in the title of the
    # current section), use $ref_before.
    $TITLE = $ref_before unless $TITLE;
    # Save the reference
    $str = gen_index_id($str, '');
    $index{$str} .= &make_half_href("$CURRENT_FILE#$br_id");
    "<a name=\"$br_id\">$anchor_invisible_mark<\/a>";
}

sub add_idx {
    print "\nDoing the index ...";
    local($key, $str, @keys, $index, $level, $count, @previous, @current);
    @keys = keys %index;
    @keys = sort keysort  @keys;
    $level = 0;
    foreach $key (@keys) {
	@current = split(/!/, $key);
	$count = 0;
	while ($current[$count] eq $previous[$count]) {
	    $count++;
	}
	while ($count > $level) {
	    $index .= "<dl compact>\n";
	    $level++;
	}
	while ($count < $level) {
	    $index .= "</dl>\n";
	    $level--;
	}
	foreach $term (@current[$count .. $#current-1]) {
	    # need to "step in" a little
	    $index .= "<dt>" . $term . "\n<dl compact>\n";
	    $level++;
	}
	$str = $current[$#current];
	$str =~ s/\#\#\#\d+$//o;	# Remove the unique id's
	$str =~ s/\#\#\#[DR]EF\d+$//o;	# Remove the unique id's
	if (&index_key_eq(join('',@current), join('',@previous))) {
	    $index .= ",\n$index{$key}" . $cross_ref_visible_mark . "</a>"; }
	else {
	    $index .= "\n<dt>$index{$key}" . $str . "</a>"; }
	@previous = @current;
    }
    while ($count < $level) {
	$index .= "</dl>\n";
	$level--;
    }
    s/$idx_mark/<dl compact>$index<\/dl>/o;
}


sub index_key_eq {
    local($a,$b) = @_;
    $a = &clean_key($a);
    $a =~ s/\#\#\#\d+$//o;  		# Remove the unique id's
    $a =~ s/\#\#\#[dr]ef\d+$//o;	# Remove the unique id's
    $b = &clean_key($b);
    $b =~ s/\#\#\#\d+$//o;  		# Remove the unique id's
    $b =~ s/\#\#\#[dr]ef\d+$//o;	# Remove the unique id's
    $a eq $b;
}

# need to remove leading <...>
sub clean_key {
    local ($_) = @_;
    tr/A-Z/a-z/;
    s/\s//;
    s/^<[a-z][-._a-z0-9]*>//;	# Remove leading <gi>
    $_
}


$idx_module_mark = '<tex2html_idx_module_mark>';
$idx_module_title = 'Module Index';

sub add_module_idx {
    print "\nDoing the module index ...";
    local($key, @keys, $index);
    $index = "<p>";
    @keys = keys %Modules;
    @keys = sort keysort  @keys;
    foreach $key (@keys) {
	$index .= "$Modules{$key}$key</a><br>\n";
    }
    s/$idx_module_mark/$index<p>/o;
}


sub remove_general_markers {
    s/$lof_mark/<UL>$figure_captions<\/UL>/o;
    s/$lot_mark/<UL>$table_captions<\/UL>/o;
    &replace_citations if /$bbl_mark/;
    &add_toc if (/$toc_mark/);
    &add_idx if (/$idx_mark/);
    &add_module_idx if (/$idx_module_mark/);
    &replace_cross_references if /$cross_ref_mark/;
    &replace_external_references if /$external_ref_mark/;
    &replace_cite_references if /$cite_mark/;
    if (defined &replace_user_references) {
 	&replace_user_references if /$user_ref_mark/;
    }
}


# In addition to the standard stuff, add label to allow named node files.
sub do_cmd_textohtmlinfopage {
    local($_) = @_;
    if ($INFO) {
	&anchor_label("about",$CURRENT_FILE,$_);	# this is added
    }
    ( ($INFO == 1)
     ? join('', "<STRONG>$t_title</STRONG><P>\nThis document was generated using the <A HREF=\"$TEX2HTMLADDRESS\"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version $TEX2HTMLVERSION Copyright &#169; 1993, 1994, 1995, 1996,  <A HREF=\"$AUTHORADDRESS\">Nikos Drakos</A>, Computer Based Learning Unit, University of Leeds. <P> The command line arguments were: <BR>
<STRONG>latex2html</STRONG> <tt>$argv</tt>. <P>The translation was initiated by $address_data[0] on $address_data[1]", $_)
     : join('',$INFO,$_))
}

# $idx_mark will be replaced with the real index at the end.
# In addition to the standard stuff, add label to allow named node files.
sub do_cmd_textohtmlindex {
    local($_) = @_;
    $TITLE = $idx_title;
    $idxfile = $CURRENT_FILE;
    &anchor_label("genindex",$CURRENT_FILE,$_);	# this is added
    join('','<P>' , &make_section_heading($idx_title, "H2"), $idx_mark, $_);
}

# $idx_module_mark will be replaced with the real index at the end
sub do_cmd_textohtmlmoduleindex {
    local($_) = @_;
    local($key) = q/modindex/;
    $TITLE = $idx_module_title;
    &anchor_label("modindex",$CURRENT_FILE,$_);
    join('', '<p>' , &make_section_heading($idx_module_title, "h2"),
	 $idx_module_mark, $_);
}

# The bibliography and the index should be treated as separate sections
# in their own HTML files. The \bibliography{} command acts as a sectioning command
# that has the desired effect. But when the bibliography is constructed 
# manually using the thebibliography environment, or when using the
# theindex environment it is not possible to use the normal sectioning 
# mechanism. This subroutine inserts a \bibliography{} or a dummy 
# \textohtmlindex command just before the appropriate environments
# to force sectioning.

# XXX	This *assumes* that if there are two {theindex} environments, the
#	first is the module index and the second is the standard index.  This
#	is sufficient for the current Python documentation, but that's about
#	it.

sub add_bbl_and_idx_dummy_commands {
    local($id);
    s/([\\]begin\s*$O\d+$C\s*thebibliography)/$bbl_cnt++; $1/eg;
#print STDERR "\nthebibliography: $bbl_cnt\n";
    #if ($bbl_cnt == 1) {
	s/([\\]begin\s*$O\d+$C\s*thebibliography)/do { $id =  ++$global{'max_id'}; "\\bibliography$O$id$C$O$id$C $1"}/geo;
    #}
    local(@parts) = split(/\\begin\s*$O\d+$C\s*theindex/);
    if (scalar(@parts) == 3) {
	print "\n&add_bbl_and_idx_dummy_commands ==> adding module index";
	s/([\\]begin\s*$O\d+$C\s*theindex)/\\textohtmlmoduleindex $1/o;
    }
    s/([\\]begin\s*$O\d+$C\s*theindex)/\\textohtmlindex $1/o;
    s/[\\]printindex/\\textohtmlindex /o;
    &lib_add_bbl_and_idx_dummy_commands() if defined(&lib_add_bbl_and_idx_dummy_commands);
}

# The bibliographic references, the appendices, the lists of figures and tables
# etc. must appear in the contents table at the same level as the outermost
# sectioning command. This subroutine finds what is the outermost level and
# sets the above to the same level;
sub set_depth_levels {
    $section_headings['textohtmlmoduleindex'] = 'h1';
    # Sets $outermost_level
    local($level);
    foreach $level ("part", "chapter", "section", "subsection",
		    "subsubsection", "paragraph") {
	last if (($outermost_level) = /\\($level)$delimiter_rx/);
	}
    $level = ($outermost_level ? $section_commands{$outermost_level} :
	      do {$outermost_level = 'section'; 3;});
    $MAX_SPLIT_DEPTH = $MAX_SPLIT_DEPTH + $level;
    %section_commands = ('tableofcontents', $level, 'listoffigures', $level,
			 'listoftables', $level, 'bibliography', $level,
			 'textohtmlindex', $level,
			 'textohtmlmoduleindex', $level,
			 %section_commands);
}
			
1;	# This must be the last line
