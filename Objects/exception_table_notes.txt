Description of the internal format of the exception table.

Conceptually, the exception table consists of a sequence of 5-tuples:
    1. start-offset (inclusive)
    2. end-offset (exclusive)
    3. target
    4. stack-depth
    5. push-lasti (boolean)

All offsets and lengths are in instructions, not bytes.

We want the format to be compact, but quickly searchable.
For it to be compact, it needs to have variable sized entries so that we can store common (small) offsets compactly, but handle large offsets if needed.
For it to be searchable quickly, we need to support binary search giving us log(n) performance in all cases.
Binary search typically assumes fixed size entries, but that is not necesary, as long as we can identify the start of an entry.

It is worth noting that the size (end-start) is always smaller than the end, so we encode the entries as:
    start, size, target, depth, push-lasti

Also, sizes are limited to 2**30 as the code length cannot exceed 2**31 and each instruction takes 2 bytes.
It also happens that depth is generally quite small.

So, we need to encode:
    start (up to 30 bits)
    size (up to 30 bits)
    target (up to 30 bits)
    depth (up to ~8 bits)
    lasti (1 bit)

We need a marker for the start of the entry, so the first byte of entry will have the most significant bit set.
Since the most significant bit is reserved for marking the start of an entry, we have 7 bits per byte to encode offsets.
Encoding uses a standard varint encoding, but with only 7 bits instead of the usual 8.
The 8 bits of a bit are (msb left) SXdddddd where S is the start bit. X is the extend bit meaning that the next byte is required to extend the offset.

In addition, we will combine depth and lasti into a single value, ((depth<<1)+lasti), before encoding.

For example, the exception entry:
    start:  20
    end:    28
    target: 100
    depth:  3
    lasti:  False

is encoded first by converting to the more compact four value form:
    start:         20
    size:          8
    target:        100
  depth<<1+lasti:  6

which is then encoded as:
    148 (MSB + 20 for start)
    8   (size)
    65  (Extend bit + 1)
    36  (Remainder of target, 100 == (1<<6)+36)
    6

for a total of five bytes.



Script to parse the exception table
-----------------------------------

def parse_varint(iterator):
    b = next(iterator)
    val = b & 63
    while b&64:
        val <<= 6
        b = next(iterator)
        val |= b&63
    return val

def parse_exception_table(code):
    iterator = iter(code.co_exceptiontable)
    try:
        while True:
            start = parse_varint(iterator)*2
            length = parse_varint(iterator)*2
            end = start + length - 2 # Present as inclusive, not exclusive
            target = parse_varint(iterator)*2
            dl = parse_varint(iterator)
            depth = dl >> 1
            lasti = bool(dl&1)
            yield start, end, target, depth, lasti
    except StopIteration:
        return
