// This file is generated by Tools/cases_generator/partial_evaluator_generator.py
// from:
//   Python/partial_evaluator_bytecodes.c
// Do not edit!

        case _NOP: {
            break;
        }

        case _CHECK_PERIODIC: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _CHECK_PERIODIC_IF_NOT_YIELD_FROM: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        /* _QUICKEN_RESUME is not a viable micro-op for tier 2 */

        case _RESUME_CHECK: {
            MATERIALIZE_INST();
            break;
        }

        /* _MONITOR_RESUME is not a viable micro-op for tier 2 */

        case _LOAD_FAST_CHECK: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = GETLOCAL(oparg);
            // We guarantee this will error - just bail and don't optimize it.
            if (sym_is_null(&value)) {
                ctx->done = true;
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST: {
            _Py_UopsPESlot value;
            value = GETLOCAL(oparg);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST_AND_CLEAR: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = GETLOCAL(oparg);
            GETLOCAL(oparg) = sym_new_null(ctx);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST: {
            _Py_UopsPESlot value;
            // Should've all been converted by specializer.
            Py_UNREACHABLE();
            // Just to please the code generator that value is defined.
            value = sym_new_const(ctx, NULL);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST_IMMORTAL: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SMALL_INT: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_FAST: {
            _Py_UopsPESlot value;
            value = stack_pointer[-1];
            value = stack_pointer[-1];
            _PyUOpInstruction *origin = sym_get_origin(&value);
            // Gets rid of things like x = x.
            if (sym_is_virtual(&value) &&
                origin != NULL &&
                origin->opcode == _LOAD_FAST &&
                origin->oparg == oparg) {
                // Leave it as virtual.
            }
            else {
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                materialize(&value);
                MATERIALIZE_INST();
                GETLOCAL(oparg) = value;
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _POP_TOP: {
            _Py_UopsPESlot value;
            value = stack_pointer[-1];
            value = stack_pointer[-1];
            if (!sym_is_virtual(&value)) {
                MATERIALIZE_INST();
            }
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_NULL: {
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _END_SEND: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot receiver;
            _Py_UopsPESlot val;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            receiver = stack_pointer[-2];
            materialize(&receiver);
            val = sym_new_not_null(ctx);
            stack_pointer[-2] = val;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNARY_NEGATIVE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _UNARY_NOT: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_BOOL: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            break;
        }

        case _TO_BOOL_INT: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_LIST: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_NONE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_STR: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _REPLACE_WITH_TRUE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _UNARY_INVERT: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _GUARD_BOTH_INT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            break;
        }

        case _GUARD_NOS_INT: {
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot left;
            _Py_UopsPESlot unused_1;
            MATERIALIZE_INST();
            unused_0 = stack_pointer[-1];
            materialize(&unused_0);
            left = stack_pointer[-2];
            materialize(&left);
            break;
        }

        case _GUARD_TOS_INT: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_ADD_INT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_BOTH_FLOAT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            break;
        }

        case _GUARD_NOS_FLOAT: {
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot left;
            _Py_UopsPESlot unused_1;
            MATERIALIZE_INST();
            unused_0 = stack_pointer[-1];
            materialize(&unused_0);
            left = stack_pointer[-2];
            materialize(&left);
            break;
        }

        case _GUARD_TOS_FLOAT: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_BOTH_UNICODE: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_INPLACE_ADD_UNICODE: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR: {
            _Py_UopsPESlot sub;
            _Py_UopsPESlot container;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            sub = stack_pointer[-1];
            materialize(&sub);
            container = stack_pointer[-2];
            materialize(&container);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SLICE: {
            _Py_UopsPESlot stop;
            _Py_UopsPESlot start;
            _Py_UopsPESlot container;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            stop = stack_pointer[-1];
            materialize(&stop);
            start = stack_pointer[-2];
            materialize(&start);
            container = stack_pointer[-3];
            materialize(&container);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SLICE: {
            _Py_UopsPESlot stop;
            _Py_UopsPESlot start;
            _Py_UopsPESlot container;
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            stop = stack_pointer[-1];
            materialize(&stop);
            start = stack_pointer[-2];
            materialize(&start);
            container = stack_pointer[-3];
            materialize(&container);
            v = stack_pointer[-4];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -4;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR_LIST_INT: {
            _Py_UopsPESlot sub_st;
            _Py_UopsPESlot list_st;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            sub_st = stack_pointer[-1];
            materialize(&sub_st);
            list_st = stack_pointer[-2];
            materialize(&list_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR_STR_INT: {
            _Py_UopsPESlot sub_st;
            _Py_UopsPESlot str_st;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            sub_st = stack_pointer[-1];
            materialize(&sub_st);
            str_st = stack_pointer[-2];
            materialize(&str_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR_TUPLE_INT: {
            _Py_UopsPESlot sub_st;
            _Py_UopsPESlot tuple_st;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            sub_st = stack_pointer[-1];
            materialize(&sub_st);
            tuple_st = stack_pointer[-2];
            materialize(&tuple_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR_DICT: {
            _Py_UopsPESlot sub_st;
            _Py_UopsPESlot dict_st;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            sub_st = stack_pointer[-1];
            materialize(&sub_st);
            dict_st = stack_pointer[-2];
            materialize(&dict_st);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SUBSCR_CHECK_FUNC: {
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot container;
            _Py_UopsPESlot unused_1;
            MATERIALIZE_INST();
            unused_0 = stack_pointer[-1];
            materialize(&unused_0);
            container = stack_pointer[-2];
            materialize(&container);
            break;
        }

        case _BINARY_SUBSCR_INIT_CALL: {
            _Py_UopsPESlot sub;
            _Py_UopsPESlot container;
            _Py_UopsPESlot new_frame;
            sub = stack_pointer[-2];
            container = stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&container);
            materialize(&sub);
            new_frame = (_Py_UopsPESlot){NULL, NULL};
            ctx->done = true;
            stack_pointer[-2] = new_frame;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LIST_APPEND: {
            _Py_UopsPESlot v;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot list;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            v = stack_pointer[-1];
            materialize(&v);
            unused_0 = &stack_pointer[-1 - (oparg-1)];
            for (int _i = oparg-1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            list = stack_pointer[-2 - (oparg-1)];
            materialize(&list);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SET_ADD: {
            _Py_UopsPESlot v;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot set;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            v = stack_pointer[-1];
            materialize(&v);
            unused_0 = &stack_pointer[-1 - (oparg-1)];
            for (int _i = oparg-1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            set = stack_pointer[-2 - (oparg-1)];
            materialize(&set);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR: {
            _Py_UopsPESlot sub;
            _Py_UopsPESlot container;
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            sub = stack_pointer[-1];
            materialize(&sub);
            container = stack_pointer[-2];
            materialize(&container);
            v = stack_pointer[-3];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR_LIST_INT: {
            _Py_UopsPESlot sub_st;
            _Py_UopsPESlot list_st;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            sub_st = stack_pointer[-1];
            materialize(&sub_st);
            list_st = stack_pointer[-2];
            materialize(&list_st);
            value = stack_pointer[-3];
            materialize(&value);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR_DICT: {
            _Py_UopsPESlot sub;
            _Py_UopsPESlot dict_st;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            sub = stack_pointer[-1];
            materialize(&sub);
            dict_st = stack_pointer[-2];
            materialize(&dict_st);
            value = stack_pointer[-3];
            materialize(&value);
            materialize_ctx(ctx);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_SUBSCR: {
            _Py_UopsPESlot sub;
            _Py_UopsPESlot container;
            MATERIALIZE_INST();
            sub = stack_pointer[-1];
            materialize(&sub);
            container = stack_pointer[-2];
            materialize(&container);
            materialize_ctx(ctx);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_INTRINSIC_1: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _CALL_INTRINSIC_2: {
            _Py_UopsPESlot value1_st;
            _Py_UopsPESlot value2_st;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value1_st = stack_pointer[-1];
            materialize(&value1_st);
            value2_st = stack_pointer[-2];
            materialize(&value2_st);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _RETURN_VALUE: {
            _Py_UopsPESlot retval;
            _Py_UopsPESlot res;
            retval = stack_pointer[-1];
            retval = stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&retval);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            ctx->frame->stack_pointer = stack_pointer;
            frame_pop(ctx);
            stack_pointer = ctx->frame->stack_pointer;
            res = retval;
            /* Stack space handling */
            assert(corresponding_check_stack == NULL);
            assert(co != NULL);
            int framesize = co->co_framesize;
            assert(framesize > 0);
            assert(framesize <= curr_space);
            curr_space -= framesize;
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code(this_instr);
            if (co == NULL) {
                // might be impossible, but bailing is still safe
                ctx->done = true;
            }
            break;
        }

        case _GET_AITER: {
            _Py_UopsPESlot obj;
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            obj = stack_pointer[-1];
            materialize(&obj);
            iter = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        case _GET_ANEXT: {
            _Py_UopsPESlot aiter;
            _Py_UopsPESlot awaitable;
            MATERIALIZE_INST();
            aiter = stack_pointer[-1];
            materialize(&aiter);
            awaitable = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = awaitable;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GET_AWAITABLE: {
            _Py_UopsPESlot iterable;
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iterable = stack_pointer[-1];
            materialize(&iterable);
            iter = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 */

        case _SEND_GEN_FRAME: {
            _Py_UopsPESlot v;
            _Py_UopsPESlot receiver;
            _Py_UopsPESlot gen_frame;
            v = stack_pointer[-2];
            receiver = stack_pointer[-1];
            gen_frame = (_Py_UopsPESlot){NULL, NULL};
            MATERIALIZE_INST();
            // We are about to hit the end of the trace:
            ctx->done = true;
            stack_pointer[-1] = gen_frame;
            break;
        }

        case _YIELD_VALUE: {
            _Py_UopsPESlot retval;
            _Py_UopsPESlot value;
            retval = stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&retval);
            value = sym_new_unknown(ctx);
            stack_pointer[-1] = value;
            break;
        }

        case _POP_EXCEPT: {
            _Py_UopsPESlot exc_value;
            MATERIALIZE_INST();
            exc_value = stack_pointer[-1];
            materialize(&exc_value);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_COMMON_CONSTANT: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_BUILD_CLASS: {
            _Py_UopsPESlot bc;
            MATERIALIZE_INST();
            bc = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = bc;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_NAME: {
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            v = stack_pointer[-1];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_NAME: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _UNPACK_SEQUENCE: {
            _Py_UopsPESlot seq;
            _Py_UopsPESlot *output;
            output = &stack_pointer[-1];
            seq = stack_pointer[-1];
            /* This has to be done manually */
            MATERIALIZE_INST();
            materialize(&seq);
            for (int i = 0; i < oparg; i++) {
                output[i] = sym_new_unknown(ctx);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE: {
            _Py_UopsPESlot seq;
            _Py_UopsPESlot val1;
            _Py_UopsPESlot val0;
            MATERIALIZE_INST();
            seq = stack_pointer[-1];
            materialize(&seq);
            val1 = sym_new_not_null(ctx);
            val0 = sym_new_not_null(ctx);
            stack_pointer[-1] = val1;
            stack_pointer[0] = val0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE: {
            _Py_UopsPESlot seq;
            _Py_UopsPESlot *values;
            MATERIALIZE_INST();
            seq = stack_pointer[-1];
            materialize(&seq);
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_LIST: {
            _Py_UopsPESlot seq;
            _Py_UopsPESlot *values;
            MATERIALIZE_INST();
            seq = stack_pointer[-1];
            materialize(&seq);
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_EX: {
            _Py_UopsPESlot seq;
            _Py_UopsPESlot *left;
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot *right;
            left = &stack_pointer[-1];
            right = &stack_pointer[(oparg & 0xFF)];
            seq = stack_pointer[-1];
            /* This has to be done manually */
            MATERIALIZE_INST();
            materialize(&seq);
            int totalargs = (oparg & 0xFF) + (oparg >> 8) + 1;
            for (int i = 0; i < totalargs; i++) {
                left[i] = sym_new_unknown(ctx);
            }
            (void)right;
            stack_pointer += (oparg & 0xFF) + (oparg >> 8);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            v = stack_pointer[-2];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_ATTR: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_GLOBAL: {
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            v = stack_pointer[-1];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_GLOBAL: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _LOAD_LOCALS: {
            _Py_UopsPESlot locals;
            MATERIALIZE_INST();
            locals = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = locals;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _LOAD_FROM_DICT_OR_GLOBALS is not a viable micro-op for tier 2 */

        case _LOAD_NAME: {
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            v = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = v;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL: {
            _Py_UopsPESlot *res;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            res = &stack_pointer[0];
            res[0] = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            materialize_ctx(ctx);
            if (oparg & 1) stack_pointer[1] = null;
            stack_pointer += 1 + (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            MATERIALIZE_INST();
            break;
        }

        case _GUARD_GLOBALS_VERSION_PUSH_KEYS: {
            _Py_UopsPESlot globals_keys;
            MATERIALIZE_INST();
            globals_keys = sym_new_not_null(ctx);
            stack_pointer[0] = globals_keys;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_BUILTINS_VERSION_PUSH_KEYS: {
            _Py_UopsPESlot builtins_keys;
            MATERIALIZE_INST();
            builtins_keys = sym_new_not_null(ctx);
            stack_pointer[0] = builtins_keys;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL_MODULE_FROM_KEYS: {
            _Py_UopsPESlot globals_keys;
            _Py_UopsPESlot res;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            uint16_t index = (uint16_t)this_instr->operand;
            globals_keys = stack_pointer[-1];
            (void)index;
            MATERIALIZE_INST();
            materialize(&globals_keys);
            res = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = res;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL_BUILTINS_FROM_KEYS: {
            _Py_UopsPESlot builtins_keys;
            _Py_UopsPESlot res;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            uint16_t index = (uint16_t)this_instr->operand;
            builtins_keys = stack_pointer[-1];
            (void)index;
            MATERIALIZE_INST();
            materialize(&builtins_keys);
            res = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = res;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_FAST: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _MAKE_CELL: {
            MATERIALIZE_INST();
            break;
        }

        case _DELETE_DEREF: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF: {
            _Py_UopsPESlot class_dict_st;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            class_dict_st = stack_pointer[-1];
            materialize(&class_dict_st);
            value = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = value;
            break;
        }

        case _LOAD_DEREF: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_DEREF: {
            _Py_UopsPESlot v;
            MATERIALIZE_INST();
            v = stack_pointer[-1];
            materialize(&v);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COPY_FREE_VARS: {
            MATERIALIZE_INST();
            break;
        }

        case _BUILD_STRING: {
            _Py_UopsPESlot *pieces;
            _Py_UopsPESlot str;
            MATERIALIZE_INST();
            pieces = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&pieces[_i]);
            }
            str = sym_new_not_null(ctx);
            stack_pointer[-oparg] = str;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_TUPLE: {
            _Py_UopsPESlot *values;
            _Py_UopsPESlot tup;
            MATERIALIZE_INST();
            values = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&values[_i]);
            }
            tup = sym_new_not_null(ctx);
            stack_pointer[-oparg] = tup;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_LIST: {
            _Py_UopsPESlot *values;
            _Py_UopsPESlot list;
            MATERIALIZE_INST();
            values = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&values[_i]);
            }
            list = sym_new_not_null(ctx);
            stack_pointer[-oparg] = list;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LIST_EXTEND: {
            _Py_UopsPESlot iterable_st;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot list_st;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            iterable_st = stack_pointer[-1];
            materialize(&iterable_st);
            unused_0 = &stack_pointer[-1 - (oparg-1)];
            for (int _i = oparg-1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            list_st = stack_pointer[-2 - (oparg-1)];
            materialize(&list_st);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SET_UPDATE: {
            _Py_UopsPESlot iterable;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot set;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            iterable = stack_pointer[-1];
            materialize(&iterable);
            unused_0 = &stack_pointer[-1 - (oparg-1)];
            for (int _i = oparg-1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            set = stack_pointer[-2 - (oparg-1)];
            materialize(&set);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_SET: {
            _Py_UopsPESlot *values;
            _Py_UopsPESlot set;
            MATERIALIZE_INST();
            values = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&values[_i]);
            }
            set = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-oparg] = set;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_MAP: {
            _Py_UopsPESlot *values;
            _Py_UopsPESlot map;
            MATERIALIZE_INST();
            values = &stack_pointer[-oparg*2];
            for (int _i = oparg*2; --_i >= 0;) {
                materialize(&values[_i]);
            }
            map = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-oparg*2] = map;
            stack_pointer += 1 - oparg*2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SETUP_ANNOTATIONS: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _DICT_UPDATE: {
            _Py_UopsPESlot update;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot dict;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            update = stack_pointer[-1];
            materialize(&update);
            unused_0 = &stack_pointer[-1 - (oparg - 1)];
            for (int _i = oparg - 1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            dict = stack_pointer[-2 - (oparg - 1)];
            materialize(&dict);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DICT_MERGE: {
            _Py_UopsPESlot update;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot dict;
            _Py_UopsPESlot unused_1;
            _Py_UopsPESlot unused_2;
            _Py_UopsPESlot callable;
            _Py_UopsPESlot unused_3;
            _Py_UopsPESlot unused_4;
            _Py_UopsPESlot *unused_5;
            MATERIALIZE_INST();
            update = stack_pointer[-1];
            materialize(&update);
            unused_0 = &stack_pointer[-1 - (oparg - 1)];
            for (int _i = oparg - 1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            dict = stack_pointer[-2 - (oparg - 1)];
            materialize(&dict);
            unused_1 = stack_pointer[-3 - (oparg - 1)];
            materialize(&unused_1);
            unused_2 = stack_pointer[-4 - (oparg - 1)];
            materialize(&unused_2);
            callable = stack_pointer[-5 - (oparg - 1)];
            materialize(&callable);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MAP_ADD: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot key;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot dict_st;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            key = stack_pointer[-2];
            materialize(&key);
            unused_0 = &stack_pointer[-2 - (oparg - 1)];
            for (int _i = oparg - 1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            dict_st = stack_pointer[-3 - (oparg - 1)];
            materialize(&dict_st);
            materialize_ctx(ctx);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _INSTRUMENTED_LOAD_SUPER_ATTR is not a viable micro-op for tier 2 */

        case _LOAD_SUPER_ATTR_ATTR: {
            _Py_UopsPESlot self_st;
            _Py_UopsPESlot class_st;
            _Py_UopsPESlot global_super_st;
            _Py_UopsPESlot attr_st;
            _Py_UopsPESlot unused_0 = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            self_st = stack_pointer[-1];
            materialize(&self_st);
            class_st = stack_pointer[-2];
            materialize(&class_st);
            global_super_st = stack_pointer[-3];
            materialize(&global_super_st);
            attr_st = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = attr_st;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD: {
            _Py_UopsPESlot self_st;
            _Py_UopsPESlot class_st;
            _Py_UopsPESlot global_super_st;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self_or_null;
            MATERIALIZE_INST();
            self_st = stack_pointer[-1];
            materialize(&self_st);
            class_st = stack_pointer[-2];
            materialize(&class_st);
            global_super_st = stack_pointer[-3];
            materialize(&global_super_st);
            attr = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = attr;
            stack_pointer[-2] = self_or_null;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self_or_null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = self_or_null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_TYPE_VERSION: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_ATTR_MODULE: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_MODULE: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_ATTR_WITH_HINT: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_SLOT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_ATTR_CLASS: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_CLASS: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[-1] = attr;
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_PROPERTY_FRAME: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot new_frame;
            PyObject *fget = (PyObject *)this_instr->operand;
            owner = stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&owner);
            new_frame = (_Py_UopsPESlot){NULL, NULL};
            ctx->done = true;
            stack_pointer[-1] = new_frame;
            break;
        }

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 */

        case _GUARD_DORV_NO_DICT: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            value = stack_pointer[-2];
            materialize(&value);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR_WITH_HINT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            value = stack_pointer[-2];
            materialize(&value);
            materialize_ctx(ctx);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR_SLOT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            value = stack_pointer[-2];
            materialize(&value);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_FLOAT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_INT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_STR: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _IS_OP: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            b = sym_new_not_null(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            b = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP_SET: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            b = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP_DICT: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            b = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_EG_MATCH: {
            _Py_UopsPESlot match_type_st;
            _Py_UopsPESlot exc_value_st;
            _Py_UopsPESlot rest;
            _Py_UopsPESlot match;
            MATERIALIZE_INST();
            match_type_st = stack_pointer[-1];
            materialize(&match_type_st);
            exc_value_st = stack_pointer[-2];
            materialize(&exc_value_st);
            rest = sym_new_not_null(ctx);
            match = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = rest;
            stack_pointer[-1] = match;
            break;
        }

        case _CHECK_EXC_MATCH: {
            _Py_UopsPESlot right;
            _Py_UopsPESlot left;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            right = stack_pointer[-1];
            materialize(&right);
            left = stack_pointer[-2];
            materialize(&left);
            b = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = b;
            break;
        }

        case _IMPORT_NAME: {
            _Py_UopsPESlot fromlist;
            _Py_UopsPESlot level;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            fromlist = stack_pointer[-1];
            materialize(&fromlist);
            level = stack_pointer[-2];
            materialize(&level);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _IMPORT_FROM: {
            _Py_UopsPESlot from;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            from = stack_pointer[-1];
            materialize(&from);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        case _IS_NONE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot b;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            b = sym_new_not_null(ctx);
            stack_pointer[-1] = b;
            break;
        }

        case _GET_LEN: {
            _Py_UopsPESlot obj;
            _Py_UopsPESlot len;
            MATERIALIZE_INST();
            obj = stack_pointer[-1];
            materialize(&obj);
            len = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = len;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_CLASS: {
            _Py_UopsPESlot names;
            _Py_UopsPESlot type;
            _Py_UopsPESlot subject;
            _Py_UopsPESlot attrs;
            MATERIALIZE_INST();
            names = stack_pointer[-1];
            materialize(&names);
            type = stack_pointer[-2];
            materialize(&type);
            subject = stack_pointer[-3];
            materialize(&subject);
            attrs = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = attrs;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_MAPPING: {
            _Py_UopsPESlot subject;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            subject = stack_pointer[-1];
            materialize(&subject);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_SEQUENCE: {
            _Py_UopsPESlot subject;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            subject = stack_pointer[-1];
            materialize(&subject);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_KEYS: {
            _Py_UopsPESlot keys;
            _Py_UopsPESlot subject;
            _Py_UopsPESlot values_or_none;
            MATERIALIZE_INST();
            keys = stack_pointer[-1];
            materialize(&keys);
            subject = stack_pointer[-2];
            materialize(&subject);
            values_or_none = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = values_or_none;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GET_ITER: {
            _Py_UopsPESlot iterable;
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iterable = stack_pointer[-1];
            materialize(&iterable);
            iter = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        case _GET_YIELD_FROM_ITER: {
            _Py_UopsPESlot iterable;
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iterable = stack_pointer[-1];
            materialize(&iterable);
            iter = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 */

        case _FOR_ITER_TIER_TWO: {
            _Py_UopsPESlot iter;
            _Py_UopsPESlot next;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            next = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 */

        case _ITER_CHECK_LIST: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_LIST: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        case _ITER_NEXT_LIST: {
            _Py_UopsPESlot iter;
            _Py_UopsPESlot next;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _ITER_CHECK_TUPLE: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        case _ITER_NEXT_TUPLE: {
            _Py_UopsPESlot iter;
            _Py_UopsPESlot next;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _ITER_CHECK_RANGE: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            _Py_UopsPESlot iter;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            break;
        }

        case _ITER_NEXT_RANGE: {
            _Py_UopsPESlot iter;
            _Py_UopsPESlot next;
            MATERIALIZE_INST();
            iter = stack_pointer[-1];
            materialize(&iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _FOR_ITER_GEN_FRAME: {
            _Py_UopsPESlot iter;
            _Py_UopsPESlot gen_frame;
            iter = stack_pointer[-1];
            MATERIALIZE_INST();
            gen_frame = (_Py_UopsPESlot){NULL, NULL};
            /* We are about to hit the end of the trace */
            ctx->done = true;
            stack_pointer[0] = gen_frame;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SPECIAL: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self_or_null;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = attr;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _WITH_EXCEPT_START: {
            _Py_UopsPESlot val;
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot lasti;
            _Py_UopsPESlot exit_self;
            _Py_UopsPESlot exit_func;
            _Py_UopsPESlot unused_1;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            val = stack_pointer[-1];
            materialize(&val);
            unused_0 = stack_pointer[-2];
            materialize(&unused_0);
            lasti = stack_pointer[-3];
            materialize(&lasti);
            exit_self = stack_pointer[-4];
            materialize(&exit_self);
            exit_func = stack_pointer[-5];
            materialize(&exit_func);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_EXC_INFO: {
            _Py_UopsPESlot exc;
            _Py_UopsPESlot prev_exc;
            _Py_UopsPESlot new_exc;
            MATERIALIZE_INST();
            exc = stack_pointer[-1];
            materialize(&exc);
            prev_exc = sym_new_not_null(ctx);
            new_exc = sym_new_not_null(ctx);
            stack_pointer[-1] = prev_exc;
            stack_pointer[0] = new_exc;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _GUARD_KEYS_VERSION: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            self = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            self = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot unused_0 = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot unused_0 = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            _Py_UopsPESlot owner;
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            _Py_UopsPESlot owner;
            _Py_UopsPESlot attr;
            _Py_UopsPESlot self = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            owner = stack_pointer[-1];
            materialize(&owner);
            attr = sym_new_not_null(ctx);
            self = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MAYBE_EXPAND_METHOD: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *func;
            _Py_UopsPESlot *maybe_self;
            args = &stack_pointer[-oparg];
            func = &stack_pointer[-2 - oparg];
            maybe_self = &stack_pointer[-1 - oparg];
            args = &stack_pointer[-2 - oparg];
            self_or_null = &stack_pointer[-2];
            callable = &stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&callable[0]);
            materialize(&self_or_null[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            func[0] = sym_new_not_null(ctx);
            maybe_self[0] = sym_new_not_null(ctx);
            break;
        }

        /* _DO_CALL is not a viable micro-op for tier 2 */

        /* _MONITOR_CALL is not a viable micro-op for tier 2 */

        case _PY_FRAME_GENERAL: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot new_frame;
            args = &stack_pointer[-2 - oparg];
            self_or_null = &stack_pointer[-2];
            callable = &stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&callable[0]);
            materialize(&self_or_null[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            PyCodeObject *co = NULL;
            assert((this_instr + 2)->opcode == _PUSH_FRAME);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code_with_logging((this_instr + 2));
            if (co == NULL) {
                ctx->done = true;
                break;
            }
            _Py_UopsPESlot temp = (_Py_UopsPESlot){
                (_Py_UopsPESymbol *)frame_new(ctx, co, 0, NULL, 0), NULL};
            new_frame = temp;
            stack_pointer[0] = new_frame;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_FUNCTION_VERSION: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _CHECK_METHOD_VERSION: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _EXPAND_METHOD: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *method;
            _Py_UopsPESlot *self;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            method = &stack_pointer[-2 - oparg];
            self = &stack_pointer[-1 - oparg];
            method[0] = sym_new_not_null(ctx);
            self[0] = sym_new_not_null(ctx);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *unused_1;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_2;
            _Py_UopsPESlot *unused_3;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            unused_1 = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&unused_1[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _CALL_NON_PY_GENERAL: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *func;
            _Py_UopsPESlot *self;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            func = &stack_pointer[-2 - oparg];
            self = &stack_pointer[-1 - oparg];
            func[0] = sym_new_not_null(ctx);
            self[0] = sym_new_not_null(ctx);
            break;
        }

        case _CHECK_PEP_523: {
            MATERIALIZE_INST();
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _CHECK_STACK_SPACE: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot new_frame;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            args = &stack_pointer[-2 - oparg];
            self_or_null = &stack_pointer[-2];
            callable = &stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&callable[0]);
            materialize(&self_or_null[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            int argcount = oparg;
            PyCodeObject *co = NULL;
            assert((this_instr + 2)->opcode == _PUSH_FRAME);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code_with_logging((this_instr + 2));
            if (co == NULL) {
                ctx->done = true;
                break;
            }
            assert(self_or_null->sym != NULL);
            assert(args != NULL);
            if (sym_is_not_null(self_or_null)) {
                // Bound method fiddling, same as _INIT_CALL_PY_EXACT_ARGS in VM
                args--;
                argcount++;
            }
            _Py_UopsPESlot temp;
            if (sym_is_null(self_or_null) || sym_is_not_null(self_or_null)) {
                temp = (_Py_UopsPESlot){
                    (_Py_UopsPESymbol *)frame_new(ctx, co, 0, args, argcount), NULL
                };
            } else {
                temp = (_Py_UopsPESlot){
                    (_Py_UopsPESymbol *)frame_new(ctx, co, 0, NULL, 0), NULL
                };
            }
            new_frame = temp;
            stack_pointer[0] = new_frame;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_FRAME: {
            _Py_UopsPESlot new_frame;
            new_frame = stack_pointer[-1];
            new_frame = stack_pointer[-1];
            MATERIALIZE_INST();
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            ctx->frame->stack_pointer = stack_pointer;
            ctx->frame = (_Py_UOpsPEAbstractFrame *)new_frame.sym;
            ctx->curr_frame_depth++;
            stack_pointer = ((_Py_UOpsPEAbstractFrame *)new_frame.sym)->stack_pointer;
            co = get_code(this_instr);
            if (co == NULL) {
                // should be about to _EXIT_TRACE anyway
                ctx->done = true;
                break;
            }
            /* Stack space handling */
            int framesize = co->co_framesize;
            assert(framesize > 0);
            curr_space += framesize;
            if (curr_space < 0 || curr_space > INT32_MAX) {
                // won't fit in signed 32-bit int
                ctx->done = true;
                break;
            }
            max_space = curr_space > max_space ? curr_space : max_space;
            if (first_valid_check_stack == NULL) {
                first_valid_check_stack = corresponding_check_stack;
            }
            else {
                if (corresponding_check_stack) {
                    // delete all but the first valid _CHECK_STACK_SPACE
                    corresponding_check_stack->opcode = _NOP;
                }
            }
            corresponding_check_stack = NULL;
            break;
        }

        case _CALL_TYPE_1: {
            _Py_UopsPESlot arg;
            _Py_UopsPESlot null;
            _Py_UopsPESlot callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            arg = stack_pointer[-1];
            materialize(&arg);
            null = stack_pointer[-2];
            materialize(&null);
            callable = stack_pointer[-3];
            materialize(&callable);
            res = sym_new_not_null(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_STR_1: {
            _Py_UopsPESlot arg;
            _Py_UopsPESlot null;
            _Py_UopsPESlot callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            arg = stack_pointer[-1];
            materialize(&arg);
            null = stack_pointer[-2];
            materialize(&null);
            callable = stack_pointer[-3];
            materialize(&callable);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_TUPLE_1: {
            _Py_UopsPESlot arg;
            _Py_UopsPESlot null;
            _Py_UopsPESlot callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            arg = stack_pointer[-1];
            materialize(&arg);
            null = stack_pointer[-2];
            materialize(&null);
            callable = stack_pointer[-3];
            materialize(&callable);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_AND_ALLOCATE_OBJECT: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *init;
            _Py_UopsPESlot *self;
            args = &stack_pointer[-oparg];
            init = &stack_pointer[-2 - oparg];
            self = &stack_pointer[-1 - oparg];
            uint32_t type_version = (uint32_t)this_instr->operand;
            args = &stack_pointer[-2 - oparg];
            null = &stack_pointer[-2];
            callable = &stack_pointer[-1];
            (void)type_version;
            MATERIALIZE_INST();
            materialize(&callable[0]);
            materialize(&null[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self[0] = sym_new_not_null(ctx);
            init[0] = sym_new_not_null(ctx);
            break;
        }

        case _CREATE_INIT_FRAME: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self;
            _Py_UopsPESlot *init;
            _Py_UopsPESlot init_frame;
            args = &stack_pointer[-2 - oparg];
            self = &stack_pointer[-2];
            init = &stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&init[0]);
            materialize(&self[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            init_frame = (_Py_UopsPESlot){NULL, NULL};
            ctx->done = true;
            stack_pointer[-2 - oparg] = init_frame;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _EXIT_INIT_CHECK: {
            _Py_UopsPESlot should_be_none;
            MATERIALIZE_INST();
            should_be_none = stack_pointer[-1];
            materialize(&should_be_none);
            materialize_ctx(ctx);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_CLASS: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_O: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_FAST: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_LEN: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_ISINSTANCE: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_LIST_APPEND: {
            _Py_UopsPESlot arg;
            _Py_UopsPESlot self;
            _Py_UopsPESlot callable;
            MATERIALIZE_INST();
            arg = stack_pointer[-1];
            materialize(&arg);
            self = stack_pointer[-2];
            materialize(&self);
            callable = stack_pointer[-3];
            materialize(&callable);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST: {
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-1 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _INSTRUMENTED_CALL_KW is not a viable micro-op for tier 2 */

        case _MAYBE_EXPAND_METHOD_KW: {
            _Py_UopsPESlot kwnames_in;
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *func;
            _Py_UopsPESlot *maybe_self;
            _Py_UopsPESlot kwnames_out;
            MATERIALIZE_INST();
            kwnames_in = stack_pointer[-1];
            materialize(&kwnames_in);
            args = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            func = &stack_pointer[-3 - oparg];
            maybe_self = &stack_pointer[-2 - oparg];
            args = &stack_pointer[-1 - oparg];
            func[0] = sym_new_not_null(ctx);
            maybe_self[0] = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            kwnames_out = sym_new_not_null(ctx);
            stack_pointer[-1] = kwnames_out;
            break;
        }

        /* _DO_CALL_KW is not a viable micro-op for tier 2 */

        case _PY_FRAME_KW: {
            _Py_UopsPESlot kwnames;
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot new_frame;
            kwnames = stack_pointer[-3 - oparg];
            args = &stack_pointer[-2 - oparg];
            self_or_null = &stack_pointer[-2];
            callable = &stack_pointer[-1];
            MATERIALIZE_INST();
            materialize(&callable[0]);
            materialize(&self_or_null[0]);
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            materialize(&kwnames);
            new_frame = (_Py_UopsPESlot){NULL, NULL};
            ctx->done = true;
            stack_pointer[-3 - oparg] = new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_FUNCTION_VERSION_KW: {
            _Py_UopsPESlot kwnames;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            kwnames = stack_pointer[-1];
            materialize(&kwnames);
            unused_0 = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            self_or_null = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _CHECK_METHOD_VERSION_KW: {
            _Py_UopsPESlot kwnames;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_1;
            MATERIALIZE_INST();
            kwnames = stack_pointer[-1];
            materialize(&kwnames);
            unused_0 = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            null = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _EXPAND_METHOD_KW: {
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot *unused_1;
            _Py_UopsPESlot *null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *method;
            _Py_UopsPESlot *self;
            _Py_UopsPESlot *unused_2;
            _Py_UopsPESlot unused_3;
            MATERIALIZE_INST();
            unused_0 = stack_pointer[-1];
            materialize(&unused_0);
            unused_1 = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_1[_i]);
            }
            null = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&null[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            method = &stack_pointer[-3 - oparg];
            self = &stack_pointer[-2 - oparg];
            method[0] = sym_new_not_null(ctx);
            self[0] = sym_new_not_null(ctx);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE_KW: {
            _Py_UopsPESlot kwnames;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot *unused_1;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot *unused_2;
            _Py_UopsPESlot *unused_3;
            MATERIALIZE_INST();
            kwnames = stack_pointer[-1];
            materialize(&kwnames);
            unused_0 = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            unused_1 = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&unused_1[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            break;
        }

        case _CALL_KW_NON_PY: {
            _Py_UopsPESlot kwnames;
            _Py_UopsPESlot *args;
            _Py_UopsPESlot *self_or_null;
            _Py_UopsPESlot *callable;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            kwnames = stack_pointer[-1];
            materialize(&kwnames);
            args = &stack_pointer[-1 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&args[_i]);
            }
            self_or_null = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&self_or_null[_i]);
            }
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                materialize(&callable[_i]);
            }
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-3 - oparg] = res;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _INSTRUMENTED_CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        case _MAKE_CALLARGS_A_TUPLE: {
            _Py_UopsPESlot kwargs_in = (_Py_UopsPESlot){NULL, 0};
            _Py_UopsPESlot callargs;
            _Py_UopsPESlot unused_0;
            _Py_UopsPESlot func;
            _Py_UopsPESlot unused_1;
            _Py_UopsPESlot tuple;
            _Py_UopsPESlot kwargs_out = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            if (oparg & 1) { kwargs_in = stack_pointer[-(oparg & 1)]; }
            materialize(&kwargs_in);
            callargs = stack_pointer[-1 - (oparg & 1)];
            materialize(&callargs);
            unused_0 = stack_pointer[-2 - (oparg & 1)];
            materialize(&unused_0);
            func = stack_pointer[-3 - (oparg & 1)];
            materialize(&func);
            tuple = sym_new_not_null(ctx);
            kwargs_out = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1 - (oparg & 1)] = tuple;
            if (oparg & 1) stack_pointer[-(oparg & 1)] = kwargs_out;
            break;
        }

        /* _DO_CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        case _MAKE_FUNCTION: {
            _Py_UopsPESlot codeobj_st;
            _Py_UopsPESlot func;
            MATERIALIZE_INST();
            codeobj_st = stack_pointer[-1];
            materialize(&codeobj_st);
            func = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = func;
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE: {
            _Py_UopsPESlot func_in;
            _Py_UopsPESlot attr_st;
            _Py_UopsPESlot func_out;
            MATERIALIZE_INST();
            func_in = stack_pointer[-1];
            materialize(&func_in);
            attr_st = stack_pointer[-2];
            materialize(&attr_st);
            func_out = sym_new_not_null(ctx);
            stack_pointer[-2] = func_out;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _RETURN_GENERATOR: {
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            ctx->frame->stack_pointer = stack_pointer;
            frame_pop(ctx);
            stack_pointer = ctx->frame->stack_pointer;
            res = sym_new_unknown(ctx);
            /* Stack space handling */
            assert(corresponding_check_stack == NULL);
            assert(co != NULL);
            int framesize = co->co_framesize;
            assert(framesize > 0);
            assert(framesize <= curr_space);
            curr_space -= framesize;
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code(this_instr);
            if (co == NULL) {
                // might be impossible, but bailing is still safe
                ctx->done = true;
            }
            break;
        }

        case _BUILD_SLICE: {
            _Py_UopsPESlot step = (_Py_UopsPESlot){NULL, 0};
            _Py_UopsPESlot stop;
            _Py_UopsPESlot start;
            _Py_UopsPESlot slice;
            MATERIALIZE_INST();
            if (oparg == 3) { step = stack_pointer[-((oparg == 3) ? 1 : 0)]; }
            materialize(&step);
            stop = stack_pointer[-1 - ((oparg == 3) ? 1 : 0)];
            materialize(&stop);
            start = stack_pointer[-2 - ((oparg == 3) ? 1 : 0)];
            materialize(&start);
            slice = sym_new_not_null(ctx);
            stack_pointer[-2 - ((oparg == 3) ? 1 : 0)] = slice;
            stack_pointer += -1 - ((oparg == 3) ? 1 : 0);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONVERT_VALUE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot result;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            result = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = result;
            break;
        }

        case _FORMAT_SIMPLE: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            value = stack_pointer[-1];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _FORMAT_WITH_SPEC: {
            _Py_UopsPESlot fmt_spec;
            _Py_UopsPESlot value;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            fmt_spec = stack_pointer[-1];
            materialize(&fmt_spec);
            value = stack_pointer[-2];
            materialize(&value);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COPY: {
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot bottom;
            _Py_UopsPESlot *unused_1;
            _Py_UopsPESlot top;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-(oparg-1)];
            for (int _i = oparg-1; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            bottom = stack_pointer[-1 - (oparg-1)];
            materialize(&bottom);
            top = sym_new_not_null(ctx);
            stack_pointer[0] = top;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP: {
            _Py_UopsPESlot rhs;
            _Py_UopsPESlot lhs;
            _Py_UopsPESlot res;
            MATERIALIZE_INST();
            rhs = stack_pointer[-1];
            materialize(&rhs);
            lhs = stack_pointer[-2];
            materialize(&lhs);
            res = sym_new_not_null(ctx);
            materialize_ctx(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SWAP: {
            _Py_UopsPESlot top_in;
            _Py_UopsPESlot *unused_0;
            _Py_UopsPESlot bottom_in;
            _Py_UopsPESlot top_out;
            _Py_UopsPESlot *unused_1;
            _Py_UopsPESlot bottom_out;
            MATERIALIZE_INST();
            top_in = stack_pointer[-1];
            materialize(&top_in);
            unused_0 = &stack_pointer[-1 - (oparg-2)];
            for (int _i = oparg-2; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            bottom_in = stack_pointer[-2 - (oparg-2)];
            materialize(&bottom_in);
            top_out = sym_new_not_null(ctx);
            bottom_out = sym_new_not_null(ctx);
            stack_pointer[-2 - (oparg-2)] = top_out;
            stack_pointer[-1] = bottom_out;
            break;
        }

        /* _INSTRUMENTED_LINE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 */

        /* _MONITOR_JUMP_BACKWARD is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 */

        case _GUARD_IS_TRUE_POP: {
            _Py_UopsPESlot flag;
            MATERIALIZE_INST();
            flag = stack_pointer[-1];
            materialize(&flag);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            _Py_UopsPESlot flag;
            MATERIALIZE_INST();
            flag = stack_pointer[-1];
            materialize(&flag);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_IS_NONE_POP: {
            _Py_UopsPESlot val;
            MATERIALIZE_INST();
            val = stack_pointer[-1];
            materialize(&val);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            _Py_UopsPESlot val;
            MATERIALIZE_INST();
            val = stack_pointer[-1];
            materialize(&val);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _JUMP_TO_TOP: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            ctx->done = true;
            break;
        }

        case _SET_IP: {
            MATERIALIZE_INST();
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND: {
            uint32_t framesize = (uint32_t)this_instr->operand;
            MATERIALIZE_INST();
            break;
        }

        case _SAVE_RETURN_OFFSET: {
            MATERIALIZE_INST();
            break;
        }

        case _EXIT_TRACE: {
            PyObject *exit_p = (PyObject *)this_instr->operand;
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            (void)exit_p;
            ctx->done = true;
            break;
        }

        case _CHECK_VALIDITY: {
            MATERIALIZE_INST();
            break;
        }

        case _LOAD_CONST_INLINE: {
            _Py_UopsPESlot value;
            PyObject *ptr = (PyObject *)this_instr->operand;
            MATERIALIZE_INST();
            value = sym_new_const(ctx, ptr);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST_INLINE_BORROW: {
            _Py_UopsPESlot value;
            PyObject *ptr = (PyObject *)this_instr->operand;
            MATERIALIZE_INST();
            value = sym_new_const(ctx, ptr);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_BORROW: {
            _Py_UopsPESlot pop;
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            pop = stack_pointer[-1];
            materialize(&pop);
            value = sym_new_not_null(ctx);
            stack_pointer[-1] = value;
            break;
        }

        case _LOAD_CONST_INLINE_WITH_NULL: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot null;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[0] = value;
            stack_pointer[1] = null;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST_INLINE_BORROW_WITH_NULL: {
            _Py_UopsPESlot value;
            _Py_UopsPESlot null;
            MATERIALIZE_INST();
            value = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[0] = value;
            stack_pointer[1] = null;
            stack_pointer += 2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_FUNCTION: {
            MATERIALIZE_INST();
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            _Py_UopsPESlot res;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            res = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[0] = res;
            if (oparg & 1) stack_pointer[1] = null;
            stack_pointer += 1 + (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            _Py_UopsPESlot res;
            _Py_UopsPESlot null = (_Py_UopsPESlot){NULL, 0};
            MATERIALIZE_INST();
            res = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            stack_pointer[0] = res;
            if (oparg & 1) stack_pointer[1] = null;
            stack_pointer += 1 + (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _INTERNAL_INCREMENT_OPT_COUNTER: {
            _Py_UopsPESlot opt;
            MATERIALIZE_INST();
            opt = stack_pointer[-1];
            materialize(&opt);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DYNAMIC_EXIT: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _START_EXECUTOR: {
            MATERIALIZE_INST();
            break;
        }

        case _MAKE_WARM: {
            MATERIALIZE_INST();
            break;
        }

        case _FATAL_ERROR: {
            MATERIALIZE_INST();
            break;
        }

        case _CHECK_VALIDITY_AND_SET_IP: {
            MATERIALIZE_INST();
            break;
        }

        case _DEOPT: {
            MATERIALIZE_INST();
            break;
        }

        case _ERROR_POP_N: {
            _Py_UopsPESlot *unused_0;
            MATERIALIZE_INST();
            unused_0 = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                materialize(&unused_0[_i]);
            }
            stack_pointer += -oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _TIER2_RESUME_CHECK: {
            MATERIALIZE_INST();
            break;
        }

