/* File automatically generated by Parser/asdl_c.py. */


/*
   __version__ 60978.

   This module must be committed separately after each AST grammar change;
   The __version__ number is set to the revision number of the commit
   containing the grammar change.
*/

#include "Python.h"
#include "Python-ast.h"

static PyTypeObject* AST_type;
static PyTypeObject *mod_type;
static PyObject* ast2obj_mod(void*);
static PyTypeObject *Module_type;
static char *Module_fields[]={
        "body",
};
static PyTypeObject *Interactive_type;
static char *Interactive_fields[]={
        "body",
};
static PyTypeObject *Expression_type;
static char *Expression_fields[]={
        "body",
};
static PyTypeObject *Suite_type;
static char *Suite_fields[]={
        "body",
};
static PyTypeObject *stmt_type;
static char *stmt_attributes[] = {
        "lineno",
        "col_offset",
};
static PyObject* ast2obj_stmt(void*);
static PyTypeObject *FunctionDef_type;
static char *FunctionDef_fields[]={
        "name",
        "args",
        "body",
        "decorator_list",
        "returns",
};
static PyTypeObject *ClassDef_type;
static char *ClassDef_fields[]={
        "name",
        "bases",
        "keywords",
        "starargs",
        "kwargs",
        "body",
        "decorator_list",
};
static PyTypeObject *Return_type;
static char *Return_fields[]={
        "value",
};
static PyTypeObject *Delete_type;
static char *Delete_fields[]={
        "targets",
};
static PyTypeObject *Assign_type;
static char *Assign_fields[]={
        "targets",
        "value",
};
static PyTypeObject *AugAssign_type;
static char *AugAssign_fields[]={
        "target",
        "op",
        "value",
};
static PyTypeObject *For_type;
static char *For_fields[]={
        "target",
        "iter",
        "body",
        "orelse",
};
static PyTypeObject *While_type;
static char *While_fields[]={
        "test",
        "body",
        "orelse",
};
static PyTypeObject *If_type;
static char *If_fields[]={
        "test",
        "body",
        "orelse",
};
static PyTypeObject *With_type;
static char *With_fields[]={
        "context_expr",
        "optional_vars",
        "body",
};
static PyTypeObject *Raise_type;
static char *Raise_fields[]={
        "exc",
        "cause",
};
static PyTypeObject *TryExcept_type;
static char *TryExcept_fields[]={
        "body",
        "handlers",
        "orelse",
};
static PyTypeObject *TryFinally_type;
static char *TryFinally_fields[]={
        "body",
        "finalbody",
};
static PyTypeObject *Assert_type;
static char *Assert_fields[]={
        "test",
        "msg",
};
static PyTypeObject *Import_type;
static char *Import_fields[]={
        "names",
};
static PyTypeObject *ImportFrom_type;
static char *ImportFrom_fields[]={
        "module",
        "names",
        "level",
};
static PyTypeObject *Global_type;
static char *Global_fields[]={
        "names",
};
static PyTypeObject *Nonlocal_type;
static char *Nonlocal_fields[]={
        "names",
};
static PyTypeObject *Expr_type;
static char *Expr_fields[]={
        "value",
};
static PyTypeObject *Pass_type;
static PyTypeObject *Break_type;
static PyTypeObject *Continue_type;
static PyTypeObject *expr_type;
static char *expr_attributes[] = {
        "lineno",
        "col_offset",
};
static PyObject* ast2obj_expr(void*);
static PyTypeObject *BoolOp_type;
static char *BoolOp_fields[]={
        "op",
        "values",
};
static PyTypeObject *BinOp_type;
static char *BinOp_fields[]={
        "left",
        "op",
        "right",
};
static PyTypeObject *UnaryOp_type;
static char *UnaryOp_fields[]={
        "op",
        "operand",
};
static PyTypeObject *Lambda_type;
static char *Lambda_fields[]={
        "args",
        "body",
};
static PyTypeObject *IfExp_type;
static char *IfExp_fields[]={
        "test",
        "body",
        "orelse",
};
static PyTypeObject *Dict_type;
static char *Dict_fields[]={
        "keys",
        "values",
};
static PyTypeObject *Set_type;
static char *Set_fields[]={
        "elts",
};
static PyTypeObject *ListComp_type;
static char *ListComp_fields[]={
        "elt",
        "generators",
};
static PyTypeObject *SetComp_type;
static char *SetComp_fields[]={
        "elt",
        "generators",
};
static PyTypeObject *DictComp_type;
static char *DictComp_fields[]={
        "key",
        "value",
        "generators",
};
static PyTypeObject *GeneratorExp_type;
static char *GeneratorExp_fields[]={
        "elt",
        "generators",
};
static PyTypeObject *Yield_type;
static char *Yield_fields[]={
        "value",
};
static PyTypeObject *Compare_type;
static char *Compare_fields[]={
        "left",
        "ops",
        "comparators",
};
static PyTypeObject *Call_type;
static char *Call_fields[]={
        "func",
        "args",
        "keywords",
        "starargs",
        "kwargs",
};
static PyTypeObject *Num_type;
static char *Num_fields[]={
        "n",
};
static PyTypeObject *Str_type;
static char *Str_fields[]={
        "s",
};
static PyTypeObject *Bytes_type;
static char *Bytes_fields[]={
        "s",
};
static PyTypeObject *Ellipsis_type;
static PyTypeObject *Attribute_type;
static char *Attribute_fields[]={
        "value",
        "attr",
        "ctx",
};
static PyTypeObject *Subscript_type;
static char *Subscript_fields[]={
        "value",
        "slice",
        "ctx",
};
static PyTypeObject *Starred_type;
static char *Starred_fields[]={
        "value",
        "ctx",
};
static PyTypeObject *Name_type;
static char *Name_fields[]={
        "id",
        "ctx",
};
static PyTypeObject *List_type;
static char *List_fields[]={
        "elts",
        "ctx",
};
static PyTypeObject *Tuple_type;
static char *Tuple_fields[]={
        "elts",
        "ctx",
};
static PyTypeObject *expr_context_type;
static PyObject *Load_singleton, *Store_singleton, *Del_singleton,
*AugLoad_singleton, *AugStore_singleton, *Param_singleton;
static PyObject* ast2obj_expr_context(expr_context_ty);
static PyTypeObject *Load_type;
static PyTypeObject *Store_type;
static PyTypeObject *Del_type;
static PyTypeObject *AugLoad_type;
static PyTypeObject *AugStore_type;
static PyTypeObject *Param_type;
static PyTypeObject *slice_type;
static PyObject* ast2obj_slice(void*);
static PyTypeObject *Slice_type;
static char *Slice_fields[]={
        "lower",
        "upper",
        "step",
};
static PyTypeObject *ExtSlice_type;
static char *ExtSlice_fields[]={
        "dims",
};
static PyTypeObject *Index_type;
static char *Index_fields[]={
        "value",
};
static PyTypeObject *boolop_type;
static PyObject *And_singleton, *Or_singleton;
static PyObject* ast2obj_boolop(boolop_ty);
static PyTypeObject *And_type;
static PyTypeObject *Or_type;
static PyTypeObject *operator_type;
static PyObject *Add_singleton, *Sub_singleton, *Mult_singleton,
*Div_singleton, *Mod_singleton, *Pow_singleton, *LShift_singleton,
*RShift_singleton, *BitOr_singleton, *BitXor_singleton, *BitAnd_singleton,
*FloorDiv_singleton;
static PyObject* ast2obj_operator(operator_ty);
static PyTypeObject *Add_type;
static PyTypeObject *Sub_type;
static PyTypeObject *Mult_type;
static PyTypeObject *Div_type;
static PyTypeObject *Mod_type;
static PyTypeObject *Pow_type;
static PyTypeObject *LShift_type;
static PyTypeObject *RShift_type;
static PyTypeObject *BitOr_type;
static PyTypeObject *BitXor_type;
static PyTypeObject *BitAnd_type;
static PyTypeObject *FloorDiv_type;
static PyTypeObject *unaryop_type;
static PyObject *Invert_singleton, *Not_singleton, *UAdd_singleton,
*USub_singleton;
static PyObject* ast2obj_unaryop(unaryop_ty);
static PyTypeObject *Invert_type;
static PyTypeObject *Not_type;
static PyTypeObject *UAdd_type;
static PyTypeObject *USub_type;
static PyTypeObject *cmpop_type;
static PyObject *Eq_singleton, *NotEq_singleton, *Lt_singleton, *LtE_singleton,
*Gt_singleton, *GtE_singleton, *Is_singleton, *IsNot_singleton, *In_singleton,
*NotIn_singleton;
static PyObject* ast2obj_cmpop(cmpop_ty);
static PyTypeObject *Eq_type;
static PyTypeObject *NotEq_type;
static PyTypeObject *Lt_type;
static PyTypeObject *LtE_type;
static PyTypeObject *Gt_type;
static PyTypeObject *GtE_type;
static PyTypeObject *Is_type;
static PyTypeObject *IsNot_type;
static PyTypeObject *In_type;
static PyTypeObject *NotIn_type;
static PyTypeObject *comprehension_type;
static PyObject* ast2obj_comprehension(void*);
static char *comprehension_fields[]={
        "target",
        "iter",
        "ifs",
};
static PyTypeObject *excepthandler_type;
static PyObject* ast2obj_excepthandler(void*);
static char *excepthandler_fields[]={
        "type",
        "name",
        "body",
        "lineno",
        "col_offset",
};
static PyTypeObject *arguments_type;
static PyObject* ast2obj_arguments(void*);
static char *arguments_fields[]={
        "args",
        "vararg",
        "varargannotation",
        "kwonlyargs",
        "kwarg",
        "kwargannotation",
        "defaults",
        "kw_defaults",
};
static PyTypeObject *arg_type;
static PyObject* ast2obj_arg(void*);
static char *arg_fields[]={
        "arg",
        "annotation",
};
static PyTypeObject *keyword_type;
static PyObject* ast2obj_keyword(void*);
static char *keyword_fields[]={
        "arg",
        "value",
};
static PyTypeObject *alias_type;
static PyObject* ast2obj_alias(void*);
static char *alias_fields[]={
        "name",
        "asname",
};


static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields)
{
    PyObject *fnames, *result;
    int i;
    if (num_fields) {
        fnames = PyTuple_New(num_fields);
        if (!fnames) return NULL;
    } else {
        fnames = Py_None;
        Py_INCREF(Py_None);
    }
    for(i=0; i < num_fields; i++) {
        PyObject *field = PyUnicode_FromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    result = PyObject_CallFunction((PyObject*)&PyType_Type, "U(O){sOss}",
                    type, base, "_fields", fnames, "__module__", "_ast");
    Py_DECREF(fnames);
    return (PyTypeObject*)result;
}

static int add_attributes(PyTypeObject* type, char**attrs, int num_fields)
{
    int i, result;
    PyObject *s, *l = PyList_New(num_fields);
    if (!l) return 0;
    for(i = 0; i < num_fields; i++) {
        s = PyUnicode_FromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return 0;
        }
        PyList_SET_ITEM(l, i, s);
    }
    result = PyObject_SetAttrString((PyObject*)type, "_attributes", l) >= 0;
    Py_DECREF(l);
    return result;
}

static PyObject* ast2obj_list(asdl_seq *seq, PyObject* (*func)(void*))
{
    int i, n = asdl_seq_LEN(seq);
    PyObject *result = PyList_New(n);
    PyObject *value;
    if (!result)
        return NULL;
    for (i = 0; i < n; i++) {
        value = func(asdl_seq_GET(seq, i));
        if (!value) {
            Py_DECREF(result);
            return NULL;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
}

static PyObject* ast2obj_object(void *o)
{
    if (!o)
        o = Py_None;
    Py_INCREF((PyObject*)o);
    return (PyObject*)o;
}
#define ast2obj_identifier ast2obj_object
#define ast2obj_string ast2obj_object

static PyObject* ast2obj_int(long b)
{
    return PyLong_FromLong(b);
}

static int init_types(void)
{
        static int initialized;
        if (initialized) return 1;
        AST_type = make_type("AST", &PyBaseObject_Type, NULL, 0);
        mod_type = make_type("mod", AST_type, NULL, 0);
        if (!mod_type) return 0;
        if (!add_attributes(mod_type, NULL, 0)) return 0;
        Module_type = make_type("Module", mod_type, Module_fields, 1);
        if (!Module_type) return 0;
        Interactive_type = make_type("Interactive", mod_type,
                                     Interactive_fields, 1);
        if (!Interactive_type) return 0;
        Expression_type = make_type("Expression", mod_type, Expression_fields,
                                    1);
        if (!Expression_type) return 0;
        Suite_type = make_type("Suite", mod_type, Suite_fields, 1);
        if (!Suite_type) return 0;
        stmt_type = make_type("stmt", AST_type, NULL, 0);
        if (!stmt_type) return 0;
        if (!add_attributes(stmt_type, stmt_attributes, 2)) return 0;
        FunctionDef_type = make_type("FunctionDef", stmt_type,
                                     FunctionDef_fields, 5);
        if (!FunctionDef_type) return 0;
        ClassDef_type = make_type("ClassDef", stmt_type, ClassDef_fields, 7);
        if (!ClassDef_type) return 0;
        Return_type = make_type("Return", stmt_type, Return_fields, 1);
        if (!Return_type) return 0;
        Delete_type = make_type("Delete", stmt_type, Delete_fields, 1);
        if (!Delete_type) return 0;
        Assign_type = make_type("Assign", stmt_type, Assign_fields, 2);
        if (!Assign_type) return 0;
        AugAssign_type = make_type("AugAssign", stmt_type, AugAssign_fields, 3);
        if (!AugAssign_type) return 0;
        For_type = make_type("For", stmt_type, For_fields, 4);
        if (!For_type) return 0;
        While_type = make_type("While", stmt_type, While_fields, 3);
        if (!While_type) return 0;
        If_type = make_type("If", stmt_type, If_fields, 3);
        if (!If_type) return 0;
        With_type = make_type("With", stmt_type, With_fields, 3);
        if (!With_type) return 0;
        Raise_type = make_type("Raise", stmt_type, Raise_fields, 2);
        if (!Raise_type) return 0;
        TryExcept_type = make_type("TryExcept", stmt_type, TryExcept_fields, 3);
        if (!TryExcept_type) return 0;
        TryFinally_type = make_type("TryFinally", stmt_type, TryFinally_fields,
                                    2);
        if (!TryFinally_type) return 0;
        Assert_type = make_type("Assert", stmt_type, Assert_fields, 2);
        if (!Assert_type) return 0;
        Import_type = make_type("Import", stmt_type, Import_fields, 1);
        if (!Import_type) return 0;
        ImportFrom_type = make_type("ImportFrom", stmt_type, ImportFrom_fields,
                                    3);
        if (!ImportFrom_type) return 0;
        Global_type = make_type("Global", stmt_type, Global_fields, 1);
        if (!Global_type) return 0;
        Nonlocal_type = make_type("Nonlocal", stmt_type, Nonlocal_fields, 1);
        if (!Nonlocal_type) return 0;
        Expr_type = make_type("Expr", stmt_type, Expr_fields, 1);
        if (!Expr_type) return 0;
        Pass_type = make_type("Pass", stmt_type, NULL, 0);
        if (!Pass_type) return 0;
        Break_type = make_type("Break", stmt_type, NULL, 0);
        if (!Break_type) return 0;
        Continue_type = make_type("Continue", stmt_type, NULL, 0);
        if (!Continue_type) return 0;
        expr_type = make_type("expr", AST_type, NULL, 0);
        if (!expr_type) return 0;
        if (!add_attributes(expr_type, expr_attributes, 2)) return 0;
        BoolOp_type = make_type("BoolOp", expr_type, BoolOp_fields, 2);
        if (!BoolOp_type) return 0;
        BinOp_type = make_type("BinOp", expr_type, BinOp_fields, 3);
        if (!BinOp_type) return 0;
        UnaryOp_type = make_type("UnaryOp", expr_type, UnaryOp_fields, 2);
        if (!UnaryOp_type) return 0;
        Lambda_type = make_type("Lambda", expr_type, Lambda_fields, 2);
        if (!Lambda_type) return 0;
        IfExp_type = make_type("IfExp", expr_type, IfExp_fields, 3);
        if (!IfExp_type) return 0;
        Dict_type = make_type("Dict", expr_type, Dict_fields, 2);
        if (!Dict_type) return 0;
        Set_type = make_type("Set", expr_type, Set_fields, 1);
        if (!Set_type) return 0;
        ListComp_type = make_type("ListComp", expr_type, ListComp_fields, 2);
        if (!ListComp_type) return 0;
        SetComp_type = make_type("SetComp", expr_type, SetComp_fields, 2);
        if (!SetComp_type) return 0;
        DictComp_type = make_type("DictComp", expr_type, DictComp_fields, 3);
        if (!DictComp_type) return 0;
        GeneratorExp_type = make_type("GeneratorExp", expr_type,
                                      GeneratorExp_fields, 2);
        if (!GeneratorExp_type) return 0;
        Yield_type = make_type("Yield", expr_type, Yield_fields, 1);
        if (!Yield_type) return 0;
        Compare_type = make_type("Compare", expr_type, Compare_fields, 3);
        if (!Compare_type) return 0;
        Call_type = make_type("Call", expr_type, Call_fields, 5);
        if (!Call_type) return 0;
        Num_type = make_type("Num", expr_type, Num_fields, 1);
        if (!Num_type) return 0;
        Str_type = make_type("Str", expr_type, Str_fields, 1);
        if (!Str_type) return 0;
        Bytes_type = make_type("Bytes", expr_type, Bytes_fields, 1);
        if (!Bytes_type) return 0;
        Ellipsis_type = make_type("Ellipsis", expr_type, NULL, 0);
        if (!Ellipsis_type) return 0;
        Attribute_type = make_type("Attribute", expr_type, Attribute_fields, 3);
        if (!Attribute_type) return 0;
        Subscript_type = make_type("Subscript", expr_type, Subscript_fields, 3);
        if (!Subscript_type) return 0;
        Starred_type = make_type("Starred", expr_type, Starred_fields, 2);
        if (!Starred_type) return 0;
        Name_type = make_type("Name", expr_type, Name_fields, 2);
        if (!Name_type) return 0;
        List_type = make_type("List", expr_type, List_fields, 2);
        if (!List_type) return 0;
        Tuple_type = make_type("Tuple", expr_type, Tuple_fields, 2);
        if (!Tuple_type) return 0;
        expr_context_type = make_type("expr_context", AST_type, NULL, 0);
        if (!expr_context_type) return 0;
        if (!add_attributes(expr_context_type, NULL, 0)) return 0;
        Load_type = make_type("Load", expr_context_type, NULL, 0);
        if (!Load_type) return 0;
        Load_singleton = PyType_GenericNew(Load_type, NULL, NULL);
        if (!Load_singleton) return 0;
        Store_type = make_type("Store", expr_context_type, NULL, 0);
        if (!Store_type) return 0;
        Store_singleton = PyType_GenericNew(Store_type, NULL, NULL);
        if (!Store_singleton) return 0;
        Del_type = make_type("Del", expr_context_type, NULL, 0);
        if (!Del_type) return 0;
        Del_singleton = PyType_GenericNew(Del_type, NULL, NULL);
        if (!Del_singleton) return 0;
        AugLoad_type = make_type("AugLoad", expr_context_type, NULL, 0);
        if (!AugLoad_type) return 0;
        AugLoad_singleton = PyType_GenericNew(AugLoad_type, NULL, NULL);
        if (!AugLoad_singleton) return 0;
        AugStore_type = make_type("AugStore", expr_context_type, NULL, 0);
        if (!AugStore_type) return 0;
        AugStore_singleton = PyType_GenericNew(AugStore_type, NULL, NULL);
        if (!AugStore_singleton) return 0;
        Param_type = make_type("Param", expr_context_type, NULL, 0);
        if (!Param_type) return 0;
        Param_singleton = PyType_GenericNew(Param_type, NULL, NULL);
        if (!Param_singleton) return 0;
        slice_type = make_type("slice", AST_type, NULL, 0);
        if (!slice_type) return 0;
        if (!add_attributes(slice_type, NULL, 0)) return 0;
        Slice_type = make_type("Slice", slice_type, Slice_fields, 3);
        if (!Slice_type) return 0;
        ExtSlice_type = make_type("ExtSlice", slice_type, ExtSlice_fields, 1);
        if (!ExtSlice_type) return 0;
        Index_type = make_type("Index", slice_type, Index_fields, 1);
        if (!Index_type) return 0;
        boolop_type = make_type("boolop", AST_type, NULL, 0);
        if (!boolop_type) return 0;
        if (!add_attributes(boolop_type, NULL, 0)) return 0;
        And_type = make_type("And", boolop_type, NULL, 0);
        if (!And_type) return 0;
        And_singleton = PyType_GenericNew(And_type, NULL, NULL);
        if (!And_singleton) return 0;
        Or_type = make_type("Or", boolop_type, NULL, 0);
        if (!Or_type) return 0;
        Or_singleton = PyType_GenericNew(Or_type, NULL, NULL);
        if (!Or_singleton) return 0;
        operator_type = make_type("operator", AST_type, NULL, 0);
        if (!operator_type) return 0;
        if (!add_attributes(operator_type, NULL, 0)) return 0;
        Add_type = make_type("Add", operator_type, NULL, 0);
        if (!Add_type) return 0;
        Add_singleton = PyType_GenericNew(Add_type, NULL, NULL);
        if (!Add_singleton) return 0;
        Sub_type = make_type("Sub", operator_type, NULL, 0);
        if (!Sub_type) return 0;
        Sub_singleton = PyType_GenericNew(Sub_type, NULL, NULL);
        if (!Sub_singleton) return 0;
        Mult_type = make_type("Mult", operator_type, NULL, 0);
        if (!Mult_type) return 0;
        Mult_singleton = PyType_GenericNew(Mult_type, NULL, NULL);
        if (!Mult_singleton) return 0;
        Div_type = make_type("Div", operator_type, NULL, 0);
        if (!Div_type) return 0;
        Div_singleton = PyType_GenericNew(Div_type, NULL, NULL);
        if (!Div_singleton) return 0;
        Mod_type = make_type("Mod", operator_type, NULL, 0);
        if (!Mod_type) return 0;
        Mod_singleton = PyType_GenericNew(Mod_type, NULL, NULL);
        if (!Mod_singleton) return 0;
        Pow_type = make_type("Pow", operator_type, NULL, 0);
        if (!Pow_type) return 0;
        Pow_singleton = PyType_GenericNew(Pow_type, NULL, NULL);
        if (!Pow_singleton) return 0;
        LShift_type = make_type("LShift", operator_type, NULL, 0);
        if (!LShift_type) return 0;
        LShift_singleton = PyType_GenericNew(LShift_type, NULL, NULL);
        if (!LShift_singleton) return 0;
        RShift_type = make_type("RShift", operator_type, NULL, 0);
        if (!RShift_type) return 0;
        RShift_singleton = PyType_GenericNew(RShift_type, NULL, NULL);
        if (!RShift_singleton) return 0;
        BitOr_type = make_type("BitOr", operator_type, NULL, 0);
        if (!BitOr_type) return 0;
        BitOr_singleton = PyType_GenericNew(BitOr_type, NULL, NULL);
        if (!BitOr_singleton) return 0;
        BitXor_type = make_type("BitXor", operator_type, NULL, 0);
        if (!BitXor_type) return 0;
        BitXor_singleton = PyType_GenericNew(BitXor_type, NULL, NULL);
        if (!BitXor_singleton) return 0;
        BitAnd_type = make_type("BitAnd", operator_type, NULL, 0);
        if (!BitAnd_type) return 0;
        BitAnd_singleton = PyType_GenericNew(BitAnd_type, NULL, NULL);
        if (!BitAnd_singleton) return 0;
        FloorDiv_type = make_type("FloorDiv", operator_type, NULL, 0);
        if (!FloorDiv_type) return 0;
        FloorDiv_singleton = PyType_GenericNew(FloorDiv_type, NULL, NULL);
        if (!FloorDiv_singleton) return 0;
        unaryop_type = make_type("unaryop", AST_type, NULL, 0);
        if (!unaryop_type) return 0;
        if (!add_attributes(unaryop_type, NULL, 0)) return 0;
        Invert_type = make_type("Invert", unaryop_type, NULL, 0);
        if (!Invert_type) return 0;
        Invert_singleton = PyType_GenericNew(Invert_type, NULL, NULL);
        if (!Invert_singleton) return 0;
        Not_type = make_type("Not", unaryop_type, NULL, 0);
        if (!Not_type) return 0;
        Not_singleton = PyType_GenericNew(Not_type, NULL, NULL);
        if (!Not_singleton) return 0;
        UAdd_type = make_type("UAdd", unaryop_type, NULL, 0);
        if (!UAdd_type) return 0;
        UAdd_singleton = PyType_GenericNew(UAdd_type, NULL, NULL);
        if (!UAdd_singleton) return 0;
        USub_type = make_type("USub", unaryop_type, NULL, 0);
        if (!USub_type) return 0;
        USub_singleton = PyType_GenericNew(USub_type, NULL, NULL);
        if (!USub_singleton) return 0;
        cmpop_type = make_type("cmpop", AST_type, NULL, 0);
        if (!cmpop_type) return 0;
        if (!add_attributes(cmpop_type, NULL, 0)) return 0;
        Eq_type = make_type("Eq", cmpop_type, NULL, 0);
        if (!Eq_type) return 0;
        Eq_singleton = PyType_GenericNew(Eq_type, NULL, NULL);
        if (!Eq_singleton) return 0;
        NotEq_type = make_type("NotEq", cmpop_type, NULL, 0);
        if (!NotEq_type) return 0;
        NotEq_singleton = PyType_GenericNew(NotEq_type, NULL, NULL);
        if (!NotEq_singleton) return 0;
        Lt_type = make_type("Lt", cmpop_type, NULL, 0);
        if (!Lt_type) return 0;
        Lt_singleton = PyType_GenericNew(Lt_type, NULL, NULL);
        if (!Lt_singleton) return 0;
        LtE_type = make_type("LtE", cmpop_type, NULL, 0);
        if (!LtE_type) return 0;
        LtE_singleton = PyType_GenericNew(LtE_type, NULL, NULL);
        if (!LtE_singleton) return 0;
        Gt_type = make_type("Gt", cmpop_type, NULL, 0);
        if (!Gt_type) return 0;
        Gt_singleton = PyType_GenericNew(Gt_type, NULL, NULL);
        if (!Gt_singleton) return 0;
        GtE_type = make_type("GtE", cmpop_type, NULL, 0);
        if (!GtE_type) return 0;
        GtE_singleton = PyType_GenericNew(GtE_type, NULL, NULL);
        if (!GtE_singleton) return 0;
        Is_type = make_type("Is", cmpop_type, NULL, 0);
        if (!Is_type) return 0;
        Is_singleton = PyType_GenericNew(Is_type, NULL, NULL);
        if (!Is_singleton) return 0;
        IsNot_type = make_type("IsNot", cmpop_type, NULL, 0);
        if (!IsNot_type) return 0;
        IsNot_singleton = PyType_GenericNew(IsNot_type, NULL, NULL);
        if (!IsNot_singleton) return 0;
        In_type = make_type("In", cmpop_type, NULL, 0);
        if (!In_type) return 0;
        In_singleton = PyType_GenericNew(In_type, NULL, NULL);
        if (!In_singleton) return 0;
        NotIn_type = make_type("NotIn", cmpop_type, NULL, 0);
        if (!NotIn_type) return 0;
        NotIn_singleton = PyType_GenericNew(NotIn_type, NULL, NULL);
        if (!NotIn_singleton) return 0;
        comprehension_type = make_type("comprehension", AST_type,
                                       comprehension_fields, 3);
        if (!comprehension_type) return 0;
        excepthandler_type = make_type("excepthandler", AST_type,
                                       excepthandler_fields, 5);
        if (!excepthandler_type) return 0;
        arguments_type = make_type("arguments", AST_type, arguments_fields, 8);
        if (!arguments_type) return 0;
        arg_type = make_type("arg", AST_type, arg_fields, 2);
        if (!arg_type) return 0;
        keyword_type = make_type("keyword", AST_type, keyword_fields, 2);
        if (!keyword_type) return 0;
        alias_type = make_type("alias", AST_type, alias_fields, 2);
        if (!alias_type) return 0;
        initialized = 1;
        return 1;
}

mod_ty
Module(asdl_seq * body, PyArena *arena)
{
        mod_ty p;
        p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Module_kind;
        p->v.Module.body = body;
        return p;
}

mod_ty
Interactive(asdl_seq * body, PyArena *arena)
{
        mod_ty p;
        p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Interactive_kind;
        p->v.Interactive.body = body;
        return p;
}

mod_ty
Expression(expr_ty body, PyArena *arena)
{
        mod_ty p;
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Expression");
                return NULL;
        }
        p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Expression_kind;
        p->v.Expression.body = body;
        return p;
}

mod_ty
Suite(asdl_seq * body, PyArena *arena)
{
        mod_ty p;
        p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Suite_kind;
        p->v.Suite.body = body;
        return p;
}

stmt_ty
FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *
            decorator_list, expr_ty returns, int lineno, int col_offset,
            PyArena *arena)
{
        stmt_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for FunctionDef");
                return NULL;
        }
        if (!args) {
                PyErr_SetString(PyExc_ValueError,
                                "field args is required for FunctionDef");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = FunctionDef_kind;
        p->v.FunctionDef.name = name;
        p->v.FunctionDef.args = args;
        p->v.FunctionDef.body = body;
        p->v.FunctionDef.decorator_list = decorator_list;
        p->v.FunctionDef.returns = returns;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
ClassDef(identifier name, asdl_seq * bases, asdl_seq * keywords, expr_ty
         starargs, expr_ty kwargs, asdl_seq * body, asdl_seq * decorator_list,
         int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for ClassDef");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = ClassDef_kind;
        p->v.ClassDef.name = name;
        p->v.ClassDef.bases = bases;
        p->v.ClassDef.keywords = keywords;
        p->v.ClassDef.starargs = starargs;
        p->v.ClassDef.kwargs = kwargs;
        p->v.ClassDef.body = body;
        p->v.ClassDef.decorator_list = decorator_list;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Return(expr_ty value, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Return_kind;
        p->v.Return.value = value;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Delete(asdl_seq * targets, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Delete_kind;
        p->v.Delete.targets = targets;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Assign(asdl_seq * targets, expr_ty value, int lineno, int col_offset, PyArena
       *arena)
{
        stmt_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Assign");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Assign_kind;
        p->v.Assign.targets = targets;
        p->v.Assign.value = value;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
AugAssign(expr_ty target, operator_ty op, expr_ty value, int lineno, int
          col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for AugAssign");
                return NULL;
        }
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for AugAssign");
                return NULL;
        }
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for AugAssign");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = AugAssign_kind;
        p->v.AugAssign.target = target;
        p->v.AugAssign.op = op;
        p->v.AugAssign.value = value;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int
    lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for For");
                return NULL;
        }
        if (!iter) {
                PyErr_SetString(PyExc_ValueError,
                                "field iter is required for For");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = For_kind;
        p->v.For.target = target;
        p->v.For.iter = iter;
        p->v.For.body = body;
        p->v.For.orelse = orelse;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
While(expr_ty test, asdl_seq * body, asdl_seq * orelse, int lineno, int
      col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for While");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = While_kind;
        p->v.While.test = test;
        p->v.While.body = body;
        p->v.While.orelse = orelse;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
If(expr_ty test, asdl_seq * body, asdl_seq * orelse, int lineno, int
   col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for If");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = If_kind;
        p->v.If.test = test;
        p->v.If.body = body;
        p->v.If.orelse = orelse;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
With(expr_ty context_expr, expr_ty optional_vars, asdl_seq * body, int lineno,
     int col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!context_expr) {
                PyErr_SetString(PyExc_ValueError,
                                "field context_expr is required for With");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = With_kind;
        p->v.With.context_expr = context_expr;
        p->v.With.optional_vars = optional_vars;
        p->v.With.body = body;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Raise(expr_ty exc, expr_ty cause, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Raise_kind;
        p->v.Raise.exc = exc;
        p->v.Raise.cause = cause;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
TryExcept(asdl_seq * body, asdl_seq * handlers, asdl_seq * orelse, int lineno,
          int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = TryExcept_kind;
        p->v.TryExcept.body = body;
        p->v.TryExcept.handlers = handlers;
        p->v.TryExcept.orelse = orelse;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
TryFinally(asdl_seq * body, asdl_seq * finalbody, int lineno, int col_offset,
           PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = TryFinally_kind;
        p->v.TryFinally.body = body;
        p->v.TryFinally.finalbody = finalbody;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Assert(expr_ty test, expr_ty msg, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for Assert");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Assert_kind;
        p->v.Assert.test = test;
        p->v.Assert.msg = msg;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Import(asdl_seq * names, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Import_kind;
        p->v.Import.names = names;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
ImportFrom(identifier module, asdl_seq * names, int level, int lineno, int
           col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!module) {
                PyErr_SetString(PyExc_ValueError,
                                "field module is required for ImportFrom");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = ImportFrom_kind;
        p->v.ImportFrom.module = module;
        p->v.ImportFrom.names = names;
        p->v.ImportFrom.level = level;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Global(asdl_seq * names, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Global_kind;
        p->v.Global.names = names;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Nonlocal(asdl_seq * names, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Nonlocal_kind;
        p->v.Nonlocal.names = names;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Expr(expr_ty value, int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Expr");
                return NULL;
        }
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Expr_kind;
        p->v.Expr.value = value;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Pass(int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Pass_kind;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Break(int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Break_kind;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

stmt_ty
Continue(int lineno, int col_offset, PyArena *arena)
{
        stmt_ty p;
        p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Continue_kind;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
BoolOp(boolop_ty op, asdl_seq * values, int lineno, int col_offset, PyArena
       *arena)
{
        expr_ty p;
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for BoolOp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = BoolOp_kind;
        p->v.BoolOp.op = op;
        p->v.BoolOp.values = values;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
BinOp(expr_ty left, operator_ty op, expr_ty right, int lineno, int col_offset,
      PyArena *arena)
{
        expr_ty p;
        if (!left) {
                PyErr_SetString(PyExc_ValueError,
                                "field left is required for BinOp");
                return NULL;
        }
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for BinOp");
                return NULL;
        }
        if (!right) {
                PyErr_SetString(PyExc_ValueError,
                                "field right is required for BinOp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = BinOp_kind;
        p->v.BinOp.left = left;
        p->v.BinOp.op = op;
        p->v.BinOp.right = right;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
UnaryOp(unaryop_ty op, expr_ty operand, int lineno, int col_offset, PyArena
        *arena)
{
        expr_ty p;
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for UnaryOp");
                return NULL;
        }
        if (!operand) {
                PyErr_SetString(PyExc_ValueError,
                                "field operand is required for UnaryOp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = UnaryOp_kind;
        p->v.UnaryOp.op = op;
        p->v.UnaryOp.operand = operand;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Lambda(arguments_ty args, expr_ty body, int lineno, int col_offset, PyArena
       *arena)
{
        expr_ty p;
        if (!args) {
                PyErr_SetString(PyExc_ValueError,
                                "field args is required for Lambda");
                return NULL;
        }
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Lambda");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Lambda_kind;
        p->v.Lambda.args = args;
        p->v.Lambda.body = body;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
IfExp(expr_ty test, expr_ty body, expr_ty orelse, int lineno, int col_offset,
      PyArena *arena)
{
        expr_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for IfExp");
                return NULL;
        }
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for IfExp");
                return NULL;
        }
        if (!orelse) {
                PyErr_SetString(PyExc_ValueError,
                                "field orelse is required for IfExp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = IfExp_kind;
        p->v.IfExp.test = test;
        p->v.IfExp.body = body;
        p->v.IfExp.orelse = orelse;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Dict(asdl_seq * keys, asdl_seq * values, int lineno, int col_offset, PyArena
     *arena)
{
        expr_ty p;
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Dict_kind;
        p->v.Dict.keys = keys;
        p->v.Dict.values = values;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Set(asdl_seq * elts, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Set_kind;
        p->v.Set.elts = elts;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
ListComp(expr_ty elt, asdl_seq * generators, int lineno, int col_offset,
         PyArena *arena)
{
        expr_ty p;
        if (!elt) {
                PyErr_SetString(PyExc_ValueError,
                                "field elt is required for ListComp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = ListComp_kind;
        p->v.ListComp.elt = elt;
        p->v.ListComp.generators = generators;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
SetComp(expr_ty elt, asdl_seq * generators, int lineno, int col_offset, PyArena
        *arena)
{
        expr_ty p;
        if (!elt) {
                PyErr_SetString(PyExc_ValueError,
                                "field elt is required for SetComp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = SetComp_kind;
        p->v.SetComp.elt = elt;
        p->v.SetComp.generators = generators;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
DictComp(expr_ty key, expr_ty value, asdl_seq * generators, int lineno, int
         col_offset, PyArena *arena)
{
        expr_ty p;
        if (!key) {
                PyErr_SetString(PyExc_ValueError,
                                "field key is required for DictComp");
                return NULL;
        }
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for DictComp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = DictComp_kind;
        p->v.DictComp.key = key;
        p->v.DictComp.value = value;
        p->v.DictComp.generators = generators;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
GeneratorExp(expr_ty elt, asdl_seq * generators, int lineno, int col_offset,
             PyArena *arena)
{
        expr_ty p;
        if (!elt) {
                PyErr_SetString(PyExc_ValueError,
                                "field elt is required for GeneratorExp");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = GeneratorExp_kind;
        p->v.GeneratorExp.elt = elt;
        p->v.GeneratorExp.generators = generators;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Yield(expr_ty value, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Yield_kind;
        p->v.Yield.value = value;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Compare(expr_ty left, asdl_int_seq * ops, asdl_seq * comparators, int lineno,
        int col_offset, PyArena *arena)
{
        expr_ty p;
        if (!left) {
                PyErr_SetString(PyExc_ValueError,
                                "field left is required for Compare");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Compare_kind;
        p->v.Compare.left = left;
        p->v.Compare.ops = ops;
        p->v.Compare.comparators = comparators;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Call(expr_ty func, asdl_seq * args, asdl_seq * keywords, expr_ty starargs,
     expr_ty kwargs, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        if (!func) {
                PyErr_SetString(PyExc_ValueError,
                                "field func is required for Call");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Call_kind;
        p->v.Call.func = func;
        p->v.Call.args = args;
        p->v.Call.keywords = keywords;
        p->v.Call.starargs = starargs;
        p->v.Call.kwargs = kwargs;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Num(object n, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        if (!n) {
                PyErr_SetString(PyExc_ValueError,
                                "field n is required for Num");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Num_kind;
        p->v.Num.n = n;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Str(string s, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        if (!s) {
                PyErr_SetString(PyExc_ValueError,
                                "field s is required for Str");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Str_kind;
        p->v.Str.s = s;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Bytes(string s, int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        if (!s) {
                PyErr_SetString(PyExc_ValueError,
                                "field s is required for Bytes");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Bytes_kind;
        p->v.Bytes.s = s;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Ellipsis(int lineno, int col_offset, PyArena *arena)
{
        expr_ty p;
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Ellipsis_kind;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Attribute(expr_ty value, identifier attr, expr_context_ty ctx, int lineno, int
          col_offset, PyArena *arena)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Attribute");
                return NULL;
        }
        if (!attr) {
                PyErr_SetString(PyExc_ValueError,
                                "field attr is required for Attribute");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Attribute");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Attribute_kind;
        p->v.Attribute.value = value;
        p->v.Attribute.attr = attr;
        p->v.Attribute.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Subscript(expr_ty value, slice_ty slice, expr_context_ty ctx, int lineno, int
          col_offset, PyArena *arena)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Subscript");
                return NULL;
        }
        if (!slice) {
                PyErr_SetString(PyExc_ValueError,
                                "field slice is required for Subscript");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Subscript");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Subscript_kind;
        p->v.Subscript.value = value;
        p->v.Subscript.slice = slice;
        p->v.Subscript.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Starred(expr_ty value, expr_context_ty ctx, int lineno, int col_offset, PyArena
        *arena)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Starred");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Starred");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Starred_kind;
        p->v.Starred.value = value;
        p->v.Starred.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Name(identifier id, expr_context_ty ctx, int lineno, int col_offset, PyArena
     *arena)
{
        expr_ty p;
        if (!id) {
                PyErr_SetString(PyExc_ValueError,
                                "field id is required for Name");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Name");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Name_kind;
        p->v.Name.id = id;
        p->v.Name.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
List(asdl_seq * elts, expr_context_ty ctx, int lineno, int col_offset, PyArena
     *arena)
{
        expr_ty p;
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for List");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = List_kind;
        p->v.List.elts = elts;
        p->v.List.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

expr_ty
Tuple(asdl_seq * elts, expr_context_ty ctx, int lineno, int col_offset, PyArena
      *arena)
{
        expr_ty p;
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Tuple");
                return NULL;
        }
        p = (expr_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Tuple_kind;
        p->v.Tuple.elts = elts;
        p->v.Tuple.ctx = ctx;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

slice_ty
Slice(expr_ty lower, expr_ty upper, expr_ty step, PyArena *arena)
{
        slice_ty p;
        p = (slice_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Slice_kind;
        p->v.Slice.lower = lower;
        p->v.Slice.upper = upper;
        p->v.Slice.step = step;
        return p;
}

slice_ty
ExtSlice(asdl_seq * dims, PyArena *arena)
{
        slice_ty p;
        p = (slice_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = ExtSlice_kind;
        p->v.ExtSlice.dims = dims;
        return p;
}

slice_ty
Index(expr_ty value, PyArena *arena)
{
        slice_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Index");
                return NULL;
        }
        p = (slice_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->kind = Index_kind;
        p->v.Index.value = value;
        return p;
}

comprehension_ty
comprehension(expr_ty target, expr_ty iter, asdl_seq * ifs, PyArena *arena)
{
        comprehension_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for comprehension");
                return NULL;
        }
        if (!iter) {
                PyErr_SetString(PyExc_ValueError,
                                "field iter is required for comprehension");
                return NULL;
        }
        p = (comprehension_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->target = target;
        p->iter = iter;
        p->ifs = ifs;
        return p;
}

excepthandler_ty
excepthandler(expr_ty type, identifier name, asdl_seq * body, int lineno, int
              col_offset, PyArena *arena)
{
        excepthandler_ty p;
        p = (excepthandler_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->type = type;
        p->name = name;
        p->body = body;
        p->lineno = lineno;
        p->col_offset = col_offset;
        return p;
}

arguments_ty
arguments(asdl_seq * args, identifier vararg, expr_ty varargannotation,
          asdl_seq * kwonlyargs, identifier kwarg, expr_ty kwargannotation,
          asdl_seq * defaults, asdl_seq * kw_defaults, PyArena *arena)
{
        arguments_ty p;
        p = (arguments_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->args = args;
        p->vararg = vararg;
        p->varargannotation = varargannotation;
        p->kwonlyargs = kwonlyargs;
        p->kwarg = kwarg;
        p->kwargannotation = kwargannotation;
        p->defaults = defaults;
        p->kw_defaults = kw_defaults;
        return p;
}

arg_ty
arg(identifier arg, expr_ty annotation, PyArena *arena)
{
        arg_ty p;
        if (!arg) {
                PyErr_SetString(PyExc_ValueError,
                                "field arg is required for arg");
                return NULL;
        }
        p = (arg_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->arg = arg;
        p->annotation = annotation;
        return p;
}

keyword_ty
keyword(identifier arg, expr_ty value, PyArena *arena)
{
        keyword_ty p;
        if (!arg) {
                PyErr_SetString(PyExc_ValueError,
                                "field arg is required for keyword");
                return NULL;
        }
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for keyword");
                return NULL;
        }
        p = (keyword_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->arg = arg;
        p->value = value;
        return p;
}

alias_ty
alias(identifier name, identifier asname, PyArena *arena)
{
        alias_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for alias");
                return NULL;
        }
        p = (alias_ty)PyArena_Malloc(arena, sizeof(*p));
        if (!p)
                return NULL;
        p->name = name;
        p->asname = asname;
        return p;
}


PyObject*
ast2obj_mod(void* _o)
{
        mod_ty o = (mod_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        switch (o->kind) {
        case Module_kind:
                result = PyType_GenericNew(Module_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Module.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Interactive_kind:
                result = PyType_GenericNew(Interactive_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Interactive.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Expression_kind:
                result = PyType_GenericNew(Expression_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Expression.body);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Suite_kind:
                result = PyType_GenericNew(Suite_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Suite.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        }
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_stmt(void* _o)
{
        stmt_ty o = (stmt_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        switch (o->kind) {
        case FunctionDef_kind:
                result = PyType_GenericNew(FunctionDef_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_identifier(o->v.FunctionDef.name);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "name", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_arguments(o->v.FunctionDef.args);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "args", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.FunctionDef.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.FunctionDef.decorator_list,
                                     ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "decorator_list", value) ==
                    -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.FunctionDef.returns);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "returns", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case ClassDef_kind:
                result = PyType_GenericNew(ClassDef_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_identifier(o->v.ClassDef.name);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "name", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ClassDef.bases, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "bases", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ClassDef.keywords, ast2obj_keyword);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "keywords", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.ClassDef.starargs);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "starargs", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.ClassDef.kwargs);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "kwargs", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ClassDef.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ClassDef.decorator_list,
                                     ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "decorator_list", value) ==
                    -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Return_kind:
                result = PyType_GenericNew(Return_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Return.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Delete_kind:
                result = PyType_GenericNew(Delete_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Delete.targets, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "targets", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Assign_kind:
                result = PyType_GenericNew(Assign_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Assign.targets, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "targets", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Assign.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case AugAssign_kind:
                result = PyType_GenericNew(AugAssign_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.AugAssign.target);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "target", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_operator(o->v.AugAssign.op);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "op", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.AugAssign.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case For_kind:
                result = PyType_GenericNew(For_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.For.target);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "target", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.For.iter);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "iter", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.For.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.For.orelse, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "orelse", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case While_kind:
                result = PyType_GenericNew(While_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.While.test);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "test", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.While.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.While.orelse, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "orelse", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case If_kind:
                result = PyType_GenericNew(If_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.If.test);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "test", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.If.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.If.orelse, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "orelse", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case With_kind:
                result = PyType_GenericNew(With_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.With.context_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "context_expr", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.With.optional_vars);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "optional_vars", value) ==
                    -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.With.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Raise_kind:
                result = PyType_GenericNew(Raise_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Raise.exc);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "exc", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Raise.cause);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "cause", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case TryExcept_kind:
                result = PyType_GenericNew(TryExcept_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.TryExcept.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.TryExcept.handlers,
                                     ast2obj_excepthandler);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "handlers", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.TryExcept.orelse, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "orelse", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case TryFinally_kind:
                result = PyType_GenericNew(TryFinally_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.TryFinally.body, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.TryFinally.finalbody, ast2obj_stmt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "finalbody", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Assert_kind:
                result = PyType_GenericNew(Assert_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Assert.test);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "test", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Assert.msg);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "msg", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Import_kind:
                result = PyType_GenericNew(Import_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Import.names, ast2obj_alias);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "names", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case ImportFrom_kind:
                result = PyType_GenericNew(ImportFrom_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_identifier(o->v.ImportFrom.module);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "module", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ImportFrom.names, ast2obj_alias);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "names", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_int(o->v.ImportFrom.level);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "level", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Global_kind:
                result = PyType_GenericNew(Global_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Global.names, ast2obj_identifier);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "names", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Nonlocal_kind:
                result = PyType_GenericNew(Nonlocal_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Nonlocal.names, ast2obj_identifier);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "names", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Expr_kind:
                result = PyType_GenericNew(Expr_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Expr.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Pass_kind:
                result = PyType_GenericNew(Pass_type, NULL, NULL);
                if (!result) goto failed;
                break;
        case Break_kind:
                result = PyType_GenericNew(Break_type, NULL, NULL);
                if (!result) goto failed;
                break;
        case Continue_kind:
                result = PyType_GenericNew(Continue_type, NULL, NULL);
                if (!result) goto failed;
                break;
        }
        value = ast2obj_int(o->lineno);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "lineno", value) < 0)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->col_offset);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "col_offset", value) < 0)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_expr(void* _o)
{
        expr_ty o = (expr_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        switch (o->kind) {
        case BoolOp_kind:
                result = PyType_GenericNew(BoolOp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_boolop(o->v.BoolOp.op);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "op", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.BoolOp.values, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "values", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case BinOp_kind:
                result = PyType_GenericNew(BinOp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.BinOp.left);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "left", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_operator(o->v.BinOp.op);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "op", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.BinOp.right);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "right", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case UnaryOp_kind:
                result = PyType_GenericNew(UnaryOp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_unaryop(o->v.UnaryOp.op);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "op", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.UnaryOp.operand);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "operand", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Lambda_kind:
                result = PyType_GenericNew(Lambda_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_arguments(o->v.Lambda.args);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "args", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Lambda.body);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case IfExp_kind:
                result = PyType_GenericNew(IfExp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.IfExp.test);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "test", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.IfExp.body);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "body", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.IfExp.orelse);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "orelse", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Dict_kind:
                result = PyType_GenericNew(Dict_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Dict.keys, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "keys", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.Dict.values, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "values", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Set_kind:
                result = PyType_GenericNew(Set_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Set.elts, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elts", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case ListComp_kind:
                result = PyType_GenericNew(ListComp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.ListComp.elt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elt", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.ListComp.generators,
                                     ast2obj_comprehension);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "generators", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case SetComp_kind:
                result = PyType_GenericNew(SetComp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.SetComp.elt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elt", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.SetComp.generators,
                                     ast2obj_comprehension);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "generators", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case DictComp_kind:
                result = PyType_GenericNew(DictComp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.DictComp.key);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "key", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.DictComp.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.DictComp.generators,
                                     ast2obj_comprehension);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "generators", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case GeneratorExp_kind:
                result = PyType_GenericNew(GeneratorExp_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.GeneratorExp.elt);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elt", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.GeneratorExp.generators,
                                     ast2obj_comprehension);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "generators", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Yield_kind:
                result = PyType_GenericNew(Yield_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Yield.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Compare_kind:
                result = PyType_GenericNew(Compare_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Compare.left);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "left", value) == -1)
                        goto failed;
                Py_DECREF(value);
                {
                        int i, n = asdl_seq_LEN(o->v.Compare.ops);
                        value = PyList_New(n);
                        if (!value) goto failed;
                        for(i = 0; i < n; i++)
                                PyList_SET_ITEM(value, i, ast2obj_cmpop((cmpop_ty)asdl_seq_GET(o->v.Compare.ops, i)));
                }
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ops", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.Compare.comparators, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "comparators", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Call_kind:
                result = PyType_GenericNew(Call_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Call.func);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "func", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.Call.args, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "args", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_list(o->v.Call.keywords, ast2obj_keyword);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "keywords", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Call.starargs);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "starargs", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Call.kwargs);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "kwargs", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Num_kind:
                result = PyType_GenericNew(Num_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_object(o->v.Num.n);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "n", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Str_kind:
                result = PyType_GenericNew(Str_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_string(o->v.Str.s);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "s", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Bytes_kind:
                result = PyType_GenericNew(Bytes_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_string(o->v.Bytes.s);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "s", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Ellipsis_kind:
                result = PyType_GenericNew(Ellipsis_type, NULL, NULL);
                if (!result) goto failed;
                break;
        case Attribute_kind:
                result = PyType_GenericNew(Attribute_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Attribute.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_identifier(o->v.Attribute.attr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "attr", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.Attribute.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Subscript_kind:
                result = PyType_GenericNew(Subscript_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Subscript.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_slice(o->v.Subscript.slice);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "slice", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.Subscript.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Starred_kind:
                result = PyType_GenericNew(Starred_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Starred.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.Starred.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Name_kind:
                result = PyType_GenericNew(Name_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_identifier(o->v.Name.id);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "id", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.Name.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case List_kind:
                result = PyType_GenericNew(List_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.List.elts, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elts", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.List.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Tuple_kind:
                result = PyType_GenericNew(Tuple_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.Tuple.elts, ast2obj_expr);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "elts", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr_context(o->v.Tuple.ctx);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "ctx", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        }
        value = ast2obj_int(o->lineno);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "lineno", value) < 0)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->col_offset);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "col_offset", value) < 0)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject* ast2obj_expr_context(expr_context_ty o)
{
        switch(o) {
                case Load:
                        Py_INCREF(Load_singleton);
                        return Load_singleton;
                case Store:
                        Py_INCREF(Store_singleton);
                        return Store_singleton;
                case Del:
                        Py_INCREF(Del_singleton);
                        return Del_singleton;
                case AugLoad:
                        Py_INCREF(AugLoad_singleton);
                        return AugLoad_singleton;
                case AugStore:
                        Py_INCREF(AugStore_singleton);
                        return AugStore_singleton;
                case Param:
                        Py_INCREF(Param_singleton);
                        return Param_singleton;
        }
        return NULL; /* cannot happen */
}
PyObject*
ast2obj_slice(void* _o)
{
        slice_ty o = (slice_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        switch (o->kind) {
        case Slice_kind:
                result = PyType_GenericNew(Slice_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Slice.lower);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "lower", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Slice.upper);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "upper", value) == -1)
                        goto failed;
                Py_DECREF(value);
                value = ast2obj_expr(o->v.Slice.step);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "step", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case ExtSlice_kind:
                result = PyType_GenericNew(ExtSlice_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_list(o->v.ExtSlice.dims, ast2obj_slice);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "dims", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        case Index_kind:
                result = PyType_GenericNew(Index_type, NULL, NULL);
                if (!result) goto failed;
                value = ast2obj_expr(o->v.Index.value);
                if (!value) goto failed;
                if (PyObject_SetAttrString(result, "value", value) == -1)
                        goto failed;
                Py_DECREF(value);
                break;
        }
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject* ast2obj_boolop(boolop_ty o)
{
        switch(o) {
                case And:
                        Py_INCREF(And_singleton);
                        return And_singleton;
                case Or:
                        Py_INCREF(Or_singleton);
                        return Or_singleton;
        }
        return NULL; /* cannot happen */
}
PyObject* ast2obj_operator(operator_ty o)
{
        switch(o) {
                case Add:
                        Py_INCREF(Add_singleton);
                        return Add_singleton;
                case Sub:
                        Py_INCREF(Sub_singleton);
                        return Sub_singleton;
                case Mult:
                        Py_INCREF(Mult_singleton);
                        return Mult_singleton;
                case Div:
                        Py_INCREF(Div_singleton);
                        return Div_singleton;
                case Mod:
                        Py_INCREF(Mod_singleton);
                        return Mod_singleton;
                case Pow:
                        Py_INCREF(Pow_singleton);
                        return Pow_singleton;
                case LShift:
                        Py_INCREF(LShift_singleton);
                        return LShift_singleton;
                case RShift:
                        Py_INCREF(RShift_singleton);
                        return RShift_singleton;
                case BitOr:
                        Py_INCREF(BitOr_singleton);
                        return BitOr_singleton;
                case BitXor:
                        Py_INCREF(BitXor_singleton);
                        return BitXor_singleton;
                case BitAnd:
                        Py_INCREF(BitAnd_singleton);
                        return BitAnd_singleton;
                case FloorDiv:
                        Py_INCREF(FloorDiv_singleton);
                        return FloorDiv_singleton;
        }
        return NULL; /* cannot happen */
}
PyObject* ast2obj_unaryop(unaryop_ty o)
{
        switch(o) {
                case Invert:
                        Py_INCREF(Invert_singleton);
                        return Invert_singleton;
                case Not:
                        Py_INCREF(Not_singleton);
                        return Not_singleton;
                case UAdd:
                        Py_INCREF(UAdd_singleton);
                        return UAdd_singleton;
                case USub:
                        Py_INCREF(USub_singleton);
                        return USub_singleton;
        }
        return NULL; /* cannot happen */
}
PyObject* ast2obj_cmpop(cmpop_ty o)
{
        switch(o) {
                case Eq:
                        Py_INCREF(Eq_singleton);
                        return Eq_singleton;
                case NotEq:
                        Py_INCREF(NotEq_singleton);
                        return NotEq_singleton;
                case Lt:
                        Py_INCREF(Lt_singleton);
                        return Lt_singleton;
                case LtE:
                        Py_INCREF(LtE_singleton);
                        return LtE_singleton;
                case Gt:
                        Py_INCREF(Gt_singleton);
                        return Gt_singleton;
                case GtE:
                        Py_INCREF(GtE_singleton);
                        return GtE_singleton;
                case Is:
                        Py_INCREF(Is_singleton);
                        return Is_singleton;
                case IsNot:
                        Py_INCREF(IsNot_singleton);
                        return IsNot_singleton;
                case In:
                        Py_INCREF(In_singleton);
                        return In_singleton;
                case NotIn:
                        Py_INCREF(NotIn_singleton);
                        return NotIn_singleton;
        }
        return NULL; /* cannot happen */
}
PyObject*
ast2obj_comprehension(void* _o)
{
        comprehension_ty o = (comprehension_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(comprehension_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_expr(o->target);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "target", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->iter);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "iter", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->ifs, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "ifs", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_excepthandler(void* _o)
{
        excepthandler_ty o = (excepthandler_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(excepthandler_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_expr(o->type);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "type", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->name);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "name", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->body, ast2obj_stmt);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "body", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->lineno);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "lineno", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_int(o->col_offset);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "col_offset", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_arguments(void* _o)
{
        arguments_ty o = (arguments_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(arguments_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_list(o->args, ast2obj_arg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "args", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->vararg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "vararg", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->varargannotation);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "varargannotation", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->kwonlyargs, ast2obj_arg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "kwonlyargs", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->kwarg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "kwarg", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->kwargannotation);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "kwargannotation", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->defaults, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "defaults", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_list(o->kw_defaults, ast2obj_expr);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "kw_defaults", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_arg(void* _o)
{
        arg_ty o = (arg_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(arg_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_identifier(o->arg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "arg", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->annotation);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "annotation", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_keyword(void* _o)
{
        keyword_ty o = (keyword_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(keyword_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_identifier(o->arg);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "arg", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_expr(o->value);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "value", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}

PyObject*
ast2obj_alias(void* _o)
{
        alias_ty o = (alias_ty)_o;
        PyObject *result = NULL, *value = NULL;
        if (!o) {
                Py_INCREF(Py_None);
                return Py_None;
        }

        result = PyType_GenericNew(alias_type, NULL, NULL);
        if (!result) return NULL;
        value = ast2obj_identifier(o->name);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "name", value) == -1)
                goto failed;
        Py_DECREF(value);
        value = ast2obj_identifier(o->asname);
        if (!value) goto failed;
        if (PyObject_SetAttrString(result, "asname", value) == -1)
                goto failed;
        Py_DECREF(value);
        return result;
failed:
        Py_XDECREF(value);
        Py_XDECREF(result);
        return NULL;
}


PyMODINIT_FUNC
init_ast(void)
{
        PyObject *m, *d;
        if (!init_types()) return;
        m = Py_InitModule3("_ast", NULL, NULL);
        if (!m) return;
        d = PyModule_GetDict(m);
        if (PyDict_SetItemString(d, "AST", (PyObject*)AST_type) < 0) return;
        if (PyModule_AddIntConstant(m, "PyCF_ONLY_AST", PyCF_ONLY_AST) < 0)
                return;
        if (PyModule_AddStringConstant(m, "__version__", "60978") < 0)
                return;
        if (PyDict_SetItemString(d, "mod", (PyObject*)mod_type) < 0) return;
        if (PyDict_SetItemString(d, "Module", (PyObject*)Module_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Interactive", (PyObject*)Interactive_type)
            < 0) return;
        if (PyDict_SetItemString(d, "Expression", (PyObject*)Expression_type) <
            0) return;
        if (PyDict_SetItemString(d, "Suite", (PyObject*)Suite_type) < 0) return;
        if (PyDict_SetItemString(d, "stmt", (PyObject*)stmt_type) < 0) return;
        if (PyDict_SetItemString(d, "FunctionDef", (PyObject*)FunctionDef_type)
            < 0) return;
        if (PyDict_SetItemString(d, "ClassDef", (PyObject*)ClassDef_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Return", (PyObject*)Return_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Delete", (PyObject*)Delete_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Assign", (PyObject*)Assign_type) < 0)
            return;
        if (PyDict_SetItemString(d, "AugAssign", (PyObject*)AugAssign_type) <
            0) return;
        if (PyDict_SetItemString(d, "For", (PyObject*)For_type) < 0) return;
        if (PyDict_SetItemString(d, "While", (PyObject*)While_type) < 0) return;
        if (PyDict_SetItemString(d, "If", (PyObject*)If_type) < 0) return;
        if (PyDict_SetItemString(d, "With", (PyObject*)With_type) < 0) return;
        if (PyDict_SetItemString(d, "Raise", (PyObject*)Raise_type) < 0) return;
        if (PyDict_SetItemString(d, "TryExcept", (PyObject*)TryExcept_type) <
            0) return;
        if (PyDict_SetItemString(d, "TryFinally", (PyObject*)TryFinally_type) <
            0) return;
        if (PyDict_SetItemString(d, "Assert", (PyObject*)Assert_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Import", (PyObject*)Import_type) < 0)
            return;
        if (PyDict_SetItemString(d, "ImportFrom", (PyObject*)ImportFrom_type) <
            0) return;
        if (PyDict_SetItemString(d, "Global", (PyObject*)Global_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Nonlocal", (PyObject*)Nonlocal_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Expr", (PyObject*)Expr_type) < 0) return;
        if (PyDict_SetItemString(d, "Pass", (PyObject*)Pass_type) < 0) return;
        if (PyDict_SetItemString(d, "Break", (PyObject*)Break_type) < 0) return;
        if (PyDict_SetItemString(d, "Continue", (PyObject*)Continue_type) < 0)
            return;
        if (PyDict_SetItemString(d, "expr", (PyObject*)expr_type) < 0) return;
        if (PyDict_SetItemString(d, "BoolOp", (PyObject*)BoolOp_type) < 0)
            return;
        if (PyDict_SetItemString(d, "BinOp", (PyObject*)BinOp_type) < 0) return;
        if (PyDict_SetItemString(d, "UnaryOp", (PyObject*)UnaryOp_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Lambda", (PyObject*)Lambda_type) < 0)
            return;
        if (PyDict_SetItemString(d, "IfExp", (PyObject*)IfExp_type) < 0) return;
        if (PyDict_SetItemString(d, "Dict", (PyObject*)Dict_type) < 0) return;
        if (PyDict_SetItemString(d, "Set", (PyObject*)Set_type) < 0) return;
        if (PyDict_SetItemString(d, "ListComp", (PyObject*)ListComp_type) < 0)
            return;
        if (PyDict_SetItemString(d, "SetComp", (PyObject*)SetComp_type) < 0)
            return;
        if (PyDict_SetItemString(d, "DictComp", (PyObject*)DictComp_type) < 0)
            return;
        if (PyDict_SetItemString(d, "GeneratorExp",
            (PyObject*)GeneratorExp_type) < 0) return;
        if (PyDict_SetItemString(d, "Yield", (PyObject*)Yield_type) < 0) return;
        if (PyDict_SetItemString(d, "Compare", (PyObject*)Compare_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Call", (PyObject*)Call_type) < 0) return;
        if (PyDict_SetItemString(d, "Num", (PyObject*)Num_type) < 0) return;
        if (PyDict_SetItemString(d, "Str", (PyObject*)Str_type) < 0) return;
        if (PyDict_SetItemString(d, "Bytes", (PyObject*)Bytes_type) < 0) return;
        if (PyDict_SetItemString(d, "Ellipsis", (PyObject*)Ellipsis_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Attribute", (PyObject*)Attribute_type) <
            0) return;
        if (PyDict_SetItemString(d, "Subscript", (PyObject*)Subscript_type) <
            0) return;
        if (PyDict_SetItemString(d, "Starred", (PyObject*)Starred_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Name", (PyObject*)Name_type) < 0) return;
        if (PyDict_SetItemString(d, "List", (PyObject*)List_type) < 0) return;
        if (PyDict_SetItemString(d, "Tuple", (PyObject*)Tuple_type) < 0) return;
        if (PyDict_SetItemString(d, "expr_context",
            (PyObject*)expr_context_type) < 0) return;
        if (PyDict_SetItemString(d, "Load", (PyObject*)Load_type) < 0) return;
        if (PyDict_SetItemString(d, "Store", (PyObject*)Store_type) < 0) return;
        if (PyDict_SetItemString(d, "Del", (PyObject*)Del_type) < 0) return;
        if (PyDict_SetItemString(d, "AugLoad", (PyObject*)AugLoad_type) < 0)
            return;
        if (PyDict_SetItemString(d, "AugStore", (PyObject*)AugStore_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Param", (PyObject*)Param_type) < 0) return;
        if (PyDict_SetItemString(d, "slice", (PyObject*)slice_type) < 0) return;
        if (PyDict_SetItemString(d, "Slice", (PyObject*)Slice_type) < 0) return;
        if (PyDict_SetItemString(d, "ExtSlice", (PyObject*)ExtSlice_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Index", (PyObject*)Index_type) < 0) return;
        if (PyDict_SetItemString(d, "boolop", (PyObject*)boolop_type) < 0)
            return;
        if (PyDict_SetItemString(d, "And", (PyObject*)And_type) < 0) return;
        if (PyDict_SetItemString(d, "Or", (PyObject*)Or_type) < 0) return;
        if (PyDict_SetItemString(d, "operator", (PyObject*)operator_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Add", (PyObject*)Add_type) < 0) return;
        if (PyDict_SetItemString(d, "Sub", (PyObject*)Sub_type) < 0) return;
        if (PyDict_SetItemString(d, "Mult", (PyObject*)Mult_type) < 0) return;
        if (PyDict_SetItemString(d, "Div", (PyObject*)Div_type) < 0) return;
        if (PyDict_SetItemString(d, "Mod", (PyObject*)Mod_type) < 0) return;
        if (PyDict_SetItemString(d, "Pow", (PyObject*)Pow_type) < 0) return;
        if (PyDict_SetItemString(d, "LShift", (PyObject*)LShift_type) < 0)
            return;
        if (PyDict_SetItemString(d, "RShift", (PyObject*)RShift_type) < 0)
            return;
        if (PyDict_SetItemString(d, "BitOr", (PyObject*)BitOr_type) < 0) return;
        if (PyDict_SetItemString(d, "BitXor", (PyObject*)BitXor_type) < 0)
            return;
        if (PyDict_SetItemString(d, "BitAnd", (PyObject*)BitAnd_type) < 0)
            return;
        if (PyDict_SetItemString(d, "FloorDiv", (PyObject*)FloorDiv_type) < 0)
            return;
        if (PyDict_SetItemString(d, "unaryop", (PyObject*)unaryop_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Invert", (PyObject*)Invert_type) < 0)
            return;
        if (PyDict_SetItemString(d, "Not", (PyObject*)Not_type) < 0) return;
        if (PyDict_SetItemString(d, "UAdd", (PyObject*)UAdd_type) < 0) return;
        if (PyDict_SetItemString(d, "USub", (PyObject*)USub_type) < 0) return;
        if (PyDict_SetItemString(d, "cmpop", (PyObject*)cmpop_type) < 0) return;
        if (PyDict_SetItemString(d, "Eq", (PyObject*)Eq_type) < 0) return;
        if (PyDict_SetItemString(d, "NotEq", (PyObject*)NotEq_type) < 0) return;
        if (PyDict_SetItemString(d, "Lt", (PyObject*)Lt_type) < 0) return;
        if (PyDict_SetItemString(d, "LtE", (PyObject*)LtE_type) < 0) return;
        if (PyDict_SetItemString(d, "Gt", (PyObject*)Gt_type) < 0) return;
        if (PyDict_SetItemString(d, "GtE", (PyObject*)GtE_type) < 0) return;
        if (PyDict_SetItemString(d, "Is", (PyObject*)Is_type) < 0) return;
        if (PyDict_SetItemString(d, "IsNot", (PyObject*)IsNot_type) < 0) return;
        if (PyDict_SetItemString(d, "In", (PyObject*)In_type) < 0) return;
        if (PyDict_SetItemString(d, "NotIn", (PyObject*)NotIn_type) < 0) return;
        if (PyDict_SetItemString(d, "comprehension",
            (PyObject*)comprehension_type) < 0) return;
        if (PyDict_SetItemString(d, "excepthandler",
            (PyObject*)excepthandler_type) < 0) return;
        if (PyDict_SetItemString(d, "arguments", (PyObject*)arguments_type) <
            0) return;
        if (PyDict_SetItemString(d, "arg", (PyObject*)arg_type) < 0) return;
        if (PyDict_SetItemString(d, "keyword", (PyObject*)keyword_type) < 0)
            return;
        if (PyDict_SetItemString(d, "alias", (PyObject*)alias_type) < 0) return;
}


PyObject* PyAST_mod2obj(mod_ty t)
{
    init_types();
    return ast2obj_mod(t);
}


