// This file is generated by Tools/cases_generator/tier2_generator.py
// from:
//   Python/bytecodes.c
// Do not edit!

#ifdef TIER_ONE
    #error "This file is for Tier 2 only"
#endif
#define TIER_TWO 2

        case _NOP: {
            break;
        }

        case _RESUME_CHECK: {
            #if defined(__EMSCRIPTEN__)
            if (_Py_emscripten_signal_clock == 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            _Py_emscripten_signal_clock -= Py_EMSCRIPTEN_SIGNAL_HANDLING;
            #endif
            uintptr_t eval_breaker = _Py_atomic_load_uintptr_relaxed(&tstate->eval_breaker);
            uintptr_t version = _PyFrame_GetCode(frame)->_co_instrumentation_version;
            assert((version & _PY_EVAL_EVENTS_MASK) == 0);
            if (eval_breaker != version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        /* _INSTRUMENTED_RESUME is not a viable micro-op for tier 2 because it is instrumented */

        case _LOAD_FAST_CHECK: {
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            if (Py_STACKREF_UNTAG_BORROWED(value) == NULL) {
                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,
                    UNBOUNDLOCAL_ERROR_MSG,
                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)
                );
                if (1) JUMP_TO_ERROR();
            }
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_0: {
            _PyStackRef value;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_1: {
            _PyStackRef value;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_2: {
            _PyStackRef value;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_3: {
            _PyStackRef value;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_4: {
            _PyStackRef value;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_5: {
            _PyStackRef value;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_6: {
            _PyStackRef value;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_7: {
            _PyStackRef value;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST: {
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            assert(Py_STACKREF_UNTAG_BORROWED(value) != NULL);
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FAST_AND_CLEAR: {
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = GETLOCAL(oparg);
            // do not use SETLOCAL here, it decrefs the old value
            GETLOCAL(oparg) = Py_STACKREF_TAG(NULL);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_CONST: {
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = Py_STACKREF_TAG(GETITEM(FRAME_CO_CONSTS, oparg));
            // Perhaps consider making co_consts tagged too?
            Py_INCREF_STACKREF(value);
            stack_pointer[0] = (value);
            stack_pointer += 1;
            break;
        }

        case _STORE_FAST_0: {
            _PyStackRef value;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_1: {
            _PyStackRef value;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_2: {
            _PyStackRef value;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_3: {
            _PyStackRef value;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_4: {
            _PyStackRef value;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_5: {
            _PyStackRef value;
            oparg = 5;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_6: {
            _PyStackRef value;
            oparg = 6;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST_7: {
            _PyStackRef value;
            oparg = 7;
            assert(oparg == CURRENT_OPARG());
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _STORE_FAST: {
            _PyStackRef value;
            oparg = CURRENT_OPARG();
            value = stack_pointer[-1];

            SETLOCAL(oparg, value);
            stack_pointer += -1;
            break;
        }

        case _POP_TOP: {
            _PyStackRef value_tagged;
            PyObject *value;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            stack_pointer += -1;
            break;
        }

        case _PUSH_NULL: {
            PyObject *res;
            res = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            stack_pointer += 1;
            break;
        }

        case _END_SEND: {
            _PyStackRef value_tagged;
            PyObject *value;
            _PyStackRef receiver_tagged;
            PyObject *receiver;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            receiver_tagged = stack_pointer[-2];
            receiver = Py_STACKREF_UNTAG_BORROWED(receiver_tagged);

            (void)receiver;
            Py_DECREF_STACKREF(receiver_tagged);
            stack_pointer[-2] = Py_STACKREF_TAG(value);
            stack_pointer += -1;
            break;
        }

        case _UNARY_NEGATIVE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            res = PyNumber_Negative(value);
            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _UNARY_NOT: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            assert(PyBool_Check(value));
            res = Py_IsFalse(value) ? Py_True : Py_False;
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _TO_BOOL: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            int err = PyObject_IsTrue(value);
            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            if (err < 0) JUMP_TO_ERROR();
            res = err ? Py_True : Py_False;
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _TO_BOOL_BOOL: {
            _PyStackRef value_tagged;
            PyObject *value;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            if (!PyBool_Check(value)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            break;
        }

        case _TO_BOOL_INT: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            if (!PyLong_CheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            if (_PyLong_IsZero((PyLongObject *)value)) {
                assert(_Py_IsImmortal(value));
                res = Py_False;
            }
            else {
                (void)value;
                Py_DECREF_STACKREF(value_tagged);
                res = Py_True;
            }
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _TO_BOOL_LIST: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            if (!PyList_CheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = Py_SIZE(value) ? Py_True : Py_False;
            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _TO_BOOL_NONE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            // This one is a bit weird, because we expect *some* failures:
            if (!Py_IsNone(value)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            res = Py_False;
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _TO_BOOL_STR: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            if (!PyUnicode_CheckExact(value)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(TO_BOOL, hit);
            if (value == &_Py_STR(empty)) {
                assert(_Py_IsImmortal(value));
                res = Py_False;
            }
            else {
                assert(Py_SIZE(value));
                (void)value;
                Py_DECREF_STACKREF(value_tagged);
                res = Py_True;
            }
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _REPLACE_WITH_TRUE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            res = Py_True;
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _UNARY_INVERT: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            res = PyNumber_Invert(value);
            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _GUARD_BOTH_INT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!PyLong_CheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyLong_CheckExact(right)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            res = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);
            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_ADD_INT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);
            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            res = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);
            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _GUARD_BOTH_FLOAT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!PyFloat_CheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyFloat_CheckExact(right)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left)->ob_fval *
            ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left)->ob_fval +
            ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            double dres =
            ((PyFloatObject *)left)->ob_fval -
            ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _GUARD_BOTH_UNICODE: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!PyUnicode_CheckExact(left)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyUnicode_CheckExact(right)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(BINARY_OP, hit);
            res = PyUnicode_Concat(left, right);
            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef container_tagged;
            PyObject *container;
            PyObject *res;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            container_tagged = stack_pointer[-2];
            container = Py_STACKREF_UNTAG_BORROWED(container_tagged);

            res = PyObject_GetItem(container, sub);
            (void)container;
            Py_DECREF_STACKREF(container_tagged);
            (void)sub;
            Py_DECREF_STACKREF(sub_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_SLICE: {
            _PyStackRef stop;
            _PyStackRef start;
            _PyStackRef container;
            PyObject *res;
            stop = stack_pointer[-1];

            start = stack_pointer[-2];

            container = stack_pointer[-3];

            PyObject *slice = _PyBuildSlice_ConsumeStackRefs(start, stop);
            // Can't use ERROR_IF() here, because we haven't
            // DECREF'ed container yet, and we still own slice.
            if (slice == NULL) {
                res = NULL;
            }
            else {
                res = PyObject_GetItem(Py_STACKREF_UNTAG_BORROWED(container), slice);
                Py_DECREF(slice);
            }
            Py_DECREF_STACKREF(container);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-3] = Py_STACKREF_TAG(res);
            stack_pointer += -2;
            break;
        }

        case _STORE_SLICE: {
            _PyStackRef stop;
            _PyStackRef start;
            _PyStackRef container;
            _PyStackRef v;
            stop = stack_pointer[-1];

            start = stack_pointer[-2];

            container = stack_pointer[-3];

            v = stack_pointer[-4];

            PyObject *slice = _PyBuildSlice_ConsumeStackRefs(start, stop);
            int err;
            if (slice == NULL) {
                err = 1;
            }
            else {
                err = PyObject_SetItem(Py_STACKREF_UNTAG_BORROWED(container), slice, Py_STACKREF_UNTAG_OWNED(v));
                Py_DECREF(slice);
            }
            Py_DECREF_STACKREF(v);
            Py_DECREF_STACKREF(container);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -4;
            break;
        }

        case _BINARY_SUBSCR_LIST_INT: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef list_tagged;
            PyObject *list;
            PyObject *res;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            list_tagged = stack_pointer[-2];
            list = Py_STACKREF_UNTAG_BORROWED(list_tagged);

            if (!PyLong_CheckExact(sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyList_CheckExact(list)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // Deopt unless 0 <= sub < PyList_Size(list)
            if (!_PyLong_IsNonNegativeCompact((PyLongObject *)sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            if (index >= PyList_GET_SIZE(list)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_SUBSCR, hit);
            res = PyList_GET_ITEM(list, index);
            assert(res != NULL);
            Py_INCREF(res);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF_STACKREF(list_tagged);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_STR_INT: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef str_tagged;
            PyObject *str;
            PyObject *res;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            str_tagged = stack_pointer[-2];
            str = Py_STACKREF_UNTAG_BORROWED(str_tagged);

            if (!PyLong_CheckExact(sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyUnicode_CheckExact(str)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!_PyLong_IsNonNegativeCompact((PyLongObject *)sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            if (PyUnicode_GET_LENGTH(str) <= index) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // Specialize for reading an ASCII character from any string:
            Py_UCS4 c = PyUnicode_READ_CHAR(str, index);
            if (Py_ARRAY_LENGTH(_Py_SINGLETON(strings).ascii) <= c) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_SUBSCR, hit);
            res = (PyObject*)&_Py_SINGLETON(strings).ascii[c];
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF_STACKREF(str_tagged);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_TUPLE_INT: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef tuple_tagged;
            PyObject *tuple;
            PyObject *res;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            tuple_tagged = stack_pointer[-2];
            tuple = Py_STACKREF_UNTAG_BORROWED(tuple_tagged);

            if (!PyLong_CheckExact(sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyTuple_CheckExact(tuple)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // Deopt unless 0 <= sub < PyTuple_Size(list)
            if (!_PyLong_IsNonNegativeCompact((PyLongObject *)sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            if (index >= PyTuple_GET_SIZE(tuple)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_SUBSCR, hit);
            res = PyTuple_GET_ITEM(tuple, index);
            assert(res != NULL);
            Py_INCREF(res);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF_STACKREF(tuple_tagged);
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_DICT: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef dict_tagged;
            PyObject *dict;
            PyObject *res;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            dict_tagged = stack_pointer[-2];
            dict = Py_STACKREF_UNTAG_BORROWED(dict_tagged);

            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(BINARY_SUBSCR, hit);
            int rc = PyDict_GetItemRef(dict, sub, &res);
            if (rc == 0) {
                _PyErr_SetKeyError(sub);
            }
            (void)dict;
            Py_DECREF_STACKREF(dict_tagged);
            (void)sub;
            Py_DECREF_STACKREF(sub_tagged);
            if (rc <= 0) JUMP_TO_ERROR();
            // not found or error
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        /* _BINARY_SUBSCR_GETITEM is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _LIST_APPEND: {
            _PyStackRef v_tagged;
            PyObject *v;
            _PyStackRef list_tagged;
            PyObject *list;
            oparg = CURRENT_OPARG();
            v_tagged = stack_pointer[-1];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            list_tagged = stack_pointer[-2 - (oparg-1)];
            list = Py_STACKREF_UNTAG_BORROWED(list_tagged);

            if (_PyList_AppendTakeRef((PyListObject *)list, v) < 0) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        case _SET_ADD: {
            _PyStackRef v_tagged;
            PyObject *v;
            _PyStackRef set_tagged;
            PyObject *set;
            oparg = CURRENT_OPARG();
            v_tagged = stack_pointer[-1];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            set_tagged = stack_pointer[-2 - (oparg-1)];
            set = Py_STACKREF_UNTAG_BORROWED(set_tagged);

            int err = PySet_Add(set, v);
            (void)v;
            Py_DECREF_STACKREF(v_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        case _STORE_SUBSCR: {
            _PyStackRef sub;
            _PyStackRef container;
            _PyStackRef v;
            sub = stack_pointer[-1];

            container = stack_pointer[-2];

            v = stack_pointer[-3];

            /* container[sub] = v */
            int err = PyObject_SetItem(Py_STACKREF_UNTAG_BORROWED(container), Py_STACKREF_UNTAG_OWNED(sub), Py_STACKREF_UNTAG_OWNED(v));
            (void)v;
            Py_DECREF_STACKREF(v);
            (void)container;
            Py_DECREF_STACKREF(container);
            (void)sub;
            Py_DECREF_STACKREF(sub);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -3;
            break;
        }

        case _STORE_SUBSCR_LIST_INT: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef list_tagged;
            PyObject *list;
            _PyStackRef value;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            list_tagged = stack_pointer[-2];
            list = Py_STACKREF_UNTAG_BORROWED(list_tagged);

            value = stack_pointer[-3];

            if (!PyLong_CheckExact(sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyList_CheckExact(list)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // Ensure nonnegative, zero-or-one-digit ints.
            if (!_PyLong_IsNonNegativeCompact((PyLongObject *)sub)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            // Ensure index < len(list)
            if (index >= PyList_GET_SIZE(list)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(STORE_SUBSCR, hit);
            PyObject *old_value = PyList_GET_ITEM(list, index);
            PyList_SET_ITEM(list, index, Py_STACKREF_UNTAG_OWNED(value));
            assert(old_value != NULL);
            Py_DECREF(old_value);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF_STACKREF(list_tagged);
            stack_pointer += -3;
            break;
        }

        case _STORE_SUBSCR_DICT: {
            _PyStackRef sub;
            _PyStackRef dict_tagged;
            PyObject *dict;
            _PyStackRef value;
            sub = stack_pointer[-1];

            dict_tagged = stack_pointer[-2];
            dict = Py_STACKREF_UNTAG_BORROWED(dict_tagged);

            value = stack_pointer[-3];

            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(STORE_SUBSCR, hit);
            int err = _PyDict_SetItem_Take2((PyDictObject *)dict,
                Py_STACKREF_UNTAG_OWNED(sub), Py_STACKREF_UNTAG_OWNED(value));
            Py_DECREF_STACKREF(dict_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -3;
            break;
        }

        case _DELETE_SUBSCR: {
            _PyStackRef sub_tagged;
            PyObject *sub;
            _PyStackRef container_tagged;
            PyObject *container;
            sub_tagged = stack_pointer[-1];
            sub = Py_STACKREF_UNTAG_BORROWED(sub_tagged);

            container_tagged = stack_pointer[-2];
            container = Py_STACKREF_UNTAG_BORROWED(container_tagged);

            /* del container[sub] */
            int err = PyObject_DelItem(container, sub);
            (void)container;
            Py_DECREF_STACKREF(container_tagged);
            (void)sub;
            Py_DECREF_STACKREF(sub_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -2;
            break;
        }

        case _CALL_INTRINSIC_1: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            oparg = CURRENT_OPARG();
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            assert(oparg <= MAX_INTRINSIC_1);
            res = _PyIntrinsics_UnaryFunctions[oparg].func(tstate, value);
            (void)value;
            Py_DECREF_STACKREF(value_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _CALL_INTRINSIC_2: {
            _PyStackRef value1_tagged;
            PyObject *value1;
            _PyStackRef value2_tagged;
            PyObject *value2;
            PyObject *res;
            oparg = CURRENT_OPARG();
            value1_tagged = stack_pointer[-1];
            value1 = Py_STACKREF_UNTAG_BORROWED(value1_tagged);

            value2_tagged = stack_pointer[-2];
            value2 = Py_STACKREF_UNTAG_BORROWED(value2_tagged);

            assert(oparg <= MAX_INTRINSIC_2);
            res = _PyIntrinsics_BinaryFunctions[oparg].func(tstate, value2, value1);
            (void)value2;
            Py_DECREF_STACKREF(value2_tagged);
            (void)value1;
            Py_DECREF_STACKREF(value1_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _POP_FRAME: {
            _PyStackRef retval;
            retval = stack_pointer[-1];

            #if TIER_ONE
            assert(frame != &entry_frame);
            #endif
            stack_pointer += -1;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            assert(EMPTY());
            _Py_LeaveRecursiveCallPy(tstate);
            // GH-99729: We need to unlink the frame *before* clearing it:
            _PyInterpreterFrame *dying = frame;
            frame = tstate->current_frame = dying->previous;
            _PyEval_FrameClearAndPop(tstate, dying);
            _PyFrame_StackPush(frame, retval);
            LOAD_SP();
            LOAD_IP(frame->return_offset);
            #if LLTRACE && TIER_ONE
            lltrace = maybe_lltrace_resume_frame(frame, &entry_frame, GLOBALS());
            if (lltrace < 0) {
                goto exit_unwind;
            }
            #endif
            break;
        }

        /* _INSTRUMENTED_RETURN_VALUE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_RETURN_CONST is not a viable micro-op for tier 2 because it is instrumented */

        case _GET_AITER: {
            _PyStackRef obj_tagged;
            PyObject *obj;
            PyObject *iter;
            obj_tagged = stack_pointer[-1];
            obj = Py_STACKREF_UNTAG_BORROWED(obj_tagged);

            unaryfunc getter = NULL;
            PyTypeObject *type = Py_TYPE(obj);
            if (type->tp_as_async != NULL) {
                getter = type->tp_as_async->am_aiter;
            }
            if (getter == NULL) {
                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' requires an object with "
                              "__aiter__ method, got %.100s",
                              type->tp_name);
                (void)obj;
                Py_DECREF_STACKREF(obj_tagged);
                if (true) JUMP_TO_ERROR();
            }
            iter = (*getter)(obj);
            (void)obj;
            Py_DECREF_STACKREF(obj_tagged);
            if (iter == NULL) JUMP_TO_ERROR();
            if (Py_TYPE(iter)->tp_as_async == NULL ||
                Py_TYPE(iter)->tp_as_async->am_anext == NULL) {
                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' received an object from __aiter__ "
                              "that does not implement __anext__: %.100s",
                              Py_TYPE(iter)->tp_name);
                Py_DECREF(iter);
                if (true) JUMP_TO_ERROR();
            }
            stack_pointer[-1] = Py_STACKREF_TAG(iter);
            break;
        }

        case _GET_ANEXT: {
            _PyStackRef aiter_tagged;
            PyObject *aiter;
            PyObject *awaitable;
            aiter_tagged = stack_pointer[-1];
            aiter = Py_STACKREF_UNTAG_BORROWED(aiter_tagged);

            unaryfunc getter = NULL;
            PyObject *next_iter = NULL;
            PyTypeObject *type = Py_TYPE(aiter);
            if (PyAsyncGen_CheckExact(aiter)) {
                awaitable = type->tp_as_async->am_anext(aiter);
                if (awaitable == NULL) {
                    JUMP_TO_ERROR();
                }
            } else {
                if (type->tp_as_async != NULL){
                    getter = type->tp_as_async->am_anext;
                }
                if (getter != NULL) {
                    next_iter = (*getter)(aiter);
                    if (next_iter == NULL) {
                        JUMP_TO_ERROR();
                    }
                }
                else {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'async for' requires an iterator with "
                                  "__anext__ method, got %.100s",
                                  type->tp_name);
                    JUMP_TO_ERROR();
                }
                awaitable = _PyCoro_GetAwaitableIter(next_iter);
                if (awaitable == NULL) {
                    _PyErr_FormatFromCause(
                        PyExc_TypeError,
                        "'async for' received an invalid object "
                        "from __anext__: %.100s",
                        Py_TYPE(next_iter)->tp_name);
                    Py_DECREF(next_iter);
                    JUMP_TO_ERROR();
                } else {
                    Py_DECREF(next_iter);
                }
            }
            stack_pointer[0] = Py_STACKREF_TAG(awaitable);
            stack_pointer += 1;
            break;
        }

        case _GET_AWAITABLE: {
            _PyStackRef iterable_tagged;
            PyObject *iterable;
            PyObject *iter;
            oparg = CURRENT_OPARG();
            iterable_tagged = stack_pointer[-1];
            iterable = Py_STACKREF_UNTAG_BORROWED(iterable_tagged);

            iter = _PyCoro_GetAwaitableIter(iterable);
            if (iter == NULL) {
                _PyEval_FormatAwaitableError(tstate, Py_TYPE(iterable), oparg);
            }
            (void)iterable;
            Py_DECREF_STACKREF(iterable_tagged);
            if (iter != NULL && PyCoro_CheckExact(iter)) {
                PyObject *yf = _PyGen_yf((PyGenObject*)iter);
                if (yf != NULL) {
                    /* `iter` is a coroutine object that is being
                       awaited, `yf` is a pointer to the current awaitable
                       being awaited on. */
                    Py_DECREF(yf);
                    Py_CLEAR(iter);
                    _PyErr_SetString(tstate, PyExc_RuntimeError,
                                     "coroutine is being awaited already");
                    /* The code below jumps to `error` if `iter` is NULL. */
                }
            }
            if (iter == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(iter);
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _SEND_GEN is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _INSTRUMENTED_YIELD_VALUE is not a viable micro-op for tier 2 because it is instrumented */

        case _POP_EXCEPT: {
            _PyStackRef exc_value_tagged;
            PyObject *exc_value;
            exc_value_tagged = stack_pointer[-1];
            exc_value = Py_STACKREF_UNTAG_BORROWED(exc_value_tagged);

            _PyErr_StackItem *exc_info = tstate->exc_info;
            Py_XSETREF(exc_info->exc_value, exc_value == Py_None ? NULL : exc_value);
            stack_pointer += -1;
            break;
        }

        case _LOAD_ASSERTION_ERROR: {
            PyObject *value;
            value = Py_NewRef(PyExc_AssertionError);
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_BUILD_CLASS: {
            PyObject *bc;
            if (PyMapping_GetOptionalItem(BUILTINS(), &_Py_ID(__build_class__), &bc) < 0) JUMP_TO_ERROR();
            if (bc == NULL) {
                _PyErr_SetString(tstate, PyExc_NameError,
                                 "__build_class__ not found");
                if (true) JUMP_TO_ERROR();
            }
            stack_pointer[0] = Py_STACKREF_TAG(bc);
            stack_pointer += 1;
            break;
        }

        case _STORE_NAME: {
            _PyStackRef v_tagged;
            PyObject *v;
            oparg = CURRENT_OPARG();
            v_tagged = stack_pointer[-1];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when storing %R", name);
                (void)v;
                Py_DECREF_STACKREF(v_tagged);
                if (true) JUMP_TO_ERROR();
            }
            if (PyDict_CheckExact(ns))
            err = PyDict_SetItem(ns, name, v);
            else
            err = PyObject_SetItem(ns, name, v);
            (void)v;
            Py_DECREF_STACKREF(v_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        case _DELETE_NAME: {
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals when deleting %R", name);
                JUMP_TO_ERROR();
            }
            err = PyObject_DelItem(ns, name);
            // Can't use ERROR_IF here.
            if (err != 0) {
                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,
                    NAME_ERROR_MSG,
                    name);
                JUMP_TO_ERROR();
            }
            break;
        }

        case _UNPACK_SEQUENCE: {
            _PyStackRef seq_tagged;
            PyObject *seq;
            oparg = CURRENT_OPARG();
            seq_tagged = stack_pointer[-1];
            seq = Py_STACKREF_UNTAG_BORROWED(seq_tagged);

            _PyStackRef *top = stack_pointer + oparg - 1;
            int res = _PyEval_UnpackTaggedIterable(tstate, seq, oparg, -1, top);
            (void)seq;
            Py_DECREF_STACKREF(seq_tagged);
            if (res == 0) JUMP_TO_ERROR();
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE: {
            _PyStackRef seq_tagged;
            PyObject *seq;
            PyObject *val1;
            PyObject *val0;
            oparg = CURRENT_OPARG();
            seq_tagged = stack_pointer[-1];
            seq = Py_STACKREF_UNTAG_BORROWED(seq_tagged);

            assert(oparg == 2);
            if (!PyTuple_CheckExact(seq)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyTuple_GET_SIZE(seq) != 2) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            val0 = Py_NewRef(PyTuple_GET_ITEM(seq, 0));
            val1 = Py_NewRef(PyTuple_GET_ITEM(seq, 1));
            (void)seq;
            Py_DECREF_STACKREF(seq_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(val1);
            stack_pointer[0] = Py_STACKREF_TAG(val0);
            stack_pointer += 1;
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE: {
            _PyStackRef seq_tagged;
            PyObject *seq;
            _PyStackRef *values;
            oparg = CURRENT_OPARG();
            seq_tagged = stack_pointer[-1];
            seq = Py_STACKREF_UNTAG_BORROWED(seq_tagged);

            values = &stack_pointer[-1];
            if (!PyTuple_CheckExact(seq)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyTuple_GET_SIZE(seq) != oparg) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyTuple_ITEMS(seq);
            for (int i = oparg; --i >= 0; ) {
                *values++ = Py_NewRef_StackRef(Py_STACKREF_TAG(items[i]));
            }
            (void)seq;
            Py_DECREF_STACKREF(seq_tagged);
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_SEQUENCE_LIST: {
            _PyStackRef seq_tagged;
            PyObject *seq;
            _PyStackRef *values;
            oparg = CURRENT_OPARG();
            seq_tagged = stack_pointer[-1];
            seq = Py_STACKREF_UNTAG_BORROWED(seq_tagged);

            values = &stack_pointer[-1];
            if (!PyList_CheckExact(seq)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyList_GET_SIZE(seq) != oparg) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyList_ITEMS(seq);
            for (int i = oparg; --i >= 0; ) {
                *values++ = Py_NewRef_StackRef(Py_STACKREF_TAG(items[i]));
            }
            (void)seq;
            Py_DECREF_STACKREF(seq_tagged);
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_EX: {
            _PyStackRef seq_tagged;
            PyObject *seq;
            oparg = CURRENT_OPARG();
            seq_tagged = stack_pointer[-1];
            seq = Py_STACKREF_UNTAG_BORROWED(seq_tagged);

            int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);
            _PyStackRef *top = stack_pointer + totalargs - 1;
            int res = _PyEval_UnpackTaggedIterable(tstate, seq, oparg & 0xFF, oparg >> 8, top);
            (void)seq;
            Py_DECREF_STACKREF(seq_tagged);
            if (res == 0) JUMP_TO_ERROR();
            stack_pointer += (oparg >> 8) + (oparg & 0xFF);
            break;
        }

        case _STORE_ATTR: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            _PyStackRef v_tagged;
            PyObject *v;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            v_tagged = stack_pointer[-2];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyObject_SetAttr(owner, name, v);
            (void)v;
            Py_DECREF_STACKREF(v_tagged);
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -2;
            break;
        }

        case _DELETE_ATTR: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyObject_DelAttr(owner, name);
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        case _STORE_GLOBAL: {
            _PyStackRef v_tagged;
            PyObject *v;
            oparg = CURRENT_OPARG();
            v_tagged = stack_pointer[-1];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyDict_SetItem(GLOBALS(), name, v);
            (void)v;
            Py_DECREF_STACKREF(v_tagged);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        case _DELETE_GLOBAL: {
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyDict_Pop(GLOBALS(), name, NULL);
            // Can't use ERROR_IF here.
            if (err < 0) {
                JUMP_TO_ERROR();
            }
            if (err == 0) {
                _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,
                    NAME_ERROR_MSG, name);
                JUMP_TO_ERROR();
            }
            break;
        }

        case _LOAD_LOCALS: {
            PyObject *locals;
            locals = LOCALS();
            if (locals == NULL) {
                _PyErr_SetString(tstate, PyExc_SystemError,
                                 "no locals found");
                if (true) JUMP_TO_ERROR();
            }
            Py_INCREF(locals);
            stack_pointer[0] = Py_STACKREF_TAG(locals);
            stack_pointer += 1;
            break;
        }

        case _LOAD_FROM_DICT_OR_GLOBALS: {
            _PyStackRef mod_or_class_dict_tagged;
            PyObject *mod_or_class_dict;
            PyObject *v;
            oparg = CURRENT_OPARG();
            mod_or_class_dict_tagged = stack_pointer[-1];
            mod_or_class_dict = Py_STACKREF_UNTAG_BORROWED(mod_or_class_dict_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            if (PyMapping_GetOptionalItem(mod_or_class_dict, name, &v) < 0) {
                JUMP_TO_ERROR();
            }
            if (v == NULL) {
                if (PyDict_GetItemRef(GLOBALS(), name, &v) < 0) {
                    JUMP_TO_ERROR();
                }
                if (v == NULL) {
                    if (PyMapping_GetOptionalItem(BUILTINS(), name, &v) < 0) {
                        JUMP_TO_ERROR();
                    }
                    if (v == NULL) {
                        _PyEval_FormatExcCheckArg(
                            tstate, PyExc_NameError,
                            NAME_ERROR_MSG, name);
                        JUMP_TO_ERROR();
                    }
                }
            }
            (void)mod_or_class_dict;
            Py_DECREF_STACKREF(mod_or_class_dict_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(v);
            break;
        }

        /* _LOAD_NAME is not a viable micro-op for tier 2 because it has both popping and not-popping errors */

        case _LOAD_GLOBAL: {
            PyObject *res;
            PyObject *null = NULL;
            oparg = CURRENT_OPARG();
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            if (PyDict_CheckExact(GLOBALS())
                && PyDict_CheckExact(BUILTINS()))
            {
                res = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),
                    (PyDictObject *)BUILTINS(),
                    name);
                if (res == NULL) {
                    if (!_PyErr_Occurred(tstate)) {
                        /* _PyDict_LoadGlobal() returns NULL without raising
                         * an exception if the key doesn't exist */
                        _PyEval_FormatExcCheckArg(tstate, PyExc_NameError,
                            NAME_ERROR_MSG, name);
                    }
                    if (true) JUMP_TO_ERROR();
                }
            }
            else {
                /* Slow-path if globals or builtins is not a dict */
                /* namespace 1: globals */
                if (PyMapping_GetOptionalItem(GLOBALS(), name, &res) < 0) JUMP_TO_ERROR();
                if (res == NULL) {
                    /* namespace 2: builtins */
                    if (PyMapping_GetOptionalItem(BUILTINS(), name, &res) < 0) JUMP_TO_ERROR();
                    if (res == NULL) {
                        _PyEval_FormatExcCheckArg(
                            tstate, PyExc_NameError,
                            NAME_ERROR_MSG, name);
                        if (true) JUMP_TO_ERROR();
                    }
                }
            }
            null = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            if (oparg & 1) stack_pointer[1] = Py_STACKREF_TAG(null);
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            uint16_t version = (uint16_t)CURRENT_OPERAND();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (dict->ma_keys->dk_version != version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(dict->ma_keys));
            break;
        }

        case _GUARD_BUILTINS_VERSION: {
            uint16_t version = (uint16_t)CURRENT_OPERAND();
            PyDictObject *dict = (PyDictObject *)BUILTINS();
            if (!PyDict_CheckExact(dict)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (dict->ma_keys->dk_version != version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(DK_IS_UNICODE(dict->ma_keys));
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            PyObject *res;
            PyObject *null = NULL;
            oparg = CURRENT_OPARG();
            uint16_t index = (uint16_t)CURRENT_OPERAND();
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(dict->ma_keys);
            res = entries[index].me_value;
            if (res == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_INCREF(res);
            STAT_INC(LOAD_GLOBAL, hit);
            null = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            if (oparg & 1) stack_pointer[1] = Py_STACKREF_TAG(null);
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            PyObject *res;
            PyObject *null = NULL;
            oparg = CURRENT_OPARG();
            uint16_t index = (uint16_t)CURRENT_OPERAND();
            PyDictObject *bdict = (PyDictObject *)BUILTINS();
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(bdict->ma_keys);
            res = entries[index].me_value;
            if (res == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_INCREF(res);
            STAT_INC(LOAD_GLOBAL, hit);
            null = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            if (oparg & 1) stack_pointer[1] = Py_STACKREF_TAG(null);
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _DELETE_FAST: {
            oparg = CURRENT_OPARG();
            PyObject *v = Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
            if (v == NULL) {
                _PyEval_FormatExcCheckArg(tstate, PyExc_UnboundLocalError,
                    UNBOUNDLOCAL_ERROR_MSG,
                    PyTuple_GetItem(_PyFrame_GetCode(frame)->co_localsplusnames, oparg)
                );
                if (1) JUMP_TO_ERROR();
            }
            SETLOCAL(oparg, Py_STACKREF_TAG(NULL));
            break;
        }

        case _MAKE_CELL: {
            oparg = CURRENT_OPARG();
            // "initial" is probably NULL but not if it's an arg (or set
            // via PyFrame_LocalsToFast() before MAKE_CELL has run).
            PyObject *initial = Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
            PyObject *cell = PyCell_New(initial);
            if (cell == NULL) {
                JUMP_TO_ERROR();
            }
            SETLOCAL(oparg, Py_STACKREF_TAG(cell));
            break;
        }

        case _DELETE_DEREF: {
            oparg = CURRENT_OPARG();
            PyObject *cell = Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
            // Can't use ERROR_IF here.
            // Fortunately we don't need its superpower.
            PyObject *oldobj = PyCell_SwapTakeRef((PyCellObject *)cell, NULL);
            if (oldobj == NULL) {
                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                JUMP_TO_ERROR();
            }
            Py_DECREF_STACKREF(Py_STACKREF_TAG(oldobj));
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF: {
            _PyStackRef class_dict_tagged;
            PyObject *class_dict;
            PyObject *value;
            oparg = CURRENT_OPARG();
            class_dict_tagged = stack_pointer[-1];
            class_dict = Py_STACKREF_UNTAG_BORROWED(class_dict_tagged);

            PyObject *name;
            assert(class_dict);
            assert(oparg >= 0 && oparg < _PyFrame_GetCode(frame)->co_nlocalsplus);
            name = PyTuple_GET_ITEM(_PyFrame_GetCode(frame)->co_localsplusnames, oparg);
            if (PyMapping_GetOptionalItem(class_dict, name, &value) < 0) {
                JUMP_TO_ERROR();
            }
            if (!value) {
                PyCellObject *cell = (PyCellObject *)Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
                value = PyCell_GetRef(cell);
                if (value == NULL) {
                    _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                    JUMP_TO_ERROR();
                }
            }
            Py_DECREF_STACKREF(class_dict_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(value);
            break;
        }

        case _LOAD_DEREF: {
            PyObject *value;
            oparg = CURRENT_OPARG();
            PyCellObject *cell = (PyCellObject *)Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
            value = PyCell_GetRef(cell);
            if (value == NULL) {
                _PyEval_FormatExcUnbound(tstate, _PyFrame_GetCode(frame), oparg);
                if (true) JUMP_TO_ERROR();
            }
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer += 1;
            break;
        }

        case _STORE_DEREF: {
            _PyStackRef v_tagged;
            PyObject *v;
            oparg = CURRENT_OPARG();
            v_tagged = stack_pointer[-1];
            v = Py_STACKREF_UNTAG_BORROWED(v_tagged);

            PyCellObject *cell = (PyCellObject *)Py_STACKREF_UNTAG_BORROWED(GETLOCAL(oparg));
            PyCell_SetTakeRef(cell, v);
            stack_pointer += -1;
            break;
        }

        case _COPY_FREE_VARS: {
            oparg = CURRENT_OPARG();
            /* Copy closure variables to free variables */
            PyCodeObject *co = _PyFrame_GetCode(frame);
            assert(PyFunction_Check(frame->f_funcobj));
            PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;
            assert(oparg == co->co_nfreevars);
            int offset = co->co_nlocalsplus - oparg;
            for (int i = 0; i < oparg; ++i) {
                PyObject *o = PyTuple_GET_ITEM(closure, i);
                frame->localsplus[offset + i] = Py_NewRef_StackRef(Py_STACKREF_TAG(o));
            }
            break;
        }

        case _BUILD_STRING: {
            _PyStackRef *pieces;
            PyObject *str;
            oparg = CURRENT_OPARG();
            pieces = &stack_pointer[-oparg];
            str = _PyUnicode_JoinStack(&_Py_STR(empty), pieces, oparg);
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF_STACKREF(pieces[_i]);
            }
            if (str == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg] = Py_STACKREF_TAG(str);
            stack_pointer += 1 - oparg;
            break;
        }

        case _BUILD_TUPLE: {
            _PyStackRef *values;
            PyObject *tup;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg];
            tup = _PyTuple_FromStackSteal(values, oparg);
            if (tup == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg] = Py_STACKREF_TAG(tup);
            stack_pointer += 1 - oparg;
            break;
        }

        case _BUILD_LIST: {
            _PyStackRef *values;
            PyObject *list;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg];
            list = _PyList_FromStackSteal(values, oparg);
            if (list == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg] = Py_STACKREF_TAG(list);
            stack_pointer += 1 - oparg;
            break;
        }

        case _LIST_EXTEND: {
            _PyStackRef iterable_tagged;
            PyObject *iterable;
            _PyStackRef list_tagged;
            PyObject *list;
            oparg = CURRENT_OPARG();
            iterable_tagged = stack_pointer[-1];
            iterable = Py_STACKREF_UNTAG_BORROWED(iterable_tagged);

            list_tagged = stack_pointer[-2 - (oparg-1)];
            list = Py_STACKREF_UNTAG_BORROWED(list_tagged);

            PyObject *none_val = _PyList_Extend((PyListObject *)list, iterable);
            if (none_val == NULL) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&
                    (Py_TYPE(iterable)->tp_iter == NULL && !PySequence_Check(iterable)))
                {
                    _PyErr_Clear(tstate);
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "Value after * must be an iterable, not %.200s",
                                  Py_TYPE(iterable)->tp_name);
                }
                (void)iterable;
                Py_DECREF_STACKREF(iterable_tagged);
                if (true) JUMP_TO_ERROR();
            }
            assert(Py_IsNone(none_val));
            (void)iterable;
            Py_DECREF_STACKREF(iterable_tagged);
            stack_pointer += -1;
            break;
        }

        case _SET_UPDATE: {
            _PyStackRef iterable_tagged;
            PyObject *iterable;
            _PyStackRef set_tagged;
            PyObject *set;
            oparg = CURRENT_OPARG();
            iterable_tagged = stack_pointer[-1];
            iterable = Py_STACKREF_UNTAG_BORROWED(iterable_tagged);

            set_tagged = stack_pointer[-2 - (oparg-1)];
            set = Py_STACKREF_UNTAG_BORROWED(set_tagged);

            int err = _PySet_Update(set, iterable);
            (void)iterable;
            Py_DECREF_STACKREF(iterable_tagged);
            if (err < 0) JUMP_TO_ERROR();
            stack_pointer += -1;
            break;
        }

        /* _BUILD_SET is not a viable micro-op for tier 2 because it has both popping and not-popping errors */

        case _BUILD_MAP: {
            _PyStackRef *values;
            PyObject *map;
            oparg = CURRENT_OPARG();
            values = &stack_pointer[-oparg*2];
            map = _PyDict_FromStackItems(
                values, 2,
                values+1, 2,
                oparg);
            for (int _i = oparg*2; --_i >= 0;) {
                Py_DECREF_STACKREF(values[_i]);
            }
            if (map == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg*2] = Py_STACKREF_TAG(map);
            stack_pointer += 1 - oparg*2;
            break;
        }

        case _SETUP_ANNOTATIONS: {
            int err;
            PyObject *ann_dict;
            if (LOCALS() == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when setting up annotations");
                if (true) JUMP_TO_ERROR();
            }
            /* check if __annotations__ in locals()... */
            if (PyMapping_GetOptionalItem(LOCALS(), &_Py_ID(__annotations__), &ann_dict) < 0) JUMP_TO_ERROR();
            if (ann_dict == NULL) {
                ann_dict = PyDict_New();
                if (ann_dict == NULL) JUMP_TO_ERROR();
                err = PyObject_SetItem(LOCALS(), &_Py_ID(__annotations__),
                                       ann_dict);
                Py_DECREF(ann_dict);
                if (err) JUMP_TO_ERROR();
            }
            else {
                Py_DECREF(ann_dict);
            }
            break;
        }

        case _BUILD_CONST_KEY_MAP: {
            _PyStackRef keys_tagged;
            PyObject *keys;
            _PyStackRef *values;
            PyObject *map;
            oparg = CURRENT_OPARG();
            keys_tagged = stack_pointer[-1];
            keys = Py_STACKREF_UNTAG_BORROWED(keys_tagged);

            values = &stack_pointer[-1 - oparg];
            assert(PyTuple_CheckExact(keys));
            assert(PyTuple_GET_SIZE(keys) == (Py_ssize_t)oparg);
            map = _PyDict_FromStackItemsUntaggedKeys(
                &PyTuple_GET_ITEM(keys, 0), 1,
                values, 1, oparg);
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF_STACKREF(values[_i]);
            }
            (void)keys;
            Py_DECREF_STACKREF(keys_tagged);
            if (map == NULL) JUMP_TO_ERROR();
            stack_pointer[-1 - oparg] = Py_STACKREF_TAG(map);
            stack_pointer += -oparg;
            break;
        }

        case _DICT_UPDATE: {
            _PyStackRef update_tagged;
            PyObject *update;
            _PyStackRef dict_tagged;
            PyObject *dict;
            oparg = CURRENT_OPARG();
            update_tagged = stack_pointer[-1];
            update = Py_STACKREF_UNTAG_BORROWED(update_tagged);

            dict_tagged = stack_pointer[-2 - (oparg - 1)];
            dict = Py_STACKREF_UNTAG_BORROWED(dict_tagged);

            if (PyDict_Update(dict, update) < 0) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object is not a mapping",
                                  Py_TYPE(update)->tp_name);
                }
                (void)update;
                Py_DECREF_STACKREF(update_tagged);
                if (true) JUMP_TO_ERROR();
            }
            (void)update;
            Py_DECREF_STACKREF(update_tagged);
            stack_pointer += -1;
            break;
        }

        case _DICT_MERGE: {
            _PyStackRef update_tagged;
            PyObject *update;
            _PyStackRef dict_tagged;
            PyObject *dict;
            _PyStackRef callable_tagged;
            PyObject *callable;
            oparg = CURRENT_OPARG();
            update_tagged = stack_pointer[-1];
            update = Py_STACKREF_UNTAG_BORROWED(update_tagged);

            dict_tagged = stack_pointer[-2 - (oparg - 1)];
            dict = Py_STACKREF_UNTAG_BORROWED(dict_tagged);

            callable_tagged = stack_pointer[-5 - (oparg - 1)];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            if (_PyDict_MergeEx(dict, update, 2) < 0) {
                _PyEval_FormatKwargsError(tstate, callable, update);
                (void)update;
                Py_DECREF_STACKREF(update_tagged);
                if (true) JUMP_TO_ERROR();
            }
            (void)update;
            Py_DECREF_STACKREF(update_tagged);
            stack_pointer += -1;
            break;
        }

        case _MAP_ADD: {
            _PyStackRef value_tagged;
            PyObject *value;
            _PyStackRef key_tagged;
            PyObject *key;
            _PyStackRef dict_tagged;
            PyObject *dict;
            oparg = CURRENT_OPARG();
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            key_tagged = stack_pointer[-2];
            key = Py_STACKREF_UNTAG_BORROWED(key_tagged);

            dict_tagged = stack_pointer[-3 - (oparg - 1)];
            dict = Py_STACKREF_UNTAG_BORROWED(dict_tagged);

            assert(PyDict_CheckExact(dict));
            /* dict[key] = value */
            // Do not DECREF INPUTS because the function steals the references
            if (_PyDict_SetItem_Take2((PyDictObject *)dict, key, value) != 0) JUMP_TO_ERROR();
            stack_pointer += -2;
            break;
        }

        /* _INSTRUMENTED_LOAD_SUPER_ATTR is not a viable micro-op for tier 2 because it is instrumented */

        case _LOAD_SUPER_ATTR_ATTR: {
            _PyStackRef self_tagged;
            PyObject *self;
            _PyStackRef class_tagged;
            PyObject *class;
            _PyStackRef global_super_tagged;
            PyObject *global_super;
            PyObject *attr;
            oparg = CURRENT_OPARG();
            self_tagged = stack_pointer[-1];
            self = Py_STACKREF_UNTAG_BORROWED(self_tagged);

            class_tagged = stack_pointer[-2];
            class = Py_STACKREF_UNTAG_BORROWED(class_tagged);

            global_super_tagged = stack_pointer[-3];
            global_super = Py_STACKREF_UNTAG_BORROWED(global_super_tagged);

            assert(!(oparg & 1));
            if (global_super != (PyObject *)&PySuper_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyType_Check(class)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            attr = _PySuper_Lookup((PyTypeObject *)class, self, name, NULL);
            (void)global_super;
            Py_DECREF_STACKREF(global_super_tagged);
            (void)class;
            Py_DECREF_STACKREF(class_tagged);
            (void)self;
            Py_DECREF_STACKREF(self_tagged);
            if (attr == NULL) JUMP_TO_ERROR();
            stack_pointer[-3] = Py_STACKREF_TAG(attr);
            stack_pointer += -2;
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD: {
            _PyStackRef self_tagged;
            PyObject *self;
            _PyStackRef class_tagged;
            PyObject *class;
            _PyStackRef global_super_tagged;
            PyObject *global_super;
            PyObject *attr;
            PyObject *self_or_null;
            oparg = CURRENT_OPARG();
            self_tagged = stack_pointer[-1];
            self = Py_STACKREF_UNTAG_BORROWED(self_tagged);

            class_tagged = stack_pointer[-2];
            class = Py_STACKREF_UNTAG_BORROWED(class_tagged);

            global_super_tagged = stack_pointer[-3];
            global_super = Py_STACKREF_UNTAG_BORROWED(global_super_tagged);

            assert(oparg & 1);
            if (global_super != (PyObject *)&PySuper_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyType_Check(class)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            PyTypeObject *cls = (PyTypeObject *)class;
            int method_found = 0;
            attr = _PySuper_Lookup(cls, self, name,
                                   Py_TYPE(self)->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);
            Py_DECREF_STACKREF(global_super_tagged);
            Py_DECREF_STACKREF(class_tagged);
            if (attr == NULL) {
                Py_DECREF_STACKREF(self_tagged);
                if (true) JUMP_TO_ERROR();
            }
            if (method_found) {
                self_or_null = self; // transfer ownership
            } else {
                Py_DECREF_STACKREF(self_tagged);
                self_or_null = NULL;
            }
            stack_pointer[-3] = Py_STACKREF_TAG(attr);
            stack_pointer[-2] = Py_STACKREF_TAG(self_or_null);
            stack_pointer += -1;
            break;
        }

        case _LOAD_ATTR: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *self_or_null = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);
            if (oparg & 1) {
                /* Designed to work in tandem with CALL, pushes two values. */
                attr = NULL;
                if (_PyObject_GetMethod(owner, name, &attr)) {
                    /* We can bypass temporary bound method object.
                       meth is unbound method and obj is self.
                       meth | self | arg1 | ... | argN
                     */
                    assert(attr != NULL);  // No errors on this branch
                    self_or_null = owner;  // Transfer ownership
                }
                else {
                    /* meth is not an unbound method (but a regular attr, or
                       something was returned by a descriptor protocol).  Set
                       the second element of the stack to NULL, to signal
                       CALL that it's not a method call.
                       meth | NULL | arg1 | ... | argN
                     */
                    (void)owner;
                    Py_DECREF_STACKREF(owner_tagged);
                    if (attr == NULL) JUMP_TO_ERROR();
                    self_or_null = NULL;
                }
            }
            else {
                /* Classic, pushes one value. */
                attr = PyObject_GetAttr(owner, name);
                (void)owner;
                Py_DECREF_STACKREF(owner_tagged);
                if (attr == NULL) JUMP_TO_ERROR();
            }
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            if (oparg & 1) stack_pointer[0] = Py_STACKREF_TAG(self_or_null);
            stack_pointer += (oparg & 1);
            break;
        }

        case _GUARD_TYPE_VERSION: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            if (tp->tp_version_tag != type_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            assert(Py_TYPE(owner)->tp_dictoffset < 0);
            assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!_PyObject_InlineValues(owner)->valid) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE_0: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            attr = _PyObject_InlineValues(owner)->values[index];
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE_1: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            attr = _PyObject_InlineValues(owner)->values[index];
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(null);
            stack_pointer += 1;
            break;
        }

        /* _LOAD_ATTR_INSTANCE_VALUE is split on (oparg & 1) */

        case _CHECK_ATTR_MODULE: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint32_t dict_version = (uint32_t)CURRENT_OPERAND();
            if (!PyModule_CheckExact(owner)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;
            assert(dict != NULL);
            if (dict->ma_keys->dk_version != dict_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_ATTR_MODULE: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;
            assert(dict->ma_keys->dk_kind == DICT_KEYS_UNICODE);
            assert(index < dict->ma_keys->dk_nentries);
            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + index;
            attr = ep->me_value;
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            if (oparg & 1) stack_pointer[0] = Py_STACKREF_TAG(null);
            stack_pointer += (oparg & 1);
            break;
        }

        case _CHECK_ATTR_WITH_HINT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyManagedDictPointer *managed_dict = _PyObject_ManagedDictPointer(owner);
            PyDictObject *dict = managed_dict->dict;
            if (dict == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(PyDict_CheckExact((PyObject *)dict));
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t hint = (uint16_t)CURRENT_OPERAND();
            PyManagedDictPointer *managed_dict = _PyObject_ManagedDictPointer(owner);
            PyDictObject *dict = managed_dict->dict;
            if (hint >= (size_t)dict->ma_keys->dk_nentries) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            if (DK_IS_UNICODE(dict->ma_keys)) {
                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;
                if (ep->me_key != name) {
                    UOP_STAT_INC(uopcode, miss);
                    JUMP_TO_JUMP_TARGET();
                }
                attr = ep->me_value;
            }
            else {
                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;
                if (ep->me_key != name) {
                    UOP_STAT_INC(uopcode, miss);
                    JUMP_TO_JUMP_TARGET();
                }
                attr = ep->me_value;
            }
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            if (oparg & 1) stack_pointer[0] = Py_STACKREF_TAG(null);
            stack_pointer += (oparg & 1);
            break;
        }

        case _LOAD_ATTR_SLOT_0: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            char *addr = (char *)owner + index;
            attr = *(PyObject **)addr;
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            break;
        }

        case _LOAD_ATTR_SLOT_1: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            char *addr = (char *)owner + index;
            attr = *(PyObject **)addr;
            if (attr == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(attr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(null);
            stack_pointer += 1;
            break;
        }

        /* _LOAD_ATTR_SLOT is split on (oparg & 1) */

        case _CHECK_ATTR_CLASS: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            if (!PyType_Check(owner)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(type_version != 0);
            if (((PyTypeObject *)owner)->tp_version_tag != type_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_ATTR_CLASS_0: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            attr = Py_NewRef(descr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            break;
        }

        case _LOAD_ATTR_CLASS_1: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *null = NULL;
            (void)null;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            attr = Py_NewRef(descr);
            null = NULL;
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(null);
            stack_pointer += 1;
            break;
        }

        /* _LOAD_ATTR_CLASS is split on (oparg & 1) */

        /* _LOAD_ATTR_PROPERTY is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _GUARD_DORV_NO_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            assert(Py_TYPE(owner)->tp_dictoffset < 0);
            assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (_PyObject_ManagedDictPointer(owner)->dict) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (_PyObject_InlineValues(owner)->valid == 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            _PyStackRef value_tagged;
            PyObject *value;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            value_tagged = stack_pointer[-2];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            STAT_INC(STORE_ATTR, hit);
            assert(_PyObject_ManagedDictPointer(owner)->dict == NULL);
            PyDictValues *values = _PyObject_InlineValues(owner);
            PyObject *old_value = values->values[index];
            values->values[index] = value;
            if (old_value == NULL) {
                _PyDictValues_AddToInsertionOrder(values, index);
            }
            else {
                Py_DECREF(old_value);
            }
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer += -2;
            break;
        }

        /* _STORE_ATTR_WITH_HINT is not a viable micro-op for tier 2 because it has unused cache entries */

        case _STORE_ATTR_SLOT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            _PyStackRef value_tagged;
            PyObject *value;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            value_tagged = stack_pointer[-2];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            uint16_t index = (uint16_t)CURRENT_OPERAND();
            char *addr = (char *)owner + index;
            STAT_INC(STORE_ATTR, hit);
            PyObject *old_value = *(PyObject **)addr;
            *(PyObject **)addr = value;
            Py_XDECREF(old_value);
            Py_DECREF_STACKREF(owner_tagged);
            stack_pointer += -2;
            break;
        }

        case _COMPARE_OP: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            assert((oparg >> 5) <= Py_GE);
            res = PyObject_RichCompare(left, right, oparg >> 5);
            (void)left;
            Py_DECREF_STACKREF(left_tagged);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            if (oparg & 16) {
                int res_bool = PyObject_IsTrue(res);
                Py_DECREF_STACKREF(Py_STACKREF_TAG(res));
                if (res_bool < 0) JUMP_TO_ERROR();
                res = res_bool ? Py_True : Py_False;
            }
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_FLOAT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(COMPARE_OP, hit);
            double dleft = PyFloat_AS_DOUBLE(left);
            double dright = PyFloat_AS_DOUBLE(right);
            // 1 if NaN, 2 if <, 4 if >, 8 if ==; this matches low four bits of the oparg
            int sign_ish = COMPARISON_BIT(dleft, dright);
            _Py_DECREF_SPECIALIZED(left, _PyFloat_ExactDealloc);
            _Py_DECREF_SPECIALIZED(right, _PyFloat_ExactDealloc);
            res = (sign_ish & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_INT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!_PyLong_IsCompact((PyLongObject *)left)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!_PyLong_IsCompact((PyLongObject *)right)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(COMPARE_OP, hit);
            assert(_PyLong_DigitCount((PyLongObject *)left) <= 1 &&
                   _PyLong_DigitCount((PyLongObject *)right) <= 1);
            Py_ssize_t ileft = _PyLong_CompactValue((PyLongObject *)left);
            Py_ssize_t iright = _PyLong_CompactValue((PyLongObject *)right);
            // 2 if <, 4 if >, 8 if ==; this matches the low 4 bits of the oparg
            int sign_ish = COMPARISON_BIT(ileft, iright);
            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
            res = (sign_ish & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_STR: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *res;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            STAT_INC(COMPARE_OP, hit);
            int eq = _PyUnicode_Equal(left, right);
            assert((oparg >> 5) == Py_EQ || (oparg >> 5) == Py_NE);
            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
            assert(eq == 0 || eq == 1);
            assert((oparg & 0xf) == COMPARISON_NOT_EQUALS || (oparg & 0xf) == COMPARISON_EQUALS);
            assert(COMPARISON_NOT_EQUALS + 1 == COMPARISON_EQUALS);
            res = ((COMPARISON_NOT_EQUALS + eq) & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _IS_OP: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *b;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            int res = Py_Is(left, right) ^ oparg;
            (void)left;
            Py_DECREF_STACKREF(left_tagged);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            b = res ? Py_True : Py_False;
            stack_pointer[-2] = Py_STACKREF_TAG(b);
            stack_pointer += -1;
            break;
        }

        case _CONTAINS_OP: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *b;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            int res = PySequence_Contains(right, left);
            (void)left;
            Py_DECREF_STACKREF(left_tagged);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            if (res < 0) JUMP_TO_ERROR();
            b = (res ^ oparg) ? Py_True : Py_False;
            stack_pointer[-2] = Py_STACKREF_TAG(b);
            stack_pointer += -1;
            break;
        }

        case _CONTAINS_OP_SET: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *b;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!(PySet_CheckExact(right) || PyFrozenSet_CheckExact(right))) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CONTAINS_OP, hit);
            // Note: both set and frozenset use the same seq_contains method!
            int res = _PySet_Contains((PySetObject *)right, left);
            (void)left;
            Py_DECREF_STACKREF(left_tagged);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            if (res < 0) JUMP_TO_ERROR();
            b = (res ^ oparg) ? Py_True : Py_False;
            stack_pointer[-2] = Py_STACKREF_TAG(b);
            stack_pointer += -1;
            break;
        }

        case _CONTAINS_OP_DICT: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *b;
            oparg = CURRENT_OPARG();
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            if (!PyDict_CheckExact(right)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CONTAINS_OP, hit);
            int res = PyDict_Contains(right, left);
            (void)left;
            Py_DECREF_STACKREF(left_tagged);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            if (res < 0) JUMP_TO_ERROR();
            b = (res ^ oparg) ? Py_True : Py_False;
            stack_pointer[-2] = Py_STACKREF_TAG(b);
            stack_pointer += -1;
            break;
        }

        case _CHECK_EG_MATCH: {
            _PyStackRef match_type_tagged;
            PyObject *match_type;
            _PyStackRef exc_value_tagged;
            PyObject *exc_value;
            PyObject *rest;
            PyObject *match;
            match_type_tagged = stack_pointer[-1];
            match_type = Py_STACKREF_UNTAG_BORROWED(match_type_tagged);

            exc_value_tagged = stack_pointer[-2];
            exc_value = Py_STACKREF_UNTAG_BORROWED(exc_value_tagged);

            if (_PyEval_CheckExceptStarTypeValid(tstate, match_type) < 0) {
                (void)exc_value;
                Py_DECREF_STACKREF(exc_value_tagged);
                (void)match_type;
                Py_DECREF_STACKREF(match_type_tagged);
                if (true) JUMP_TO_ERROR();
            }
            match = NULL;
            rest = NULL;
            int res = _PyEval_ExceptionGroupMatch(exc_value, match_type,
                &match, &rest);
            (void)exc_value;
            Py_DECREF_STACKREF(exc_value_tagged);
            (void)match_type;
            Py_DECREF_STACKREF(match_type_tagged);
            if (res < 0) JUMP_TO_ERROR();
            assert((match == NULL) == (rest == NULL));
            if (match == NULL) JUMP_TO_ERROR();
            if (!Py_IsNone(match)) {
                PyErr_SetHandledException(match);
            }
            stack_pointer[-2] = Py_STACKREF_TAG(rest);
            stack_pointer[-1] = Py_STACKREF_TAG(match);
            break;
        }

        case _CHECK_EXC_MATCH: {
            _PyStackRef right_tagged;
            PyObject *right;
            _PyStackRef left_tagged;
            PyObject *left;
            PyObject *b;
            right_tagged = stack_pointer[-1];
            right = Py_STACKREF_UNTAG_BORROWED(right_tagged);

            left_tagged = stack_pointer[-2];
            left = Py_STACKREF_UNTAG_BORROWED(left_tagged);

            assert(PyExceptionInstance_Check(left));
            if (_PyEval_CheckExceptTypeValid(tstate, right) < 0) {
                (void)right;
                Py_DECREF_STACKREF(right_tagged);
                if (true) JUMP_TO_ERROR();
            }
            int res = PyErr_GivenExceptionMatches(left, right);
            (void)right;
            Py_DECREF_STACKREF(right_tagged);
            b = res ? Py_True : Py_False;
            stack_pointer[-1] = Py_STACKREF_TAG(b);
            break;
        }

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 because it is replaced */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 because it is replaced */

        case _IS_NONE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *b;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            if (Py_IsNone(value)) {
                b = Py_True;
            }
            else {
                b = Py_False;
                (void)value;
                Py_DECREF_STACKREF(value_tagged);
            }
            stack_pointer[-1] = Py_STACKREF_TAG(b);
            break;
        }

        case _GET_LEN: {
            _PyStackRef obj_tagged;
            PyObject *obj;
            PyObject *len_o;
            obj_tagged = stack_pointer[-1];
            obj = Py_STACKREF_UNTAG_BORROWED(obj_tagged);

            // PUSH(len(TOS))
            Py_ssize_t len_i = PyObject_Length(obj);
            if (len_i < 0) JUMP_TO_ERROR();
            len_o = PyLong_FromSsize_t(len_i);
            if (len_o == NULL) JUMP_TO_ERROR();
            stack_pointer[0] = Py_STACKREF_TAG(len_o);
            stack_pointer += 1;
            break;
        }

        case _MATCH_CLASS: {
            _PyStackRef names_tagged;
            PyObject *names;
            _PyStackRef type_tagged;
            PyObject *type;
            _PyStackRef subject_tagged;
            PyObject *subject;
            PyObject *attrs;
            oparg = CURRENT_OPARG();
            names_tagged = stack_pointer[-1];
            names = Py_STACKREF_UNTAG_BORROWED(names_tagged);

            type_tagged = stack_pointer[-2];
            type = Py_STACKREF_UNTAG_BORROWED(type_tagged);

            subject_tagged = stack_pointer[-3];
            subject = Py_STACKREF_UNTAG_BORROWED(subject_tagged);

            // Pop TOS and TOS1. Set TOS to a tuple of attributes on success, or
            // None on failure.
            assert(PyTuple_CheckExact(names));
            attrs = _PyEval_MatchClass(tstate, subject, type, oparg, names);
            (void)subject;
            Py_DECREF_STACKREF(subject_tagged);
            (void)type;
            Py_DECREF_STACKREF(type_tagged);
            (void)names;
            Py_DECREF_STACKREF(names_tagged);
            if (attrs) {
                assert(PyTuple_CheckExact(attrs));  // Success!
            }
            else {
                if (_PyErr_Occurred(tstate)) JUMP_TO_ERROR();
                // Error!
                attrs = Py_None;  // Failure!
            }
            stack_pointer[-3] = Py_STACKREF_TAG(attrs);
            stack_pointer += -2;
            break;
        }

        case _MATCH_MAPPING: {
            _PyStackRef subject_tagged;
            PyObject *subject;
            PyObject *res;
            subject_tagged = stack_pointer[-1];
            subject = Py_STACKREF_UNTAG_BORROWED(subject_tagged);

            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? Py_True : Py_False;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            stack_pointer += 1;
            break;
        }

        case _MATCH_SEQUENCE: {
            _PyStackRef subject_tagged;
            PyObject *subject;
            PyObject *res;
            subject_tagged = stack_pointer[-1];
            subject = Py_STACKREF_UNTAG_BORROWED(subject_tagged);

            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? Py_True : Py_False;
            stack_pointer[0] = Py_STACKREF_TAG(res);
            stack_pointer += 1;
            break;
        }

        case _MATCH_KEYS: {
            _PyStackRef keys_tagged;
            PyObject *keys;
            _PyStackRef subject_tagged;
            PyObject *subject;
            PyObject *values_or_none;
            keys_tagged = stack_pointer[-1];
            keys = Py_STACKREF_UNTAG_BORROWED(keys_tagged);

            subject_tagged = stack_pointer[-2];
            subject = Py_STACKREF_UNTAG_BORROWED(subject_tagged);

            // On successful match, PUSH(values). Otherwise, PUSH(None).
            values_or_none = _PyEval_MatchKeys(tstate, subject, keys);
            if (values_or_none == NULL) JUMP_TO_ERROR();
            stack_pointer[0] = Py_STACKREF_TAG(values_or_none);
            stack_pointer += 1;
            break;
        }

        case _GET_ITER: {
            _PyStackRef iterable_tagged;
            PyObject *iterable;
            PyObject *iter;
            iterable_tagged = stack_pointer[-1];
            iterable = Py_STACKREF_UNTAG_BORROWED(iterable_tagged);

            /* before: [obj]; after [getiter(obj)] */
            iter = PyObject_GetIter(iterable);
            (void)iterable;
            Py_DECREF_STACKREF(iterable_tagged);
            if (iter == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(iter);
            break;
        }

        case _GET_YIELD_FROM_ITER: {
            _PyStackRef iterable_tagged;
            PyObject *iterable;
            PyObject *iter;
            iterable_tagged = stack_pointer[-1];
            iterable = Py_STACKREF_UNTAG_BORROWED(iterable_tagged);

            /* before: [obj]; after [getiter(obj)] */
            if (PyCoro_CheckExact(iterable)) {
                /* `iterable` is a coroutine */
                if (!(_PyFrame_GetCode(frame)->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {
                    /* and it is used in a 'yield from' expression of a
                       regular generator. */
                    _PyErr_SetString(tstate, PyExc_TypeError,
                                     "cannot 'yield from' a coroutine object "
                                     "in a non-coroutine generator");
                    JUMP_TO_ERROR();
                }
                iter = iterable;
            }
            else if (PyGen_CheckExact(iterable)) {
                iter = iterable;
            }
            else {
                /* `iterable` is not a generator. */
                iter = PyObject_GetIter(iterable);
                if (iter == NULL) {
                    JUMP_TO_ERROR();
                }
                (void)iterable;
                Py_DECREF_STACKREF(iterable_tagged);
            }
            stack_pointer[-1] = Py_STACKREF_TAG(iter);
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 because it is replaced */

        case _FOR_ITER_TIER_TWO: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            PyObject *next;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            /* before: [iter]; after: [iter, iter()] *or* [] (and jump over END_FOR.) */
            next = (*Py_TYPE(iter)->tp_iternext)(iter);
            if (next == NULL) {
                if (_PyErr_Occurred(tstate)) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {
                        JUMP_TO_ERROR();
                    }
                    _PyErr_Clear(tstate);
                }
                /* iterator ended normally */
                Py_DECREF_STACKREF(iter_tagged);
                STACK_SHRINK(1);
                /* The translator sets the deopt target just past END_FOR */
                if (true) {
                    UOP_STAT_INC(uopcode, miss);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            // Common case: no jump, leave it to the code generator
            stack_pointer[0] = Py_STACKREF_TAG(next);
            stack_pointer += 1;
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 because it is instrumented */

        case _ITER_CHECK_LIST: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            if (Py_TYPE(iter) != &PyListIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_LIST: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyListIterObject *it = (_PyListIterObject *)iter;
            assert(Py_TYPE(iter) == &PyListIter_Type);
            PyListObject *seq = it->it_seq;
            if (seq == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if ((size_t)it->it_index >= (size_t)PyList_GET_SIZE(seq)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _ITER_NEXT_LIST: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            PyObject *next;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyListIterObject *it = (_PyListIterObject *)iter;
            assert(Py_TYPE(iter) == &PyListIter_Type);
            PyListObject *seq = it->it_seq;
            assert(seq);
            assert(it->it_index < PyList_GET_SIZE(seq));
            next = Py_NewRef(PyList_GET_ITEM(seq, it->it_index++));
            stack_pointer[0] = Py_STACKREF_TAG(next);
            stack_pointer += 1;
            break;
        }

        case _ITER_CHECK_TUPLE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            if (Py_TYPE(iter) != &PyTupleIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyTupleIterObject *it = (_PyTupleIterObject *)iter;
            assert(Py_TYPE(iter) == &PyTupleIter_Type);
            PyTupleObject *seq = it->it_seq;
            if (seq == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (it->it_index >= PyTuple_GET_SIZE(seq)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _ITER_NEXT_TUPLE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            PyObject *next;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyTupleIterObject *it = (_PyTupleIterObject *)iter;
            assert(Py_TYPE(iter) == &PyTupleIter_Type);
            PyTupleObject *seq = it->it_seq;
            assert(seq);
            assert(it->it_index < PyTuple_GET_SIZE(seq));
            next = Py_NewRef(PyTuple_GET_ITEM(seq, it->it_index++));
            stack_pointer[0] = Py_STACKREF_TAG(next);
            stack_pointer += 1;
            break;
        }

        case _ITER_CHECK_RANGE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
            if (Py_TYPE(r) != &PyRangeIter_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 because it is replaced */

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            if (r->len <= 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _ITER_NEXT_RANGE: {
            _PyStackRef iter_tagged;
            PyObject *iter;
            PyObject *next;
            iter_tagged = stack_pointer[-1];
            iter = Py_STACKREF_UNTAG_BORROWED(iter_tagged);

            _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
            assert(Py_TYPE(r) == &PyRangeIter_Type);
            assert(r->len > 0);
            long value = r->start;
            r->start = value + r->step;
            r->len--;
            next = PyLong_FromLong(value);
            if (next == NULL) JUMP_TO_ERROR();
            stack_pointer[0] = Py_STACKREF_TAG(next);
            stack_pointer += 1;
            break;
        }

        /* _FOR_ITER_GEN is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _BEFORE_ASYNC_WITH is not a viable micro-op for tier 2 because it has both popping and not-popping errors */

        /* _BEFORE_WITH is not a viable micro-op for tier 2 because it has both popping and not-popping errors */

        case _WITH_EXCEPT_START: {
            _PyStackRef val_tagged;
            PyObject *val;
            _PyStackRef lasti_tagged;
            PyObject *lasti;
            _PyStackRef exit_func_tagged;
            PyObject *exit_func;
            PyObject *res;
            val_tagged = stack_pointer[-1];
            val = Py_STACKREF_UNTAG_BORROWED(val_tagged);

            lasti_tagged = stack_pointer[-3];
            lasti = Py_STACKREF_UNTAG_BORROWED(lasti_tagged);

            exit_func_tagged = stack_pointer[-4];
            exit_func = Py_STACKREF_UNTAG_BORROWED(exit_func_tagged);

            /* At the top of the stack are 4 values:
               - val: TOP = exc_info()
               - unused: SECOND = previous exception
               - lasti: THIRD = lasti of exception in exc_info()
               - exit_func: FOURTH = the context.__exit__ bound method
               We call FOURTH(type(TOP), TOP, GetTraceback(TOP)).
               Then we push the __exit__ return value.
             */
            PyObject *exc, *tb;
            assert(val && PyExceptionInstance_Check(val));
            exc = PyExceptionInstance_Class(val);
            tb = PyException_GetTraceback(val);
            if (tb == NULL) {
                tb = Py_None;
            }
            else {
                Py_DECREF(tb);
            }
            assert(PyLong_Check(lasti));
            (void)lasti; // Shut up compiler warning if asserts are off
            PyObject *stack[4] = {NULL, exc, val, tb};
            res = PyObject_Vectorcall(exit_func, stack + 1,
                                      3 | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[0] = Py_STACKREF_TAG(res);
            stack_pointer += 1;
            break;
        }

        case _PUSH_EXC_INFO: {
            _PyStackRef new_exc_tagged;
            PyObject *new_exc;
            PyObject *prev_exc;
            new_exc_tagged = stack_pointer[-1];
            new_exc = Py_STACKREF_UNTAG_BORROWED(new_exc_tagged);

            _PyErr_StackItem *exc_info = tstate->exc_info;
            if (exc_info->exc_value != NULL) {
                prev_exc = exc_info->exc_value;
            }
            else {
                prev_exc = Py_None;
            }
            assert(PyExceptionInstance_Check(new_exc));
            exc_info->exc_value = Py_NewRef(new_exc);
            stack_pointer[-1] = Py_STACKREF_TAG(prev_exc);
            stack_pointer[0] = Py_STACKREF_TAG(new_exc);
            stack_pointer += 1;
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_INLINE_VALUES);
            if (!_PyObject_InlineValues(owner)->valid) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _GUARD_KEYS_VERSION: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint32_t keys_version = (uint32_t)CURRENT_OPERAND();
            PyTypeObject *owner_cls = Py_TYPE(owner);
            PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
            if (owner_heap_type->ht_cached_keys->dk_version != keys_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *self = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            assert(oparg & 1);
            /* Cached method object */
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            attr = Py_NewRef(descr);
            assert(_PyType_HasFeature(Py_TYPE(attr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            self = owner;
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(self);
            stack_pointer += 1;
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *self = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            assert(oparg & 1);
            assert(Py_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = Py_NewRef(descr);
            self = owner;
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(self);
            stack_pointer += 1;
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            assert((oparg & 1) == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            attr = Py_NewRef(descr);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            assert((oparg & 1) == 0);
            assert(Py_TYPE(owner)->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            (void)owner;
            Py_DECREF_STACKREF(owner_tagged);
            attr = Py_NewRef(descr);
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            uint16_t dictoffset = (uint16_t)CURRENT_OPERAND();
            char *ptr = ((char *)owner) + MANAGED_DICT_OFFSET + dictoffset;
            PyObject *dict = *(PyObject **)ptr;
            /* This object has a __dict__, just not yet created */
            if (dict != NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            _PyStackRef owner_tagged;
            PyObject *owner;
            PyObject *attr;
            PyObject *self = NULL;
            oparg = CURRENT_OPARG();
            owner_tagged = stack_pointer[-1];
            owner = Py_STACKREF_UNTAG_BORROWED(owner_tagged);

            PyObject *descr = (PyObject *)CURRENT_OPERAND();
            assert(oparg & 1);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            attr = Py_NewRef(descr);
            self = owner;
            stack_pointer[-1] = Py_STACKREF_TAG(attr);
            stack_pointer[0] = Py_STACKREF_TAG(self);
            stack_pointer += 1;
            break;
        }

        /* _INSTRUMENTED_CALL is not a viable micro-op for tier 2 because it is instrumented */

        /* _CALL is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _CHECK_PERIODIC: {
            CHECK_EVAL_BREAKER();
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            _PyStackRef null_tagged;
            PyObject *null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            oparg = CURRENT_OPARG();
            null_tagged = stack_pointer[-1 - oparg];
            null = Py_STACKREF_UNTAG_BORROWED(null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            if (null != NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (Py_TYPE(callable) != &PyMethod_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *func;
            PyObject *self;
            oparg = CURRENT_OPARG();
            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            STAT_INC(CALL, hit);
            // Ugly tag and untag because the uop header needs to have consistent type with
            // the rest of the inst. So we can't change it to _PyStackRef.
            self = Py_STACKREF_UNTAG_BORROWED(Py_NewRef_StackRef(Py_STACKREF_TAG(((PyMethodObject *)callable)->im_self)));
            stack_pointer[-1 - oparg] = Py_STACKREF_TAG(self);  // Patch stack as it is used by _INIT_CALL_PY_EXACT_ARGS
            func = Py_STACKREF_UNTAG_BORROWED(Py_NewRef_StackRef(Py_STACKREF_TAG(((PyMethodObject *)callable)->im_func)));
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(func);  // This is used by CALL, upon deoptimization
            Py_DECREF_STACKREF(callable_tagged);
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(func);
            stack_pointer[-1 - oparg] = Py_STACKREF_TAG(self);
            break;
        }

        case _CHECK_PEP_523: {
            if (tstate->interp->eval_frame) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            oparg = CURRENT_OPARG();
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            uint32_t func_version = (uint32_t)CURRENT_OPERAND();
            if (!PyFunction_Check(callable)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyFunctionObject *func = (PyFunctionObject *)callable;
            if (func->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            if (code->co_argcount != oparg + (self_or_null != NULL)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _CHECK_STACK_SPACE: {
            _PyStackRef callable_tagged;
            PyObject *callable;
            oparg = CURRENT_OPARG();
            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            PyFunctionObject *func = (PyFunctionObject *)callable;
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            if (!_PyThreadState_HasStackSpace(tstate, code->co_framesize)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_0: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = 0;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_1: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = 1;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_2: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = 2;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_3: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = 3;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS_4: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = 4;
            assert(oparg == CURRENT_OPARG());
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            _PyStackRef *first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null_tagged;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG((PyObject *)new_frame);
            stack_pointer += -1 - oparg;
            break;
        }

        case _PUSH_FRAME: {
            _PyStackRef new_frame_tagged;
            _PyInterpreterFrame *new_frame;
            new_frame_tagged = stack_pointer[-1];
            new_frame = (_PyInterpreterFrame *)Py_STACKREF_UNTAG_BORROWED(new_frame_tagged);

            // Write it out explicitly because it's subtly different.
            // Eventually this should be the only occurrence of this code.
            assert(tstate->interp->eval_frame == NULL);
            stack_pointer += -1;
            _PyFrame_SetStackPointer(frame, stack_pointer);
            new_frame->previous = frame;
            CALL_STAT_INC(inlined_py_calls);
            frame = tstate->current_frame = new_frame;
            tstate->py_recursion_remaining--;
            LOAD_SP();
            LOAD_IP(0);
            #if LLTRACE && TIER_ONE
            lltrace = maybe_lltrace_resume_frame(frame, &entry_frame, GLOBALS());
            if (lltrace < 0) {
                goto exit_unwind;
            }
            #endif
            break;
        }

        /* _CALL_PY_WITH_DEFAULTS is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _CALL_TYPE_1: {
            _PyStackRef arg_tagged;
            PyObject *arg;
            _PyStackRef null_tagged;
            PyObject *null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            _PyStackRef res;
            oparg = CURRENT_OPARG();
            arg_tagged = stack_pointer[-1];
            arg = Py_STACKREF_UNTAG_BORROWED(arg_tagged);

            null_tagged = stack_pointer[-2];
            null = Py_STACKREF_UNTAG_BORROWED(null_tagged);

            callable_tagged = stack_pointer[-3];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            assert(oparg == 1);
            if (null != NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (callable != (PyObject *)&PyType_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            res = Py_NewRef_StackRef(Py_STACKREF_TAG(Py_TYPE(arg)));
            Py_DECREF_STACKREF(arg_tagged);
            stack_pointer[-3] = (res);
            stack_pointer += -2;
            break;
        }

        case _CALL_STR_1: {
            _PyStackRef arg_tagged;
            PyObject *arg;
            _PyStackRef null_tagged;
            PyObject *null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            arg_tagged = stack_pointer[-1];
            arg = Py_STACKREF_UNTAG_BORROWED(arg_tagged);

            null_tagged = stack_pointer[-2];
            null = Py_STACKREF_UNTAG_BORROWED(null_tagged);

            callable_tagged = stack_pointer[-3];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            assert(oparg == 1);
            if (null != NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (callable != (PyObject *)&PyUnicode_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            res = PyObject_Str(arg);
            Py_DECREF_STACKREF(arg_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-3] = Py_STACKREF_TAG(res);
            stack_pointer += -2;
            break;
        }

        case _CALL_TUPLE_1: {
            _PyStackRef arg_tagged;
            PyObject *arg;
            _PyStackRef null_tagged;
            PyObject *null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            arg_tagged = stack_pointer[-1];
            arg = Py_STACKREF_UNTAG_BORROWED(arg_tagged);

            null_tagged = stack_pointer[-2];
            null = Py_STACKREF_UNTAG_BORROWED(null_tagged);

            callable_tagged = stack_pointer[-3];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            assert(oparg == 1);
            if (null != NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (callable != (PyObject *)&PyTuple_Type) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            res = PySequence_Tuple(arg);
            Py_DECREF_STACKREF(arg_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-3] = Py_STACKREF_TAG(res);
            stack_pointer += -2;
            break;
        }

        /* _CALL_ALLOC_AND_ENTER_INIT is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _EXIT_INIT_CHECK: {
            _PyStackRef should_be_none_tagged;
            PyObject *should_be_none;
            should_be_none_tagged = stack_pointer[-1];
            should_be_none = Py_STACKREF_UNTAG_BORROWED(should_be_none_tagged);

            assert(STACK_LEVEL() == 2);
            if (should_be_none != Py_None) {
                PyErr_Format(PyExc_TypeError,
                             "__init__() should return None, not '%.200s'",
                             Py_TYPE(should_be_none)->tp_name);
                JUMP_TO_ERROR();
            }
            stack_pointer += -1;
            break;
        }

        case _CALL_BUILTIN_CLASS: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (!PyType_Check(callable)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *tp = (PyTypeObject *)callable;
            if (tp->tp_vectorcall == NULL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            res = PyObject_TypeVectorcall_Tagged(tp, args, total_args, NULL);
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF_STACKREF(args[i]);
            }
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_O: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            /* Builtin METH_O functions */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (total_args != 1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!PyCFunction_CheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyCFunction_GET_FLAGS(callable) != METH_O) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // CPython promises to check all non-vectorcall function calls.
            if (tstate->c_recursion_remaining <= 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);
            _PyStackRef arg = args[0];
            _Py_EnterRecursiveCallTstateUnchecked(tstate);
            res = _PyCFunction_TrampolineCall(cfunc, PyCFunction_GET_SELF(callable), Py_STACKREF_UNTAG_BORROWED(arg));
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF_STACKREF(arg);
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_FAST: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            /* Builtin METH_FASTCALL functions, without keywords */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (!PyCFunction_CheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyCFunction_GET_FLAGS(callable) != METH_FASTCALL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);
            /* res = func(self, args, nargs) */
            res = PyObject_PyCFunctionFastCall_Tagged(
                ((PyCFunctionFast)(void(*)(void))cfunc),
                PyCFunction_GET_SELF(callable),
                args,
                total_args);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF_STACKREF(args[i]);
            }
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            /* Builtin METH_FASTCALL | METH_KEYWORDS functions */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (!PyCFunction_CheckExact(callable)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (PyCFunction_GET_FLAGS(callable) != (METH_FASTCALL | METH_KEYWORDS)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            /* res = func(self, args, nargs, kwnames) */
            PyCFunctionFastWithKeywords cfunc =
            (PyCFunctionFastWithKeywords)(void(*)(void))
            PyCFunction_GET_FUNCTION(callable);
            res = PyObject_PyCFunctionFastWithKeywordsCall_Tagged(
                cfunc, PyCFunction_GET_SELF(callable), args, total_args, NULL
            );
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF_STACKREF(args[i]);
            }
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_LEN: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            /* len(o) */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (total_args != 1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyInterpreterState *interp = tstate->interp;
            if (callable != interp->callable_cache.len) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            _PyStackRef arg_tagged = args[0];
            PyObject *arg = Py_STACKREF_UNTAG_BORROWED(arg_tagged);
            Py_ssize_t len_i = PyObject_Length(arg);
            if (len_i < 0) {
                JUMP_TO_ERROR();
            }
            res = PyLong_FromSsize_t(len_i);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            if (res == NULL) {
                GOTO_ERROR(error);
            }
            Py_DECREF_STACKREF(callable_tagged);
            Py_DECREF_STACKREF(arg_tagged);
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_ISINSTANCE: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            /* isinstance(o, o2) */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (total_args != 2) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyInterpreterState *interp = tstate->interp;
            if (callable != interp->callable_cache.isinstance) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            _PyStackRef cls_tagged = args[1];
            _PyStackRef inst_tagged = args[0];
            int retval = PyObject_IsInstance(Py_STACKREF_UNTAG_BORROWED(inst_tagged), Py_STACKREF_UNTAG_BORROWED(cls_tagged));
            if (retval < 0) {
                JUMP_TO_ERROR();
            }
            res = PyBool_FromLong(retval);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            if (res == NULL) {
                GOTO_ERROR(error);
            }
            Py_DECREF_STACKREF(inst_tagged);
            Py_DECREF_STACKREF(cls_tagged);
            Py_DECREF_STACKREF(callable_tagged);
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable;
            if (total_args != 2) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (!Py_IS_TYPE(method, &PyMethodDescr_Type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != METH_O) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // CPython promises to check all non-vectorcall function calls.
            if (tstate->c_recursion_remaining <= 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            _PyStackRef arg_tagged = args[1];
            _PyStackRef self_tagged = args[0];
            PyObject *self = Py_STACKREF_UNTAG_BORROWED(self_tagged);
            PyObject *arg = Py_STACKREF_UNTAG_BORROWED(arg_tagged);
            if (!Py_IS_TYPE(self, method->d_common.d_type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            _Py_EnterRecursiveCallTstateUnchecked(tstate);
            res = _PyCFunction_TrampolineCall(cfunc, self, arg);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF_STACKREF(self_tagged);
            Py_DECREF_STACKREF(arg_tagged);
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable;
            if (!Py_IS_TYPE(method, &PyMethodDescr_Type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != (METH_FASTCALL|METH_KEYWORDS)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyTypeObject *d_type = method->d_common.d_type;
            PyObject *self = Py_STACKREF_UNTAG_BORROWED(args[0]);
            if (!Py_IS_TYPE(self, d_type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            int nargs = total_args - 1;
            PyCFunctionFastWithKeywords cfunc =
            (PyCFunctionFastWithKeywords)(void(*)(void))meth->ml_meth;
            res = PyObject_PyCFunctionFastWithKeywordsCall_Tagged(
                cfunc, self, (args + 1), nargs, NULL
            );
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF_STACKREF(args[i]);
            }
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            assert(oparg == 0 || oparg == 1);
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (total_args != 1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable;
            if (!Py_IS_TYPE(method, &PyMethodDescr_Type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDef *meth = method->d_method;
            _PyStackRef self_tagged = args[0];
            PyObject *self = Py_STACKREF_UNTAG_BORROWED(self_tagged);
            if (!Py_IS_TYPE(self, method->d_common.d_type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (meth->ml_flags != METH_NOARGS) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            // CPython promises to check all non-vectorcall function calls.
            if (tstate->c_recursion_remaining <= 0) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            _Py_EnterRecursiveCallTstateUnchecked(tstate);
            res = _PyCFunction_TrampolineCall(cfunc, self, NULL);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF_STACKREF(self_tagged);
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST: {
            _PyStackRef *args;
            _PyStackRef self_or_null_tagged;
            PyObject *self_or_null;
            _PyStackRef callable_tagged;
            PyObject *callable;
            PyObject *res;
            oparg = CURRENT_OPARG();
            args = &stack_pointer[-oparg];
            self_or_null_tagged = stack_pointer[-1 - oparg];
            self_or_null = Py_STACKREF_UNTAG_BORROWED(self_or_null_tagged);

            callable_tagged = stack_pointer[-2 - oparg];
            callable = Py_STACKREF_UNTAG_BORROWED(callable_tagged);

            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable;
            /* Builtin METH_FASTCALL methods, without keywords */
            if (!Py_IS_TYPE(method, &PyMethodDescr_Type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != METH_FASTCALL) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            PyObject *self = Py_STACKREF_UNTAG_BORROWED(args[0]);
            if (!Py_IS_TYPE(self, method->d_common.d_type)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            STAT_INC(CALL, hit);
            PyCFunctionFast cfunc =
            (PyCFunctionFast)(void(*)(void))meth->ml_meth;
            int nargs = total_args - 1;
            res = PyObject_PyCFunctionFastCall_Tagged(
                cfunc, self, (args + 1), nargs
            );
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Clear the stack of the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF_STACKREF(args[i]);
            }
            Py_DECREF_STACKREF(callable_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = Py_STACKREF_TAG(res);
            stack_pointer += -1 - oparg;
            break;
        }

        /* _INSTRUMENTED_CALL_KW is not a viable micro-op for tier 2 because it is instrumented */

        /* _CALL_KW is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        /* _INSTRUMENTED_CALL_FUNCTION_EX is not a viable micro-op for tier 2 because it is instrumented */

        /* _CALL_FUNCTION_EX is not a viable micro-op for tier 2 because it uses the 'this_instr' variable */

        case _MAKE_FUNCTION: {
            _PyStackRef codeobj_tagged;
            PyObject *codeobj;
            PyObject *func;
            codeobj_tagged = stack_pointer[-1];
            codeobj = Py_STACKREF_UNTAG_BORROWED(codeobj_tagged);

            PyFunctionObject *func_obj = (PyFunctionObject *)
            PyFunction_New(codeobj, GLOBALS());
            Py_DECREF_STACKREF(codeobj_tagged);
            if (func_obj == NULL) {
                JUMP_TO_ERROR();
            }
            _PyFunction_SetVersion(
                                   func_obj, ((PyCodeObject *)codeobj)->co_version);
            func = (PyObject *)func_obj;
            stack_pointer[-1] = Py_STACKREF_TAG(func);
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE: {
            _PyStackRef func_tagged;
            PyObject *func;
            _PyStackRef attr_tagged;
            PyObject *attr;
            oparg = CURRENT_OPARG();
            func_tagged = stack_pointer[-1];
            func = Py_STACKREF_UNTAG_BORROWED(func_tagged);

            attr_tagged = stack_pointer[-2];
            attr = Py_STACKREF_UNTAG_BORROWED(attr_tagged);

            assert(PyFunction_Check(func));
            PyFunctionObject *func_obj = (PyFunctionObject *)func;
            switch(oparg) {
                case MAKE_FUNCTION_CLOSURE:
                assert(func_obj->func_closure == NULL);
                func_obj->func_closure = attr;
                break;
                case MAKE_FUNCTION_ANNOTATIONS:
                assert(func_obj->func_annotations == NULL);
                func_obj->func_annotations = attr;
                break;
                case MAKE_FUNCTION_KWDEFAULTS:
                assert(PyDict_CheckExact(attr));
                assert(func_obj->func_kwdefaults == NULL);
                func_obj->func_kwdefaults = attr;
                break;
                case MAKE_FUNCTION_DEFAULTS:
                assert(PyTuple_CheckExact(attr));
                assert(func_obj->func_defaults == NULL);
                func_obj->func_defaults = attr;
                break;
                default:
                Py_UNREACHABLE();
            }
            stack_pointer[-2] = Py_STACKREF_TAG(func);
            stack_pointer += -1;
            break;
        }

        case _BUILD_SLICE: {
            _PyStackRef step_tagged = Py_STACKREF_TAG(NULL);
            PyObject *step = NULL;
            _PyStackRef stop_tagged;
            PyObject *stop;
            _PyStackRef start_tagged;
            PyObject *start;
            PyObject *slice;
            oparg = CURRENT_OPARG();
            if (oparg == 3) { step_tagged = stack_pointer[-((oparg == 3) ? 1 : 0)];
step = Py_STACKREF_UNTAG_BORROWED(step_tagged);
 }
            stop_tagged = stack_pointer[-1 - ((oparg == 3) ? 1 : 0)];
            stop = Py_STACKREF_UNTAG_BORROWED(stop_tagged);

            start_tagged = stack_pointer[-2 - ((oparg == 3) ? 1 : 0)];
            start = Py_STACKREF_UNTAG_BORROWED(start_tagged);

            slice = PySlice_New(start, stop, step);
            (void)start;
            Py_DECREF_STACKREF(start_tagged);
            (void)stop;
            Py_DECREF_STACKREF(stop_tagged);
            (void)step;
            Py_XDECREF_STACKREF(step_tagged);
            if (slice == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - ((oparg == 3) ? 1 : 0)] = Py_STACKREF_TAG(slice);
            stack_pointer += -1 - ((oparg == 3) ? 1 : 0);
            break;
        }

        case _CONVERT_VALUE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *result;
            oparg = CURRENT_OPARG();
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            conversion_func conv_fn;
            assert(oparg >= FVC_STR && oparg <= FVC_ASCII);
            conv_fn = _PyEval_ConversionFuncs[oparg];
            result = conv_fn(value);
            Py_DECREF_STACKREF(value_tagged);
            if (result == NULL) JUMP_TO_ERROR();
            stack_pointer[-1] = Py_STACKREF_TAG(result);
            break;
        }

        case _FORMAT_SIMPLE: {
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            value_tagged = stack_pointer[-1];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            /* If value is a unicode object, then we know the result
             * of format(value) is value itself. */
            if (!PyUnicode_CheckExact(value)) {
                res = PyObject_Format(value, NULL);
                Py_DECREF_STACKREF(value_tagged);
                if (res == NULL) JUMP_TO_ERROR();
            }
            else {
                res = value;
            }
            stack_pointer[-1] = Py_STACKREF_TAG(res);
            break;
        }

        case _FORMAT_WITH_SPEC: {
            _PyStackRef fmt_spec_tagged;
            PyObject *fmt_spec;
            _PyStackRef value_tagged;
            PyObject *value;
            PyObject *res;
            fmt_spec_tagged = stack_pointer[-1];
            fmt_spec = Py_STACKREF_UNTAG_BORROWED(fmt_spec_tagged);

            value_tagged = stack_pointer[-2];
            value = Py_STACKREF_UNTAG_BORROWED(value_tagged);

            res = PyObject_Format(value, fmt_spec);
            Py_DECREF_STACKREF(value_tagged);
            Py_DECREF_STACKREF(fmt_spec_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _COPY: {
            _PyStackRef bottom_tagged;
            PyObject *bottom;
            PyObject *top;
            oparg = CURRENT_OPARG();
            bottom_tagged = stack_pointer[-1 - (oparg-1)];
            bottom = Py_STACKREF_UNTAG_BORROWED(bottom_tagged);

            assert(oparg > 0);
            top = Py_NewRef(bottom);
            stack_pointer[0] = Py_STACKREF_TAG(top);
            stack_pointer += 1;
            break;
        }

        case _BINARY_OP: {
            _PyStackRef rhs_tagged;
            PyObject *rhs;
            _PyStackRef lhs_tagged;
            PyObject *lhs;
            PyObject *res;
            oparg = CURRENT_OPARG();
            rhs_tagged = stack_pointer[-1];
            rhs = Py_STACKREF_UNTAG_BORROWED(rhs_tagged);

            lhs_tagged = stack_pointer[-2];
            lhs = Py_STACKREF_UNTAG_BORROWED(lhs_tagged);

            assert(_PyEval_BinaryOps[oparg]);
            res = _PyEval_BinaryOps[oparg](lhs, rhs);
            (void)lhs;
            Py_DECREF_STACKREF(lhs_tagged);
            (void)rhs;
            Py_DECREF_STACKREF(rhs_tagged);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2] = Py_STACKREF_TAG(res);
            stack_pointer += -1;
            break;
        }

        case _SWAP: {
            _PyStackRef top_tagged;
            PyObject *top;
            _PyStackRef bottom_tagged;
            PyObject *bottom;
            oparg = CURRENT_OPARG();
            top_tagged = stack_pointer[-1];
            top = Py_STACKREF_UNTAG_BORROWED(top_tagged);

            bottom_tagged = stack_pointer[-2 - (oparg-2)];
            bottom = Py_STACKREF_UNTAG_BORROWED(bottom_tagged);

            assert(oparg >= 2);
            stack_pointer[-2 - (oparg-2)] = Py_STACKREF_TAG(top);
            stack_pointer[-1] = Py_STACKREF_TAG(bottom);
            break;
        }

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_JUMP_BACKWARD is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 because it is instrumented */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 because it is instrumented */

        case _GUARD_IS_TRUE_POP: {
            _PyStackRef flag_tagged;
            PyObject *flag;
            flag_tagged = stack_pointer[-1];
            flag = Py_STACKREF_UNTAG_BORROWED(flag_tagged);

            stack_pointer += -1;
            if (!Py_IsTrue(flag)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(Py_IsTrue(flag));
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            _PyStackRef flag_tagged;
            PyObject *flag;
            flag_tagged = stack_pointer[-1];
            flag = Py_STACKREF_UNTAG_BORROWED(flag_tagged);

            stack_pointer += -1;
            if (!Py_IsFalse(flag)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            assert(Py_IsFalse(flag));
            break;
        }

        case _GUARD_IS_NONE_POP: {
            _PyStackRef val_tagged;
            PyObject *val;
            val_tagged = stack_pointer[-1];
            val = Py_STACKREF_UNTAG_BORROWED(val_tagged);

            stack_pointer += -1;
            if (!Py_IsNone(val)) {
                Py_DECREF_STACKREF(val_tagged);
                if (1) {
                    UOP_STAT_INC(uopcode, miss);
                    JUMP_TO_JUMP_TARGET();
                }
            }
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            _PyStackRef val_tagged;
            PyObject *val;
            val_tagged = stack_pointer[-1];
            val = Py_STACKREF_UNTAG_BORROWED(val_tagged);

            stack_pointer += -1;
            if (Py_IsNone(val)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            Py_DECREF_STACKREF(val_tagged);
            break;
        }

        case _JUMP_TO_TOP: {
            #ifndef _Py_JIT
            next_uop = &current_executor->trace[1];
            #endif
            CHECK_EVAL_BREAKER();
            break;
        }

        case _SET_IP: {
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND();
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND: {
            uint32_t framesize = (uint32_t)CURRENT_OPERAND();
            assert(framesize <= INT_MAX);
            if (!_PyThreadState_HasStackSpace(tstate, framesize)) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            if (tstate->py_recursion_remaining <= 1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _SAVE_RETURN_OFFSET: {
            oparg = CURRENT_OPARG();
            #if TIER_ONE
            frame->return_offset = (uint16_t)(next_instr - this_instr);
            #endif
            #if TIER_TWO
            frame->return_offset = oparg;
            #endif
            break;
        }

        case _EXIT_TRACE: {
            if (1) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _CHECK_VALIDITY: {
            if (!current_executor->vm_data.valid) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _LOAD_CONST_INLINE: {
            PyObject *value;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND();
            value = Py_NewRef(ptr);
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer += 1;
            break;
        }

        case _LOAD_CONST_INLINE_BORROW: {
            PyObject *value;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND();
            value = ptr;
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer += 1;
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_BORROW: {
            _PyStackRef pop_tagged;
            PyObject *pop;
            PyObject *value;
            pop_tagged = stack_pointer[-1];
            pop = Py_STACKREF_UNTAG_BORROWED(pop_tagged);

            PyObject *ptr = (PyObject *)CURRENT_OPERAND();
            (void)pop;
            Py_DECREF_STACKREF(pop_tagged);
            value = ptr;
            stack_pointer[-1] = Py_STACKREF_TAG(value);
            break;
        }

        case _LOAD_CONST_INLINE_WITH_NULL: {
            PyObject *value;
            PyObject *null;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND();
            value = Py_NewRef(ptr);
            null = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer[1] = Py_STACKREF_TAG(null);
            stack_pointer += 2;
            break;
        }

        case _LOAD_CONST_INLINE_BORROW_WITH_NULL: {
            PyObject *value;
            PyObject *null;
            PyObject *ptr = (PyObject *)CURRENT_OPERAND();
            value = ptr;
            null = NULL;
            stack_pointer[0] = Py_STACKREF_TAG(value);
            stack_pointer[1] = Py_STACKREF_TAG(null);
            stack_pointer += 2;
            break;
        }

        case _CHECK_FUNCTION: {
            uint32_t func_version = (uint32_t)CURRENT_OPERAND();
            assert(PyFunction_Check(frame->f_funcobj));
            if (((PyFunctionObject *)frame->f_funcobj)->func_version != func_version) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            break;
        }

        case _INTERNAL_INCREMENT_OPT_COUNTER: {
            _PyStackRef opt_tagged;
            PyObject *opt;
            opt_tagged = stack_pointer[-1];
            opt = Py_STACKREF_UNTAG_BORROWED(opt_tagged);

            _PyCounterOptimizerObject *exe = (_PyCounterOptimizerObject *)opt;
            exe->count++;
            stack_pointer += -1;
            break;
        }

        case _COLD_EXIT: {
            oparg = CURRENT_OPARG();
            _PyExecutorObject *previous = (_PyExecutorObject *)tstate->previous_executor;
            _PyExitData *exit = &previous->exits[oparg];
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _Py_CODEUNIT *target = _PyCode_CODE(code) + exit->target;
            _Py_BackoffCounter temperature = exit->temperature;
            if (!backoff_counter_triggers(temperature)) {
                exit->temperature = advance_backoff_counter(temperature);
                GOTO_TIER_ONE(target);
            }
            _PyExecutorObject *executor;
            if (target->op.code == ENTER_EXECUTOR) {
                executor = code->co_executors->executors[target->op.arg];
                Py_INCREF(executor);
            }
            else {
                int optimized = _PyOptimizer_Optimize(frame, target, stack_pointer, &executor);
                if (optimized <= 0) {
                    exit->temperature = restart_backoff_counter(temperature);
                    if (optimized < 0) {
                        Py_DECREF(previous);
                        tstate->previous_executor = Py_None;
                        GOTO_UNWIND();
                    }
                    GOTO_TIER_ONE(target);
                }
            }
            /* We need two references. One to store in exit->executor and
             * one to keep the executor alive when executing. */
            Py_INCREF(executor);
            exit->executor = executor;
            GOTO_TIER_TWO(executor);
            break;
        }

        case _START_EXECUTOR: {
            PyObject *executor = (PyObject *)CURRENT_OPERAND();
            Py_DECREF(tstate->previous_executor);
            tstate->previous_executor = NULL;
            #ifndef _Py_JIT
            current_executor = (_PyExecutorObject*)executor;
            #endif
            break;
        }

        case _FATAL_ERROR: {
            assert(0);
            Py_FatalError("Fatal error uop executed.");
            break;
        }

        case _CHECK_VALIDITY_AND_SET_IP: {
            PyObject *instr_ptr = (PyObject *)CURRENT_OPERAND();
            if (!current_executor->vm_data.valid) {
                UOP_STAT_INC(uopcode, miss);
                JUMP_TO_JUMP_TARGET();
            }
            frame->instr_ptr = (_Py_CODEUNIT *)instr_ptr;
            break;
        }

        case _DEOPT: {
            EXIT_TO_TIER1();
            break;
        }

        case _SIDE_EXIT: {
            EXIT_TO_TRACE();
            break;
        }

        case _ERROR_POP_N: {
            oparg = CURRENT_OPARG();
            stack_pointer += -oparg;
            GOTO_UNWIND();
            break;
        }

#undef TIER_TWO
