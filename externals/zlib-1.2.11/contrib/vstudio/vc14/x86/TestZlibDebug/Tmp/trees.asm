; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

	TITLE	C:\CPython\externals\zlib-1.2.11\trees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__length_code
PUBLIC	__dist_code
CONST	SEGMENT
__length_code DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
__dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
_extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
_bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
_extra_blbits DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
_static_ltree DW 0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
_static_dtree DW 00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
_base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
_base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
_static_l_desc DD FLAT:_static_ltree
	DD	FLAT:_extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
_static_d_desc DD FLAT:_static_dtree
	DD	FLAT:_extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
_static_bl_desc DD 00H
	DD	FLAT:_extra_blbits
	DD	00H
	DD	013H
	DD	07H
CONST	ENDS
PUBLIC	__tr_init
PUBLIC	__tr_tally
PUBLIC	__tr_flush_block
PUBLIC	__tr_flush_bits
PUBLIC	__tr_align
PUBLIC	__tr_stored_block
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_bi_flush PROC

; 1175 : {

	push	ebp
	mov	ebp, esp

; 1176 :     if (s->bi_valid == 16) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], 16		; 00000010H
	jne	SHORT $LN2@bi_flush

; 1177 :         put_short(s, s->bi_buf);

	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+5816]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+5816]
	sar	edx, 8
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1178 :         s->bi_buf = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx

; 1179 :         s->bi_valid = 0;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], 0
	jmp	SHORT $LN1@bi_flush
$LN2@bi_flush:

; 1180 :     } else if (s->bi_valid >= 8) {

	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], 8
	jl	SHORT $LN1@bi_flush

; 1181 :         put_byte(s, (Byte)s->bi_buf);

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	cl, BYTE PTR [ecx+5816]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1182 :         s->bi_buf >>= 8;

	mov	edx, DWORD PTR _s$[ebp]
	mov	ax, WORD PTR [edx+5816]
	shr	ax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax

; 1183 :         s->bi_valid -= 8;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	sub	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN1@bi_flush:

; 1184 :     }
; 1185 : }

	pop	ebp
	ret	0
_bi_flush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
_bi_windup PROC

; 1192 : {

	push	ebp
	mov	ebp, esp

; 1193 :     if (s->bi_valid > 8) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], 8
	jle	SHORT $LN2@bi_windup

; 1194 :         put_short(s, s->bi_buf);

	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+5816]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+5816]
	sar	edx, 8
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx
	jmp	SHORT $LN3@bi_windup
$LN2@bi_windup:

; 1195 :     } else if (s->bi_valid > 0) {

	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], 0
	jle	SHORT $LN3@bi_windup

; 1196 :         put_byte(s, (Byte)s->bi_buf);

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	cl, BYTE PTR [ecx+5816]
	mov	BYTE PTR [edx+eax], cl
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@bi_windup:

; 1197 :     }
; 1198 :     s->bi_buf = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+5816], dx

; 1199 :     s->bi_valid = 0;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], 0

; 1200 : #ifdef ZLIB_DEBUG
; 1201 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1202 : #endif
; 1203 : }

	pop	ebp
	ret	0
_bi_windup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_res$ = -4						; size = 4
_code$ = 8						; size = 4
_len$ = 12						; size = 4
_bi_reverse PROC

; 1161 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1162 :     register unsigned res = 0;

	mov	DWORD PTR _res$[ebp], 0
$LN4@bi_reverse:

; 1163 :     do {
; 1164 :         res |= code & 1;

	mov	eax, DWORD PTR _code$[ebp]
	and	eax, 1
	or	eax, DWORD PTR _res$[ebp]
	mov	DWORD PTR _res$[ebp], eax

; 1165 :         code >>= 1, res <<= 1;

	mov	ecx, DWORD PTR _code$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _code$[ebp], ecx
	mov	edx, DWORD PTR _res$[ebp]
	shl	edx, 1
	mov	DWORD PTR _res$[ebp], edx

; 1166 :     } while (--len > 0);

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN4@bi_reverse

; 1167 :     return res >> 1;

	mov	eax, DWORD PTR _res$[ebp]
	shr	eax, 1

; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_bi_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_black_mask$ = -8					; size = 4
_n$ = -4						; size = 4
_s$ = 8							; size = 4
_detect_data_type PROC

; 1126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1127 :     /* black_mask is the bit mask of black-listed bytes
; 1128 :      * set bits 0..6, 14..25, and 28..31
; 1129 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1130 :      */
; 1131 :     unsigned long black_mask = 0xf3ffc07fUL;

	mov	DWORD PTR _black_mask$[ebp], -201342849	; f3ffc07fH

; 1132 :     int n;
; 1133 : 
; 1134 :     /* Check for non-textual ("black-listed") bytes. */
; 1135 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@detect_dat
$LN2@detect_dat:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	mov	ecx, DWORD PTR _black_mask$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _black_mask$[ebp], ecx
$LN4@detect_dat:
	cmp	DWORD PTR _n$[ebp], 31			; 0000001fH
	jg	SHORT $LN3@detect_dat

; 1136 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

	mov	edx, DWORD PTR _black_mask$[ebp]
	and	edx, 1
	je	SHORT $LN8@detect_dat
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4+148]
	test	edx, edx
	je	SHORT $LN8@detect_dat

; 1137 :             return Z_BINARY;

	xor	eax, eax
	jmp	$LN1@detect_dat
$LN8@detect_dat:
	jmp	SHORT $LN2@detect_dat
$LN3@detect_dat:

; 1138 : 
; 1139 :     /* Check for textual ("white-listed") bytes. */
; 1140 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1141 :             || s->dyn_ltree[13].Freq != 0)

	mov	eax, 4
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx+148]
	test	eax, eax
	jne	SHORT $LN10@detect_dat
	mov	ecx, 4
	imul	edx, ecx, 10
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+edx+148]
	test	ecx, ecx
	jne	SHORT $LN10@detect_dat
	mov	edx, 4
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+148]
	test	edx, edx
	je	SHORT $LN9@detect_dat
$LN10@detect_dat:

; 1142 :         return Z_TEXT;

	mov	eax, 1
	jmp	SHORT $LN1@detect_dat
$LN9@detect_dat:

; 1143 :     for (n = 32; n < LITERALS; n++)

	mov	DWORD PTR _n$[ebp], 32			; 00000020H
	jmp	SHORT $LN7@detect_dat
$LN5@detect_dat:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN7@detect_dat:
	cmp	DWORD PTR _n$[ebp], 256			; 00000100H
	jge	SHORT $LN6@detect_dat

; 1144 :         if (s->dyn_ltree[n].Freq != 0)

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+148]
	test	eax, eax
	je	SHORT $LN11@detect_dat

; 1145 :             return Z_TEXT;

	mov	eax, 1
	jmp	SHORT $LN1@detect_dat
$LN11@detect_dat:
	jmp	SHORT $LN5@detect_dat
$LN6@detect_dat:

; 1146 : 
; 1147 :     /* There are no "black-listed" or "white-listed" bytes:
; 1148 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1149 :      */
; 1150 :     return Z_BINARY;

	xor	eax, eax
$LN1@detect_dat:

; 1151 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_detect_data_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_val$1 = -72						; size = 4
_val$2 = -68						; size = 4
_val$3 = -64						; size = 4
tv317 = -60						; size = 4
_val$4 = -56						; size = 4
_val$5 = -52						; size = 4
_val$6 = -48						; size = 4
_len$7 = -44						; size = 4
_len$8 = -40						; size = 4
_len$9 = -36						; size = 4
_len$10 = -32						; size = 4
_len$11 = -28						; size = 4
_len$12 = -24						; size = 4
_lx$ = -20						; size = 4
_extra$ = -16						; size = 4
_lc$ = -12						; size = 4
_dist$ = -8						; size = 4
_code$ = -4						; size = 4
_s$ = 8							; size = 4
_ltree$ = 12						; size = 4
_dtree$ = 16						; size = 4
_compress_block PROC

; 1068 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 1069 :     unsigned dist;      /* distance of matched string */
; 1070 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1071 :     unsigned lx = 0;    /* running index in l_buf */

	mov	DWORD PTR _lx$[ebp], 0

; 1072 :     unsigned code;      /* the code to send */
; 1073 :     int extra;          /* number of extra bits to send */
; 1074 : 
; 1075 :     if (s->last_lit != 0) do {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5792], 0
	je	$LN5@compress_b
$LN4@compress_b:

; 1076 :         dist = s->d_buf[lx];

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+5796]
	mov	eax, DWORD PTR _lx$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	mov	DWORD PTR _dist$[ebp], ecx

; 1077 :         lc = s->l_buf[lx++];

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5784]
	mov	ecx, DWORD PTR _lx$[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	DWORD PTR _lc$[ebp], edx
	mov	eax, DWORD PTR _lx$[ebp]
	add	eax, 1
	mov	DWORD PTR _lx$[ebp], eax

; 1078 :         if (dist == 0) {

	cmp	DWORD PTR _dist$[ebp], 0
	jne	$LN6@compress_b

; 1079 :             send_code(s, lc, ltree); /* send a literal byte */

	mov	ecx, DWORD PTR _lc$[ebp]
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2]
	mov	DWORD PTR _len$12[ebp], eax
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _len$12[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [edx+5820], ecx
	jle	$LN8@compress_b
	mov	eax, DWORD PTR _lc$[ebp]
	mov	ecx, DWORD PTR _ltree$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4]
	mov	DWORD PTR _val$6[ebp], edx
	movzx	eax, WORD PTR _val$6[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$6[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$12[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN9@compress_b
$LN8@compress_b:
	mov	ecx, DWORD PTR _lc$[ebp]
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$12[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN9@compress_b:

; 1080 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1081 :         } else {

	jmp	$LN2@compress_b
$LN6@compress_b:

; 1082 :             /* Here, lc is the match length - MIN_MATCH */
; 1083 :             code = _length_code[lc];

	mov	eax, DWORD PTR _lc$[ebp]
	movzx	ecx, BYTE PTR __length_code[eax]
	mov	DWORD PTR _code$[ebp], ecx

; 1084 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _ltree$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+1030]
	mov	DWORD PTR _len$11[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$11[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN10@compress_b
	mov	ecx, DWORD PTR _code$[ebp]
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+1028]
	mov	DWORD PTR _val$5[ebp], eax
	movzx	edx, WORD PTR _val$5[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$5[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$11[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN11@compress_b
$LN10@compress_b:
	mov	ecx, DWORD PTR _code$[ebp]
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+1028]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$11[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN11@compress_b:

; 1085 :             extra = extra_lbits[code];

	mov	eax, DWORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _extra_lbits[eax*4]
	mov	DWORD PTR _extra$[ebp], ecx

; 1086 :             if (extra != 0) {

	cmp	DWORD PTR _extra$[ebp], 0
	je	$LN12@compress_b

; 1087 :                 lc -= base_length[code];

	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _lc$[ebp]
	sub	eax, DWORD PTR _base_length[edx*4]
	mov	DWORD PTR _lc$[ebp], eax

; 1088 :                 send_bits(s, lc, extra);       /* send the extra length bits */

	mov	ecx, DWORD PTR _extra$[ebp]
	mov	DWORD PTR _len$10[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$10[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN13@compress_b
	mov	ecx, DWORD PTR _lc$[ebp]
	mov	DWORD PTR _val$4[ebp], ecx
	movzx	edx, WORD PTR _val$4[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$4[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$10[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN12@compress_b
$LN13@compress_b:
	movzx	edx, WORD PTR _lc$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$10[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN12@compress_b:

; 1089 :             }
; 1090 :             dist--; /* dist is now the match distance - 1 */

	mov	edx, DWORD PTR _dist$[ebp]
	sub	edx, 1
	mov	DWORD PTR _dist$[ebp], edx

; 1091 :             code = d_code(dist);

	cmp	DWORD PTR _dist$[ebp], 256		; 00000100H
	jae	SHORT $LN23@compress_b
	mov	eax, DWORD PTR _dist$[ebp]
	movzx	ecx, BYTE PTR __dist_code[eax]
	mov	DWORD PTR tv317[ebp], ecx
	jmp	SHORT $LN24@compress_b
$LN23@compress_b:
	mov	edx, DWORD PTR _dist$[ebp]
	shr	edx, 7
	movzx	eax, BYTE PTR __dist_code[edx+256]
	mov	DWORD PTR tv317[ebp], eax
$LN24@compress_b:
	mov	ecx, DWORD PTR tv317[ebp]
	mov	DWORD PTR _code$[ebp], ecx

; 1092 :             Assert (code < D_CODES, "bad d_code");
; 1093 : 
; 1094 :             send_code(s, code, dtree);       /* send the distance code */

	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _dtree$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2]
	mov	DWORD PTR _len$9[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$9[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN15@compress_b
	mov	ecx, DWORD PTR _code$[ebp]
	mov	edx, DWORD PTR _dtree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	DWORD PTR _val$3[ebp], eax
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$9[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN16@compress_b
$LN15@compress_b:
	mov	ecx, DWORD PTR _code$[ebp]
	mov	edx, DWORD PTR _dtree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$9[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN16@compress_b:

; 1095 :             extra = extra_dbits[code];

	mov	eax, DWORD PTR _code$[ebp]
	mov	ecx, DWORD PTR _extra_dbits[eax*4]
	mov	DWORD PTR _extra$[ebp], ecx

; 1096 :             if (extra != 0) {

	cmp	DWORD PTR _extra$[ebp], 0
	je	$LN2@compress_b

; 1097 :                 dist -= (unsigned)base_dist[code];

	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _dist$[ebp]
	sub	eax, DWORD PTR _base_dist[edx*4]
	mov	DWORD PTR _dist$[ebp], eax

; 1098 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

	mov	ecx, DWORD PTR _extra$[ebp]
	mov	DWORD PTR _len$8[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$8[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN18@compress_b
	mov	ecx, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _val$2[ebp], ecx
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$8[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN2@compress_b
$LN18@compress_b:
	movzx	edx, WORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$8[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN2@compress_b:

; 1099 :             }
; 1100 :         } /* literal or match pair ? */
; 1101 : 
; 1102 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1103 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1104 :                "pendingBuf overflow");
; 1105 : 
; 1106 :     } while (lx < s->last_lit);

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _lx$[ebp]
	cmp	eax, DWORD PTR [edx+5792]
	jb	$LN4@compress_b
$LN5@compress_b:

; 1107 : 
; 1108 :     send_code(s, END_BLOCK, ltree);

	mov	ecx, 4
	shl	ecx, 8
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx+2]
	mov	DWORD PTR _len$7[ebp], eax
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _len$7[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [edx+5820], ecx
	jle	$LN20@compress_b
	mov	eax, 4
	shl	eax, 8
	mov	ecx, DWORD PTR _ltree$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _val$1[ebp], edx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$7[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN1@compress_b
$LN20@compress_b:
	mov	ecx, 4
	shl	ecx, 8
	mov	edx, DWORD PTR _ltree$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$7[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN1@compress_b:

; 1109 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_compress_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_val$1 = -36						; size = 4
_val$2 = -32						; size = 4
_val$3 = -28						; size = 4
_val$4 = -24						; size = 4
_len$5 = -20						; size = 4
_len$6 = -16						; size = 4
_len$7 = -12						; size = 4
_len$8 = -8						; size = 4
_rank$ = -4						; size = 4
_s$ = 8							; size = 4
_lcodes$ = 12						; size = 4
_dcodes$ = 16						; size = 4
_blcodes$ = 20						; size = 4
_send_all_trees PROC

; 837  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 838  :     int rank;                    /* index in bl_order */
; 839  : 
; 840  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 841  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 842  :             "too many codes");
; 843  :     Tracev((stderr, "\nbl counts: "));
; 844  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

	mov	DWORD PTR _len$8[ebp], 5
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$8[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN5@send_all_t
	mov	edx, DWORD PTR _lcodes$[ebp]
	sub	edx, 257				; 00000101H
	mov	DWORD PTR _val$4[ebp], edx
	movzx	eax, WORD PTR _val$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$8[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN6@send_all_t
$LN5@send_all_t:
	mov	ecx, DWORD PTR _lcodes$[ebp]
	sub	ecx, 257				; 00000101H
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$8[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN6@send_all_t:

; 845  :     send_bits(s, dcodes-1,   5);

	mov	DWORD PTR _len$7[ebp], 5
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$7[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN7@send_all_t
	mov	ecx, DWORD PTR _dcodes$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _val$3[ebp], ecx
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$7[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN8@send_all_t
$LN7@send_all_t:
	mov	ecx, DWORD PTR _dcodes$[ebp]
	sub	ecx, 1
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$7[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN8@send_all_t:

; 846  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

	mov	DWORD PTR _len$6[ebp], 4
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$6[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN9@send_all_t
	mov	ecx, DWORD PTR _blcodes$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _val$2[ebp], ecx
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$6[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN10@send_all_t
$LN9@send_all_t:
	mov	ecx, DWORD PTR _blcodes$[ebp]
	sub	ecx, 4
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$6[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN10@send_all_t:

; 847  :     for (rank = 0; rank < blcodes; rank++) {

	mov	DWORD PTR _rank$[ebp], 0
	jmp	SHORT $LN4@send_all_t
$LN2@send_all_t:
	mov	edx, DWORD PTR _rank$[ebp]
	add	edx, 1
	mov	DWORD PTR _rank$[ebp], edx
$LN4@send_all_t:
	mov	eax, DWORD PTR _rank$[ebp]
	cmp	eax, DWORD PTR _blcodes$[ebp]
	jge	$LN3@send_all_t

; 848  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 849  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

	mov	DWORD PTR _len$5[ebp], 3
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _len$5[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [edx+5820], ecx
	jle	$LN11@send_all_t
	mov	eax, DWORD PTR _rank$[ebp]
	movzx	ecx, BYTE PTR _bl_order[eax]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2686]
	mov	DWORD PTR _val$1[ebp], eax
	movzx	edx, WORD PTR _val$1[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$1[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$5[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN12@send_all_t
$LN11@send_all_t:
	mov	ecx, DWORD PTR _rank$[ebp]
	movzx	edx, BYTE PTR _bl_order[ecx]
	mov	eax, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [eax+edx*4+2686]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$5[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN12@send_all_t:

; 850  :     }

	jmp	$LN2@send_all_t
$LN3@send_all_t:

; 851  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 852  : 
; 853  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

	mov	edx, DWORD PTR _lcodes$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_send_tree
	add	esp, 12					; 0000000cH

; 854  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 855  : 
; 856  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

	mov	edx, DWORD PTR _dcodes$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2440				; 00000988H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_send_tree
	add	esp, 12					; 0000000cH

; 857  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 858  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_all_trees ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_max_blindex$ = -4					; size = 4
_s$ = 8							; size = 4
_build_bl_tree PROC

; 801  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 802  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 803  : 
; 804  :     /* Determine the bit length frequencies for literal and distance trees */
; 805  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+2844]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_scan_tree
	add	esp, 12					; 0000000cH

; 806  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+2856]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2440				; 00000988H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_scan_tree
	add	esp, 12					; 0000000cH

; 807  : 
; 808  :     /* Build the bit length tree: */
; 809  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2864				; 00000b30H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_build_tree
	add	esp, 8

; 810  :     /* opt_len now includes the length of the tree representations, except
; 811  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 812  :      */
; 813  : 
; 814  :     /* Determine the number of bit length codes to send. The pkzip format
; 815  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 816  :      * 3 but the actual value used is 4.)
; 817  :      */
; 818  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

	mov	DWORD PTR _max_blindex$[ebp], 18	; 00000012H
	jmp	SHORT $LN4@build_bl_t
$LN2@build_bl_t:
	mov	ecx, DWORD PTR _max_blindex$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _max_blindex$[ebp], ecx
$LN4@build_bl_t:
	cmp	DWORD PTR _max_blindex$[ebp], 3
	jl	SHORT $LN3@build_bl_t

; 819  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

	mov	edx, DWORD PTR _max_blindex$[ebp]
	movzx	eax, BYTE PTR _bl_order[edx]
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4+2686]
	test	edx, edx
	je	SHORT $LN5@build_bl_t
	jmp	SHORT $LN3@build_bl_t
$LN5@build_bl_t:

; 820  :     }

	jmp	SHORT $LN2@build_bl_t
$LN3@build_bl_t:

; 821  :     /* Update opt_len to include the bit length tree and counts */
; 822  :     s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;

	mov	eax, DWORD PTR _max_blindex$[ebp]
	add	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5800]
	lea	ecx, DWORD PTR [ecx+eax+14]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5800], ecx

; 823  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 824  :             s->opt_len, s->static_len));
; 825  : 
; 826  :     return max_blindex;

	mov	eax, DWORD PTR _max_blindex$[ebp]

; 827  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_build_bl_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_prevlen$ = -92						; size = 4
_val$1 = -88						; size = 4
_val$2 = -84						; size = 4
_val$3 = -80						; size = 4
_val$4 = -76						; size = 4
_val$5 = -72						; size = 4
_val$6 = -68						; size = 4
_val$7 = -64						; size = 4
_val$8 = -60						; size = 4
_len$9 = -56						; size = 4
_len$10 = -52						; size = 4
_len$11 = -48						; size = 4
_len$12 = -44						; size = 4
_len$13 = -40						; size = 4
_len$14 = -36						; size = 4
_len$15 = -32						; size = 4
_len$16 = -28						; size = 4
_n$ = -24						; size = 4
_min_count$ = -20					; size = 4
_max_count$ = -16					; size = 4
_nextlen$ = -12						; size = 4
_curlen$ = -8						; size = 4
_count$ = -4						; size = 4
_s$ = 8							; size = 4
_tree$ = 12						; size = 4
_max_code$ = 16						; size = 4
_send_tree PROC

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 753  :     int n;                     /* iterates over all tree elements */
; 754  :     int prevlen = -1;          /* last emitted length */

	mov	DWORD PTR _prevlen$[ebp], -1

; 755  :     int curlen;                /* length of current code */
; 756  :     int nextlen = tree[0].Len; /* length of next code */

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx+2]
	mov	DWORD PTR _nextlen$[ebp], eax

; 757  :     int count = 0;             /* repeat count of the current code */

	mov	DWORD PTR _count$[ebp], 0

; 758  :     int max_count = 7;         /* max repeat count */

	mov	DWORD PTR _max_count$[ebp], 7

; 759  :     int min_count = 4;         /* min repeat count */

	mov	DWORD PTR _min_count$[ebp], 4

; 760  : 
; 761  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 762  :     if (nextlen == 0) max_count = 138, min_count = 3;

	cmp	DWORD PTR _nextlen$[ebp], 0
	jne	SHORT $LN8@send_tree
	mov	DWORD PTR _max_count$[ebp], 138		; 0000008aH
	mov	DWORD PTR _min_count$[ebp], 3
$LN8@send_tree:

; 763  : 
; 764  :     for (n = 0; n <= max_code; n++) {

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@send_tree
$LN2@send_tree:
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
$LN4@send_tree:
	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _max_code$[ebp]
	jg	$LN1@send_tree

; 765  :         curlen = nextlen; nextlen = tree[n+1].Len;

	mov	eax, DWORD PTR _nextlen$[ebp]
	mov	DWORD PTR _curlen$[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+6]
	mov	DWORD PTR _nextlen$[ebp], eax

; 766  :         if (++count < max_count && curlen == nextlen) {

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _max_count$[ebp]
	jge	SHORT $LN9@send_tree
	mov	eax, DWORD PTR _curlen$[ebp]
	cmp	eax, DWORD PTR _nextlen$[ebp]
	jne	SHORT $LN9@send_tree

; 767  :             continue;

	jmp	SHORT $LN2@send_tree
	jmp	$LN10@send_tree
$LN9@send_tree:

; 768  :         } else if (count < min_count) {

	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _min_count$[ebp]
	jge	$LN11@send_tree
$LN7@send_tree:

; 769  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2686]
	mov	DWORD PTR _len$16[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$16[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN13@send_tree
	mov	ecx, DWORD PTR _curlen$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2684]
	mov	DWORD PTR _val$8[ebp], eax
	movzx	edx, WORD PTR _val$8[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$8[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$16[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN5@send_tree
$LN13@send_tree:
	mov	ecx, DWORD PTR _curlen$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2684]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$16[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN5@send_tree:
	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	jne	$LN7@send_tree

; 770  : 
; 771  :         } else if (curlen != 0) {

	jmp	$LN10@send_tree
$LN11@send_tree:
	cmp	DWORD PTR _curlen$[ebp], 0
	je	$LN15@send_tree

; 772  :             if (curlen != prevlen) {

	mov	ecx, DWORD PTR _curlen$[ebp]
	cmp	ecx, DWORD PTR _prevlen$[ebp]
	je	$LN17@send_tree

; 773  :                 send_code(s, curlen, s->bl_tree); count--;

	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2686]
	mov	DWORD PTR _len$15[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$15[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN18@send_tree
	mov	ecx, DWORD PTR _curlen$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2684]
	mov	DWORD PTR _val$7[ebp], eax
	movzx	edx, WORD PTR _val$7[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$7[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$15[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN19@send_tree
$LN18@send_tree:
	mov	ecx, DWORD PTR _curlen$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2684]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$15[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN19@send_tree:
	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN17@send_tree:

; 774  :             }
; 775  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 776  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx+2686]
	mov	DWORD PTR _len$14[ebp], eax
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _len$14[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [edx+5820], ecx
	jle	$LN20@send_tree
	mov	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+2684]
	mov	DWORD PTR _val$6[ebp], edx
	movzx	eax, WORD PTR _val$6[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$6[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$14[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN21@send_tree
$LN20@send_tree:
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx+2684]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$14[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN21@send_tree:
	mov	DWORD PTR _len$13[ebp], 2
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$13[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN22@send_tree
	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 3
	mov	DWORD PTR _val$5[ebp], edx
	movzx	eax, WORD PTR _val$5[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$5[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$13[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN23@send_tree
$LN22@send_tree:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 3
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$13[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN23@send_tree:
	jmp	$LN10@send_tree
$LN15@send_tree:

; 777  : 
; 778  :         } else if (count <= 10) {

	cmp	DWORD PTR _count$[ebp], 10		; 0000000aH
	jg	$LN24@send_tree

; 779  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+2686]
	mov	DWORD PTR _len$12[ebp], edx
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$12[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN26@send_tree
	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+2684]
	mov	DWORD PTR _val$4[ebp], edx
	movzx	eax, WORD PTR _val$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$12[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN27@send_tree
$LN26@send_tree:
	mov	ecx, 4
	imul	edx, ecx, 17
	mov	eax, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [eax+edx+2684]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$12[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN27@send_tree:
	mov	DWORD PTR _len$11[ebp], 3
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$11[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN28@send_tree
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 3
	mov	DWORD PTR _val$3[ebp], ecx
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$11[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN29@send_tree
$LN28@send_tree:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 3
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$11[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN29@send_tree:

; 780  : 
; 781  :         } else {

	jmp	$LN10@send_tree
$LN24@send_tree:

; 782  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

	mov	edx, 4
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+2686]
	mov	DWORD PTR _len$10[ebp], edx
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$10[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN30@send_tree
	mov	edx, 4
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [ecx+eax+2684]
	mov	DWORD PTR _val$2[ebp], edx
	movzx	eax, WORD PTR _val$2[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$2[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$10[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN31@send_tree
$LN30@send_tree:
	mov	ecx, 4
	imul	edx, ecx, 18
	mov	eax, DWORD PTR _s$[ebp]
	movzx	edx, WORD PTR [eax+edx+2684]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$10[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN31@send_tree:
	mov	DWORD PTR _len$9[ebp], 7
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$9[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN32@send_tree
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 11					; 0000000bH
	mov	DWORD PTR _val$1[ebp], ecx
	movzx	edx, WORD PTR _val$1[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$1[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$9[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN10@send_tree
$LN32@send_tree:
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 11					; 0000000bH
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$9[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN10@send_tree:

; 783  :         }
; 784  :         count = 0; prevlen = curlen;

	mov	DWORD PTR _count$[ebp], 0
	mov	edx, DWORD PTR _curlen$[ebp]
	mov	DWORD PTR _prevlen$[ebp], edx

; 785  :         if (nextlen == 0) {

	cmp	DWORD PTR _nextlen$[ebp], 0
	jne	SHORT $LN34@send_tree

; 786  :             max_count = 138, min_count = 3;

	mov	DWORD PTR _max_count$[ebp], 138		; 0000008aH
	mov	DWORD PTR _min_count$[ebp], 3
	jmp	SHORT $LN35@send_tree
$LN34@send_tree:

; 787  :         } else if (curlen == nextlen) {

	mov	eax, DWORD PTR _curlen$[ebp]
	cmp	eax, DWORD PTR _nextlen$[ebp]
	jne	SHORT $LN36@send_tree

; 788  :             max_count = 6, min_count = 3;

	mov	DWORD PTR _max_count$[ebp], 6
	mov	DWORD PTR _min_count$[ebp], 3

; 789  :         } else {

	jmp	SHORT $LN35@send_tree
$LN36@send_tree:

; 790  :             max_count = 7, min_count = 4;

	mov	DWORD PTR _max_count$[ebp], 7
	mov	DWORD PTR _min_count$[ebp], 4
$LN35@send_tree:

; 791  :         }
; 792  :     }

	jmp	$LN2@send_tree
$LN1@send_tree:

; 793  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_send_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_prevlen$ = -28						; size = 4
_n$ = -24						; size = 4
_min_count$ = -20					; size = 4
_max_count$ = -16					; size = 4
_nextlen$ = -12						; size = 4
_count$ = -8						; size = 4
_curlen$ = -4						; size = 4
_s$ = 8							; size = 4
_tree$ = 12						; size = 4
_max_code$ = 16						; size = 4
_scan_tree PROC

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 708  :     int n;                     /* iterates over all tree elements */
; 709  :     int prevlen = -1;          /* last emitted length */

	mov	DWORD PTR _prevlen$[ebp], -1

; 710  :     int curlen;                /* length of current code */
; 711  :     int nextlen = tree[0].Len; /* length of next code */

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx+2]
	mov	DWORD PTR _nextlen$[ebp], eax

; 712  :     int count = 0;             /* repeat count of the current code */

	mov	DWORD PTR _count$[ebp], 0

; 713  :     int max_count = 7;         /* max repeat count */

	mov	DWORD PTR _max_count$[ebp], 7

; 714  :     int min_count = 4;         /* min repeat count */

	mov	DWORD PTR _min_count$[ebp], 4

; 715  : 
; 716  :     if (nextlen == 0) max_count = 138, min_count = 3;

	cmp	DWORD PTR _nextlen$[ebp], 0
	jne	SHORT $LN5@scan_tree
	mov	DWORD PTR _max_count$[ebp], 138		; 0000008aH
	mov	DWORD PTR _min_count$[ebp], 3
$LN5@scan_tree:

; 717  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _max_code$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	mov	WORD PTR [eax+edx*4+6], cx

; 718  : 
; 719  :     for (n = 0; n <= max_code; n++) {

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@scan_tree
$LN2@scan_tree:
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
$LN4@scan_tree:
	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _max_code$[ebp]
	jg	$LN1@scan_tree

; 720  :         curlen = nextlen; nextlen = tree[n+1].Len;

	mov	eax, DWORD PTR _nextlen$[ebp]
	mov	DWORD PTR _curlen$[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+6]
	mov	DWORD PTR _nextlen$[ebp], eax

; 721  :         if (++count < max_count && curlen == nextlen) {

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _max_count$[ebp]
	jge	SHORT $LN6@scan_tree
	mov	eax, DWORD PTR _curlen$[ebp]
	cmp	eax, DWORD PTR _nextlen$[ebp]
	jne	SHORT $LN6@scan_tree

; 722  :             continue;

	jmp	SHORT $LN2@scan_tree
	jmp	$LN7@scan_tree
$LN6@scan_tree:

; 723  :         } else if (count < min_count) {

	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _min_count$[ebp]
	jge	SHORT $LN8@scan_tree

; 724  :             s->bl_tree[curlen].Freq += count;

	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2684]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+edx*4+2684], cx
	jmp	$LN7@scan_tree
$LN8@scan_tree:

; 725  :         } else if (curlen != 0) {

	cmp	DWORD PTR _curlen$[ebp], 0
	je	SHORT $LN10@scan_tree

; 726  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

	mov	ecx, DWORD PTR _curlen$[ebp]
	cmp	ecx, DWORD PTR _prevlen$[ebp]
	je	SHORT $LN12@scan_tree
	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	cx, WORD PTR [eax+edx*4+2684]
	add	cx, 1
	mov	edx, DWORD PTR _curlen$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+edx*4+2684], cx
$LN12@scan_tree:

; 727  :             s->bl_tree[REP_3_6].Freq++;

	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _s$[ebp]
	mov	ax, WORD PTR [edx+ecx+2684]
	add	ax, 1
	mov	ecx, 4
	shl	ecx, 4
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+ecx+2684], ax
	jmp	SHORT $LN7@scan_tree
$LN10@scan_tree:

; 728  :         } else if (count <= 10) {

	cmp	DWORD PTR _count$[ebp], 10		; 0000000aH
	jg	SHORT $LN13@scan_tree

; 729  :             s->bl_tree[REPZ_3_10].Freq++;

	mov	eax, 4
	imul	ecx, eax, 17
	mov	edx, DWORD PTR _s$[ebp]
	mov	ax, WORD PTR [edx+ecx+2684]
	add	ax, 1
	mov	ecx, 4
	imul	edx, ecx, 17
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+edx+2684], ax

; 730  :         } else {

	jmp	SHORT $LN7@scan_tree
$LN13@scan_tree:

; 731  :             s->bl_tree[REPZ_11_138].Freq++;

	mov	edx, 4
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+eax+2684]
	add	dx, 1
	mov	eax, 4
	imul	ecx, eax, 18
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+ecx+2684], dx
$LN7@scan_tree:

; 732  :         }
; 733  :         count = 0; prevlen = curlen;

	mov	DWORD PTR _count$[ebp], 0
	mov	ecx, DWORD PTR _curlen$[ebp]
	mov	DWORD PTR _prevlen$[ebp], ecx

; 734  :         if (nextlen == 0) {

	cmp	DWORD PTR _nextlen$[ebp], 0
	jne	SHORT $LN15@scan_tree

; 735  :             max_count = 138, min_count = 3;

	mov	DWORD PTR _max_count$[ebp], 138		; 0000008aH
	mov	DWORD PTR _min_count$[ebp], 3
	jmp	SHORT $LN16@scan_tree
$LN15@scan_tree:

; 736  :         } else if (curlen == nextlen) {

	mov	edx, DWORD PTR _curlen$[ebp]
	cmp	edx, DWORD PTR _nextlen$[ebp]
	jne	SHORT $LN17@scan_tree

; 737  :             max_count = 6, min_count = 3;

	mov	DWORD PTR _max_count$[ebp], 6
	mov	DWORD PTR _min_count$[ebp], 3

; 738  :         } else {

	jmp	SHORT $LN16@scan_tree
$LN17@scan_tree:

; 739  :             max_count = 7, min_count = 4;

	mov	DWORD PTR _max_count$[ebp], 7
	mov	DWORD PTR _min_count$[ebp], 4
$LN16@scan_tree:

; 740  :         }
; 741  :     }

	jmp	$LN2@scan_tree
$LN1@scan_tree:

; 742  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_scan_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
tv244 = -56						; size = 4
tv223 = -52						; size = 4
tv187 = -48						; size = 4
tv181 = -44						; size = 4
_elems$ = -40						; size = 4
_stree$ = -36						; size = 4
tv95 = -32						; size = 4
tv81 = -28						; size = 4
tv132 = -24						; size = 4
_m$ = -20						; size = 4
_max_code$ = -16					; size = 4
_node$ = -12						; size = 4
_tree$ = -8						; size = 4
_n$ = -4						; size = 4
_s$ = 8							; size = 4
_desc$ = 12						; size = 4
_build_tree PROC

; 618  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi

; 619  :     ct_data *tree         = desc->dyn_tree;

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tree$[ebp], ecx

; 620  :     const ct_data *stree  = desc->stat_desc->static_tree;

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _stree$[ebp], ecx

; 621  :     int elems             = desc->stat_desc->elems;

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _elems$[ebp], ecx

; 622  :     int n, m;          /* iterate over heap elements */
; 623  :     int max_code = -1; /* largest code with non zero frequency */

	mov	DWORD PTR _max_code$[ebp], -1

; 624  :     int node;          /* new node being created */
; 625  : 
; 626  :     /* Construct the initial heap, with least frequent element in
; 627  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 628  :      * heap[0] is not used.
; 629  :      */
; 630  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5200], 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5204], 573		; 0000023dH

; 631  : 
; 632  :     for (n = 0; n < elems; n++) {

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@build_tree
$LN2@build_tree:
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
$LN4@build_tree:
	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _elems$[ebp]
	jge	SHORT $LN5@build_tree

; 633  :         if (tree[n].Freq != 0) {

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _tree$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4]
	test	edx, edx
	je	SHORT $LN13@build_tree

; 634  :             s->heap[++(s->heap_len)] = max_code = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _max_code$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+5200]
	add	edx, 1
	mov	DWORD PTR tv81[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [eax+5200], ecx
	mov	edx, DWORD PTR tv81[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _max_code$[ebp]
	mov	DWORD PTR [eax+edx*4+2908], ecx

; 635  :             s->depth[n] = 0;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR _n$[ebp]
	mov	BYTE PTR [edx+5208], 0

; 636  :         } else {

	jmp	SHORT $LN14@build_tree
$LN13@build_tree:

; 637  :             tree[n].Len = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	WORD PTR [edx+ecx*4+2], ax
$LN14@build_tree:

; 638  :         }
; 639  :     }

	jmp	SHORT $LN2@build_tree
$LN5@build_tree:

; 640  : 
; 641  :     /* The pkzip format requires that at least one distance code exists,
; 642  :      * and that at least one bit should be sent even if there is only one
; 643  :      * possible code. So to avoid special checks later on we force at least
; 644  :      * two codes of non zero frequency.
; 645  :      */
; 646  :     while (s->heap_len < 2) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5200], 2
	jge	$LN6@build_tree

; 647  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

	cmp	DWORD PTR _max_code$[ebp], 2
	jge	SHORT $LN17@build_tree
	mov	ecx, DWORD PTR _max_code$[ebp]
	add	ecx, 1
	mov	DWORD PTR _max_code$[ebp], ecx
	mov	edx, DWORD PTR _max_code$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN18@build_tree
$LN17@build_tree:
	mov	DWORD PTR tv132[ebp], 0
$LN18@build_tree:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5200]
	add	ecx, 1
	mov	DWORD PTR tv95[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR [edx+5200], eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR [edx+ecx*4+2908], eax
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR _node$[ebp], ecx

; 648  :         tree[node].Freq = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	WORD PTR [ecx+eax*4], dx

; 649  :         s->depth[node] = 0;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR _node$[ebp]
	mov	BYTE PTR [edx+5208], 0

; 650  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5800]
	sub	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5800], ecx
	cmp	DWORD PTR _stree$[ebp], 0
	je	SHORT $LN15@build_tree
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _stree$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4+2]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5804]
	sub	ecx, edx
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5804], ecx
$LN15@build_tree:

; 651  :         /* node is 0 or 1 so it does not have extra bits */
; 652  :     }

	jmp	$LN5@build_tree
$LN6@build_tree:

; 653  :     desc->max_code = max_code;

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR _max_code$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 654  : 
; 655  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 656  :      * establish sub-heaps of increasing lengths:
; 657  :      */
; 658  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5200]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN9@build_tree
$LN7@build_tree:
	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN9@build_tree:
	cmp	DWORD PTR _n$[ebp], 1
	jl	SHORT $LN8@build_tree
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_pqdownheap
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@build_tree
$LN8@build_tree:

; 659  : 
; 660  :     /* Construct the Huffman tree by repeatedly combining the least two
; 661  :      * frequent nodes.
; 662  :      */
; 663  :     node = elems;              /* next internal node of the tree */

	mov	ecx, DWORD PTR _elems$[ebp]
	mov	DWORD PTR _node$[ebp], ecx
$LN12@build_tree:

; 664  :     do {
; 665  :         pqremove(s, tree, n);  /* n = node of least frequency */

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+edx+2908]
	mov	DWORD PTR _n$[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5200]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _s$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+2908]
	mov	DWORD PTR [edx+ecx+2908], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+5200]
	sub	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5200], edx
	push	1
	mov	ecx, DWORD PTR _tree$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_pqdownheap
	add	esp, 12					; 0000000cH

; 666  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+eax+2908]
	mov	DWORD PTR _m$[ebp], edx

; 667  : 
; 668  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5204]
	sub	ecx, 1
	mov	DWORD PTR tv181[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR tv181[ebp]
	mov	DWORD PTR [edx+5204], eax
	mov	ecx, DWORD PTR tv181[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4+2908], eax

; 669  :         s->heap[--(s->heap_max)] = m;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+5204]
	sub	edx, 1
	mov	DWORD PTR tv187[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR tv187[ebp]
	mov	DWORD PTR [eax+5204], ecx
	mov	edx, DWORD PTR tv187[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+edx*4+2908], ecx

; 670  : 
; 671  :         /* Create a new node father of n and m */
; 672  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	movzx	edx, WORD PTR [eax+edx*4]
	add	ecx, edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	WORD PTR [edx+eax*4], cx

; 673  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movzx	ecx, BYTE PTR [eax+5208]
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR _m$[ebp]
	movzx	eax, BYTE PTR [edx+5208]
	cmp	ecx, eax
	jl	SHORT $LN19@build_tree
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR _n$[ebp]
	movzx	edx, BYTE PTR [ecx+5208]
	mov	DWORD PTR tv223[ebp], edx
	jmp	SHORT $LN20@build_tree
$LN19@build_tree:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _m$[ebp]
	movzx	ecx, BYTE PTR [eax+5208]
	mov	DWORD PTR tv223[ebp], ecx
$LN20@build_tree:
	mov	edx, DWORD PTR tv223[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _node$[ebp]
	mov	BYTE PTR [eax+5208], dl

; 674  :                                 s->depth[n] : s->depth[m]) + 1);
; 675  :         tree[n].Dad = tree[m].Dad = (ush)node;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	ax, WORD PTR _node$[ebp]
	mov	WORD PTR [edx+ecx*4+2], ax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	ax, WORD PTR _node$[ebp]
	mov	WORD PTR [edx+ecx*4+2], ax

; 676  : #ifdef DUMP_BL_TREE
; 677  :         if (tree == s->bl_tree) {
; 678  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 679  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 680  :         }
; 681  : #endif
; 682  :         /* and insert the new node in the heap */
; 683  :         s->heap[SMALLEST] = node++;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+ecx+2908], eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 1
	mov	DWORD PTR _node$[ebp], ecx

; 684  :         pqdownheap(s, tree, SMALLEST);

	push	1
	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_pqdownheap
	add	esp, 12					; 0000000cH

; 685  : 
; 686  :     } while (s->heap_len >= 2);

	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5200], 2
	jge	$LN12@build_tree

; 687  : 
; 688  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5204]
	sub	eax, 1
	mov	DWORD PTR tv244[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR tv244[ebp]
	mov	DWORD PTR [ecx+5204], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR tv244[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [esi+eax+2908]
	mov	DWORD PTR [edx+ecx*4+2908], eax

; 689  : 
; 690  :     /* At this point, the fields freq and dad are set. We can now
; 691  :      * generate the bit lengths.
; 692  :      */
; 693  :     gen_bitlen(s, (tree_desc *)desc);

	mov	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_gen_bitlen
	add	esp, 8

; 694  : 
; 695  :     /* The field len is now set, we can generate the bit codes */
; 696  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2876				; 00000b3cH
	push	eax
	mov	ecx, DWORD PTR _max_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	call	_gen_codes
	add	esp, 12					; 0000000cH

; 697  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_next_code$ = -52					; size = 32
tv94 = -20						; size = 4
_code$ = -16						; size = 4
_n$ = -12						; size = 4
_len$1 = -8						; size = 4
_bits$ = -4						; size = 4
_tree$ = 8						; size = 4
_max_code$ = 12						; size = 4
_bl_count$ = 16						; size = 4
_gen_codes PROC

; 576  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 577  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 578  :     unsigned code = 0;         /* running code value */

	mov	DWORD PTR _code$[ebp], 0

; 579  :     int bits;                  /* bit index */
; 580  :     int n;                     /* code index */
; 581  : 
; 582  :     /* The distribution counts are first used to generate the code values
; 583  :      * without bit reversal.
; 584  :      */
; 585  :     for (bits = 1; bits <= MAX_BITS; bits++) {

	mov	DWORD PTR _bits$[ebp], 1
	jmp	SHORT $LN4@gen_codes
$LN2@gen_codes:
	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 1
	mov	DWORD PTR _bits$[ebp], eax
$LN4@gen_codes:
	cmp	DWORD PTR _bits$[ebp], 15		; 0000000fH
	jg	SHORT $LN3@gen_codes

; 586  :         code = (code + bl_count[bits-1]) << 1;

	mov	ecx, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _bl_count$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2-2]
	add	eax, DWORD PTR _code$[ebp]
	shl	eax, 1
	mov	DWORD PTR _code$[ebp], eax

; 587  :         next_code[bits] = (ush)code;

	mov	ecx, DWORD PTR _bits$[ebp]
	mov	dx, WORD PTR _code$[ebp]
	mov	WORD PTR _next_code$[ebp+ecx*2], dx

; 588  :     }

	jmp	SHORT $LN2@gen_codes
$LN3@gen_codes:

; 589  :     /* Check that the bit counts in bl_count are consistent. The last code
; 590  :      * must be all ones.
; 591  :      */
; 592  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 593  :             "inconsistent bit counts");
; 594  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 595  : 
; 596  :     for (n = 0;  n <= max_code; n++) {

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN7@gen_codes
$LN5@gen_codes:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN7@gen_codes:
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR _max_code$[ebp]
	jg	SHORT $LN1@gen_codes

; 597  :         int len = tree[n].Len;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2]
	mov	DWORD PTR _len$1[ebp], ecx

; 598  :         if (len == 0) continue;

	cmp	DWORD PTR _len$1[ebp], 0
	jne	SHORT $LN8@gen_codes
	jmp	SHORT $LN5@gen_codes
$LN8@gen_codes:

; 599  :         /* Now reverse the bits */
; 600  :         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

	mov	edx, DWORD PTR _len$1[ebp]
	movzx	eax, WORD PTR _next_code$[ebp+edx*2]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _len$1[ebp]
	mov	dx, WORD PTR _next_code$[ebp+ecx*2]
	add	dx, 1
	mov	eax, DWORD PTR _len$1[ebp]
	mov	WORD PTR _next_code$[ebp+eax*2], dx
	mov	ecx, DWORD PTR _len$1[ebp]
	push	ecx
	mov	edx, DWORD PTR tv94[ebp]
	push	edx
	call	_bi_reverse
	add	esp, 8
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	WORD PTR [edx+ecx*4], ax

; 601  : 
; 602  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 603  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 604  :     }

	jmp	SHORT $LN5@gen_codes
$LN1@gen_codes:

; 605  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gen_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_extra$ = -52						; size = 4
_max_code$ = -48					; size = 4
_stree$ = -44						; size = 4
_base$ = -40						; size = 4
_xbits$ = -36						; size = 4
_m$ = -32						; size = 4
_max_length$ = -28					; size = 4
_overflow$ = -24					; size = 4
_h$ = -20						; size = 4
_tree$ = -16						; size = 4
_n$ = -12						; size = 4
_bits$ = -8						; size = 4
_f$ = -4						; size = 2
_s$ = 8							; size = 4
_desc$ = 12						; size = 4
_gen_bitlen PROC

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 490  :     ct_data *tree        = desc->dyn_tree;

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tree$[ebp], ecx

; 491  :     int max_code         = desc->max_code;

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _max_code$[ebp], eax

; 492  :     const ct_data *stree = desc->stat_desc->static_tree;

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _stree$[ebp], eax

; 493  :     const intf *extra    = desc->stat_desc->extra_bits;

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _extra$[ebp], eax

; 494  :     int base             = desc->stat_desc->extra_base;

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _base$[ebp], eax

; 495  :     int max_length       = desc->stat_desc->max_length;

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _max_length$[ebp], eax

; 496  :     int h;              /* heap index */
; 497  :     int n, m;           /* iterate over the tree elements */
; 498  :     int bits;           /* bit length */
; 499  :     int xbits;          /* extra bits */
; 500  :     ush f;              /* frequency */
; 501  :     int overflow = 0;   /* number of elements with bit length too large */

	mov	DWORD PTR _overflow$[ebp], 0

; 502  : 
; 503  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

	mov	DWORD PTR _bits$[ebp], 0
	jmp	SHORT $LN4@gen_bitlen
$LN2@gen_bitlen:
	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bits$[ebp], ecx
$LN4@gen_bitlen:
	cmp	DWORD PTR _bits$[ebp], 15		; 0000000fH
	jg	SHORT $LN3@gen_bitlen
	xor	edx, edx
	mov	eax, DWORD PTR _bits$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+eax*2+2876], dx
	jmp	SHORT $LN2@gen_bitlen
$LN3@gen_bitlen:

; 504  : 
; 505  :     /* In a first pass, compute the optimal bit lengths (which may
; 506  :      * overflow in the case of the bit length tree).
; 507  :      */
; 508  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5204]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2908]
	xor	eax, eax
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	WORD PTR [ecx+edx*4+2], ax

; 509  : 
; 510  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5204]
	add	eax, 1
	mov	DWORD PTR _h$[ebp], eax
	jmp	SHORT $LN7@gen_bitlen
$LN5@gen_bitlen:
	mov	ecx, DWORD PTR _h$[ebp]
	add	ecx, 1
	mov	DWORD PTR _h$[ebp], ecx
$LN7@gen_bitlen:
	cmp	DWORD PTR _h$[ebp], 573			; 0000023dH
	jge	$LN6@gen_bitlen

; 511  :         n = s->heap[h];

	mov	edx, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2908]
	mov	DWORD PTR _n$[ebp], ecx

; 512  :         bits = tree[tree[n].Dad].Len + 1;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [eax+edx*4+2]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2]
	add	eax, 1
	mov	DWORD PTR _bits$[ebp], eax

; 513  :         if (bits > max_length) bits = max_length, overflow++;

	mov	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _max_length$[ebp]
	jle	SHORT $LN18@gen_bitlen
	mov	edx, DWORD PTR _max_length$[ebp]
	mov	DWORD PTR _bits$[ebp], edx
	mov	eax, DWORD PTR _overflow$[ebp]
	add	eax, 1
	mov	DWORD PTR _overflow$[ebp], eax
$LN18@gen_bitlen:

; 514  :         tree[n].Len = (ush)bits;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	ax, WORD PTR _bits$[ebp]
	mov	WORD PTR [edx+ecx*4+2], ax

; 515  :         /* We overwrite tree[n].Dad which is no longer needed */
; 516  : 
; 517  :         if (n > max_code) continue; /* not a leaf node */

	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR _max_code$[ebp]
	jle	SHORT $LN19@gen_bitlen
	jmp	SHORT $LN5@gen_bitlen
$LN19@gen_bitlen:

; 518  : 
; 519  :         s->bl_count[bits]++;

	mov	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	cx, WORD PTR [eax+edx*2+2876]
	add	cx, 1
	mov	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+edx*2+2876], cx

; 520  :         xbits = 0;

	mov	DWORD PTR _xbits$[ebp], 0

; 521  :         if (n >= base) xbits = extra[n-base];

	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR _base$[ebp]
	jl	SHORT $LN20@gen_bitlen
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _extra$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _xbits$[ebp], ecx
$LN20@gen_bitlen:

; 522  :         f = tree[n].Freq;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	mov	cx, WORD PTR [eax+edx*4]
	mov	WORD PTR _f$[ebp], cx

; 523  :         s->opt_len += (ulg)f * (unsigned)(bits + xbits);

	movzx	edx, WORD PTR _f$[ebp]
	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, DWORD PTR _xbits$[ebp]
	imul	edx, eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR [ecx+5800]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5800], edx

; 524  :         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);

	cmp	DWORD PTR _stree$[ebp], 0
	je	SHORT $LN21@gen_bitlen
	movzx	ecx, WORD PTR _f$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _stree$[ebp]
	movzx	edx, WORD PTR [eax+edx*4+2]
	add	edx, DWORD PTR _xbits$[ebp]
	imul	ecx, edx
	mov	eax, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR [eax+5804]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5804], ecx
$LN21@gen_bitlen:

; 525  :     }

	jmp	$LN5@gen_bitlen
$LN6@gen_bitlen:

; 526  :     if (overflow == 0) return;

	cmp	DWORD PTR _overflow$[ebp], 0
	jne	SHORT $LN10@gen_bitlen
	jmp	$LN1@gen_bitlen
$LN10@gen_bitlen:

; 527  : 
; 528  :     Tracev((stderr,"\nbit length overflow\n"));
; 529  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 530  : 
; 531  :     /* Find the first bit length which could increase: */
; 532  :     do {
; 533  :         bits = max_length-1;

	mov	eax, DWORD PTR _max_length$[ebp]
	sub	eax, 1
	mov	DWORD PTR _bits$[ebp], eax
$LN11@gen_bitlen:

; 534  :         while (s->bl_count[bits] == 0) bits--;

	mov	ecx, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2+2876]
	test	eax, eax
	jne	SHORT $LN12@gen_bitlen
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _bits$[ebp], ecx
	jmp	SHORT $LN11@gen_bitlen
$LN12@gen_bitlen:

; 535  :         s->bl_count[bits]--;      /* move one leaf down the tree */

	mov	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	cx, WORD PTR [eax+edx*2+2876]
	sub	cx, 1
	mov	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+edx*2+2876], cx

; 536  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */

	mov	ecx, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2+2878]
	add	eax, 2
	mov	ecx, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+ecx*2+2878], ax

; 537  :         s->bl_count[max_length]--;

	mov	eax, DWORD PTR _max_length$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+2876]
	sub	dx, 1
	mov	eax, DWORD PTR _max_length$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+eax*2+2876], dx

; 538  :         /* The brother of the overflow item also moves one step up,
; 539  :          * but this does not affect bl_count[max_length]
; 540  :          */
; 541  :         overflow -= 2;

	mov	edx, DWORD PTR _overflow$[ebp]
	sub	edx, 2
	mov	DWORD PTR _overflow$[ebp], edx

; 542  :     } while (overflow > 0);

	cmp	DWORD PTR _overflow$[ebp], 0
	jg	$LN10@gen_bitlen

; 543  : 
; 544  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 545  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 546  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 547  :      * from 'ar' written by Haruhiko Okumura.)
; 548  :      */
; 549  :     for (bits = max_length; bits != 0; bits--) {

	mov	eax, DWORD PTR _max_length$[ebp]
	mov	DWORD PTR _bits$[ebp], eax
	jmp	SHORT $LN15@gen_bitlen
$LN13@gen_bitlen:
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _bits$[ebp], ecx
$LN15@gen_bitlen:
	cmp	DWORD PTR _bits$[ebp], 0
	je	$LN1@gen_bitlen

; 550  :         n = s->bl_count[bits];

	mov	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2+2876]
	mov	DWORD PTR _n$[ebp], ecx
$LN16@gen_bitlen:

; 551  :         while (n != 0) {

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN17@gen_bitlen

; 552  :             m = s->heap[--h];

	mov	edx, DWORD PTR _h$[ebp]
	sub	edx, 1
	mov	DWORD PTR _h$[ebp], edx
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2908]
	mov	DWORD PTR _m$[ebp], edx

; 553  :             if (m > max_code) continue;

	mov	eax, DWORD PTR _m$[ebp]
	cmp	eax, DWORD PTR _max_code$[ebp]
	jle	SHORT $LN23@gen_bitlen
	jmp	SHORT $LN16@gen_bitlen
$LN23@gen_bitlen:

; 554  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2]
	cmp	eax, DWORD PTR _bits$[ebp]
	je	SHORT $LN24@gen_bitlen

; 555  :                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 556  :                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4+2]
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, eax
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	movzx	edx, WORD PTR [eax+edx*4]
	imul	ecx, edx
	mov	eax, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR [eax+5800]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5800], ecx

; 557  :                 tree[m].Len = (ush)bits;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _tree$[ebp]
	mov	dx, WORD PTR _bits$[ebp]
	mov	WORD PTR [ecx+eax*4+2], dx
$LN24@gen_bitlen:

; 558  :             }
; 559  :             n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 560  :         }

	jmp	$LN16@gen_bitlen
$LN17@gen_bitlen:

; 561  :     }

	jmp	$LN13@gen_bitlen
$LN1@gen_bitlen:

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gen_bitlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_v$ = -8						; size = 4
_j$ = -4						; size = 4
_s$ = 8							; size = 4
_tree$ = 12						; size = 4
_k$ = 16						; size = 4
_pqdownheap PROC

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 456  :     int v = s->heap[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2908]
	mov	DWORD PTR _v$[ebp], edx

; 457  :     int j = k << 1;  /* left son of k */

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN2@pqdownheap:

; 458  :     while (j <= s->heap_len) {

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+5200]
	jg	$LN3@pqdownheap

; 459  :         /* Set j to the smallest of the two sons: */
; 460  :         if (j < s->heap_len &&

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+5200]
	jge	$LN4@pqdownheap
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2912]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2908]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*4]
	cmp	eax, ecx
	jl	SHORT $LN5@pqdownheap
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2912]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2908]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*4]
	cmp	eax, ecx
	jne	SHORT $LN4@pqdownheap
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2912]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+5208]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2908]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx+5208]
	cmp	eax, ecx
	jg	SHORT $LN4@pqdownheap
$LN5@pqdownheap:

; 461  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
; 462  :             j++;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN4@pqdownheap:

; 463  :         }
; 464  :         /* Exit if v is smaller than both sons */
; 465  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _tree$[ebp]
	movzx	edx, WORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+2908]
	mov	ecx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [ecx+eax*4]
	cmp	edx, eax
	jl	SHORT $LN7@pqdownheap
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	eax, WORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2908]
	mov	edx, DWORD PTR _tree$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*4]
	cmp	eax, ecx
	jne	SHORT $LN6@pqdownheap
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, DWORD PTR _v$[ebp]
	movzx	eax, BYTE PTR [edx+5208]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2908]
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx+5208]
	cmp	eax, ecx
	jg	SHORT $LN6@pqdownheap
$LN7@pqdownheap:
	jmp	SHORT $LN3@pqdownheap
$LN6@pqdownheap:

; 466  : 
; 467  :         /* Exchange v with the smallest son */
; 468  :         s->heap[k] = s->heap[j];  k = j;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+2908]
	mov	DWORD PTR [eax+edx*4+2908], ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _k$[ebp], edx

; 469  : 
; 470  :         /* And continue down the tree, setting j to the left son of k */
; 471  :         j <<= 1;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 472  :     }

	jmp	$LN2@pqdownheap
$LN3@pqdownheap:

; 473  :     s->heap[k] = v;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx*4+2908], eax

; 474  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_pqdownheap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_n$ = -4						; size = 4
_s$ = 8							; size = 4
_init_block PROC

; 409  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 410  :     int n; /* iterates over tree elements */
; 411  : 
; 412  :     /* Initialize the trees. */
; 413  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@init_block
$LN2@init_block:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN4@init_block:
	cmp	DWORD PTR _n$[ebp], 286			; 0000011eH
	jge	SHORT $LN3@init_block
	xor	ecx, ecx
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	WORD PTR [eax+edx*4+148], cx
	jmp	SHORT $LN2@init_block
$LN3@init_block:

; 414  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN7@init_block
$LN5@init_block:
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
$LN7@init_block:
	cmp	DWORD PTR _n$[ebp], 30			; 0000001eH
	jge	SHORT $LN6@init_block
	xor	edx, edx
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+eax*4+2440], dx
	jmp	SHORT $LN5@init_block
$LN6@init_block:

; 415  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN10@init_block
$LN8@init_block:
	mov	edx, DWORD PTR _n$[ebp]
	add	edx, 1
	mov	DWORD PTR _n$[ebp], edx
$LN10@init_block:
	cmp	DWORD PTR _n$[ebp], 19			; 00000013H
	jge	SHORT $LN9@init_block
	xor	eax, eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+ecx*4+2684], ax
	jmp	SHORT $LN8@init_block
$LN9@init_block:

; 416  : 
; 417  :     s->dyn_ltree[END_BLOCK].Freq = 1;

	mov	eax, 4
	shl	eax, 8
	mov	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+eax+148], cx

; 418  :     s->opt_len = s->static_len = 0L;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5804], 0
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5800], 0

; 419  :     s->last_lit = s->matches = 0;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5808], 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5792], 0

; 420  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_init_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_tr_static_init PROC

; 233  : {

	push	ebp
	mov	ebp, esp

; 234  : #if defined(GEN_TREES_H) || !defined(STDC)
; 235  :     static int static_init_done = 0;
; 236  :     int n;        /* iterates over tree elements */
; 237  :     int bits;     /* bit counter */
; 238  :     int length;   /* length value */
; 239  :     int code;     /* code value */
; 240  :     int dist;     /* distance index */
; 241  :     ush bl_count[MAX_BITS+1];
; 242  :     /* number of codes at each bit length for an optimal tree */
; 243  : 
; 244  :     if (static_init_done) return;
; 245  : 
; 246  :     /* For some embedded targets, global variables are not initialized: */
; 247  : #ifdef NO_INIT_GLOBAL_POINTERS
; 248  :     static_l_desc.static_tree = static_ltree;
; 249  :     static_l_desc.extra_bits = extra_lbits;
; 250  :     static_d_desc.static_tree = static_dtree;
; 251  :     static_d_desc.extra_bits = extra_dbits;
; 252  :     static_bl_desc.extra_bits = extra_blbits;
; 253  : #endif
; 254  : 
; 255  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 256  :     length = 0;
; 257  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 258  :         base_length[code] = length;
; 259  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 260  :             _length_code[length++] = (uch)code;
; 261  :         }
; 262  :     }
; 263  :     Assert (length == 256, "tr_static_init: length != 256");
; 264  :     /* Note that the length 255 (match length 258) can be represented
; 265  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 266  :      * overwrite length_code[255] to use the best encoding:
; 267  :      */
; 268  :     _length_code[length-1] = (uch)code;
; 269  : 
; 270  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 271  :     dist = 0;
; 272  :     for (code = 0 ; code < 16; code++) {
; 273  :         base_dist[code] = dist;
; 274  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 275  :             _dist_code[dist++] = (uch)code;
; 276  :         }
; 277  :     }
; 278  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 279  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 280  :     for ( ; code < D_CODES; code++) {
; 281  :         base_dist[code] = dist << 7;
; 282  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 283  :             _dist_code[256 + dist++] = (uch)code;
; 284  :         }
; 285  :     }
; 286  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 287  : 
; 288  :     /* Construct the codes of the static literal tree */
; 289  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 290  :     n = 0;
; 291  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 292  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 293  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 294  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 295  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 296  :      * tree construction to get a canonical Huffman tree (longest code
; 297  :      * all ones)
; 298  :      */
; 299  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 300  : 
; 301  :     /* The static distance tree is trivial: */
; 302  :     for (n = 0; n < D_CODES; n++) {
; 303  :         static_dtree[n].Len = 5;
; 304  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 305  :     }
; 306  :     static_init_done = 1;
; 307  : 
; 308  : #  ifdef GEN_TREES_H
; 309  :     gen_trees_header();
; 310  : #  endif
; 311  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 312  : }

	pop	ebp
	ret	0
_tr_static_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_val$1 = -8						; size = 4
_len$2 = -4						; size = 4
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_stored_len$ = 16					; size = 4
_last$ = 20						; size = 4
__tr_stored_block PROC

; 868  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 869  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

	mov	DWORD PTR _len$2[ebp], 3
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$2[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN2@tr_stored_
	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR _val$1[ebp], edx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$2[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN3@tr_stored_
$LN2@tr_stored_:
	movzx	edx, WORD PTR _last$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$2[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN3@tr_stored_:

; 870  :     bi_windup(s);        /* align on byte boundary */

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_bi_windup
	add	esp, 4

; 871  :     put_short(s, (ush)stored_len);

	movzx	eax, WORD PTR _stored_len$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _stored_len$[ebp]
	sar	edx, 8
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx

; 872  :     put_short(s, (ush)~stored_len);

	mov	ecx, DWORD PTR _stored_len$[ebp]
	not	ecx
	movzx	edx, cx
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR _stored_len$[ebp]
	not	ecx
	movzx	edx, cx
	sar	edx, 8
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+20], edx

; 873  :     zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);

	mov	ecx, DWORD PTR _stored_len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _s$[ebp]
	add	ecx, DWORD PTR [edx+20]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 874  :     s->pending += stored_len;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _stored_len$[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 875  : #ifdef ZLIB_DEBUG
; 876  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 877  :     s->compressed_len += (stored_len + 4) << 3;
; 878  :     s->bits_sent += 2*16;
; 879  :     s->bits_sent += stored_len<<3;
; 880  : #endif
; 881  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__tr_stored_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_val$1 = -16						; size = 4
_val$2 = -12						; size = 4
_len$3 = -8						; size = 4
_len$4 = -4						; size = 4
_s$ = 8							; size = 4
__tr_align PROC

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 899  :     send_bits(s, STATIC_TREES<<1, 3);

	mov	DWORD PTR _len$4[ebp], 3
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN2@tr_align
	mov	DWORD PTR _val$2[ebp], 2
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$4[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN3@tr_align
$LN2@tr_align:
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 2
	mov	ecx, DWORD PTR [ecx+5820]
	shl	edx, cl
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	or	ecx, edx
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	add	ecx, DWORD PTR _len$4[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], ecx
$LN3@tr_align:

; 900  :     send_code(s, END_BLOCK, static_ltree);

	mov	eax, 4
	shl	eax, 8
	movzx	ecx, WORD PTR _static_ltree[eax+2]
	mov	DWORD PTR _len$3[ebp], ecx
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$3[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN4@tr_align
	mov	ecx, 4
	shl	ecx, 8
	movzx	edx, WORD PTR _static_ltree[ecx]
	mov	DWORD PTR _val$1[ebp], edx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$3[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN5@tr_align
$LN4@tr_align:
	mov	ecx, 4
	shl	ecx, 8
	movzx	edx, WORD PTR _static_ltree[ecx]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$3[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN5@tr_align:

; 901  : #ifdef ZLIB_DEBUG
; 902  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 903  : #endif
; 904  :     bi_flush(s);

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_bi_flush
	add	esp, 4

; 905  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__tr_align ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
__tr_flush_bits PROC

; 888  : {

	push	ebp
	mov	ebp, esp

; 889  :     bi_flush(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_bi_flush
	add	esp, 4

; 890  : }

	pop	ebp
	ret	0
__tr_flush_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_max_blindex$ = -28					; size = 4
_val$1 = -24						; size = 4
_val$2 = -20						; size = 4
_len$3 = -16						; size = 4
_len$4 = -12						; size = 4
_opt_lenb$ = -8						; size = 4
_static_lenb$ = -4					; size = 4
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_stored_len$ = 16					; size = 4
_last$ = 20						; size = 4
__tr_flush_block PROC

; 916  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 917  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 918  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */

	mov	DWORD PTR _max_blindex$[ebp], 0

; 919  : 
; 920  :     /* Build the Huffman trees unless a stored block is forced */
; 921  :     if (s->level > 0) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jle	$LN2@tr_flush_b

; 922  : 
; 923  :         /* Check if the file is binary or text */
; 924  :         if (s->strm->data_type == Z_UNKNOWN)

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 2
	jne	SHORT $LN4@tr_flush_b

; 925  :             s->strm->data_type = detect_data_type(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_detect_data_type
	add	esp, 4
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+44], eax
$LN4@tr_flush_b:

; 926  : 
; 927  :         /* Construct the literal and distance trees */
; 928  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2840				; 00000b18H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_build_tree
	add	esp, 8

; 929  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 930  :                 s->static_len));
; 931  : 
; 932  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2852				; 00000b24H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_build_tree
	add	esp, 8

; 933  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 934  :                 s->static_len));
; 935  :         /* At this point, opt_len and static_len are the total bit lengths of
; 936  :          * the compressed block data, excluding the tree representations.
; 937  :          */
; 938  : 
; 939  :         /* Build the bit length tree for the above two trees, and get the index
; 940  :          * in bl_order of the last bit length code to send.
; 941  :          */
; 942  :         max_blindex = build_bl_tree(s);

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_build_bl_tree
	add	esp, 4
	mov	DWORD PTR _max_blindex$[ebp], eax

; 943  : 
; 944  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 945  :         opt_lenb = (s->opt_len+3+7)>>3;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5800]
	add	eax, 10					; 0000000aH
	shr	eax, 3
	mov	DWORD PTR _opt_lenb$[ebp], eax

; 946  :         static_lenb = (s->static_len+3+7)>>3;

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+5804]
	add	edx, 10					; 0000000aH
	shr	edx, 3
	mov	DWORD PTR _static_lenb$[ebp], edx

; 947  : 
; 948  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 949  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 950  :                 s->last_lit));
; 951  : 
; 952  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

	mov	eax, DWORD PTR _static_lenb$[ebp]
	cmp	eax, DWORD PTR _opt_lenb$[ebp]
	ja	SHORT $LN5@tr_flush_b
	mov	ecx, DWORD PTR _static_lenb$[ebp]
	mov	DWORD PTR _opt_lenb$[ebp], ecx
$LN5@tr_flush_b:

; 953  : 
; 954  :     } else {

	jmp	SHORT $LN3@tr_flush_b
$LN2@tr_flush_b:

; 955  :         Assert(buf != (char*)0, "lost buf");
; 956  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

	mov	edx, DWORD PTR _stored_len$[ebp]
	add	edx, 5
	mov	DWORD PTR _static_lenb$[ebp], edx
	mov	eax, DWORD PTR _static_lenb$[ebp]
	mov	DWORD PTR _opt_lenb$[ebp], eax
$LN3@tr_flush_b:

; 957  :     }
; 958  : 
; 959  : #ifdef FORCE_STORED
; 960  :     if (buf != (char*)0) { /* force stored block */
; 961  : #else
; 962  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

	mov	ecx, DWORD PTR _stored_len$[ebp]
	add	ecx, 4
	cmp	ecx, DWORD PTR _opt_lenb$[ebp]
	ja	SHORT $LN6@tr_flush_b
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN6@tr_flush_b

; 963  :                        /* 4: two words for the lengths */
; 964  : #endif
; 965  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 966  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 967  :          * the last block flush, because compression would have been
; 968  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 969  :          * transform a block into a stored block.
; 970  :          */
; 971  :         _tr_stored_block(s, buf, stored_len, last);

	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	mov	eax, DWORD PTR _stored_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	__tr_stored_block
	add	esp, 16					; 00000010H
	jmp	$LN7@tr_flush_b
$LN6@tr_flush_b:

; 972  : 
; 973  : #ifdef FORCE_STATIC
; 974  :     } else if (static_lenb >= 0) { /* force static trees */
; 975  : #else
; 976  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+136], 4
	je	SHORT $LN10@tr_flush_b
	mov	ecx, DWORD PTR _static_lenb$[ebp]
	cmp	ecx, DWORD PTR _opt_lenb$[ebp]
	jne	$LN8@tr_flush_b
$LN10@tr_flush_b:

; 977  : #endif
; 978  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

	mov	DWORD PTR _len$4[ebp], 3
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR _len$4[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+5820], edx
	jle	$LN11@tr_flush_b
	mov	ecx, DWORD PTR _last$[ebp]
	add	ecx, 2
	mov	DWORD PTR _val$2[ebp], ecx
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [edx+5816]
	sar	eax, 8
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+edx], al
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+20], eax
	movzx	edx, WORD PTR _val$2[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR [eax+5820]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], dx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$4[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN12@tr_flush_b
$LN11@tr_flush_b:
	mov	ecx, DWORD PTR _last$[ebp]
	add	ecx, 2
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$4[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN12@tr_flush_b:

; 979  :         compress_block(s, (const ct_data *)static_ltree,

	push	OFFSET _static_dtree
	push	OFFSET _static_ltree
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_compress_block
	add	esp, 12					; 0000000cH

; 980  :                        (const ct_data *)static_dtree);
; 981  : #ifdef ZLIB_DEBUG
; 982  :         s->compressed_len += 3 + s->static_len;
; 983  : #endif
; 984  :     } else {

	jmp	$LN7@tr_flush_b
$LN8@tr_flush_b:

; 985  :         send_bits(s, (DYN_TREES<<1)+last, 3);

	mov	DWORD PTR _len$3[ebp], 3
	mov	eax, 16					; 00000010H
	sub	eax, DWORD PTR _len$3[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5820], eax
	jle	$LN13@tr_flush_b
	mov	edx, DWORD PTR _last$[ebp]
	add	edx, 4
	mov	DWORD PTR _val$1[ebp], edx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [ecx+5820]
	shl	eax, cl
	mov	edx, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [edx+5816]
	or	ecx, eax
	mov	edx, DWORD PTR _s$[ebp]
	mov	WORD PTR [edx+5816], cx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax+5816]
	sar	ecx, 8
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	BYTE PTR [edx+eax], cl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+20], ecx
	movzx	eax, WORD PTR _val$1[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, 16					; 00000010H
	sub	edx, DWORD PTR [ecx+5820]
	mov	ecx, edx
	sar	eax, cl
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	mov	ecx, DWORD PTR _len$3[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+5820], edx
	jmp	SHORT $LN14@tr_flush_b
$LN13@tr_flush_b:
	mov	ecx, DWORD PTR _last$[ebp]
	add	ecx, 4
	movzx	edx, cx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5820]
	shl	edx, cl
	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, WORD PTR [ecx+5816]
	or	eax, edx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5820]
	add	eax, DWORD PTR _len$3[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5820], eax
$LN14@tr_flush_b:

; 986  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,

	mov	edx, DWORD PTR _max_blindex$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+2856]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+2844]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_send_all_trees
	add	esp, 16					; 00000010H

; 987  :                        max_blindex+1);
; 988  :         compress_block(s, (const ct_data *)s->dyn_ltree,

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 2440				; 00000988H
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_compress_block
	add	esp, 12					; 0000000cH
$LN7@tr_flush_b:

; 989  :                        (const ct_data *)s->dyn_dtree);
; 990  : #ifdef ZLIB_DEBUG
; 991  :         s->compressed_len += 3 + s->opt_len;
; 992  : #endif
; 993  :     }
; 994  :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 995  :     /* The above check is made mod 2^32, for files larger than 512 MB
; 996  :      * and uLong implemented on 32 bits.
; 997  :      */
; 998  :     init_block(s);

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_init_block
	add	esp, 4

; 999  : 
; 1000 :     if (last) {

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN1@tr_flush_b

; 1001 :         bi_windup(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_bi_windup
	add	esp, 4
$LN1@tr_flush_b:

; 1002 : #ifdef ZLIB_DEBUG
; 1003 :         s->compressed_len += 7;  /* align on byte boundary */
; 1004 : #endif
; 1005 :     }
; 1006 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1007 :            s->compressed_len-7*last));
; 1008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__tr_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
tv181 = -8						; size = 4
tv164 = -4						; size = 4
_s$ = 8							; size = 4
_dist$ = 12						; size = 4
_lc$ = 16						; size = 4
__tr_tally PROC

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1019 :     s->d_buf[s->last_lit] = (ush)dist;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5792]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5796]
	mov	dx, WORD PTR _dist$[ebp]
	mov	WORD PTR [eax+ecx*2], dx

; 1020 :     s->l_buf[s->last_lit++] = (uch)lc;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5792]
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5784]
	mov	dl, BYTE PTR _lc$[ebp]
	mov	BYTE PTR [eax+ecx], dl
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+5792]
	add	ecx, 1
	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5792], ecx

; 1021 :     if (dist == 0) {

	cmp	DWORD PTR _dist$[ebp], 0
	jne	SHORT $LN2@tr_tally

; 1022 :         /* lc is the unmatched char */
; 1023 :         s->dyn_ltree[lc].Freq++;

	mov	eax, DWORD PTR _lc$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+eax*4+148]
	add	dx, 1
	mov	eax, DWORD PTR _lc$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+eax*4+148], dx

; 1024 :     } else {

	jmp	$LN3@tr_tally
$LN2@tr_tally:

; 1025 :         s->matches++;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5808]
	add	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+5808], eax

; 1026 :         /* Here, lc is the match length - MIN_MATCH */
; 1027 :         dist--;             /* dist = match distance - 1 */

	mov	edx, DWORD PTR _dist$[ebp]
	sub	edx, 1
	mov	DWORD PTR _dist$[ebp], edx

; 1028 :         Assert((ush)dist < (ush)MAX_DIST(s) &&
; 1029 :                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
; 1030 :                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
; 1031 : 
; 1032 :         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;

	mov	eax, DWORD PTR _lc$[ebp]
	movzx	ecx, BYTE PTR __length_code[eax]
	mov	edx, DWORD PTR _s$[ebp]
	mov	ax, WORD PTR [edx+ecx*4+1176]
	add	ax, 1
	mov	ecx, DWORD PTR _lc$[ebp]
	movzx	edx, BYTE PTR __length_code[ecx]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+edx*4+1176], ax

; 1033 :         s->dyn_dtree[d_code(dist)].Freq++;

	cmp	DWORD PTR _dist$[ebp], 256		; 00000100H
	jae	SHORT $LN5@tr_tally
	mov	edx, DWORD PTR _dist$[ebp]
	movzx	eax, BYTE PTR __dist_code[edx]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN6@tr_tally
$LN5@tr_tally:
	mov	ecx, DWORD PTR _dist$[ebp]
	shr	ecx, 7
	movzx	edx, BYTE PTR __dist_code[ecx+256]
	mov	DWORD PTR tv164[ebp], edx
$LN6@tr_tally:
	mov	eax, DWORD PTR tv164[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+eax*4+2440]
	add	dx, 1
	mov	eax, DWORD PTR tv164[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+eax*4+2440], dx
$LN3@tr_tally:

; 1034 :     }
; 1035 : 
; 1036 : #ifdef TRUNCATE_BLOCK
; 1037 :     /* Try to guess if it is profitable to stop the current block here */
; 1038 :     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
; 1039 :         /* Compute an upper bound for the compressed length */
; 1040 :         ulg out_length = (ulg)s->last_lit*8L;
; 1041 :         ulg in_length = (ulg)((long)s->strstart - s->block_start);
; 1042 :         int dcode;
; 1043 :         for (dcode = 0; dcode < D_CODES; dcode++) {
; 1044 :             out_length += (ulg)s->dyn_dtree[dcode].Freq *
; 1045 :                 (5L+extra_dbits[dcode]);
; 1046 :         }
; 1047 :         out_length >>= 3;
; 1048 :         Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
; 1049 :                s->last_lit, in_length, out_length,
; 1050 :                100L - out_length*100L/in_length));
; 1051 :         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
; 1052 :     }
; 1053 : #endif
; 1054 :     return (s->last_lit == s->lit_bufsize-1);

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+5788]
	sub	eax, 1
	mov	ecx, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [ecx+5792], eax
	jne	SHORT $LN7@tr_tally
	mov	DWORD PTR tv181[ebp], 1
	jmp	SHORT $LN8@tr_tally
$LN7@tr_tally:
	mov	DWORD PTR tv181[ebp], 0
$LN8@tr_tally:
	mov	eax, DWORD PTR tv181[ebp]

; 1055 :     /* We avoid equality with lit_bufsize because of wraparound at 64K
; 1056 :      * on 16 bit machines and because stored blocks are restricted to
; 1057 :      * 64K-1 bytes.
; 1058 :      */
; 1059 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__tr_tally ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\cpython\externals\zlib-1.2.11\trees.c
_TEXT	SEGMENT
_s$ = 8							; size = 4
__tr_init PROC

; 381  : {

	push	ebp
	mov	ebp, esp

; 382  :     tr_static_init();

	call	_tr_static_init

; 383  : 
; 384  :     s->l_desc.dyn_tree = s->dyn_ltree;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 148				; 00000094H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+2840], eax

; 385  :     s->l_desc.stat_desc = &static_l_desc;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+2848], OFFSET _static_l_desc

; 386  : 
; 387  :     s->d_desc.dyn_tree = s->dyn_dtree;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2440				; 00000988H
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+2852], eax

; 388  :     s->d_desc.stat_desc = &static_d_desc;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+2860], OFFSET _static_d_desc

; 389  : 
; 390  :     s->bl_desc.dyn_tree = s->bl_tree;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 2684				; 00000a7cH
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [ecx+2864], eax

; 391  :     s->bl_desc.stat_desc = &static_bl_desc;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+2872], OFFSET _static_bl_desc

; 392  : 
; 393  :     s->bi_buf = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx+5816], ax

; 394  :     s->bi_valid = 0;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+5820], 0

; 395  : #ifdef ZLIB_DEBUG
; 396  :     s->compressed_len = 0L;
; 397  :     s->bits_sent = 0L;
; 398  : #endif
; 399  : 
; 400  :     /* Initialize the first block of the first file: */
; 401  :     init_block(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_init_block
	add	esp, 4

; 402  : }

	pop	ebp
	ret	0
__tr_init ENDP
_TEXT	ENDS
END
