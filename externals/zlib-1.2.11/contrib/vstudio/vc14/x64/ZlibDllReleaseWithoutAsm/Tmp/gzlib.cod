; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@		; `string'
EXTRN	__imp_malloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_wcstombs:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__wopen:PROC
EXTRN	__imp__lseeki64:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
PUBLIC	gz_error
PUBLIC	gzclearerr
PUBLIC	gzerror
PUBLIC	gzeof
PUBLIC	gzoffset
PUBLIC	gzoffset64
PUBLIC	gztell
PUBLIC	gztell64
PUBLIC	gzseek
PUBLIC	gzseek64
PUBLIC	gzrewind
PUBLIC	gzbuffer
PUBLIC	gzopen_w
PUBLIC	gzdopen
PUBLIC	gzopen
PUBLIC	snprintf
PUBLIC	vsnprintf
PUBLIC	__local_stdio_printf_options
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN15
	DD	imagerel $LN15+253
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$gzoffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN9
	DD	imagerel $LN9+92
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$gztell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$gzseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN25
	DD	imagerel $LN25+94
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzseek64 DD imagerel $LN25+94
	DD	imagerel $LN25+206
	DD	imagerel $chain$0$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzseek64 DD imagerel $LN25+206
	DD	imagerel $LN25+258
	DD	imagerel $chain$2$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gzseek64 DD imagerel $LN25+258
	DD	imagerel $LN25+333
	DD	imagerel $chain$4$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN8
	DD	imagerel $LN8+82
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN6
	DD	imagerel $LN6+129
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_open DD imagerel gz_open+52
	DD	imagerel gz_open+75
	DD	imagerel $chain$0$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_open DD imagerel gz_open+75
	DD	imagerel gz_open+638
	DD	imagerel $chain$1$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_open DD imagerel gz_open+638
	DD	imagerel gz_open+643
	DD	imagerel $chain$2$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_open DD imagerel gz_open+643
	DD	imagerel gz_open+786
	DD	imagerel $chain$3$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+67
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$snprintf DD imagerel $LN6
	DD	imagerel $LN6+90
	DD	imagerel $unwind$snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsnprintf DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$vsnprintf
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsnprintf DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$snprintf DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_open DD 021H
	DD	imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_open DD 021H
	DD	imagerel gz_open+52
	DD	imagerel gz_open+75
	DD	imagerel $chain$0$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_open DD 020521H
	DD	097405H
	DD	imagerel gz_open+52
	DD	imagerel gz_open+75
	DD	imagerel $chain$0$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_open DD 020521H
	DD	083405H
	DD	imagerel gz_open
	DD	imagerel gz_open+52
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 081401H
	DD	0b6414H
	DD	0a5414H
	DD	0f0103214H
	DD	0c00ce00eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN25
	DD	imagerel $LN25+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN25
	DD	imagerel $LN25+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzseek64 DD 020521H
	DD	066405H
	DD	imagerel $LN25
	DD	imagerel $LN25+94
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
vsnprintf PROC						; COMDAT

; 1435 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b d9	 mov	 rbx, r9
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 1436 :     int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0002a	4c 8b cf	 mov	 r9, rdi
  0002d	4c 8b c6	 mov	 r8, rsi
  00030	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00039	48 8b d5	 mov	 rdx, rbp
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	48 83 c9 02	 or	 rcx, 2
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;
; 1441 : }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	83 c9 ff	 or	 ecx, -1
  00051	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00056	85 c0		 test	 eax, eax
  00058	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0005d	0f 48 c1	 cmovs	 eax, ecx
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT snprintf
_TEXT	SEGMENT
_Buffer$ = 96
_BufferCount$ = 104
_Format$ = 112
snprintf PROC						; COMDAT

; 1940 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	49 8b f0	 mov	 rsi, r8

; 1941 :     int _Result;
; 1942 :     va_list _ArgList;
; 1943 :     __crt_va_start(_ArgList, _Format);

  00015	48 8d 6c 24 78	 lea	 rbp, QWORD PTR _Format$[rsp+8]
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f9	 mov	 rdi, rcx

; 1436 :     int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  0002a	4c 8b ce	 mov	 r9, rsi
  0002d	4c 8b c3	 mov	 r8, rbx
  00030	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00039	48 8b d7	 mov	 rdx, rdi
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	48 83 c9 02	 or	 rcx, 2
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1437 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1438 :         _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1439 : 
; 1440 :     return _Result < 0 ? -1 : _Result;

  00049	83 c9 ff	 or	 ecx, -1
  0004c	85 c0		 test	 eax, eax
  0004e	0f 48 c1	 cmovs	 eax, ecx

; 1944 : #pragma warning(suppress:28719)    // __WARNING_BANNED_API_USAGE
; 1945 :     _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1946 :     __crt_va_end(_ArgList);
; 1947 :     return _Result;
; 1948 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	5f		 pop	 rdi
  00056	5e		 pop	 rsi
  00057	5d		 pop	 rbp
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 77   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 78   :     state->x.have = 0;              /* no output data available */

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000f	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00016	89 39		 mov	 DWORD PTR [rcx], edi
  00018	75 07		 jne	 SHORT $LN2@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  0001a	48 89 79 50	 mov	 QWORD PTR [rcx+80], rdi

; 81   :         state->past = 0;            /* have not read past end yet */
; 82   :         state->how = LOOK;          /* look for gzip header */

  0001e	89 79 44	 mov	 DWORD PTR [rcx+68], edi
$LN2@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */
; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00021	45 33 c0	 xor	 r8d, r8d
  00024	89 79 68	 mov	 DWORD PTR [rcx+104], edi
  00027	33 d2		 xor	 edx, edx
  00029	e8 00 00 00 00	 call	 gz_error

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  0002e	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  00032	89 bb 80 00 00
	00		 mov	 DWORD PTR [rbx+128], edi

; 88   : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_open
_TEXT	SEGMENT
path$ = 64
fd$ = 72
mode$ = 80
gz_open	PROC						; COMDAT

; 95   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 96   :     gz_statep state;
; 97   :     z_size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00014	45 33 e4	 xor	 r12d, r12d
  00017	49 8b f0	 mov	 rsi, r8
  0001a	44 8b f2	 mov	 r14d, edx
  0001d	48 8b e9	 mov	 rbp, rcx
  00020	45 8b fc	 mov	 r15d, r12d

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  00023	48 85 c9	 test	 rcx, rcx
  00026	75 07		 jne	 SHORT $LN6@gz_open

; 108  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 54 02 00 00	 jmp	 $LN1@gz_open
$LN6@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = (gz_statep)malloc(sizeof(gz_state));

  0002f	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  00034	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 8b d8	 mov	 rbx, rax

; 112  :     if (state == NULL)

  00042	48 85 c0	 test	 rax, rax
  00045	0f 84 33 02 00
	00		 je	 $LN54@gz_open
$LN7@gz_open:
  0004b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 113  :         return NULL;
; 114  :     state->size = 0;            /* no buffers allocated yet */
; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 116  :     state->msg = NULL;          /* no error message yet */
; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;
; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  00050	48 83 cf ff	 or	 rdi, -1
  00054	89 78 58	 mov	 DWORD PTR [rax+88], edi
  00057	44 89 60 28	 mov	 DWORD PTR [rax+40], r12d
  0005b	c7 40 2c 00 20
	00 00		 mov	 DWORD PTR [rax+44], 8192 ; 00002000H
  00062	4c 89 60 70	 mov	 QWORD PTR [rax+112], r12
  00066	44 89 60 18	 mov	 DWORD PTR [rax+24], r12d

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  0006a	44 89 60 5c	 mov	 DWORD PTR [rax+92], r12d

; 122  :     state->direct = 0;

  0006e	44 89 60 40	 mov	 DWORD PTR [rax+64], r12d

; 123  :     while (*mode) {

  00072	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  00075	84 c9		 test	 cl, cl
  00077	0f 84 94 00 00
	00		 je	 $LN49@gz_open
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LL2@gz_open:
  00084	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00087	3c 09		 cmp	 al, 9

; 124  :         if (*mode >= '0' && *mode <= '9')
; 125  :             state->level = *mode - '0';

  00089	0f be c1	 movsx	 eax, cl
  0008c	77 08		 ja	 SHORT $LN8@gz_open
  0008e	83 e8 30	 sub	 eax, 48			; 00000030H
  00091	89 43 58	 mov	 DWORD PTR [rbx+88], eax
  00094	eb 6c		 jmp	 SHORT $LN21@gz_open
$LN8@gz_open:

; 126  :         else
; 127  :             switch (*mode) {

  00096	83 c0 d5	 add	 eax, -43		; ffffffffffffffd5H
  00099	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0009c	77 64		 ja	 SHORT $LN21@gz_open
  0009e	48 98		 cdqe
  000a0	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN51@gz_open[rdx+rax]
  000a8	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN52@gz_open[rdx+rax*4]
  000af	48 03 ca	 add	 rcx, rdx
  000b2	ff e1		 jmp	 rcx
$LN10@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000b4	c7 43 18 4f 1c
	00 00		 mov	 DWORD PTR [rbx+24], 7247 ; 00001c4fH

; 130  :                 break;

  000bb	eb 45		 jmp	 SHORT $LN21@gz_open
$LN11@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  000bd	c7 43 18 b1 79
	00 00		 mov	 DWORD PTR [rbx+24], 31153 ; 000079b1H

; 134  :                 break;

  000c4	eb 3c		 jmp	 SHORT $LN21@gz_open
$LN12@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000c6	c7 43 18 01 00
	00 00		 mov	 DWORD PTR [rbx+24], 1

; 137  :                 break;

  000cd	eb 33		 jmp	 SHORT $LN21@gz_open
$LN15@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);
; 141  :                 return NULL;
; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;
; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  000cf	41 bf 01 00 00
	00		 mov	 r15d, 1

; 152  :                 break;

  000d5	eb 2b		 jmp	 SHORT $LN21@gz_open
$LN16@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  000d7	c7 43 5c 01 00
	00 00		 mov	 DWORD PTR [rbx+92], 1

; 156  :                 break;

  000de	eb 22		 jmp	 SHORT $LN21@gz_open
$LN17@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  000e0	c7 43 5c 02 00
	00 00		 mov	 DWORD PTR [rbx+92], 2

; 159  :                 break;

  000e7	eb 19		 jmp	 SHORT $LN21@gz_open
$LN18@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  000e9	c7 43 5c 03 00
	00 00		 mov	 DWORD PTR [rbx+92], 3

; 162  :                 break;

  000f0	eb 10		 jmp	 SHORT $LN21@gz_open
$LN19@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  000f2	c7 43 5c 04 00
	00 00		 mov	 DWORD PTR [rbx+92], 4

; 165  :                 break;

  000f9	eb 07		 jmp	 SHORT $LN21@gz_open
$LN20@gz_open:

; 166  :             case 'T':
; 167  :                 state->direct = 1;

  000fb	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN21@gz_open:

; 123  :     while (*mode) {

  00102	0f b6 4e 01	 movzx	 ecx, BYTE PTR [rsi+1]

; 168  :                 break;
; 169  :             default:        /* could consider as an error, but just ignore */
; 170  :                 ;
; 171  :             }
; 172  :         mode++;

  00106	48 ff c6	 inc	 rsi
  00109	84 c9		 test	 cl, cl
  0010b	0f 85 73 ff ff
	ff		 jne	 $LL2@gz_open
$LN49@gz_open:

; 173  :     }
; 174  : 
; 175  :     /* must provide an "r", "w", or "a" */
; 176  :     if (state->mode == GZ_NONE) {

  00111	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00114	85 c0		 test	 eax, eax
  00116	0f 84 03 01 00
	00		 je	 $LN57@gz_open

; 177  :         free(state);
; 178  :         return NULL;
; 179  :     }
; 180  : 
; 181  :     /* can't force transparent read */
; 182  :     if (state->mode == GZ_READ) {

  0011c	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00121	75 11		 jne	 SHORT $LN23@gz_open

; 183  :         if (state->direct) {

  00123	44 39 63 40	 cmp	 DWORD PTR [rbx+64], r12d
  00127	0f 85 f2 00 00
	00		 jne	 $LN57@gz_open

; 184  :             free(state);
; 185  :             return NULL;
; 186  :         }
; 187  :         state->direct = 1;      /* for empty file */

  0012d	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN23@gz_open:

; 188  :     }
; 189  : 
; 190  :     /* save the path name for error messages */
; 191  : #ifdef WIDECHAR
; 192  :     if (fd == -2) {

  00134	41 83 fe fe	 cmp	 r14d, -2
  00138	75 1c		 jne	 SHORT $LL25@gz_open

; 193  :         len = wcstombs(NULL, path, 0);

  0013a	45 33 c0	 xor	 r8d, r8d
  0013d	48 8b d5	 mov	 rdx, rbp
  00140	33 c9		 xor	 ecx, ecx
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00148	48 8b f8	 mov	 rdi, rax

; 194  :         if (len == (z_size_t)-1)

  0014b	48 83 f8 ff	 cmp	 rax, -1
  0014f	75 0e		 jne	 SHORT $LN26@gz_open

; 195  :             len = 0;

  00151	49 8b fc	 mov	 rdi, r12

; 196  :     }

  00154	eb 09		 jmp	 SHORT $LN26@gz_open
$LL25@gz_open:

; 197  :     else
; 198  : #endif
; 199  :         len = strlen((const char *)path);

  00156	48 ff c7	 inc	 rdi
  00159	44 38 24 2f	 cmp	 BYTE PTR [rdi+rbp], r12b
  0015d	75 f7		 jne	 SHORT $LL25@gz_open
$LN26@gz_open:

; 200  :     state->path = (char *)malloc(len + 1);

  0015f	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00169	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 201  :     if (state->path == NULL) {

  0016d	48 85 c0	 test	 rax, rax
  00170	0f 84 a9 00 00
	00		 je	 $LN57@gz_open

; 202  :         free(state);
; 203  :         return NULL;
; 204  :     }
; 205  : #ifdef WIDECHAR
; 206  :     if (fd == -2)

  00176	41 83 fe fe	 cmp	 r14d, -2
  0017a	75 1c		 jne	 SHORT $LN29@gz_open

; 207  :         if (len)

  0017c	48 85 ff	 test	 rdi, rdi
  0017f	74 12		 je	 SHORT $LN31@gz_open

; 208  :             wcstombs(state->path, path, len + 1);

  00181	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  00185	48 8b d5	 mov	 rdx, rbp
  00188	48 8b c8	 mov	 rcx, rax
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00191	eb 1b		 jmp	 SHORT $LN30@gz_open
$LN31@gz_open:

; 209  :         else
; 210  :             *(state->path) = 0;

  00193	44 88 20	 mov	 BYTE PTR [rax], r12b
  00196	eb 16		 jmp	 SHORT $LN30@gz_open
$LN29@gz_open:

; 211  :     else
; 212  : #endif
; 213  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 214  :         (void)snprintf(state->path, len + 1, "%s", (const char *)path);

  00198	4c 8b cd	 mov	 r9, rbp
  0019b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  001a2	48 8d 57 01	 lea	 rdx, QWORD PTR [rdi+1]
  001a6	48 8b c8	 mov	 rcx, rax
  001a9	e8 00 00 00 00	 call	 snprintf
$LN30@gz_open:

; 215  : #else
; 216  :         strcpy(state->path, path);
; 217  : #endif
; 218  : 
; 219  :     /* compute the flags for open() */
; 220  :     oflag =

  001ae	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001b1	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  001b6	75 05		 jne	 SHORT $LN38@gz_open
  001b8	41 8b d4	 mov	 edx, r12d
  001bb	eb 24		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  001bd	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  001c2	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001c7	ba 08 00 00 00	 mov	 edx, 8
  001cc	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  001d1	0f 44 d1	 cmove	 edx, ecx
  001d4	45 85 ff	 test	 r15d, r15d
  001d7	b9 01 05 00 00	 mov	 ecx, 1281		; 00000501H
  001dc	0f 45 c1	 cmovne	 eax, ecx
  001df	0b d0		 or	 edx, eax
$LN39@gz_open:
  001e1	0f ba ea 0f	 bts	 edx, 15

; 221  : #ifdef O_LARGEFILE
; 222  :         O_LARGEFILE |
; 223  : #endif
; 224  : #ifdef O_BINARY
; 225  :         O_BINARY |
; 226  : #endif
; 227  : #ifdef O_CLOEXEC
; 228  :         (cloexec ? O_CLOEXEC : 0) |
; 229  : #endif
; 230  :         (state->mode == GZ_READ ?
; 231  :          O_RDONLY :
; 232  :          (O_WRONLY | O_CREAT |
; 233  : #ifdef O_EXCL
; 234  :           (exclusive ? O_EXCL : 0) |
; 235  : #endif
; 236  :           (state->mode == GZ_WRITE ?
; 237  :            O_TRUNC :
; 238  :            O_APPEND)));
; 239  : 
; 240  :     /* open the file with the appropriate flags (or just use fd) */
; 241  :     state->fd = fd > -1 ? fd : (

  001e5	41 83 fe ff	 cmp	 r14d, -1
  001e9	7f 20		 jg	 SHORT $LN41@gz_open
  001eb	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  001f1	48 8b cd	 mov	 rcx, rbp
  001f4	41 83 fe fe	 cmp	 r14d, -2
  001f8	75 08		 jne	 SHORT $LN40@gz_open
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
  00200	eb 06		 jmp	 SHORT $LN56@gz_open
$LN40@gz_open:
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open
$LN56@gz_open:
  00208	44 8b f0	 mov	 r14d, eax
$LN41@gz_open:
  0020b	44 89 73 1c	 mov	 DWORD PTR [rbx+28], r14d

; 242  : #ifdef WIDECHAR
; 243  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 244  : #endif
; 245  :         open((const char *)path, oflag, 0666));
; 246  :     if (state->fd == -1) {

  0020f	41 83 fe ff	 cmp	 r14d, -1
  00213	75 17		 jne	 SHORT $LN33@gz_open

; 247  :         free(state->path);

  00215	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN57@gz_open:

; 248  :         free(state);

  0021f	48 8b cb	 mov	 rcx, rbx
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 249  :         return NULL;

  00228	33 c0		 xor	 eax, eax
  0022a	eb 4d		 jmp	 SHORT $LN55@gz_open
$LN33@gz_open:

; 250  :     }
; 251  :     if (state->mode == GZ_APPEND) {

  0022c	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00230	75 16		 jne	 SHORT $LN34@gz_open

; 252  :         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */

  00232	33 d2		 xor	 edx, edx
  00234	41 8b ce	 mov	 ecx, r14d
  00237	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 253  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00241	c7 43 18 b1 79
	00 00		 mov	 DWORD PTR [rbx+24], 31153 ; 000079b1H
$LN34@gz_open:

; 254  :     }
; 255  : 
; 256  :     /* save the current position for rewinding (only if reading) */
; 257  :     if (state->mode == GZ_READ) {

  00248	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  0024f	75 1d		 jne	 SHORT $LN36@gz_open

; 258  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00251	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00254	33 d2		 xor	 edx, edx
  00256	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00260	48 89 43 48	 mov	 QWORD PTR [rbx+72], rax

; 259  :         if (state->start == -1) state->start = 0;

  00264	48 83 f8 ff	 cmp	 rax, -1
  00268	75 04		 jne	 SHORT $LN36@gz_open
  0026a	4c 89 63 48	 mov	 QWORD PTR [rbx+72], r12
$LN36@gz_open:

; 260  :     }
; 261  : 
; 262  :     /* initialize stream */
; 263  :     gz_reset(state);

  0026e	48 8b cb	 mov	 rcx, rbx
  00271	e8 00 00 00 00	 call	 gz_reset

; 264  : 
; 265  :     /* return stream */
; 266  :     return (gzFile)state;

  00276	48 8b c3	 mov	 rax, rbx
$LN55@gz_open:
  00279	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$LN54@gz_open:
  0027e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN1@gz_open:

; 267  : }

  00283	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00288	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0028d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00291	41 5f		 pop	 r15
  00293	41 5e		 pop	 r14
  00295	41 5c		 pop	 r12
  00297	c3		 ret	 0
$LN52@gz_open:
  00298	00 00 00 00	 DD	 $LN57@gz_open
  0029c	00 00 00 00	 DD	 $LN19@gz_open
  002a0	00 00 00 00	 DD	 $LN18@gz_open
  002a4	00 00 00 00	 DD	 $LN20@gz_open
  002a8	00 00 00 00	 DD	 $LN12@gz_open
  002ac	00 00 00 00	 DD	 $LN16@gz_open
  002b0	00 00 00 00	 DD	 $LN17@gz_open
  002b4	00 00 00 00	 DD	 $LN10@gz_open
  002b8	00 00 00 00	 DD	 $LN11@gz_open
  002bc	00 00 00 00	 DD	 $LN15@gz_open
  002c0	00 00 00 00	 DD	 $LN21@gz_open
$LN51@gz_open:
  002c4	00		 DB	 0
  002c5	0a		 DB	 10
  002c6	0a		 DB	 10
  002c7	0a		 DB	 10
  002c8	0a		 DB	 10
  002c9	0a		 DB	 10
  002ca	0a		 DB	 10
  002cb	0a		 DB	 10
  002cc	0a		 DB	 10
  002cd	0a		 DB	 10
  002ce	0a		 DB	 10
  002cf	0a		 DB	 10
  002d0	0a		 DB	 10
  002d1	0a		 DB	 10
  002d2	0a		 DB	 10
  002d3	0a		 DB	 10
  002d4	0a		 DB	 10
  002d5	0a		 DB	 10
  002d6	0a		 DB	 10
  002d7	0a		 DB	 10
  002d8	0a		 DB	 10
  002d9	0a		 DB	 10
  002da	0a		 DB	 10
  002db	0a		 DB	 10
  002dc	0a		 DB	 10
  002dd	0a		 DB	 10
  002de	0a		 DB	 10
  002df	01		 DB	 1
  002e0	0a		 DB	 10
  002e1	0a		 DB	 10
  002e2	0a		 DB	 10
  002e3	0a		 DB	 10
  002e4	0a		 DB	 10
  002e5	0a		 DB	 10
  002e6	0a		 DB	 10
  002e7	0a		 DB	 10
  002e8	0a		 DB	 10
  002e9	0a		 DB	 10
  002ea	0a		 DB	 10
  002eb	02		 DB	 2
  002ec	0a		 DB	 10
  002ed	03		 DB	 3
  002ee	0a		 DB	 10
  002ef	0a		 DB	 10
  002f0	0a		 DB	 10
  002f1	0a		 DB	 10
  002f2	0a		 DB	 10
  002f3	0a		 DB	 10
  002f4	0a		 DB	 10
  002f5	0a		 DB	 10
  002f6	0a		 DB	 10
  002f7	0a		 DB	 10
  002f8	0a		 DB	 10
  002f9	0a		 DB	 10
  002fa	04		 DB	 4
  002fb	0a		 DB	 10
  002fc	0a		 DB	 10
  002fd	0a		 DB	 10
  002fe	0a		 DB	 10
  002ff	05		 DB	 5
  00300	0a		 DB	 10
  00301	06		 DB	 6
  00302	0a		 DB	 10
  00303	0a		 DB	 10
  00304	0a		 DB	 10
  00305	0a		 DB	 10
  00306	0a		 DB	 10
  00307	0a		 DB	 10
  00308	0a		 DB	 10
  00309	0a		 DB	 10
  0030a	0a		 DB	 10
  0030b	07		 DB	 7
  0030c	0a		 DB	 10
  0030d	0a		 DB	 10
  0030e	0a		 DB	 10
  0030f	0a		 DB	 10
  00310	08		 DB	 8
  00311	09		 DB	 9
gz_open	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen	PROC						; COMDAT

; 274  :     return gz_open(path, -1, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	83 ca ff	 or	 edx, -1
  00006	e9 00 00 00 00	 jmp	 gz_open
gzopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzdopen
_TEXT	SEGMENT
fd$ = 48
mode$ = 56
gzdopen	PROC						; COMDAT

; 289  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	8b d9		 mov	 ebx, ecx

; 290  :     char *path;         /* identifier for error messages */
; 291  :     gzFile gz;
; 292  : 
; 293  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  00014	83 f9 ff	 cmp	 ecx, -1
  00017	74 56		 je	 SHORT $LN3@gzdopen
  00019	b9 13 00 00 00	 mov	 ecx, 19
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 85 c0	 test	 rax, rax
  0002a	74 43		 je	 SHORT $LN3@gzdopen

; 294  :         return NULL;
; 295  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 296  :     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);

  0002c	44 8b cb	 mov	 r9d, ebx
  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00036	ba 13 00 00 00	 mov	 edx, 19
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 snprintf

; 297  : #else
; 298  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 299  : #endif
; 300  :     gz = gz_open(path, fd, mode);

  00043	4c 8b c6	 mov	 r8, rsi
  00046	8b d3		 mov	 edx, ebx
  00048	48 8b cf	 mov	 rcx, rdi
  0004b	e8 00 00 00 00	 call	 gz_open

; 301  :     free(path);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	48 8b d8	 mov	 rbx, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 302  :     return gz;

  0005c	48 8b c3	 mov	 rax, rbx

; 303  : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN3@gzdopen:
  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	33 c0		 xor	 eax, eax
  00076	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzopen_w
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen_w PROC						; COMDAT

; 311  :     return gz_open(path, -2, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	ba fe ff ff ff	 mov	 edx, -2
  00008	e9 00 00 00 00	 jmp	 gz_open
gzopen_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzbuffer
_TEXT	SEGMENT
file$ = 8
size$ = 16
gzbuffer PROC						; COMDAT

; 320  :     gz_statep state;
; 321  : 
; 322  :     /* get internal structure and check integrity */
; 323  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 04		 jne	 SHORT $LN2@gzbuffer
$LN8@gzbuffer:

; 324  :         return -1;

  00005	83 c8 ff	 or	 eax, -1

; 340  : }

  00008	c3		 ret	 0
$LN2@gzbuffer:

; 325  :     state = (gz_statep)file;
; 326  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000c	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00011	74 07		 je	 SHORT $LN3@gzbuffer
  00013	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00018	75 eb		 jne	 SHORT $LN8@gzbuffer
$LN3@gzbuffer:

; 327  :         return -1;
; 328  : 
; 329  :     /* make sure we haven't already allocated memory */
; 330  :     if (state->size != 0)

  0001a	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0001e	75 e5		 jne	 SHORT $LN8@gzbuffer

; 331  :         return -1;
; 332  : 
; 333  :     /* check and set requested size */
; 334  :     if ((size << 1) < size)

  00020	8d 04 12	 lea	 eax, DWORD PTR [rdx+rdx]
  00023	3b c2		 cmp	 eax, edx
  00025	72 de		 jb	 SHORT $LN8@gzbuffer

; 335  :         return -1;              /* need to be able to double it */
; 336  :     if (size < 2)
; 337  :         size = 2;               /* need two bytes to check magic header */
; 338  :     state->want = size;

  00027	b8 02 00 00 00	 mov	 eax, 2
  0002c	3b d0		 cmp	 edx, eax
  0002e	0f 43 c2	 cmovae	 eax, edx
  00031	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 339  :     return 0;

  00034	33 c0		 xor	 eax, eax

; 340  : }

  00036	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzrewind
_TEXT	SEGMENT
file$ = 48
gzrewind PROC						; COMDAT

; 345  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 346  :     gz_statep state;
; 347  : 
; 348  :     /* get internal structure */
; 349  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3b		 je	 SHORT $LN4@gzrewind

; 350  :         return -1;
; 351  :     state = (gz_statep)file;
; 352  : 
; 353  :     /* check that we're reading and that there's no error */
; 354  :     if (state->mode != GZ_READ ||

  0000e	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00015	75 32		 jne	 SHORT $LN4@gzrewind
  00017	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN3@gzrewind
  0001e	83 f8 fb	 cmp	 eax, -5
  00021	75 26		 jne	 SHORT $LN4@gzrewind
$LN3@gzrewind:

; 357  : 
; 358  :     /* back up and start over */
; 359  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00023	48 8b 51 48	 mov	 rdx, QWORD PTR [rcx+72]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00033	48 83 f8 ff	 cmp	 rax, -1
  00037	74 10		 je	 SHORT $LN4@gzrewind

; 360  :         return -1;
; 361  :     gz_reset(state);

  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 gz_reset

; 362  :     return 0;

  00041	33 c0		 xor	 eax, eax

; 363  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN4@gzrewind:

; 355  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 356  :         return -1;

  00049	83 c8 ff	 or	 eax, -1

; 363  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzseek64
_TEXT	SEGMENT
file$ = 48
offset$ = 56
whence$ = 64
gzseek64 PROC						; COMDAT

; 370  : {

$LN25:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 371  :     unsigned n;
; 372  :     z_off64_t ret;
; 373  :     gz_statep state;
; 374  : 
; 375  :     /* get internal structure and check integrity */
; 376  :     if (file == NULL)

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 0f		 jne	 SHORT $LN2@gzseek64
$LN23@gzseek64:

; 377  :         return -1;

  00015	48 83 c8 ff	 or	 rax, -1

; 440  : }

  00019	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN2@gzseek64:

; 378  :     state = (gz_statep)file;
; 379  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00024	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00027	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0002d	74 08		 je	 SHORT $LN3@gzseek64
  0002f	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H
  00035	75 de		 jne	 SHORT $LN23@gzseek64
$LN3@gzseek64:

; 380  :         return -1;
; 381  : 
; 382  :     /* check that there's no error */
; 383  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00037	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0003a	85 c0		 test	 eax, eax
  0003c	74 05		 je	 SHORT $LN4@gzseek64
  0003e	83 f8 fb	 cmp	 eax, -5
  00041	75 d2		 jne	 SHORT $LN23@gzseek64
$LN4@gzseek64:

; 384  :         return -1;
; 385  : 
; 386  :     /* can only seek from start or relative to current position */
; 387  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00043	45 85 c0	 test	 r8d, r8d
  00046	74 12		 je	 SHORT $LN20@gzseek64
  00048	41 83 f8 01	 cmp	 r8d, 1
  0004c	75 c7		 jne	 SHORT $LN23@gzseek64

; 393  :     else if (state->seek)

  0004e	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00052	74 0a		 je	 SHORT $LN8@gzseek64

; 394  :         offset += state->skip;

  00054	48 03 79 60	 add	 rdi, QWORD PTR [rcx+96]
  00058	eb 04		 jmp	 SHORT $LN8@gzseek64
$LN20@gzseek64:

; 388  :         return -1;
; 389  : 
; 390  :     /* normalize offset to a SEEK_CUR specification */
; 391  :     if (whence == SEEK_SET)
; 392  :         offset -= state->x.pos;

  0005a	48 2b 79 10	 sub	 rdi, QWORD PTR [rcx+16]
$LN8@gzseek64:
  0005e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 395  :     state->seek = 0;

  00063	33 f6		 xor	 esi, esi
  00065	89 71 68	 mov	 DWORD PTR [rcx+104], esi

; 396  : 
; 397  :     /* if within raw area while reading, just go there */
; 398  :     if (state->mode == GZ_READ && state->how == COPY &&

  00068	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0006e	75 5e		 jne	 SHORT $LN9@gzseek64
  00070	83 79 44 01	 cmp	 DWORD PTR [rcx+68], 1
  00074	75 58		 jne	 SHORT $LN9@gzseek64
  00076	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007a	48 03 cf	 add	 rcx, rdi
  0007d	78 4f		 js	 SHORT $LN9@gzseek64

; 399  :             state->x.pos + offset >= 0) {
; 400  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  0007f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00081	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00085	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00088	48 8b d7	 mov	 rdx, rdi
  0008b	48 2b d0	 sub	 rdx, rax
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 401  :         if (ret == -1)

  00094	48 83 f8 ff	 cmp	 rax, -1
  00098	74 54		 je	 SHORT $LN22@gzseek64

; 402  :             return -1;
; 403  :         state->x.have = 0;
; 404  :         state->eof = 0;
; 405  :         state->past = 0;
; 406  :         state->seek = 0;
; 407  :         gz_error(state, Z_OK, NULL);

  0009a	45 33 c0	 xor	 r8d, r8d
  0009d	89 33		 mov	 DWORD PTR [rbx], esi
  0009f	33 d2		 xor	 edx, edx
  000a1	48 89 73 50	 mov	 QWORD PTR [rbx+80], rsi
  000a5	48 8b cb	 mov	 rcx, rbx
  000a8	89 73 68	 mov	 DWORD PTR [rbx+104], esi
  000ab	e8 00 00 00 00	 call	 gz_error

; 408  :         state->strm.avail_in = 0;
; 409  :         state->x.pos += offset;

  000b0	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 410  :         return state->x.pos;

  000b4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000b8	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi
  000be	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 440  : }

  000c3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN9@gzseek64:

; 411  :     }
; 412  : 
; 413  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 414  :     if (offset < 0) {

  000ce	48 85 ff	 test	 rdi, rdi
  000d1	79 2f		 jns	 SHORT $LN14@gzseek64

; 415  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000d3	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  000d9	75 13		 jne	 SHORT $LN22@gzseek64

; 416  :             return -1;
; 417  :         offset += state->x.pos;

  000db	48 03 7b 10	 add	 rdi, QWORD PTR [rbx+16]

; 418  :         if (offset < 0)                     /* before start of file! */

  000df	78 0d		 js	 SHORT $LN22@gzseek64

; 419  :             return -1;
; 420  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  000e1	48 8b cb	 mov	 rcx, rbx
  000e4	e8 00 00 00 00	 call	 gzrewind
  000e9	83 f8 ff	 cmp	 eax, -1
  000ec	75 14		 jne	 SHORT $LN14@gzseek64
$LN22@gzseek64:

; 421  :             return -1;

  000ee	48 83 c8 ff	 or	 rax, -1
  000f2	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 440  : }

  000f7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00100	5f		 pop	 rdi
  00101	c3		 ret	 0
$LN14@gzseek64:

; 422  :     }
; 423  : 
; 424  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 425  :     if (state->mode == GZ_READ) {

  00102	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  00109	75 1b		 jne	 SHORT $LN15@gzseek64

; 426  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?

  0010b	8b 03		 mov	 eax, DWORD PTR [rbx]
  0010d	8b cf		 mov	 ecx, edi
  0010f	48 3b c7	 cmp	 rax, rdi
  00112	0f 4e c8	 cmovle	 ecx, eax

; 427  :             (unsigned)offset : state->x.have;
; 428  :         state->x.have -= n;

  00115	2b c1		 sub	 eax, ecx
  00117	89 03		 mov	 DWORD PTR [rbx], eax

; 429  :         state->x.next += n;

  00119	8b c1		 mov	 eax, ecx
  0011b	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 430  :         state->x.pos += n;

  0011f	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 431  :         offset -= n;

  00123	48 2b f8	 sub	 rdi, rax
$LN15@gzseek64:

; 432  :     }
; 433  : 
; 434  :     /* request skip (if not zero) */
; 435  :     if (offset) {

  00126	48 85 ff	 test	 rdi, rdi
  00129	74 0b		 je	 SHORT $LN16@gzseek64

; 436  :         state->seek = 1;

  0012b	c7 43 68 01 00
	00 00		 mov	 DWORD PTR [rbx+104], 1

; 437  :         state->skip = offset;

  00132	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
$LN16@gzseek64:

; 438  :     }
; 439  :     return state->x.pos + offset;

  00136	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0013a	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0013f	48 03 c7	 add	 rax, rdi

; 440  : }

  00142	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00147	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzseek
_TEXT	SEGMENT
file$ = 48
offset$ = 56
whence$ = 64
gzseek	PROC						; COMDAT

; 447  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 448  :     z_off64_t ret;
; 449  : 
; 450  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00004	48 63 d2	 movsxd	 rdx, edx
  00007	e8 00 00 00 00	 call	 gzseek64
  0000c	48 8b d0	 mov	 rdx, rax

; 451  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000f	48 63 c8	 movsxd	 rcx, eax
  00012	83 c8 ff	 or	 eax, -1
  00015	48 3b d1	 cmp	 rdx, rcx
  00018	0f 44 c2	 cmove	 eax, edx

; 452  : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
gzseek	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gztell64
_TEXT	SEGMENT
file$ = 8
gztell64 PROC						; COMDAT

; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure and check integrity */
; 461  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 462  :         return -1;

  00005	48 83 c8 ff	 or	 rax, -1

; 469  : }

  00009	c3		 ret	 0
$LN2@gztell64:

; 463  :     state = (gz_statep)file;
; 464  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN3@gztell64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00019	75 ea		 jne	 SHORT $LN7@gztell64
$LN3@gztell64:

; 465  :         return -1;
; 466  : 
; 467  :     /* return position */
; 468  :     return state->x.pos + (state->seek ? state->skip : 0);

  0001b	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  0001f	74 0c		 je	 SHORT $LN5@gztell64
  00021	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00025	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00029	48 03 c2	 add	 rax, rdx

; 469  : }

  0002c	c3		 ret	 0
$LN5@gztell64:

; 465  :         return -1;
; 466  : 
; 467  :     /* return position */
; 468  :     return state->x.pos + (state->seek ? state->skip : 0);

  0002d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00031	33 d2		 xor	 edx, edx
  00033	48 03 c2	 add	 rax, rdx

; 469  : }

  00036	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gztell
_TEXT	SEGMENT
file$ = 48
gztell	PROC						; COMDAT

; 474  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 475  :     z_off64_t ret;
; 476  : 
; 477  :     ret = gztell64(file);

  00004	e8 00 00 00 00	 call	 gztell64
  00009	4c 8b c0	 mov	 r8, rax

; 478  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000c	48 63 c8	 movsxd	 rcx, eax
  0000f	83 c8 ff	 or	 eax, -1
  00012	4c 3b c1	 cmp	 r8, rcx
  00015	41 0f 44 c0	 cmove	 eax, r8d

; 479  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
gztell	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzoffset64
_TEXT	SEGMENT
file$ = 48
gzoffset64 PROC						; COMDAT

; 484  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 485  :     z_off64_t offset;
; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure and check integrity */
; 489  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN2@gzoffset64
$LN7@gzoffset64:

; 490  :         return -1;

  0000e	48 83 c8 ff	 or	 rax, -1

; 502  : }

  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5b		 pop	 rbx
  00017	c3		 ret	 0
$LN2@gzoffset64:

; 491  :     state = (gz_statep)file;
; 492  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00018	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0001b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00020	74 07		 je	 SHORT $LN3@gzoffset64
  00022	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00027	75 e5		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 493  :         return -1;
; 494  : 
; 495  :     /* compute and return effective offset in file */
; 496  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00029	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0002c	33 d2		 xor	 edx, edx
  0002e	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00038	48 8b c8	 mov	 rcx, rax

; 497  :     if (offset == -1)

  0003b	48 83 f8 ff	 cmp	 rax, -1
  0003f	74 cd		 je	 SHORT $LN7@gzoffset64

; 498  :         return -1;
; 499  :     if (state->mode == GZ_READ)             /* reading */

  00041	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  00048	75 09		 jne	 SHORT $LN5@gzoffset64

; 500  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0004a	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  00050	48 2b c8	 sub	 rcx, rax
$LN5@gzoffset64:

; 501  :     return offset;

  00053	48 8b c1	 mov	 rax, rcx

; 502  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzoffset
_TEXT	SEGMENT
file$ = 48
gzoffset PROC						; COMDAT

; 507  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 508  :     z_off64_t ret;
; 509  : 
; 510  :     ret = gzoffset64(file);

  00004	e8 00 00 00 00	 call	 gzoffset64
  00009	48 8b d0	 mov	 rdx, rax

; 511  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0000c	48 63 c8	 movsxd	 rcx, eax
  0000f	83 c8 ff	 or	 eax, -1
  00012	48 3b d1	 cmp	 rdx, rcx
  00015	0f 44 c2	 cmove	 eax, edx

; 512  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
gzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzeof
_TEXT	SEGMENT
file$ = 8
gzeof	PROC						; COMDAT

; 518  :     gz_statep state;
; 519  : 
; 520  :     /* get internal structure and check integrity */
; 521  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1c		 je	 SHORT $LN5@gzeof

; 522  :         return 0;
; 523  :     state = (gz_statep)file;
; 524  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 0e		 je	 SHORT $LN8@gzeof
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 0b		 jne	 SHORT $LN5@gzeof

; 525  :         return 0;
; 526  : 
; 527  :     /* return end-of-file state */
; 528  :     return state->mode == GZ_READ ? state->past : 0;

  00016	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0001b	75 04		 jne	 SHORT $LN5@gzeof
$LN8@gzeof:
  0001d	8b 41 54	 mov	 eax, DWORD PTR [rcx+84]

; 529  : }

  00020	c3		 ret	 0
$LN5@gzeof:

; 525  :         return 0;
; 526  : 
; 527  :     /* return end-of-file state */
; 528  :     return state->mode == GZ_READ ? state->past : 0;

  00021	33 c0		 xor	 eax, eax

; 529  : }

  00023	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzerror
_TEXT	SEGMENT
file$ = 8
errnum$ = 16
gzerror	PROC						; COMDAT

; 536  :     gz_statep state;
; 537  : 
; 538  :     /* get internal structure and check integrity */
; 539  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 03		 jne	 SHORT $LN2@gzerror
$LN10@gzerror:

; 540  :         return NULL;

  00005	33 c0		 xor	 eax, eax

; 549  :                                        (state->msg == NULL ? "" : state->msg);
; 550  : }

  00007	c3		 ret	 0
$LN2@gzerror:

; 541  :     state = (gz_statep)file;
; 542  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00008	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00010	74 07		 je	 SHORT $LN3@gzerror
  00012	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00017	75 ec		 jne	 SHORT $LN10@gzerror
$LN3@gzerror:

; 543  :         return NULL;
; 544  : 
; 545  :     /* return error information */
; 546  :     if (errnum != NULL)

  00019	48 85 d2	 test	 rdx, rdx
  0001c	74 05		 je	 SHORT $LN4@gzerror

; 547  :         *errnum = state->err;

  0001e	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00021	89 02		 mov	 DWORD PTR [rdx], eax
$LN4@gzerror:

; 548  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  00023	83 79 6c fc	 cmp	 DWORD PTR [rcx+108], -4
  00027	75 08		 jne	 SHORT $LN8@gzerror
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@

; 549  :                                        (state->msg == NULL ? "" : state->msg);
; 550  : }

  00030	c3		 ret	 0
$LN8@gzerror:

; 548  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  00031	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0003c	48 85 c9	 test	 rcx, rcx
  0003f	48 0f 45 c1	 cmovne	 rax, rcx

; 549  :                                        (state->msg == NULL ? "" : state->msg);
; 550  : }

  00043	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzclearerr
_TEXT	SEGMENT
file$ = 8
gzclearerr PROC						; COMDAT

; 556  :     gz_statep state;
; 557  : 
; 558  :     /* get internal structure and check integrity */
; 559  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 28		 je	 SHORT $LN1@gzclearerr

; 560  :         return;
; 561  :     state = (gz_statep)file;
; 562  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 0e		 je	 SHORT $LN7@gzclearerr
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 17		 jne	 SHORT $LN1@gzclearerr

; 563  :         return;
; 564  : 
; 565  :     /* clear error and end-of-file */
; 566  :     if (state->mode == GZ_READ) {

  00016	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0001b	75 06		 jne	 SHORT $LN4@gzclearerr
$LN7@gzclearerr:

; 567  :         state->eof = 0;

  0001d	33 c0		 xor	 eax, eax
  0001f	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN4@gzclearerr:

; 568  :         state->past = 0;
; 569  :     }
; 570  :     gz_error(state, Z_OK, NULL);

  00023	45 33 c0	 xor	 r8d, r8d
  00026	33 d2		 xor	 edx, edx
  00028	e9 00 00 00 00	 jmp	 gz_error
$LN1@gzclearerr:

; 571  : }

  0002d	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_error
_TEXT	SEGMENT
state$ = 64
err$ = 72
msg$ = 80
gz_error PROC						; COMDAT

; 583  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	49 8b f0	 mov	 rsi, r8

; 584  :     /* free previously allocated message and clear */
; 585  :     if (state->msg != NULL) {

  00015	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00019	8b da		 mov	 ebx, edx
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 14		 je	 SHORT $LN2@gz_error

; 586  :         if (state->err != Z_MEM_ERROR)

  00020	83 7f 6c fc	 cmp	 DWORD PTR [rdi+108], -4
  00024	74 06		 je	 SHORT $LN3@gz_error

; 587  :             free(state->msg);

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gz_error:

; 588  :         state->msg = NULL;

  0002c	48 c7 47 70 00
	00 00 00	 mov	 QWORD PTR [rdi+112], 0
$LN2@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 592  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00034	85 db		 test	 ebx, ebx
  00036	74 0b		 je	 SHORT $LN4@gz_error
  00038	83 fb fb	 cmp	 ebx, -5
  0003b	74 06		 je	 SHORT $LN4@gz_error

; 593  :         state->x.have = 0;

  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [rdi], 0
$LN4@gz_error:

; 594  : 
; 595  :     /* set error code, and if no message, then done */
; 596  :     state->err = err;

  00043	89 5f 6c	 mov	 DWORD PTR [rdi+108], ebx

; 597  :     if (msg == NULL)

  00046	48 85 f6	 test	 rsi, rsi
  00049	0f 84 9e 00 00
	00		 je	 $LN1@gz_error

; 598  :         return;
; 599  : 
; 600  :     /* for an out of memory error, return literal string when requested */
; 601  :     if (err == Z_MEM_ERROR)

  0004f	83 fb fc	 cmp	 ebx, -4
  00052	0f 84 95 00 00
	00		 je	 $LN1@gz_error

; 602  :         return;
; 603  : 
; 604  :     /* construct error message with path */
; 605  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==

  00058	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0005c	48 83 cb ff	 or	 rbx, -1
  00060	48 8b c3	 mov	 rax, rbx
$LL12@gz_error:
  00063	48 ff c0	 inc	 rax
  00066	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  0006a	75 f7		 jne	 SHORT $LL12@gz_error
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	90		 npad	 1
$LL11@gz_error:
  00070	48 ff c1	 inc	 rcx
  00073	80 3c 0e 00	 cmp	 BYTE PTR [rsi+rcx], 0
  00077	75 f7		 jne	 SHORT $LL11@gz_error
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 03 c8	 add	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00086	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	48 85 c0	 test	 rax, rax
  00090	75 17		 jne	 SHORT $LN7@gz_error

; 606  :             NULL) {
; 607  :         state->err = Z_MEM_ERROR;

  00092	c7 47 6c fc ff
	ff ff		 mov	 DWORD PTR [rdi+108], -4

; 612  :                    "%s%s%s", state->path, ": ", msg);
; 613  : #else
; 614  :     strcpy(state->msg, state->path);
; 615  :     strcat(state->msg, ": ");
; 616  :     strcat(state->msg, msg);
; 617  : #endif
; 618  : }

  00099	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$LN7@gz_error:

; 608  :         return;
; 609  :     }
; 610  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 611  :     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,

  000a9	4c 8b 4f 20	 mov	 r9, QWORD PTR [rdi+32]
  000ad	48 8b c3	 mov	 rax, rbx
$LL10@gz_error:
  000b0	41 80 7c 01 01
	00		 cmp	 BYTE PTR [r9+rax+1], 0
  000b6	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  000ba	75 f4		 jne	 SHORT $LL10@gz_error
  000bc	0f 1f 40 00	 npad	 4
$LL9@gz_error:
  000c0	48 ff c3	 inc	 rbx
  000c3	80 3c 1e 00	 cmp	 BYTE PTR [rsi+rbx], 0
  000c7	75 f7		 jne	 SHORT $LL9@gz_error
  000c9	48 8d 50 03	 lea	 rdx, QWORD PTR [rax+3]
  000cd	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  000d9	48 03 d3	 add	 rdx, rbx
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
  000e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e8	e8 00 00 00 00	 call	 snprintf
$LN1@gz_error:

; 612  :                    "%s%s%s", state->path, ": ", msg);
; 613  : #else
; 614  :     strcpy(state->msg, state->path);
; 615  :     strcat(state->msg, ": ");
; 616  :     strcat(state->msg, msg);
; 617  : #endif
; 618  : }

  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fb	5f		 pop	 rdi
  000fc	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
END
