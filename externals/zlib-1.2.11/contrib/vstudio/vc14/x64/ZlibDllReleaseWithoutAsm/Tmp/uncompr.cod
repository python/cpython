; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	uncompress
PUBLIC	uncompress2
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress2 DD imagerel $LN28
	DD	imagerel $LN28+111
	DD	imagerel $unwind$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$uncompress2 DD imagerel $LN28+111
	DD	imagerel $LN28+121
	DD	imagerel $chain$0$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$uncompress2 DD imagerel $LN28+121
	DD	imagerel $LN28+236
	DD	imagerel $chain$1$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$uncompress2 DD imagerel $LN28+236
	DD	imagerel $LN28+315
	DD	imagerel $chain$2$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$uncompress2 DD imagerel $LN28+315
	DD	imagerel $LN28+339
	DD	imagerel $chain$3$uncompress2
;	COMDAT xdata
xdata	SEGMENT
$chain$3$uncompress2 DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+111
	DD	imagerel $unwind$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$uncompress2 DD 021H
	DD	imagerel $LN28+111
	DD	imagerel $LN28+121
	DD	imagerel $chain$0$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$uncompress2 DD 020821H
	DD	019d408H
	DD	imagerel $LN28+111
	DD	imagerel $LN28+121
	DD	imagerel $chain$0$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$uncompress2 DD 020821H
	DD	0187408H
	DD	imagerel $LN28
	DD	imagerel $LN28+111
	DD	imagerel $unwind$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress2 DD 091401H
	DD	01a3414H
	DD	0120114H
	DD	0e00bf00dH
	DD	06007c009H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress DD 010901H
	DD	04209H
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress2
_TEXT	SEGMENT
buf$ = 32
stream$ = 48
dest$ = 192
destLen$ = 200
source$ = 208
sourceLen$ = 216
uncompress2 PROC					; COMDAT

; 32   : {

$LN28:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;
; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;
; 40   :     if (*destLen) {

  00014	8b 1a		 mov	 ebx, DWORD PTR [rdx]
  00016	33 ed		 xor	 ebp, ebp
  00018	41 8b 31	 mov	 esi, DWORD PTR [r9]
  0001b	4d 8b e1	 mov	 r12, r9
  0001e	4c 8b fa	 mov	 r15, rdx
  00021	4c 8b f1	 mov	 r14, rcx
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	85 db		 test	 ebx, ebx
  0002b	74 04		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;
; 42   :         *destLen = 0;

  0002d	89 2a		 mov	 DWORD PTR [rdx], ebp

; 43   :     }

  0002f	eb 07		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;

  00031	8b d8		 mov	 ebx, eax

; 46   :         dest = buf;

  00033	4c 8d 74 24 20	 lea	 r14, QWORD PTR buf$[rsp]
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  00038	4c 89 44 24 30	 mov	 QWORD PTR stream$[rsp], r8

; 50   :     stream.avail_in = 0;
; 51   :     stream.zalloc = (alloc_func)0;
; 52   :     stream.zfree = (free_func)0;
; 53   :     stream.opaque = (voidpf)0;
; 54   : 
; 55   :     err = inflateInit(&stream);

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411?$AA@
  00044	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  0004a	89 6c 24 38	 mov	 DWORD PTR stream$[rsp+8], ebp
  0004e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  00053	48 89 6c 24 60	 mov	 QWORD PTR stream$[rsp+48], rbp
  00058	48 89 6c 24 68	 mov	 QWORD PTR stream$[rsp+56], rbp
  0005d	48 89 6c 24 70	 mov	 QWORD PTR stream$[rsp+64], rbp
  00062	e8 00 00 00 00	 call	 inflateInit_

; 56   :     if (err != Z_OK) return err;

  00067	85 c0		 test	 eax, eax
  00069	0f 85 cc 00 00
	00		 jne	 $LN1@uncompress

; 57   : 
; 58   :     stream.next_out = dest;
; 59   :     stream.avail_out = 0;

  0006f	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rdi
  00077	8b c5		 mov	 eax, ebp
  00079	4c 89 ac 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r13
  00081	41 83 cd ff	 or	 r13d, -1		; ffffffffH
  00085	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax
  00089	4c 89 74 24 40	 mov	 QWORD PTR stream$[rsp+16], r14
  0008e	66 90		 npad	 2
$LL4@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  00090	85 c0		 test	 eax, eax
  00092	75 0f		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00094	41 3b dd	 cmp	 ebx, r13d
  00097	8b c3		 mov	 eax, ebx
  00099	41 0f 47 c5	 cmova	 eax, r13d
  0009d	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax

; 64   :             left -= stream.avail_out;

  000a1	2b d8		 sub	 ebx, eax
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  000a3	39 6c 24 38	 cmp	 DWORD PTR stream$[rsp+8], ebp
  000a7	75 0f		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  000a9	41 3b f5	 cmp	 esi, r13d
  000ac	8b c6		 mov	 eax, esi
  000ae	41 0f 47 c5	 cmova	 eax, r13d
  000b2	89 44 24 38	 mov	 DWORD PTR stream$[rsp+8], eax

; 68   :             len -= stream.avail_in;

  000b6	2b f0		 sub	 esi, eax
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000b8	33 d2		 xor	 edx, edx
  000ba	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000bf	e8 00 00 00 00	 call	 inflate
  000c4	8b f8		 mov	 edi, eax

; 71   :     } while (err == Z_OK);

  000c6	85 c0		 test	 eax, eax
  000c8	75 06		 jne	 SHORT $LN26@uncompress

; 57   : 
; 58   :     stream.next_out = dest;
; 59   :     stream.avail_out = 0;

  000ca	8b 44 24 48	 mov	 eax, DWORD PTR stream$[rsp+24]
  000ce	eb c0		 jmp	 SHORT $LL4@uncompress
$LN26@uncompress:

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000d0	8b 4c 24 38	 mov	 ecx, DWORD PTR stream$[rsp+8]

; 74   :     if (dest != buf)

  000d4	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  000d9	4c 8b ac 24 c8
	00 00 00	 mov	 r13, QWORD PTR [rsp+200]
  000e1	03 ce		 add	 ecx, esi
  000e3	41 29 0c 24	 sub	 DWORD PTR [r12], ecx
  000e7	4c 3b f0	 cmp	 r14, rax
  000ea	74 09		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  000ec	8b 44 24 4c	 mov	 eax, DWORD PTR stream$[rsp+28]
  000f0	41 89 07	 mov	 DWORD PTR [r15], eax
  000f3	eb 11		 jmp	 SHORT $LN12@uncompress
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  000f5	39 6c 24 4c	 cmp	 DWORD PTR stream$[rsp+28], ebp
  000f9	74 0b		 je	 SHORT $LN12@uncompress
  000fb	83 ff fb	 cmp	 edi, -5
  000fe	b8 01 00 00 00	 mov	 eax, 1
  00103	0f 44 d8	 cmove	 ebx, eax
$LN12@uncompress:

; 77   :         left = 1;
; 78   : 
; 79   :     inflateEnd(&stream);

  00106	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  0010b	e8 00 00 00 00	 call	 inflateEnd

; 80   :     return err == Z_STREAM_END ? Z_OK :

  00110	83 ff 01	 cmp	 edi, 1
  00113	74 1c		 je	 SHORT $LN15@uncompress
  00115	83 ff 02	 cmp	 edi, 2
  00118	75 05		 jne	 SHORT $LN16@uncompress
  0011a	8d 6f fb	 lea	 ebp, QWORD PTR [rdi-5]
  0011d	eb 12		 jmp	 SHORT $LN15@uncompress
$LN16@uncompress:
  0011f	83 ff fb	 cmp	 edi, -5
  00122	75 0b		 jne	 SHORT $LN14@uncompress
  00124	8b 4c 24 48	 mov	 ecx, DWORD PTR stream$[rsp+24]
  00128	8d 6f 02	 lea	 ebp, QWORD PTR [rdi+2]
  0012b	03 cb		 add	 ecx, ebx
  0012d	75 02		 jne	 SHORT $LN15@uncompress
$LN14@uncompress:
  0012f	8b ef		 mov	 ebp, edi
$LN15@uncompress:
  00131	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]
  00139	8b c5		 mov	 eax, ebp
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  0013b	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+208]
  00143	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0014a	41 5f		 pop	 r15
  0014c	41 5e		 pop	 r14
  0014e	41 5c		 pop	 r12
  00150	5e		 pop	 rsi
  00151	5d		 pop	 rbp
  00152	c3		 ret	 0
uncompress2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress
_TEXT	SEGMENT
dest$ = 48
destLen$ = 56
source$ = 64
sourceLen$ = 72
uncompress PROC						; COMDAT

; 91   : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00009	4c 8d 4c 24 48	 lea	 r9, QWORD PTR sourceLen$[rsp]
  0000e	e8 00 00 00 00	 call	 uncompress2

; 93   : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
uncompress ENDP
_TEXT	ENDS
END
