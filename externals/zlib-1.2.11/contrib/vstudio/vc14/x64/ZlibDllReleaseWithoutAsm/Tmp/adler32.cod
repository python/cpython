; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	adler32_combine
PUBLIC	adler32
PUBLIC	adler32_z
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+205
	DD	imagerel $unwind$adler32_combine_
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_z
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32_z PROC						; COMDAT

; 68   :     unsigned long sum2;
; 69   :     unsigned n;
; 70   : 
; 71   :     /* split Adler-32 into component sums */
; 72   :     sum2 = (adler >> 16) & 0xffff;

  00000	44 8b c9	 mov	 r9d, ecx
  00003	4c 8b d2	 mov	 r10, rdx
  00006	41 c1 e9 10	 shr	 r9d, 16

; 73   :     adler &= 0xffff;

  0000a	0f b7 c9	 movzx	 ecx, cx

; 74   : 
; 75   :     /* in case user likes doing a byte at a time, keep it fast */
; 76   :     if (len == 1) {

  0000d	49 83 f8 01	 cmp	 r8, 1
  00011	75 2f		 jne	 SHORT $LN13@adler32_z

; 77   :         adler += buf[0];

  00013	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00016	03 c8		 add	 ecx, eax
  00018	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  0001e	8d 91 0f 00 ff
	ff		 lea	 edx, DWORD PTR [rcx-65521]
  00024	0f 42 d1	 cmovb	 edx, ecx

; 78   :         if (adler >= BASE)
; 79   :             adler -= BASE;
; 80   :         sum2 += adler;

  00027	44 03 ca	 add	 r9d, edx
  0002a	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00031	41 8d 81 0f 00
	ff ff		 lea	 eax, DWORD PTR [r9-65521]
  00038	41 0f 42 c1	 cmovb	 eax, r9d

; 81   :         if (sum2 >= BASE)
; 82   :             sum2 -= BASE;
; 83   :         return adler | (sum2 << 16);

  0003c	c1 e0 10	 shl	 eax, 16
  0003f	0b c2		 or	 eax, edx

; 131  : }

  00041	c3		 ret	 0
$LN13@adler32_z:

; 84   :     }
; 85   : 
; 86   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 87   :     if (buf == Z_NULL)

  00042	48 85 d2	 test	 rdx, rdx
  00045	75 04		 jne	 SHORT $LN16@adler32_z

; 88   :         return 1L;

  00047	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 131  : }

  0004a	c3		 ret	 0
$LN16@adler32_z:

; 89   : 
; 90   :     /* in case short lengths are provided, keep it somewhat fast */
; 91   :     if (len < 16) {

  0004b	49 83 f8 10	 cmp	 r8, 16
  0004f	73 4b		 jae	 SHORT $LN22@adler32_z

; 92   :         while (len--) {

  00051	4d 85 c0	 test	 r8, r8
  00054	74 1d		 je	 SHORT $LN26@adler32_z
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@adler32_z:

; 93   :             adler += *buf++;

  00060	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00064	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00068	03 c8		 add	 ecx, eax

; 94   :             sum2 += adler;

  0006a	44 03 c9	 add	 r9d, ecx
  0006d	49 83 e8 01	 sub	 r8, 1
  00071	75 ed		 jne	 SHORT $LL2@adler32_z
$LN26@adler32_z:
  00073	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00079	44 8d 81 0f 00
	ff ff		 lea	 r8d, DWORD PTR [rcx-65521]

; 95   :         }
; 96   :         if (adler >= BASE)
; 97   :             adler -= BASE;
; 98   :         MOD28(sum2);            /* only added so many BASE's */

  00080	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00085	44 0f 42 c1	 cmovb	 r8d, ecx
  00089	41 f7 e1	 mul	 r9d
  0008c	c1 ea 0f	 shr	 edx, 15

; 99   :         return adler | (sum2 << 16);

  0008f	6b c2 0f	 imul	 eax, edx, 15
  00092	41 03 c1	 add	 eax, r9d
  00095	c1 e0 10	 shl	 eax, 16
  00098	41 0b c0	 or	 eax, r8d

; 131  : }

  0009b	c3		 ret	 0
$LN22@adler32_z:

; 100  :     }
; 101  : 
; 102  :     /* do length NMAX blocks -- requires just one modulo operation */
; 103  :     while (len >= NMAX) {

  0009c	49 81 f8 b0 15
	00 00		 cmp	 r8, 5552		; 000015b0H
  000a3	0f 82 13 01 00
	00		 jb	 $LN5@adler32_z
  000a9	4d 8b d8	 mov	 r11, r8
  000ac	48 b8 f7 b6 98
	63 bb a6 ba 79	 mov	 rax, 8771506548017510135 ; 79baa6bb6398b6f7H
  000b6	49 f7 e0	 mul	 r8
  000b9	4c 2b da	 sub	 r11, rdx
  000bc	49 d1 eb	 shr	 r11, 1
  000bf	4c 03 da	 add	 r11, rdx
  000c2	49 c1 eb 0c	 shr	 r11, 12
  000c6	49 69 c3 50 ea
	ff ff		 imul	 rax, r11, -5552		; ffffffffffffea50H
  000cd	4c 03 c0	 add	 r8, rax
$LL4@adler32_z:

; 104  :         len -= NMAX;
; 105  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000d0	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  000d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@adler32_z:

; 106  :         do {
; 107  :             DO16(buf);          /* 16 sums unrolled */

  000e0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000e4	03 c8		 add	 ecx, eax
  000e6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000eb	44 03 c9	 add	 r9d, ecx
  000ee	03 c8		 add	 ecx, eax
  000f0	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  000f5	44 03 c9	 add	 r9d, ecx
  000f8	03 c8		 add	 ecx, eax
  000fa	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  000ff	44 03 c9	 add	 r9d, ecx
  00102	03 c8		 add	 ecx, eax
  00104	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  00109	44 03 c9	 add	 r9d, ecx
  0010c	03 c8		 add	 ecx, eax
  0010e	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  00113	44 03 c9	 add	 r9d, ecx
  00116	03 c8		 add	 ecx, eax
  00118	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]
  0011d	44 03 c9	 add	 r9d, ecx
  00120	03 c8		 add	 ecx, eax
  00122	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00127	44 03 c9	 add	 r9d, ecx
  0012a	03 c8		 add	 ecx, eax
  0012c	41 0f b6 42 08	 movzx	 eax, BYTE PTR [r10+8]
  00131	44 03 c9	 add	 r9d, ecx
  00134	03 c8		 add	 ecx, eax
  00136	41 0f b6 42 09	 movzx	 eax, BYTE PTR [r10+9]
  0013b	44 03 c9	 add	 r9d, ecx
  0013e	03 c8		 add	 ecx, eax
  00140	41 0f b6 42 0a	 movzx	 eax, BYTE PTR [r10+10]
  00145	44 03 c9	 add	 r9d, ecx
  00148	03 c8		 add	 ecx, eax
  0014a	41 0f b6 42 0b	 movzx	 eax, BYTE PTR [r10+11]
  0014f	44 03 c9	 add	 r9d, ecx
  00152	03 c8		 add	 ecx, eax
  00154	41 0f b6 42 0c	 movzx	 eax, BYTE PTR [r10+12]
  00159	44 03 c9	 add	 r9d, ecx
  0015c	03 c8		 add	 ecx, eax
  0015e	41 0f b6 42 0d	 movzx	 eax, BYTE PTR [r10+13]
  00163	44 03 c9	 add	 r9d, ecx
  00166	03 c8		 add	 ecx, eax
  00168	41 0f b6 42 0e	 movzx	 eax, BYTE PTR [r10+14]
  0016d	44 03 c9	 add	 r9d, ecx
  00170	03 c8		 add	 ecx, eax
  00172	41 0f b6 42 0f	 movzx	 eax, BYTE PTR [r10+15]
  00177	44 03 c9	 add	 r9d, ecx

; 108  :             buf += 16;

  0017a	49 83 c2 10	 add	 r10, 16
  0017e	03 c8		 add	 ecx, eax
  00180	44 03 c9	 add	 r9d, ecx

; 109  :         } while (--n);

  00183	83 c2 ff	 add	 edx, -1			; ffffffffH
  00186	0f 85 54 ff ff
	ff		 jne	 $LL8@adler32_z

; 110  :         MOD(adler);

  0018c	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00191	f7 e1		 mul	 ecx
  00193	c1 ea 0f	 shr	 edx, 15
  00196	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  0019c	03 c8		 add	 ecx, eax

; 111  :         MOD(sum2);

  0019e	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  001a3	41 f7 e1	 mul	 r9d
  001a6	c1 ea 0f	 shr	 edx, 15
  001a9	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  001af	44 03 c8	 add	 r9d, eax
  001b2	49 83 eb 01	 sub	 r11, 1
  001b6	0f 85 14 ff ff
	ff		 jne	 $LL4@adler32_z
$LN5@adler32_z:

; 112  :     }
; 113  : 
; 114  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 115  :     if (len) {                  /* avoid modulos if none remaining */

  001bc	4d 85 c0	 test	 r8, r8
  001bf	0f 84 06 01 00
	00		 je	 $LN19@adler32_z

; 116  :         while (len >= 16) {

  001c5	49 83 f8 10	 cmp	 r8, 16
  001c9	0f 82 be 00 00
	00		 jb	 $LN25@adler32_z
  001cf	49 8b d0	 mov	 rdx, r8
  001d2	48 c1 ea 04	 shr	 rdx, 4
  001d6	48 6b c2 f0	 imul	 rax, rdx, -16
  001da	4c 03 c0	 add	 r8, rax
  001dd	0f 1f 00	 npad	 3
$LL9@adler32_z:

; 117  :             len -= 16;
; 118  :             DO16(buf);

  001e0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001e4	03 c8		 add	 ecx, eax
  001e6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  001eb	44 03 c9	 add	 r9d, ecx
  001ee	03 c8		 add	 ecx, eax
  001f0	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  001f5	44 03 c9	 add	 r9d, ecx
  001f8	03 c8		 add	 ecx, eax
  001fa	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  001ff	44 03 c9	 add	 r9d, ecx
  00202	03 c8		 add	 ecx, eax
  00204	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  00209	44 03 c9	 add	 r9d, ecx
  0020c	03 c8		 add	 ecx, eax
  0020e	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  00213	44 03 c9	 add	 r9d, ecx
  00216	03 c8		 add	 ecx, eax
  00218	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]
  0021d	44 03 c9	 add	 r9d, ecx
  00220	03 c8		 add	 ecx, eax
  00222	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00227	44 03 c9	 add	 r9d, ecx
  0022a	03 c8		 add	 ecx, eax
  0022c	41 0f b6 42 08	 movzx	 eax, BYTE PTR [r10+8]
  00231	44 03 c9	 add	 r9d, ecx
  00234	03 c8		 add	 ecx, eax
  00236	41 0f b6 42 09	 movzx	 eax, BYTE PTR [r10+9]
  0023b	44 03 c9	 add	 r9d, ecx
  0023e	03 c8		 add	 ecx, eax
  00240	41 0f b6 42 0a	 movzx	 eax, BYTE PTR [r10+10]
  00245	44 03 c9	 add	 r9d, ecx
  00248	03 c8		 add	 ecx, eax
  0024a	41 0f b6 42 0b	 movzx	 eax, BYTE PTR [r10+11]
  0024f	44 03 c9	 add	 r9d, ecx
  00252	03 c8		 add	 ecx, eax
  00254	41 0f b6 42 0c	 movzx	 eax, BYTE PTR [r10+12]
  00259	44 03 c9	 add	 r9d, ecx
  0025c	03 c8		 add	 ecx, eax
  0025e	41 0f b6 42 0d	 movzx	 eax, BYTE PTR [r10+13]
  00263	44 03 c9	 add	 r9d, ecx
  00266	03 c8		 add	 ecx, eax
  00268	41 0f b6 42 0e	 movzx	 eax, BYTE PTR [r10+14]
  0026d	44 03 c9	 add	 r9d, ecx
  00270	03 c8		 add	 ecx, eax
  00272	41 0f b6 42 0f	 movzx	 eax, BYTE PTR [r10+15]
  00277	44 03 c9	 add	 r9d, ecx

; 119  :             buf += 16;

  0027a	49 83 c2 10	 add	 r10, 16
  0027e	03 c8		 add	 ecx, eax
  00280	44 03 c9	 add	 r9d, ecx
  00283	48 83 ea 01	 sub	 rdx, 1
  00287	0f 85 53 ff ff
	ff		 jne	 $LL9@adler32_z
$LN25@adler32_z:

; 120  :         }
; 121  :         while (len--) {

  0028d	4d 85 c0	 test	 r8, r8
  00290	74 13		 je	 SHORT $LN30@adler32_z
$LL11@adler32_z:

; 122  :             adler += *buf++;

  00292	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00296	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  0029a	03 c8		 add	 ecx, eax

; 123  :             sum2 += adler;

  0029c	44 03 c9	 add	 r9d, ecx
  0029f	49 83 e8 01	 sub	 r8, 1
  002a3	75 ed		 jne	 SHORT $LL11@adler32_z
$LN30@adler32_z:

; 124  :         }
; 125  :         MOD(adler);

  002a5	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002aa	f7 e1		 mul	 ecx

; 126  :         MOD(sum2);

  002ac	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002b1	c1 ea 0f	 shr	 edx, 15
  002b4	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521	; ffff000fH
  002ba	03 ca		 add	 ecx, edx
  002bc	41 f7 e1	 mul	 r9d
  002bf	c1 ea 0f	 shr	 edx, 15
  002c2	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521	; ffff000fH
  002c8	44 03 ca	 add	 r9d, edx
$LN19@adler32_z:

; 127  :     }
; 128  : 
; 129  :     /* return recombined sums */
; 130  :     return adler | (sum2 << 16);

  002cb	41 c1 e1 10	 shl	 r9d, 16
  002cf	44 0b c9	 or	 r9d, ecx
  002d2	41 8b c1	 mov	 eax, r9d

; 131  : }

  002d5	c3		 ret	 0
adler32_z ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32	PROC						; COMDAT

; 139  :     return adler32_z(adler, buf, len);

  00000	45 8b c0	 mov	 r8d, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_z
adler32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 147  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4d 8b d0	 mov	 r10, r8
  00008	8b da		 mov	 ebx, edx
  0000a	44 8b d9	 mov	 r11d, ecx

; 148  :     unsigned long sum1;
; 149  :     unsigned long sum2;
; 150  :     unsigned rem;
; 151  : 
; 152  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 153  :     if (len2 < 0)

  0000d	4d 85 c0	 test	 r8, r8
  00010	79 09		 jns	 SHORT $LN2@adler32_co

; 154  :         return 0xffffffffUL;

  00012	83 c8 ff	 or	 eax, -1			; ffffffffH

; 164  :     if (sum1 >= BASE) sum1 -= BASE;
; 165  :     if (sum1 >= BASE) sum1 -= BASE;
; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  00015	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0001a	c3		 ret	 0
$LN2@adler32_co:

; 155  : 
; 156  :     /* the derivation of this formula is left as an exercise for the reader */
; 157  :     MOD63(len2);                /* assumes len2 >= 0 */
; 158  :     rem = (unsigned)len2;
; 159  :     sum1 = adler1 & 0xffff;

  0001b	41 0f b7 cb	 movzx	 ecx, r11w
  0001f	48 b8 e7 e2 97
	86 70 80 07 80	 mov	 rax, -9221260491235007769 ; 800780708697e2e7H
  00029	49 f7 ea	 imul	 r10

; 160  :     sum2 = rem * sum1;

  0002c	44 8b c1	 mov	 r8d, ecx

; 161  :     MOD(sum2);
; 162  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 163  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  0002f	41 c1 eb 10	 shr	 r11d, 16
  00033	49 03 d2	 add	 rdx, r10
  00036	44 0f b7 cb	 movzx	 r9d, bx
  0003a	48 c1 fa 0f	 sar	 rdx, 15
  0003e	81 c1 f0 ff 00
	00		 add	 ecx, 65520		; 0000fff0H
  00044	44 03 c9	 add	 r9d, ecx
  00047	c1 eb 10	 shr	 ebx, 16
  0004a	48 8b c2	 mov	 rax, rdx
  0004d	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00051	48 03 d0	 add	 rdx, rax
  00054	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  0005a	44 2b d0	 sub	 r10d, eax
  0005d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00062	45 0f af c2	 imul	 r8d, r10d
  00066	41 f7 e0	 mul	 r8d
  00069	c1 ea 0f	 shr	 edx, 15
  0006c	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  00072	41 8d 91 0f 00
	ff ff		 lea	 edx, DWORD PTR [r9-65521]
  00079	44 2b d8	 sub	 r11d, eax
  0007c	42 8d 04 1b	 lea	 eax, DWORD PTR [rbx+r11]

; 164  :     if (sum1 >= BASE) sum1 -= BASE;
; 165  :     if (sum1 >= BASE) sum1 -= BASE;
; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  00080	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00085	41 2b c2	 sub	 eax, r10d
  00088	05 f1 ff 00 00	 add	 eax, 65521		; 0000fff1H
  0008d	41 03 c0	 add	 eax, r8d
  00090	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00097	41 0f 42 d1	 cmovb	 edx, r9d
  0009b	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  000a0	8d 88 1e 00 fe
	ff		 lea	 ecx, DWORD PTR [rax-131042]
  000a6	0f 42 c8	 cmovb	 ecx, eax
  000a9	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  000af	8d 81 0f 00 ff
	ff		 lea	 eax, DWORD PTR [rcx-65521]
  000b5	0f 42 c1	 cmovb	 eax, ecx
  000b8	8d 8a 0f 00 ff
	ff		 lea	 ecx, DWORD PTR [rdx-65521]
  000be	c1 e0 10	 shl	 eax, 16
  000c1	81 fa f1 ff 00
	00		 cmp	 edx, 65521		; 0000fff1H
  000c7	0f 42 ca	 cmovb	 ecx, edx
  000ca	0b c1		 or	 eax, ecx
  000cc	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 177  :     return adler32_combine_(adler1, adler2, len2);

  00000	4d 63 c0	 movsxd	 r8, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
_TEXT	ENDS
END
