; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN502
	DD	imagerel $LN502+64
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN502+64
	DD	imagerel $LN502+3709
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN502+3709
	DD	imagerel $LN502+3804
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN13+83
	DD	imagerel $LN13+192
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN13+192
	DD	imagerel $LN13+225
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN13+225
	DD	imagerel $LN13+267
	DD	imagerel $chain$4$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN502
	DD	imagerel $LN502+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0be422H
	DD	0c740eH
	DD	0d640aH
	DD	0e3404H
	DD	imagerel $LN502
	DD	imagerel $LN502+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 d6 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 cc 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c1 00 00
	00		 jne	 $LN3@inflateBac

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 a3 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 9a 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 8e 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00053	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00058	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0005d	45 33 f6	 xor	 r14d, r14d
  00060	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00064	4c 39 71 30	 cmp	 QWORD PTR [rcx+48], r14
  00068	75 0f		 jne	 SHORT $LN6@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00071	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00079	4c 39 71 38	 cmp	 QWORD PTR [rcx+56], r14
  0007d	75 0b		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  0008a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0008e	bf 01 00 00 00	 mov	 edi, 1
  00093	8b d7		 mov	 edx, edi
  00095	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0009b	ff 53 30	 call	 QWORD PTR [rbx+48]

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0009e	48 85 c0	 test	 rax, rax
  000a1	75 1d		 jne	 SHORT $LN8@inflateBac
  000a3	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN11@inflateBac:
  000a6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000ab	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 70   : }

  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5e		 pop	 rsi
  000bf	c3		 ret	 0
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c0	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000c4	8b ce		 mov	 ecx, esi
  000c6	d3 e7		 shl	 edi, cl
  000c8	89 78 34	 mov	 DWORD PTR [rax+52], edi
  000cb	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000d2	89 70 30	 mov	 DWORD PTR [rax+48], esi

; 66   :     state->window = window;

  000d5	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp

; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;

  000d9	4c 89 70 38	 mov	 QWORD PTR [rax+56], r14

; 69   :     return Z_OK;

  000dd	33 c0		 xor	 eax, eax
  000df	eb c5		 jmp	 SHORT $LN11@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e1	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000e6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000eb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5e		 pop	 rsi
  000f5	c3		 ret	 0
$LN3@inflateBac:
  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	b8 fa ff ff ff	 mov	 eax, -6
  00100	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5e		 pop	 rsi
  0010a	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 121  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 122  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN502:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e0	 mov	 r12, r8
  00024	4c 8b c1	 mov	 r8, rcx
  00027	4c 8b ea	 mov	 r13, rdx

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 4a 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 3d 0e 00
	00		 je	 $LN254@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00044	33 d2		 xor	 edx, edx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  0004e	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  00052	49 c7 47 08 3f
	3f 00 00	 mov	 QWORD PTR [r15+8], 16191 ; 00003f3fH

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  0005a	41 89 57 38	 mov	 DWORD PTR [r15+56], edx
  0005e	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14

; 282  :     next = strm->next_in;

  00062	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00065	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00069	48 85 c0	 test	 rax, rax
  0006c	74 05		 je	 SHORT $LN343@inflateBac
  0006e	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00071	eb 02		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00073	8b fa		 mov	 edi, edx
$LN344@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00075	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00079	44 8b f2	 mov	 r14d, edx
  0007c	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00080	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00085	45 8b 4f 34	 mov	 r9d, DWORD PTR [r15+52]
  00089	8b f2		 mov	 esi, edx
  0008b	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008f	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00093	83 f8 12	 cmp	 eax, 18
  00096	0f 87 aa 0d 00
	00		 ja	 $LN341@inflateBac
$LN496@inflateBac:
  0009c	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  000a3	48 98		 cdqe
  000a5	41 bb 01 00 00
	00		 mov	 r11d, 1
  000ab	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN473@inflateBac[r10+rax*4]
  000b3	49 03 ca	 add	 rcx, r10
  000b6	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000b8	41 83 7f 0c 00	 cmp	 DWORD PTR [r15+12], 0
  000bd	74 17		 je	 SHORT $LN12@inflateBac

; 295  :                 BYTEBITS();

  000bf	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c1	41 c7 47 08 50
	3f 00 00	 mov	 DWORD PTR [r15+8], 16208 ; 00003f50H
  000c9	83 e1 07	 and	 ecx, 7
  000cc	41 d3 ee	 shr	 r14d, cl
  000cf	2b f1		 sub	 esi, ecx

; 297  :                 break;

  000d1	e9 1c 0d 00 00	 jmp	 $LN480@inflateBac
$LN12@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000d6	83 fe 03	 cmp	 esi, 3
  000d9	73 43		 jae	 SHORT $LN10@inflateBac
  000db	0f 1f 44 00 00	 npad	 5
$LL13@inflateBac:
  000e0	85 ff		 test	 edi, edi
  000e2	75 14		 jne	 SHORT $LN18@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cc	 mov	 rcx, r12
  000eb	41 ff d5	 call	 r13
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 15 0d 00
	00		 je	 $LN369@inflateBac
$LN18@inflateBac:
  000f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  000fc	8b ce		 mov	 ecx, esi
  000fe	ff cf		 dec	 edi
  00100	83 c6 08	 add	 esi, 8
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0010a	d3 e0		 shl	 eax, cl
  0010c	44 03 f0	 add	 r14d, eax
  0010f	83 fe 03	 cmp	 esi, 3
  00112	72 cc		 jb	 SHORT $LL13@inflateBac
  00114	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00118	33 d2		 xor	 edx, edx
  0011a	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN10@inflateBac:

; 300  :             state->last = BITS(1);

  0011e	41 8b c6	 mov	 eax, r14d

; 301  :             DROPBITS(1);

  00121	41 d1 ee	 shr	 r14d, 1
  00124	83 e0 01	 and	 eax, 1
  00127	41 89 47 0c	 mov	 DWORD PTR [r15+12], eax

; 302  :             switch (BITS(2)) {

  0012b	41 8b c6	 mov	 eax, r14d
  0012e	83 e0 03	 and	 eax, 3
  00131	74 5e		 je	 SHORT $LN259@inflateBac
  00133	83 e8 01	 sub	 eax, 1
  00136	74 3d		 je	 SHORT $LN260@inflateBac
  00138	83 e8 01	 sub	 eax, 1
  0013b	74 24		 je	 SHORT $LN261@inflateBac
  0013d	83 f8 01	 cmp	 eax, 1
  00140	75 57		 jne	 SHORT $LN28@inflateBac

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00149	41 c1 ee 02	 shr	 r14d, 2
  0014d	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00151	83 c6 fd	 add	 esi, -3			; fffffffdH
  00154	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 324  :             break;

  0015c	e9 91 0c 00 00	 jmp	 $LN480@inflateBac
$LN261@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00161	41 c1 ee 02	 shr	 r14d, 2
  00165	83 c6 fd	 add	 esi, -3			; fffffffdH
  00168	41 c7 47 08 44
	3f 00 00	 mov	 DWORD PTR [r15+8], 16196 ; 00003f44H

; 324  :             break;

  00170	e9 7d 0c 00 00	 jmp	 $LN480@inflateBac
$LN260@inflateBac:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00175	49 8b cf	 mov	 rcx, r15
  00178	e8 00 00 00 00	 call	 fixedtables

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0017d	41 c1 ee 02	 shr	 r14d, 2
  00181	83 c6 fd	 add	 esi, -3			; fffffffdH
  00184	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 324  :             break;

  0018c	e9 61 0c 00 00	 jmp	 $LN480@inflateBac
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  00191	41 c7 47 08 41
	3f 00 00	 mov	 DWORD PTR [r15+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00199	41 c1 ee 02	 shr	 r14d, 2
  0019d	83 c6 fd	 add	 esi, -3			; fffffffdH

; 324  :             break;

  001a0	e9 4d 0c 00 00	 jmp	 $LN480@inflateBac
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001a5	8b ce		 mov	 ecx, esi
  001a7	83 e1 07	 and	 ecx, 7
  001aa	41 d3 ee	 shr	 r14d, cl
  001ad	2b f1		 sub	 esi, ecx

; 329  :             NEEDBITS(32);

  001af	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b2	73 3e		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b4	85 ff		 test	 edi, edi
  001b6	75 14		 jne	 SHORT $LN40@inflateBac
  001b8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001bc	49 8b cc	 mov	 rcx, r12
  001bf	41 ff d5	 call	 r13
  001c2	8b f8		 mov	 edi, eax
  001c4	85 c0		 test	 eax, eax
  001c6	0f 84 41 0c 00
	00		 je	 $LN369@inflateBac
$LN40@inflateBac:
  001cc	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  001d0	8b ce		 mov	 ecx, esi
  001d2	ff cf		 dec	 edi
  001d4	83 c6 08	 add	 esi, 8
  001d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001da	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  001de	d3 e0		 shl	 eax, cl
  001e0	44 03 f0	 add	 r14d, eax
  001e3	83 fe 20	 cmp	 esi, 32			; 00000020H
  001e6	72 cc		 jb	 SHORT $LL35@inflateBac
  001e8	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ec	33 d2		 xor	 edx, edx
  001ee	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f2	41 8b c6	 mov	 eax, r14d
  001f5	41 0f b7 ce	 movzx	 ecx, r14w
  001f9	f7 d0		 not	 eax
  001fb	c1 e8 10	 shr	 eax, 16
  001fe	3b c8		 cmp	 ecx, eax
  00200	74 18		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00202	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00209	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 332  :                 state->mode = BAD;

  0020d	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 333  :                 break;

  00215	e9 d8 0b 00 00	 jmp	 $LN480@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  0021a	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  0021e	44 8b f2	 mov	 r14d, edx
  00221	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00223	85 c9		 test	 ecx, ecx
  00225	0f 84 97 00 00
	00		 je	 $LN47@inflateBac
  0022b	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  0022f	90		 npad	 1
$LL46@inflateBac:

; 342  :                 copy = state->length;

  00230	45 8b 67 50	 mov	 r12d, DWORD PTR [r15+80]

; 343  :                 PULL();

  00234	85 ff		 test	 edi, edi
  00236	75 14		 jne	 SHORT $LN48@inflateBac
  00238	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0023c	49 8b cd	 mov	 rcx, r13
  0023f	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00242	8b f8		 mov	 edi, eax
  00244	85 c0		 test	 eax, eax
  00246	0f 84 c1 0b 00
	00		 je	 $LN369@inflateBac
$LN48@inflateBac:

; 344  :                 ROOM();

  0024c	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  0024f	85 db		 test	 ebx, ebx
  00251	75 28		 jne	 SHORT $LN51@inflateBac
  00253	41 8b 5f 34	 mov	 ebx, DWORD PTR [r15+52]
  00257	44 8b c3	 mov	 r8d, ebx
  0025a	49 8b 47 40	 mov	 rax, QWORD PTR [r15+64]
  0025e	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00262	48 8b d0	 mov	 rdx, rax
  00265	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  00269	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  0026c	41 89 5f 38	 mov	 DWORD PTR [r15+56], ebx
  00270	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00273	85 c0		 test	 eax, eax
  00275	0f 85 9a 0b 00
	00		 jne	 $LN372@inflateBac
$LN51@inflateBac:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  0027b	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0027f	44 3b e7	 cmp	 r12d, edi
  00282	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00286	44 0f 47 e7	 cmova	 r12d, edi
  0028a	44 3b e3	 cmp	 r12d, ebx
  0028d	44 0f 47 e3	 cmova	 r12d, ebx
  00291	45 8b c4	 mov	 r8d, r12d
  00294	41 8b dc	 mov	 ebx, r12d
  00297	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;
; 350  :                 left -= copy;

  0029c	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002a0	41 2b fc	 sub	 edi, r12d
  002a3	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx
  002a7	45 2b cc	 sub	 r9d, r12d

; 351  :                 put += copy;

  002aa	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx

; 352  :                 state->length -= copy;

  002ae	45 29 67 50	 sub	 DWORD PTR [r15+80], r12d
  002b2	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002b6	0f 85 74 ff ff
	ff		 jne	 $LL46@inflateBac
  002bc	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002c0	33 d2		 xor	 edx, edx
$LN47@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  002c2	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH

; 356  :             break;

  002ca	e9 1f 0b 00 00	 jmp	 $LN489@inflateBac
$LN56@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002cf	83 fe 0e	 cmp	 esi, 14
  002d2	73 43		 jae	 SHORT $LN54@inflateBac
$LL57@inflateBac:
  002d4	85 ff		 test	 edi, edi
  002d6	75 14		 jne	 SHORT $LN62@inflateBac
  002d8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002dc	49 8b cc	 mov	 rcx, r12
  002df	41 ff d5	 call	 r13
  002e2	8b f8		 mov	 edi, eax
  002e4	85 c0		 test	 eax, eax
  002e6	0f 84 21 0b 00
	00		 je	 $LN369@inflateBac
$LN62@inflateBac:
  002ec	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  002f0	8b ce		 mov	 ecx, esi
  002f2	ff cf		 dec	 edi
  002f4	83 c6 08	 add	 esi, 8
  002f7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002fa	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  002fe	d3 e0		 shl	 eax, cl
  00300	44 03 f0	 add	 r14d, eax
  00303	83 fe 0e	 cmp	 esi, 14
  00306	72 cc		 jb	 SHORT $LL57@inflateBac
  00308	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0030c	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  00313	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN54@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  00317	41 8b c6	 mov	 eax, r14d

; 362  :             DROPBITS(5);
; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  0031a	83 c6 f2	 add	 esi, -14		; fffffff2H
  0031d	41 c1 ee 05	 shr	 r14d, 5
  00321	83 e0 1f	 and	 eax, 31
  00324	41 8b ce	 mov	 ecx, r14d
  00327	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0032c	41 c1 ee 05	 shr	 r14d, 5
  00330	83 e1 1f	 and	 ecx, 31
  00333	41 8b d6	 mov	 edx, r14d
  00336	41 89 47 7c	 mov	 DWORD PTR [r15+124], eax
  0033a	83 e2 0f	 and	 edx, 15
  0033d	41 c1 ee 04	 shr	 r14d, 4
  00341	83 c2 04	 add	 edx, 4
  00344	ff c1		 inc	 ecx
  00346	41 89 8f 80 00
	00 00		 mov	 DWORD PTR [r15+128], ecx
  0034d	41 89 57 78	 mov	 DWORD PTR [r15+120], edx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00351	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  00356	0f 87 62 05 00
	00		 ja	 $LN277@inflateBac
  0035c	83 f9 1e	 cmp	 ecx, 30
  0035f	0f 87 59 05 00
	00		 ja	 $LN277@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  00365	33 c9		 xor	 ecx, ecx
  00367	41 89 8f 84 00
	00 00		 mov	 DWORD PTR [r15+132], ecx

; 378  :             while (state->have < state->ncode) {

  0036e	85 d2		 test	 edx, edx
  00370	0f 84 8a 00 00
	00		 je	 $LN352@inflateBac
$LL74@inflateBac:

; 379  :                 NEEDBITS(3);

  00376	83 fe 03	 cmp	 esi, 3
  00379	73 43		 jae	 SHORT $LN76@inflateBac
  0037b	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0037f	90		 npad	 1
$LL79@inflateBac:
  00380	85 ff		 test	 edi, edi
  00382	75 18		 jne	 SHORT $LN84@inflateBac
  00384	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00388	49 8b cc	 mov	 rcx, r12
  0038b	41 ff d5	 call	 r13
  0038e	8b f8		 mov	 edi, eax
  00390	85 c0		 test	 eax, eax
  00392	0f 84 75 0a 00
	00		 je	 $LN369@inflateBac
  00398	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  0039c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0039f	8b ce		 mov	 ecx, esi
  003a1	d3 e0		 shl	 eax, cl
  003a3	48 ff c2	 inc	 rdx
  003a6	44 03 f0	 add	 r14d, eax
  003a9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003ad	ff cf		 dec	 edi
  003af	83 c6 08	 add	 esi, 8
  003b2	83 fe 03	 cmp	 esi, 3
  003b5	72 c9		 jb	 SHORT $LL79@inflateBac
  003b7	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003be	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003c5	41 0f b7 ce	 movzx	 ecx, r14w
  003c9	66 83 e1 07	 and	 cx, 7

; 381  :                 DROPBITS(3);

  003cd	41 c1 ee 03	 shr	 r14d, 3
  003d1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003d4	41 0f b7 84 42
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r10+rax*2]
  003dd	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  003e6	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  003ed	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003f4	41 3b 47 78	 cmp	 eax, DWORD PTR [r15+120]
  003f8	0f 82 78 ff ff
	ff		 jb	 $LL74@inflateBac
  003fe	33 c9		 xor	 ecx, ecx
$LN352@inflateBac:

; 382  :             }
; 383  :             while (state->have < 19)

  00400	41 83 bf 84 00
	00 00 13	 cmp	 DWORD PTR [r15+132], 19
  00408	73 30		 jae	 SHORT $LN91@inflateBac
  0040a	66 0f 1f 44 00
	00		 npad	 6
$LL90@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  00410	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00417	41 0f b7 84 42
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r10+rax*2]
  00420	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00429	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  00430	41 83 bf 84 00
	00 00 13	 cmp	 DWORD PTR [r15+132], 19
  00438	72 d6		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  0043a	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  00441	41 c7 47 70 07
	00 00 00	 mov	 DWORD PTR [r15+112], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00449	49 8d 97 10 03
	00 00		 lea	 rdx, QWORD PTR [r15+784]
  00450	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  00457	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0045c	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00463	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  00467	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  0046e	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  00472	41 b8 13 00 00
	00		 mov	 r8d, 19
  00478	33 c9		 xor	 ecx, ecx
  0047a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047f	e8 00 00 00 00	 call	 inflate_table

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  00484	85 c0		 test	 eax, eax
  00486	74 22		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  00488	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN499@inflateBac:
  0048f	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00493	33 d2		 xor	 edx, edx
  00495	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00499	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  0049d	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  004a5	e9 48 09 00 00	 jmp	 $LN480@inflateBac
$LN280@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004aa	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  004b1	41 c7 87 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r15+132], 0
  004bc	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  004c0	0f 84 78 02 00
	00		 je	 $LN93@inflateBac
  004c6	49 8d 5f 70	 lea	 rbx, QWORD PTR [r15+112]
  004ca	66 0f 1f 44 00
	00		 npad	 6
$LL92@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004d0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004d2	b8 01 00 00 00	 mov	 eax, 1

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004d7	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  004db	d3 e0		 shl	 eax, cl
  004dd	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004e0	41 8b c6	 mov	 eax, r14d
  004e3	48 23 c8	 and	 rcx, rax
  004e6	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  004ea	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004ed	8b c8		 mov	 ecx, eax
  004ef	c1 e9 08	 shr	 ecx, 8
  004f2	0f b6 c9	 movzx	 ecx, cl
  004f5	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  004f8	3b ce		 cmp	 ecx, esi
  004fa	76 5e		 jbe	 SHORT $LN375@inflateBac
  004fc	0f 1f 40 00	 npad	 4
$LL94@inflateBac:

; 403  :                     PULLBYTE();

  00500	85 ff		 test	 edi, edi
  00502	75 18		 jne	 SHORT $LN100@inflateBac
  00504	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00508	49 8b cc	 mov	 rcx, r12
  0050b	41 ff d5	 call	 r13
  0050e	8b f8		 mov	 edi, eax
  00510	85 c0		 test	 eax, eax
  00512	0f 84 f5 08 00
	00		 je	 $LN369@inflateBac
  00518	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  0051c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0051f	8b ce		 mov	 ecx, esi
  00521	d3 e0		 shl	 eax, cl
  00523	48 ff c2	 inc	 rdx
  00526	44 03 f0	 add	 r14d, eax
  00529	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  0052d	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0052f	b8 01 00 00 00	 mov	 eax, 1
  00534	d3 e0		 shl	 eax, cl
  00536	ff cf		 dec	 edi
  00538	83 c6 08	 add	 esi, 8
  0053b	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0053e	41 8b c6	 mov	 eax, r14d
  00541	48 23 c8	 and	 rcx, rax
  00544	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00548	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0054b	8b c8		 mov	 ecx, eax
  0054d	c1 e9 08	 shr	 ecx, 8
  00550	0f b6 c9	 movzx	 ecx, cl
  00553	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00556	3b ce		 cmp	 ecx, esi
  00558	77 a6		 ja	 SHORT $LL94@inflateBac
$LN375@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  0055a	44 8b c0	 mov	 r8d, eax
  0055d	41 c1 e8 10	 shr	 r8d, 16
  00561	66 41 83 f8 10	 cmp	 r8w, 16
  00566	73 2e		 jae	 SHORT $LN490@inflateBac

; 406  :                     DROPBITS(here.bits);

  00568	c1 e8 08	 shr	 eax, 8
  0056b	0f b6 c8	 movzx	 ecx, al

; 407  :                     state->lens[state->have++] = here.val;

  0056e	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00575	2b f1		 sub	 esi, ecx
  00577	41 d3 ee	 shr	 r14d, cl
  0057a	66 45 89 84 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r8w
  00583	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  0058a	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]

; 408  :                 }

  00591	e9 91 01 00 00	 jmp	 $LN406@inflateBac
$LN490@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  00596	75 7b		 jne	 SHORT $LN286@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  00598	c1 e8 08	 shr	 eax, 8
  0059b	0f b6 d8	 movzx	 ebx, al
  0059e	83 c3 02	 add	 ebx, 2
  005a1	3b f3		 cmp	 esi, ebx
  005a3	73 36		 jae	 SHORT $LN106@inflateBac
$LL109@inflateBac:
  005a5	85 ff		 test	 edi, edi
  005a7	75 18		 jne	 SHORT $LN114@inflateBac
  005a9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005ad	49 8b cc	 mov	 rcx, r12
  005b0	41 ff d5	 call	 r13
  005b3	8b f8		 mov	 edi, eax
  005b5	85 c0		 test	 eax, eax
  005b7	0f 84 50 08 00
	00		 je	 $LN369@inflateBac
  005bd	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005c1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  005c4	8b ce		 mov	 ecx, esi
  005c6	d3 e0		 shl	 eax, cl
  005c8	48 ff c2	 inc	 rdx
  005cb	44 03 f0	 add	 r14d, eax
  005ce	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  005d2	ff cf		 dec	 edi
  005d4	83 c6 08	 add	 esi, 8
  005d7	3b f3		 cmp	 esi, ebx
  005d9	72 ca		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 412  :                         DROPBITS(here.bits);

  005db	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 413  :                         if (state->have == 0) {

  005df	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  005e6	2b f1		 sub	 esi, ecx
  005e8	41 d3 ee	 shr	 r14d, cl
  005eb	85 c0		 test	 eax, eax
  005ed	0f 84 70 01 00
	00		 je	 $LN380@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";
; 415  :                             state->mode = BAD;
; 416  :                             break;
; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  005f3	41 8b d6	 mov	 edx, r14d
  005f6	ff c8		 dec	 eax
  005f8	83 e2 03	 and	 edx, 3

; 420  :                         DROPBITS(2);

  005fb	41 c1 ee 02	 shr	 r14d, 2
  005ff	83 c2 03	 add	 edx, 3
  00602	83 c6 fe	 add	 esi, -2			; fffffffeH
  00605	45 0f b7 84 47
	90 00 00 00	 movzx	 r8d, WORD PTR [r15+rax*2+144]

; 421  :                     }

  0060e	e9 c7 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  00613	66 83 7d be 11	 cmp	 WORD PTR here$[rbp-118], 17

; 423  :                         NEEDBITS(here.bits + 3);

  00618	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR here$[rbp-119]
  0061d	75 58		 jne	 SHORT $LN142@inflateBac
  0061f	41 8d 5d 03	 lea	 ebx, DWORD PTR [r13+3]
  00623	3b f3		 cmp	 esi, ebx
  00625	73 36		 jae	 SHORT $LN123@inflateBac
$LL126@inflateBac:
  00627	85 ff		 test	 edi, edi
  00629	75 18		 jne	 SHORT $LN131@inflateBac
  0062b	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0062f	49 8b cc	 mov	 rcx, r12
  00632	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00635	8b f8		 mov	 edi, eax
  00637	85 c0		 test	 eax, eax
  00639	0f 84 ce 07 00
	00		 je	 $LN369@inflateBac
  0063f	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  00643	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00646	8b ce		 mov	 ecx, esi
  00648	d3 e0		 shl	 eax, cl
  0064a	48 ff c2	 inc	 rdx
  0064d	44 03 f0	 add	 r14d, eax
  00650	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00654	ff cf		 dec	 edi
  00656	83 c6 08	 add	 esi, 8
  00659	3b f3		 cmp	 esi, ebx
  0065b	72 ca		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 424  :                         DROPBITS(here.bits);

  0065d	41 8b cd	 mov	 ecx, r13d

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  00660	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00665	41 d3 ee	 shr	 r14d, cl
  00668	41 8b d6	 mov	 edx, r14d
  0066b	83 e2 07	 and	 edx, 7
  0066e	83 c2 03	 add	 edx, 3
  00671	41 c1 ee 03	 shr	 r14d, 3

; 428  :                     }

  00675	eb 57		 jmp	 SHORT $LN491@inflateBac
$LN142@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  00677	41 8d 5d 07	 lea	 ebx, DWORD PTR [r13+7]
  0067b	3b f3		 cmp	 esi, ebx
  0067d	73 37		 jae	 SHORT $LN140@inflateBac
  0067f	90		 npad	 1
$LL143@inflateBac:
  00680	85 ff		 test	 edi, edi
  00682	75 18		 jne	 SHORT $LN148@inflateBac
  00684	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00688	49 8b cc	 mov	 rcx, r12
  0068b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0068e	8b f8		 mov	 edi, eax
  00690	85 c0		 test	 eax, eax
  00692	0f 84 75 07 00
	00		 je	 $LN369@inflateBac
  00698	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  0069c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0069f	8b ce		 mov	 ecx, esi
  006a1	d3 e0		 shl	 eax, cl
  006a3	48 ff c2	 inc	 rdx
  006a6	44 03 f0	 add	 r14d, eax
  006a9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  006ad	ff cf		 dec	 edi
  006af	83 c6 08	 add	 esi, 8
  006b2	3b f3		 cmp	 esi, ebx
  006b4	72 ca		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 431  :                         DROPBITS(here.bits);

  006b6	41 8b cd	 mov	 ecx, r13d

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006b9	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006be	41 d3 ee	 shr	 r14d, cl
  006c1	41 8b d6	 mov	 edx, r14d
  006c4	83 e2 7f	 and	 edx, 127		; 0000007fH
  006c7	83 c2 0b	 add	 edx, 11
  006ca	41 c1 ee 07	 shr	 r14d, 7
$LN491@inflateBac:
  006ce	41 2b c5	 sub	 eax, r13d
  006d1	45 33 c0	 xor	 r8d, r8d
  006d4	4c 8b 6d 30	 mov	 r13, QWORD PTR in$[rbp-120]
  006d8	03 f0		 add	 esi, eax
$LN155@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  006da	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  006e1	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  006e8	03 ca		 add	 ecx, edx
  006ea	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  006ee	3b c8		 cmp	 ecx, eax
  006f0	77 71		 ja	 SHORT $LN380@inflateBac
  006f2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL157@inflateBac:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)
; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00700	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00707	66 45 89 84 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r8w
  00710	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  00717	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  0071e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00721	75 dd		 jne	 SHORT $LL157@inflateBac
  00723	49 8d 5f 70	 lea	 rbx, QWORD PTR [r15+112]
$LN406@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  00727	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  0072e	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00732	3b c8		 cmp	 ecx, eax
  00734	0f 82 96 fd ff
	ff		 jb	 $LL92@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  0073a	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN93@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  0073e	41 81 7f 08 51
	3f 00 00	 cmp	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00746	0f 84 68 03 00
	00		 je	 $LN487@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  0074c	66 41 83 bf 90
	02 00 00 00	 cmp	 WORD PTR [r15+656], 0
  00755	75 1c		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00757	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;
; 453  :                 break;

  0075e	e9 2c fd ff ff	 jmp	 $LN499@inflateBac
$LN380@inflateBac:

; 532  :                 strm->msg = (char *)"invalid literal/length code";
; 533  :                 state->mode = BAD;
; 534  :                 break;

  00763	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00767	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  0076e	e9 1c fd ff ff	 jmp	 $LN499@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00773	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;

  0077a	41 c7 47 70 09
	00 00 00	 mov	 DWORD PTR [r15+112], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00782	4d 8d 87 10 03
	00 00		 lea	 r8, QWORD PTR [r15+784]
  00789	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  00790	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00795	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  0079c	45 8b 47 7c	 mov	 r8d, DWORD PTR [r15+124]
  007a0	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  007a7	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007ab	b9 01 00 00 00	 mov	 ecx, 1
  007b0	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  007b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b9	e8 00 00 00 00	 call	 inflate_table

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  007be	85 c0		 test	 eax, eax
  007c0	74 0c		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  007c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;
; 467  :                 break;

  007c9	e9 c1 fc ff ff	 jmp	 $LN499@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);
; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  007ce	45 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [r15+128]
  007d5	49 8d 4f 74	 lea	 rcx, QWORD PTR [r15+116]
  007d9	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  007e0	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  007e6	49 8b 01	 mov	 rax, QWORD PTR [r9]
  007e9	49 89 47 68	 mov	 QWORD PTR [r15+104], rax
  007ed	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  007f1	48 83 c0 48	 add	 rax, 72			; 00000048H
  007f5	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  007f9	49 8d 87 10 03
	00 00		 lea	 rax, QWORD PTR [r15+784]
  00800	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00805	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0080a	b9 02 00 00 00	 mov	 ecx, 2
  0080f	e8 00 00 00 00	 call	 inflate_table

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {
; 474  :                 strm->msg = (char *)"invalid distances set";

  00814	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 475  :                 state->mode = BAD;
; 476  :                 break;

  00818	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0081c	85 c0		 test	 eax, eax
  0081e	74 1a		 je	 SHORT $LN301@inflateBac

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00820	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00827	33 d2		 xor	 edx, edx
  00829	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  0082d	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00835	e9 b8 05 00 00	 jmp	 $LN480@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  0083a	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
  00842	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN302@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00848	83 ff 06	 cmp	 edi, 6
  0084b	0f 82 87 00 00
	00		 jb	 $LN303@inflateBac
  00851	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00858	72 7e		 jb	 SHORT $LN303@inflateBac

; 484  :                 RESTORE();

  0085a	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  0085e	49 89 00	 mov	 QWORD PTR [r8], rax
  00861	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  00865	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  00869	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 485  :                 if (state->whave < state->wsize)

  0086d	41 8b 57 34	 mov	 edx, DWORD PTR [r15+52]
  00871	45 89 77 48	 mov	 DWORD PTR [r15+72], r14d
  00875	41 89 77 4c	 mov	 DWORD PTR [r15+76], esi
  00879	41 39 57 38	 cmp	 DWORD PTR [r15+56], edx
  0087d	73 09		 jae	 SHORT $LN304@inflateBac

; 486  :                     state->whave = state->wsize - left;

  0087f	8b c2		 mov	 eax, edx
  00881	41 2b c1	 sub	 eax, r9d
  00884	41 89 47 38	 mov	 DWORD PTR [r15+56], eax
$LN304@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  00888	49 8b c8	 mov	 rcx, r8
  0088b	e8 00 00 00 00	 call	 inflate_fast

; 488  :                 LOAD();

  00890	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00894	33 d2		 xor	 edx, edx
  00896	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00899	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  0089d	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  008a1	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  008a5	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  008a9	45 8b 77 48	 mov	 r14d, DWORD PTR [r15+72]
  008ad	41 8b 77 4c	 mov	 esi, DWORD PTR [r15+76]
  008b1	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  008b5	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  008b9	e9 34 05 00 00	 jmp	 $LN480@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  008be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;
; 371  :                 break;

  008c5	33 d2		 xor	 edx, edx
  008c7	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  008cb	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  008d3	e9 1a 05 00 00	 jmp	 $LN480@inflateBac
$LN303@inflateBac:

; 489  :                 break;
; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  008d8	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  008dc	41 8b c3	 mov	 eax, r11d
  008df	d3 e0		 shl	 eax, cl
  008e1	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  008e4	41 8b c6	 mov	 eax, r14d
  008e7	48 23 c8	 and	 rcx, rax
  008ea	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  008ee	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  008f1	8b c8		 mov	 ecx, eax
  008f3	c1 e9 08	 shr	 ecx, 8
  008f6	0f b6 c9	 movzx	 ecx, cl
  008f9	3b ce		 cmp	 ecx, esi
  008fb	76 5d		 jbe	 SHORT $LN382@inflateBac
  008fd	0f 1f 00	 npad	 3
$LL165@inflateBac:

; 496  :                 PULLBYTE();

  00900	85 ff		 test	 edi, edi
  00902	75 1a		 jne	 SHORT $LN171@inflateBac
  00904	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00908	49 8b cc	 mov	 rcx, r12
  0090b	41 ff d5	 call	 r13
  0090e	8b f8		 mov	 edi, eax
  00910	85 c0		 test	 eax, eax
  00912	0f 84 f5 04 00
	00		 je	 $LN369@inflateBac
  00918	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN171@inflateBac:
  0091e	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00922	8b ce		 mov	 ecx, esi
  00924	ff cf		 dec	 edi
  00926	83 c6 08	 add	 esi, 8
  00929	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0092c	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00930	d3 e0		 shl	 eax, cl
  00932	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00936	44 03 f0	 add	 r14d, eax
  00939	41 8b c3	 mov	 eax, r11d
  0093c	d3 e0		 shl	 eax, cl
  0093e	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00941	41 8b c6	 mov	 eax, r14d
  00944	48 23 c8	 and	 rcx, rax
  00947	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  0094b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0094e	8b c8		 mov	 ecx, eax
  00950	c1 e9 08	 shr	 ecx, 8
  00953	0f b6 c9	 movzx	 ecx, cl
  00956	3b ce		 cmp	 ecx, esi
  00958	77 a6		 ja	 SHORT $LL165@inflateBac
$LN382@inflateBac:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  0095a	84 c0		 test	 al, al
  0095c	0f 84 d6 00 00
	00		 je	 $LN184@inflateBac
  00962	a8 f0		 test	 al, 240			; 000000f0H
  00964	0f 85 ce 00 00
	00		 jne	 $LN184@inflateBac

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +

  0096a	44 8b c8	 mov	 r9d, eax
  0096d	0f b6 c8	 movzx	 ecx, al
  00970	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax
  00973	8b d8		 mov	 ebx, eax

; 502  :                             (BITS(last.bits + last.op) >> last.bits)];
; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00975	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR last$[rbp-119]
  0097a	45 8b c3	 mov	 r8d, r11d
  0097d	c1 e8 10	 shr	 eax, 16
  00980	41 c1 e9 08	 shr	 r9d, 8
  00984	41 0f b6 d1	 movzx	 edx, r9b
  00988	03 ca		 add	 ecx, edx
  0098a	41 d3 e0	 shl	 r8d, cl
  0098d	8b ca		 mov	 ecx, edx
  0098f	41 ff c8	 dec	 r8d
  00992	45 23 c6	 and	 r8d, r14d
  00995	41 d3 e8	 shr	 r8d, cl
  00998	44 03 c0	 add	 r8d, eax
  0099b	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  0099f	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  009a3	8b c8		 mov	 ecx, eax
  009a5	c1 e9 08	 shr	 ecx, 8
  009a8	0f b6 d1	 movzx	 edx, cl
  009ab	41 0f b6 c9	 movzx	 ecx, r9b
  009af	03 d1		 add	 edx, ecx
  009b1	3b d6		 cmp	 edx, esi
  009b3	76 76		 jbe	 SHORT $LN185@inflateBac
  009b5	44 0f b7 6d be	 movzx	 r13d, WORD PTR last$[rbp-118]
  009ba	66 0f 1f 44 00
	00		 npad	 6
$LL174@inflateBac:

; 504  :                     PULLBYTE();

  009c0	85 ff		 test	 edi, edi
  009c2	75 1b		 jne	 SHORT $LN180@inflateBac
  009c4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009c8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009cc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009cf	8b f8		 mov	 edi, eax
  009d1	85 c0		 test	 eax, eax
  009d3	0f 84 34 04 00
	00		 je	 $LN369@inflateBac
  009d9	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN180@inflateBac:
  009df	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  009e3	8b ce		 mov	 ecx, esi
  009e5	45 0f b6 c4	 movzx	 r8d, r12b
  009e9	41 8b d3	 mov	 edx, r11d
  009ec	ff cf		 dec	 edi
  009ee	83 c6 08	 add	 esi, 8
  009f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009f4	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  009f8	d3 e0		 shl	 eax, cl
  009fa	44 03 f0	 add	 r14d, eax
  009fd	0f b6 cb	 movzx	 ecx, bl
  00a00	41 03 c8	 add	 ecx, r8d
  00a03	41 0f b7 c5	 movzx	 eax, r13w
  00a07	d3 e2		 shl	 edx, cl
  00a09	41 8b c8	 mov	 ecx, r8d
  00a0c	ff ca		 dec	 edx
  00a0e	41 23 d6	 and	 edx, r14d
  00a11	d3 ea		 shr	 edx, cl
  00a13	03 d0		 add	 edx, eax
  00a15	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00a19	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a1c	8b c8		 mov	 ecx, eax
  00a1e	c1 e9 08	 shr	 ecx, 8
  00a21	0f b6 d1	 movzx	 edx, cl
  00a24	41 03 d0	 add	 edx, r8d
  00a27	3b d6		 cmp	 edx, esi
  00a29	77 95		 ja	 SHORT $LL174@inflateBac
$LN185@inflateBac:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  00a2b	41 0f b6 cc	 movzx	 ecx, r12b
  00a2f	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
  00a33	41 d3 ee	 shr	 r14d, cl
  00a36	2b f1		 sub	 esi, ecx
$LN184@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00a38	8b c8		 mov	 ecx, eax
  00a3a	c1 e9 08	 shr	 ecx, 8
  00a3d	0f b6 c9	 movzx	 ecx, cl
  00a40	41 d3 ee	 shr	 r14d, cl
  00a43	2b f1		 sub	 esi, ecx

; 509  :             state->length = (unsigned)here.val;

  00a45	8b c8		 mov	 ecx, eax
  00a47	c1 e9 10	 shr	 ecx, 16
  00a4a	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00a4e	84 c0		 test	 al, al
  00a50	75 52		 jne	 SHORT $LN312@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00a52	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a56	45 85 e4	 test	 r12d, r12d
  00a59	75 23		 jne	 SHORT $LN486@inflateBac
  00a5b	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00a5f	45 8b c4	 mov	 r8d, r12d
  00a62	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00a66	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a6a	48 8b d3	 mov	 rdx, rbx
  00a6d	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00a71	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00a74	85 c0		 test	 eax, eax
  00a76	0f 85 99 03 00
	00		 jne	 $LN372@inflateBac
  00a7c	eb 04		 jmp	 SHORT $LN189@inflateBac
$LN486@inflateBac:
  00a7e	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 517  :                 *put++ = (unsigned char)(state->length);

  00a82	41 0f b6 47 50	 movzx	 eax, BYTE PTR [r15+80]
  00a87	88 03		 mov	 BYTE PTR [rbx], al
  00a89	48 ff c3	 inc	 rbx

; 518  :                 left--;

  00a8c	41 ff cc	 dec	 r12d
  00a8f	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00a93	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d

; 519  :                 state->mode = LEN;

  00a97	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 520  :                 break;

  00a9f	e9 45 03 00 00	 jmp	 $LN488@inflateBac
$LN312@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00aa4	a8 20		 test	 al, 32			; 00000020H
  00aa6	74 15		 je	 SHORT $LN315@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;
; 527  :                 break;

  00aa8	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00aac	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
$LN487@inflateBac:
  00ab4	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00ab8	e9 2f 03 00 00	 jmp	 $LN492@inflateBac
$LN315@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00abd	a8 40		 test	 al, 64			; 00000040H
  00abf	74 10		 je	 SHORT $LN316@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";
; 533  :                 state->mode = BAD;
; 534  :                 break;

  00ac1	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ac5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00acc	e9 be f9 ff ff	 jmp	 $LN499@inflateBac
$LN316@inflateBac:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00ad1	0f b6 c8	 movzx	 ecx, al
  00ad4	83 e1 0f	 and	 ecx, 15
  00ad7	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 539  :             if (state->extra != 0) {

  00adb	74 5d		 je	 SHORT $LN204@inflateBac

; 540  :                 NEEDBITS(state->extra);

  00add	3b f1		 cmp	 esi, ecx
  00adf	73 42		 jae	 SHORT $LN192@inflateBac
  00ae1	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL195@inflateBac:
  00ae5	85 ff		 test	 edi, edi
  00ae7	75 18		 jne	 SHORT $LN200@inflateBac
  00ae9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00aed	49 8b cc	 mov	 rcx, r12
  00af0	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00af3	8b f8		 mov	 edi, eax
  00af5	85 c0		 test	 eax, eax
  00af7	0f 84 10 03 00
	00		 je	 $LN369@inflateBac
  00afd	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b01	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b04	8b ce		 mov	 ecx, esi
  00b06	d3 e0		 shl	 eax, cl
  00b08	48 ff c2	 inc	 rdx
  00b0b	44 03 f0	 add	 r14d, eax
  00b0e	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b12	ff cf		 dec	 edi
  00b14	83 c6 08	 add	 esi, 8
  00b17	41 3b 77 58	 cmp	 esi, DWORD PTR [r15+88]
  00b1b	72 c8		 jb	 SHORT $LL195@inflateBac
  00b1d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN192@inflateBac:

; 541  :                 state->length += BITS(state->extra);

  00b23	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00b27	41 8b c3	 mov	 eax, r11d
  00b2a	d3 e0		 shl	 eax, cl
  00b2c	ff c8		 dec	 eax
  00b2e	41 23 c6	 and	 eax, r14d

; 542  :                 DROPBITS(state->extra);

  00b31	41 d3 ee	 shr	 r14d, cl
  00b34	41 01 47 50	 add	 DWORD PTR [r15+80], eax
  00b38	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00b3a	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b3e	41 8b c3	 mov	 eax, r11d

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00b41	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b45	d3 e0		 shl	 eax, cl
  00b47	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b4a	41 8b c6	 mov	 eax, r14d
  00b4d	48 23 c8	 and	 rcx, rax
  00b50	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00b54	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00b57	8b c8		 mov	 ecx, eax
  00b59	c1 e9 08	 shr	 ecx, 8
  00b5c	0f b6 c9	 movzx	 ecx, cl
  00b5f	3b ce		 cmp	 ecx, esi
  00b61	76 5e		 jbe	 SHORT $LN387@inflateBac
$LL206@inflateBac:

; 550  :                 PULLBYTE();

  00b63	85 ff		 test	 edi, edi
  00b65	75 1e		 jne	 SHORT $LN212@inflateBac
  00b67	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b6b	49 8b cc	 mov	 rcx, r12
  00b6e	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b71	8b f8		 mov	 edi, eax
  00b73	85 c0		 test	 eax, eax
  00b75	0f 84 92 02 00
	00		 je	 $LN369@inflateBac
  00b7b	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b7f	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN212@inflateBac:
  00b85	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00b89	8b ce		 mov	 ecx, esi
  00b8b	d3 e0		 shl	 eax, cl
  00b8d	49 ff c2	 inc	 r10
  00b90	44 03 f0	 add	 r14d, eax
  00b93	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00b97	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b9b	41 8b c3	 mov	 eax, r11d
  00b9e	d3 e0		 shl	 eax, cl
  00ba0	ff cf		 dec	 edi
  00ba2	83 c6 08	 add	 esi, 8
  00ba5	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00ba8	41 8b c6	 mov	 eax, r14d
  00bab	48 23 c8	 and	 rcx, rax
  00bae	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00bb2	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bb5	8b c8		 mov	 ecx, eax
  00bb7	c1 e9 08	 shr	 ecx, 8
  00bba	0f b6 c9	 movzx	 ecx, cl
  00bbd	3b ce		 cmp	 ecx, esi
  00bbf	77 a2		 ja	 SHORT $LL206@inflateBac
$LN387@inflateBac:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00bc1	a8 f0		 test	 al, 240			; 000000f0H
  00bc3	0f 85 cf 00 00
	00		 jne	 $LN225@inflateBac

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +

  00bc9	44 8b c8	 mov	 r9d, eax
  00bcc	0f b6 c8	 movzx	 ecx, al
  00bcf	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax
  00bd2	8b d8		 mov	 ebx, eax

; 556  :                             (BITS(last.bits + last.op) >> last.bits)];
; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bd4	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR last$[rbp-119]
  00bd9	45 8b c3	 mov	 r8d, r11d
  00bdc	c1 e8 10	 shr	 eax, 16
  00bdf	41 c1 e9 08	 shr	 r9d, 8
  00be3	41 0f b6 d1	 movzx	 edx, r9b
  00be7	03 ca		 add	 ecx, edx
  00be9	41 d3 e0	 shl	 r8d, cl
  00bec	8b ca		 mov	 ecx, edx
  00bee	41 ff c8	 dec	 r8d
  00bf1	45 23 c6	 and	 r8d, r14d
  00bf4	41 d3 e8	 shr	 r8d, cl
  00bf7	44 03 c0	 add	 r8d, eax
  00bfa	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00bfe	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00c02	8b c8		 mov	 ecx, eax
  00c04	c1 e9 08	 shr	 ecx, 8
  00c07	0f b6 d1	 movzx	 edx, cl
  00c0a	41 0f b6 c9	 movzx	 ecx, r9b
  00c0e	03 d1		 add	 edx, ecx
  00c10	3b d6		 cmp	 edx, esi
  00c12	76 7b		 jbe	 SHORT $LN226@inflateBac
  00c14	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
  00c19	0f 1f 80 00 00
	00 00		 npad	 7
$LL215@inflateBac:

; 558  :                     PULLBYTE();

  00c20	85 ff		 test	 edi, edi
  00c22	75 1f		 jne	 SHORT $LN221@inflateBac
  00c24	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c28	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c2c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c2f	8b f8		 mov	 edi, eax
  00c31	85 c0		 test	 eax, eax
  00c33	0f 84 d4 01 00
	00		 je	 $LN369@inflateBac
  00c39	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c3d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN221@inflateBac:
  00c43	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c47	8b ce		 mov	 ecx, esi
  00c49	d3 e0		 shl	 eax, cl
  00c4b	41 8b d3	 mov	 edx, r11d
  00c4e	44 03 f0	 add	 r14d, eax
  00c51	45 0f b6 c5	 movzx	 r8d, r13b
  00c55	49 ff c2	 inc	 r10
  00c58	41 0f b7 c4	 movzx	 eax, r12w
  00c5c	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00c60	ff cf		 dec	 edi
  00c62	0f b6 cb	 movzx	 ecx, bl
  00c65	83 c6 08	 add	 esi, 8
  00c68	41 03 c8	 add	 ecx, r8d
  00c6b	d3 e2		 shl	 edx, cl
  00c6d	41 8b c8	 mov	 ecx, r8d
  00c70	ff ca		 dec	 edx
  00c72	41 23 d6	 and	 edx, r14d
  00c75	d3 ea		 shr	 edx, cl
  00c77	03 d0		 add	 edx, eax
  00c79	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00c7d	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00c80	8b c8		 mov	 ecx, eax
  00c82	c1 e9 08	 shr	 ecx, 8
  00c85	0f b6 d1	 movzx	 edx, cl
  00c88	41 03 d0	 add	 edx, r8d
  00c8b	3b d6		 cmp	 edx, esi
  00c8d	77 91		 ja	 SHORT $LL215@inflateBac
$LN226@inflateBac:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00c8f	41 0f b6 cd	 movzx	 ecx, r13b
  00c93	41 d3 ee	 shr	 r14d, cl
  00c96	2b f1		 sub	 esi, ecx
$LN225@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00c98	8b c8		 mov	 ecx, eax
  00c9a	c1 e9 08	 shr	 ecx, 8
  00c9d	0f b6 c9	 movzx	 ecx, cl
  00ca0	41 d3 ee	 shr	 r14d, cl
  00ca3	2b f1		 sub	 esi, ecx

; 563  :             if (here.op & 64) {

  00ca5	a8 40		 test	 al, 64			; 00000040H
  00ca7	74 10		 je	 SHORT $LN327@inflateBac

; 564  :                 strm->msg = (char *)"invalid distance code";

  00ca9	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00cad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00cb4	e9 d6 f7 ff ff	 jmp	 $LN499@inflateBac
$LN327@inflateBac:

; 565  :                 state->mode = BAD;
; 566  :                 break;
; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00cb9	8b c8		 mov	 ecx, eax
  00cbb	c1 e9 10	 shr	 ecx, 16
  00cbe	41 89 4f 54	 mov	 DWORD PTR [r15+84], ecx

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00cc2	0f b6 c8	 movzx	 ecx, al
  00cc5	83 e1 0f	 and	 ecx, 15
  00cc8	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 572  :             if (state->extra != 0) {

  00ccc	74 5e		 je	 SHORT $LN242@inflateBac

; 573  :                 NEEDBITS(state->extra);

  00cce	3b f1		 cmp	 esi, ecx
  00cd0	73 43		 jae	 SHORT $LN230@inflateBac
  00cd2	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL233@inflateBac:
  00cd6	85 ff		 test	 edi, edi
  00cd8	75 19		 jne	 SHORT $LN238@inflateBac
  00cda	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cde	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00ce2	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00ce5	8b f8		 mov	 edi, eax
  00ce7	85 c0		 test	 eax, eax
  00ce9	0f 84 1e 01 00
	00		 je	 $LN369@inflateBac
  00cef	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00cf3	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00cf6	8b ce		 mov	 ecx, esi
  00cf8	d3 e0		 shl	 eax, cl
  00cfa	48 ff c2	 inc	 rdx
  00cfd	44 03 f0	 add	 r14d, eax
  00d00	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d04	ff cf		 dec	 edi
  00d06	83 c6 08	 add	 esi, 8
  00d09	41 3b 77 58	 cmp	 esi, DWORD PTR [r15+88]
  00d0d	72 c7		 jb	 SHORT $LL233@inflateBac
  00d0f	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN230@inflateBac:

; 574  :                 state->offset += BITS(state->extra);

  00d15	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00d19	41 8b c3	 mov	 eax, r11d
  00d1c	d3 e0		 shl	 eax, cl
  00d1e	ff c8		 dec	 eax
  00d20	41 23 c6	 and	 eax, r14d

; 575  :                 DROPBITS(state->extra);

  00d23	41 d3 ee	 shr	 r14d, cl
  00d26	41 01 47 54	 add	 DWORD PTR [r15+84], eax
  00d2a	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00d2c	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00d30	33 d2		 xor	 edx, edx
  00d32	41 39 4f 38	 cmp	 DWORD PTR [r15+56], ecx
  00d36	8b c2		 mov	 eax, edx
  00d38	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d3c	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d40	41 0f 42 c4	 cmovb	 eax, r12d
  00d44	2b c8		 sub	 ecx, eax
  00d46	41 39 4f 54	 cmp	 DWORD PTR [r15+84], ecx
  00d4a	76 24		 jbe	 SHORT $LL246@inflateBac

; 578  :                                                 left : 0)) {
; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00d4c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00d50	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d57	45 8b cc	 mov	 r9d, r12d
  00d5a	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00d5e	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00d66	e9 87 00 00 00	 jmp	 $LN480@inflateBac
  00d6b	0f 1f 44 00 00	 npad	 5
$LL246@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00d70	45 85 e4	 test	 r12d, r12d
  00d73	75 21		 jne	 SHORT $LN247@inflateBac
  00d75	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00d79	45 8b c4	 mov	 r8d, r12d
  00d7c	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00d80	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00d84	48 8b d3	 mov	 rdx, rbx
  00d87	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00d8b	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00d8e	85 c0		 test	 eax, eax
  00d90	0f 85 7f 00 00
	00		 jne	 $LN372@inflateBac
$LN247@inflateBac:

; 588  :                 copy = state->wsize - state->offset;

  00d96	41 8b 4f 54	 mov	 ecx, DWORD PTR [r15+84]
  00d9a	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00d9e	2b c1		 sub	 eax, ecx

; 589  :                 if (copy < left) {

  00da0	41 3b c4	 cmp	 eax, r12d
  00da3	73 0c		 jae	 SHORT $LN334@inflateBac

; 590  :                     from = put + copy;

  00da5	8b d0		 mov	 edx, eax

; 591  :                     copy = left - copy;

  00da7	41 8b cc	 mov	 ecx, r12d
  00daa	48 03 d3	 add	 rdx, rbx
  00dad	2b c8		 sub	 ecx, eax

; 592  :                 }

  00daf	eb 09		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 593  :                 else {
; 594  :                     from = put - state->offset;

  00db1	48 8b d3	 mov	 rdx, rbx
  00db4	48 2b d1	 sub	 rdx, rcx

; 595  :                     copy = left;

  00db7	41 8b cc	 mov	 ecx, r12d
$LN335@inflateBac:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00dba	41 3b 4f 50	 cmp	 ecx, DWORD PTR [r15+80]
  00dbe	41 0f 47 4f 50	 cmova	 ecx, DWORD PTR [r15+80]

; 598  :                 state->length -= copy;

  00dc3	41 29 4f 50	 sub	 DWORD PTR [r15+80], ecx

; 599  :                 left -= copy;

  00dc7	44 2b e1	 sub	 r12d, ecx
  00dca	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d

; 602  :                 } while (--copy);

  00dce	48 2b d3	 sub	 rdx, rbx
$LL252@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00dd1	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00dd5	88 03		 mov	 BYTE PTR [rbx], al
  00dd7	48 ff c3	 inc	 rbx

; 602  :                 } while (--copy);

  00dda	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00ddd	75 f2		 jne	 SHORT $LL252@inflateBac

; 603  :             } while (state->length != 0);

  00ddf	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00de3	41 39 4f 50	 cmp	 DWORD PTR [r15+80], ecx
  00de7	75 87		 jne	 SHORT $LL246@inflateBac
$LN488@inflateBac:
  00de9	45 8b cc	 mov	 r9d, r12d
$LN492@inflateBac:
  00dec	33 d2		 xor	 edx, edx
$LN489@inflateBac:
  00dee	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN480@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00df2	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00df6	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00dfb	83 f8 12	 cmp	 eax, 18
  00dfe	77 46		 ja	 SHORT $LN341@inflateBac
  00e00	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
  00e04	4c 8b 6d 30	 mov	 r13, QWORD PTR in$[rbp-120]
  00e08	e9 8f f2 ff ff	 jmp	 $LN496@inflateBac
$LN369@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  00e0d	48 c7 45 c0 00
	00 00 00	 mov	 QWORD PTR next$[rbp-120], 0
$LN372@inflateBac:
  00e15	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e1b	eb 2f		 jmp	 SHORT $inf_leave$503
$LN337@inflateBac:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00e1d	45 8b 47 34	 mov	 r8d, DWORD PTR [r15+52]
  00e21	45 3b c8	 cmp	 r9d, r8d
  00e24	73 26		 jae	 SHORT $inf_leave$503

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00e26	49 8b 57 40	 mov	 rdx, QWORD PTR [r15+64]
  00e2a	45 2b c1	 sub	 r8d, r9d
  00e2d	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e31	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00e34	85 c0		 test	 eax, eax
  00e36	75 dd		 jne	 SHORT $LN372@inflateBac
  00e38	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00e3c	eb 0e		 jmp	 SHORT $inf_leave$503
$LN340@inflateBac:

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;
; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00e3e	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 617  :             goto inf_leave;

  00e44	eb 06		 jmp	 SHORT $inf_leave$503
$LN341@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00e46	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$503:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e4c	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e50	48 8b 4d c0	 mov	 rcx, QWORD PTR next$[rbp-120]
  00e54	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e59	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e5e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 627  :     strm->avail_in = have;

  00e63	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00e66	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e6b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 628  :     return ret;

  00e6e	41 8b c3	 mov	 eax, r11d

; 629  : }

  00e71	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e75	41 5f		 pop	 r15
  00e77	41 5d		 pop	 r13
  00e79	41 5c		 pop	 r12
  00e7b	5d		 pop	 rbp
  00e7c	c3		 ret	 0
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00e7d	b8 fe ff ff ff	 mov	 eax, -2

; 629  : }

  00e82	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e86	41 5f		 pop	 r15
  00e88	41 5d		 pop	 r13
  00e8a	41 5c		 pop	 r12
  00e8c	5d		 pop	 rbp
  00e8d	c3		 ret	 0
  00e8e	66 90		 npad	 2
$LN473@inflateBac:
  00e90	00 00 00 00	 DD	 $LN255@inflateBac
  00e94	00 00 00 00	 DD	 $LN341@inflateBac
  00e98	00 00 00 00	 DD	 $LN31@inflateBac
  00e9c	00 00 00 00	 DD	 $LN341@inflateBac
  00ea0	00 00 00 00	 DD	 $LN341@inflateBac
  00ea4	00 00 00 00	 DD	 $LN56@inflateBac
  00ea8	00 00 00 00	 DD	 $LN341@inflateBac
  00eac	00 00 00 00	 DD	 $LN341@inflateBac
  00eb0	00 00 00 00	 DD	 $LN341@inflateBac
  00eb4	00 00 00 00	 DD	 $LN302@inflateBac
  00eb8	00 00 00 00	 DD	 $LN341@inflateBac
  00ebc	00 00 00 00	 DD	 $LN341@inflateBac
  00ec0	00 00 00 00	 DD	 $LN341@inflateBac
  00ec4	00 00 00 00	 DD	 $LN341@inflateBac
  00ec8	00 00 00 00	 DD	 $LN341@inflateBac
  00ecc	00 00 00 00	 DD	 $LN341@inflateBac
  00ed0	00 00 00 00	 DD	 $LN341@inflateBac
  00ed4	00 00 00 00	 DD	 $LN337@inflateBac
  00ed8	00 00 00 00	 DD	 $LN340@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 637  :     strm->state = Z_NULL;
; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 640  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 640  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
