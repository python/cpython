; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int?$AA@ ; `string'
PUBLIC	??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp_strerror:PROC
EXTRN	__imp_memchr:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__read:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@
CONST	SEGMENT
??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@ DB 'request do'
	DB	'es not fit in a size_t', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int?$AA@
CONST	SEGMENT
??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int?$AA@ DB 'request '
	DB	'does not fit in an int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
PUBLIC	gzdirect
PUBLIC	gzgets
PUBLIC	gzungetc
PUBLIC	gzgetc_
PUBLIC	gzgetc
PUBLIC	gzfread
PUBLIC	gzread
PUBLIC	gzclose_r
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN6
	DD	imagerel $LN6+56
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzgets DD imagerel $LN32+107
	DD	imagerel $LN32+304
	DD	imagerel $chain$3$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzgets DD imagerel $LN32+304
	DD	imagerel $LN32+308
	DD	imagerel $chain$5$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gzgets DD imagerel $LN32+308
	DD	imagerel $LN32+320
	DD	imagerel $chain$6$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN19
	DD	imagerel $LN19+267
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN10
	DD	imagerel $LN10+107
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfread DD imagerel $LN10
	DD	imagerel $LN10+120
	DD	imagerel $unwind$gzfread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN9
	DD	imagerel $LN9+99
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_read DD imagerel gz_read
	DD	imagerel gz_read+34
	DD	imagerel $unwind$gz_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_read DD imagerel gz_read+34
	DD	imagerel gz_read+82
	DD	imagerel $chain$0$gz_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gz_read DD imagerel gz_read+82
	DD	imagerel gz_read+347
	DD	imagerel $chain$6$gz_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+119
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_fetch DD imagerel gz_fetch
	DD	imagerel gz_fetch+167
	DD	imagerel $unwind$gz_fetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+270
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_look DD imagerel gz_look
	DD	imagerel gz_look+464
	DD	imagerel $unwind$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+144
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+178
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$gzclose_r
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 063001H
	DD	077430H
	DD	06342bH
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_look DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_fetch DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gz_read DD 0a1d21H
	DD	0b741dH
	DD	04f415H
	DD	05d40aH
	DD	0a6405H
	DD	0dc400H
	DD	imagerel gz_read
	DD	imagerel gz_read+34
	DD	imagerel $unwind$gz_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_read DD 020521H
	DD	0dc405H
	DD	imagerel gz_read
	DD	imagerel gz_read+34
	DD	imagerel $unwind$gz_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_read DD 040901H
	DD	0e0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gzgets DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzgets DD 080021H
	DD	0bc400H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzgets DD 081421H
	DD	0bc414H
	DD	0a740fH
	DD	09540aH
	DD	083405H
	DD	imagerel $LN32
	DD	imagerel $LN32+107
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 040a01H
	DD	0f006320aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzclose_r
_TEXT	SEGMENT
file$ = 48
gzclose_r PROC						; COMDAT

; 629  : {

$LN8:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 630  :     int ret, err;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0b		 jne	 SHORT $LN2@gzclose_r
$LN6@gzclose_r:

; 635  :         return Z_STREAM_ERROR;

  0000e	b8 fe ff ff ff	 mov	 eax, -2

; 654  : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5e		 pop	 rsi
  00018	c3		 ret	 0
$LN2@gzclose_r:

; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  00019	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00020	75 ec		 jne	 SHORT $LN6@gzclose_r

; 640  :         return Z_STREAM_ERROR;
; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  00022	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00030	74 1d		 je	 SHORT $LN4@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00032	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00036	e8 00 00 00 00	 call	 inflateEnd

; 645  :         free(state->out);

  0003b	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 646  :         free(state->in);

  00045	48 8b 4e 30	 mov	 rcx, QWORD PTR [rsi+48]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gzclose_r:

; 647  :     }
; 648  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  0004f	b8 fb ff ff ff	 mov	 eax, -5
  00054	33 ff		 xor	 edi, edi
  00056	39 46 6c	 cmp	 DWORD PTR [rsi+108], eax

; 649  :     gz_error(state, Z_OK, NULL);

  00059	48 8b ce	 mov	 rcx, rsi
  0005c	0f 44 f8	 cmove	 edi, eax
  0005f	45 33 c0	 xor	 r8d, r8d
  00062	33 d2		 xor	 edx, edx
  00064	e8 00 00 00 00	 call	 gz_error

; 650  :     free(state->path);

  00069	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 651  :     ret = close(state->fd);

  00073	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close

; 652  :     free(state);

  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	8b d8		 mov	 ebx, eax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 653  :     return ret ? Z_ERRNO : err;

  00087	83 c8 ff	 or	 eax, -1
  0008a	85 db		 test	 ebx, ebx
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	0f 45 f8	 cmovne	 edi, eax
  00094	8b c7		 mov	 eax, edi
  00096	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 654  : }

  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5e		 pop	 rsi
  000a0	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_load
_TEXT	SEGMENT
state$ = 48
buf$ = 56
len$ = 64
have$ = 72
gz_load	PROC						; COMDAT

; 26   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	49 8b d9	 mov	 rbx, r9

; 27   :     int ret;
; 28   :     unsigned get, max = ((unsigned)-1 >> 2) + 1;
; 29   : 
; 30   :     *have = 0;

  0001d	41 c7 01 00 00
	00 00		 mov	 DWORD PTR [r9], 0
  00024	41 8b f8	 mov	 edi, r8d
  00027	48 8b ea	 mov	 rbp, rdx
  0002a	48 8b f1	 mov	 rsi, rcx
  0002d	41 be 00 00 00
	40		 mov	 r14d, 1073741824	; 40000000H
  00033	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@gz_load:

; 31   :     do {
; 32   :         get = len - *have;

  00040	8b 13		 mov	 edx, DWORD PTR [rbx]
  00042	44 8b c7	 mov	 r8d, edi

; 33   :         if (get > max)
; 34   :             get = max;
; 35   :         ret = read(state->fd, buf + *have, get);

  00045	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00048	44 2b c2	 sub	 r8d, edx
  0004b	45 3b c6	 cmp	 r8d, r14d
  0004e	45 0f 47 c6	 cmova	 r8d, r14d
  00052	48 03 d5	 add	 rdx, rbp
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read

; 36   :         if (ret <= 0)

  0005b	85 c0		 test	 eax, eax
  0005d	7e 08		 jle	 SHORT $LN14@gz_load

; 37   :             break;
; 38   :         *have += (unsigned)ret;

  0005f	01 03		 add	 DWORD PTR [rbx], eax

; 39   :     } while (*have < len);

  00061	39 3b		 cmp	 DWORD PTR [rbx], edi
  00063	72 db		 jb	 SHORT $LL4@gz_load

; 40   :     if (ret < 0) {

  00065	85 c0		 test	 eax, eax
$LN14@gz_load:
  00067	79 21		 jns	 SHORT $LN7@gz_load

; 41   :         gz_error(state, Z_ERRNO, zstrerror());

  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00077	83 ca ff	 or	 edx, -1
  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	4c 8b c0	 mov	 r8, rax
  00080	e8 00 00 00 00	 call	 gz_error

; 42   :         return -1;

  00085	83 c8 ff	 or	 eax, -1
  00088	eb 0d		 jmp	 SHORT $LN1@gz_load
$LN7@gz_load:

; 43   :     }
; 44   :     if (ret == 0)

  0008a	85 c0		 test	 eax, eax
  0008c	75 07		 jne	 SHORT $LN8@gz_load

; 45   :         state->eof = 1;

  0008e	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [rsi+80], 1
$LN8@gz_load:

; 46   :     return 0;

  00095	33 c0		 xor	 eax, eax
$LN1@gz_load:

; 47   : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000af	41 5e		 pop	 r14
  000b1	c3		 ret	 0
gz_load	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_avail
_TEXT	SEGMENT
got$ = 48
state$ = 48
gz_avail PROC						; COMDAT

; 58   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 59   :     unsigned got;
; 60   :     z_streamp strm = &(state->strm);
; 61   : 
; 62   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00006	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	85 c0		 test	 eax, eax
  0000e	74 0e		 je	 SHORT $LN5@gz_avail
  00010	83 f8 fb	 cmp	 eax, -5
  00013	74 09		 je	 SHORT $LN5@gz_avail
$LN13@gz_avail:

; 63   :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 80   : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN5@gz_avail:

; 64   :     if (state->eof == 0) {

  0001e	83 79 50 00	 cmp	 DWORD PTR [rcx+80], 0
  00022	75 64		 jne	 SHORT $LN6@gz_avail

; 65   :         if (strm->avail_in) {       /* copy what's there to the start */

  00024	44 8b 81 80 00
	00 00		 mov	 r8d, DWORD PTR [rcx+128]
  0002b	45 85 c0	 test	 r8d, r8d
  0002e	74 23		 je	 SHORT $LN3@gz_avail

; 66   :             unsigned char *p = state->in;

  00030	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]

; 67   :             unsigned const char *q = strm->next_in;

  00034	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gz_avail:

; 68   :             unsigned n = strm->avail_in;
; 69   :             do {
; 70   :                 *p++ = *q++;

  00040	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00043	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  00047	88 01		 mov	 BYTE PTR [rcx], al
  00049	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]

; 71   :             } while (--n);

  0004d	41 83 c0 ff	 add	 r8d, -1			; ffffffffH
  00051	75 ed		 jne	 SHORT $LL4@gz_avail
$LN3@gz_avail:

; 72   :         }
; 73   :         if (gz_load(state, state->in + strm->avail_in,
; 74   :                     state->size - strm->avail_in, &got) == -1)

  00053	8b 93 80 00 00
	00		 mov	 edx, DWORD PTR [rbx+128]
  00059	4c 8d 4c 24 30	 lea	 r9, QWORD PTR got$[rsp]
  0005e	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00062	48 8b cb	 mov	 rcx, rbx
  00065	44 2b c2	 sub	 r8d, edx
  00068	48 03 53 30	 add	 rdx, QWORD PTR [rbx+48]
  0006c	e8 00 00 00 00	 call	 gz_load
  00071	83 f8 ff	 cmp	 eax, -1
  00074	74 9f		 je	 SHORT $LN13@gz_avail

; 75   :             return -1;
; 76   :         strm->avail_in += got;

  00076	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
  0007a	01 83 80 00 00
	00		 add	 DWORD PTR [rbx+128], eax

; 77   :         strm->next_in = state->in;

  00080	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00084	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN6@gz_avail:

; 78   :     }
; 79   :     return 0;

  00088	33 c0		 xor	 eax, eax

; 80   : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_look
_TEXT	SEGMENT
state$ = 48
gz_look	PROC						; COMDAT

; 93   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 94   :     z_streamp strm = &(state->strm);
; 95   : 
; 96   :     /* allocate read buffers and inflate memory */
; 97   :     if (state->size == 0) {

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b d9	 mov	 rbx, rcx
  00014	39 71 28	 cmp	 DWORD PTR [rcx+40], esi
  00017	0f 85 e2 00 00
	00		 jne	 $LN5@gz_look

; 98   :         /* allocate buffers */
; 99   :         state->in = (unsigned char *)malloc(state->want);

  0001d	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00026	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 100  :         state->out = (unsigned char *)malloc(state->want << 1);

  0002a	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  0002d	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00036	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 101  :         if (state->in == NULL || state->out == NULL) {

  0003a	48 39 73 30	 cmp	 QWORD PTR [rbx+48], rsi
  0003e	0f 84 81 00 00
	00		 je	 $LN4@gz_look
  00044	48 85 c0	 test	 rax, rax
  00047	74 7c		 je	 SHORT $LN4@gz_look

; 106  :         }
; 107  :         state->size = state->want;

  00049	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]

; 108  : 
; 109  :         /* allocate inflate memory */
; 110  :         state->strm.zalloc = Z_NULL;
; 111  :         state->strm.zfree = Z_NULL;
; 112  :         state->strm.opaque = Z_NULL;
; 113  :         state->strm.avail_in = 0;
; 114  :         state->strm.next_in = Z_NULL;
; 115  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  0004c	44 8d 4e 58	 lea	 r9d, QWORD PTR [rsi+88]
  00050	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411?$AA@
  00057	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0005a	8d 56 1f	 lea	 edx, QWORD PTR [rsi+31]
  0005d	48 89 b3 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rsi
  00064	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  00068	48 89 b3 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rsi
  0006f	48 89 b3 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rsi
  00076	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi
  0007c	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  00080	e8 00 00 00 00	 call	 inflateInit2_
  00085	85 c0		 test	 eax, eax
  00087	74 76		 je	 SHORT $LN5@gz_look

; 116  :             free(state->out);

  00089	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 117  :             free(state->in);

  00093	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 118  :             state->size = 0;
; 119  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0009d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a4	89 73 28	 mov	 DWORD PTR [rbx+40], esi
  000a7	8d 56 fc	 lea	 edx, QWORD PTR [rsi-4]
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 gz_error

; 120  :             return -1;

  000b2	83 c8 ff	 or	 eax, -1

; 168  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN4@gz_look:

; 102  :             free(state->out);

  000c5	48 8b c8	 mov	 rcx, rax
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 103  :             free(state->in);

  000ce	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 104  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000df	ba fc ff ff ff	 mov	 edx, -4
  000e4	48 8b cb	 mov	 rcx, rbx
  000e7	e8 00 00 00 00	 call	 gz_error
$LN14@gz_look:

; 105  :             return -1;

  000ec	83 c8 ff	 or	 eax, -1

; 168  : }

  000ef	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
$LN5@gz_look:

; 121  :         }
; 122  :     }
; 123  : 
; 124  :     /* get at least the magic bytes in the input buffer */
; 125  :     if (strm->avail_in < 2) {

  000ff	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  00105	83 f8 02	 cmp	 eax, 2
  00108	73 1b		 jae	 SHORT $LN8@gz_look

; 126  :         if (gz_avail(state) == -1)

  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 gz_avail
  00112	83 f8 ff	 cmp	 eax, -1
  00115	74 d5		 je	 SHORT $LN14@gz_look

; 127  :             return -1;
; 128  :         if (strm->avail_in == 0)

  00117	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 99 00 00
	00		 je	 $LN13@gz_look
$LN8@gz_look:

; 129  :             return 0;
; 130  :     }
; 131  : 
; 132  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 133  :        a logical dilemma here when considering the case of a partially written
; 134  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 135  :        whether this is a single-byte file, or just a partially written gzip
; 136  :        file -- for here we assume that if a gzip file is being written, then
; 137  :        the header will be written in a single operation, so that reading a
; 138  :        single byte is sufficient indication that it is not a gzip file) */
; 139  :     if (strm->avail_in > 1 &&
; 140  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  00125	83 f8 01	 cmp	 eax, 1
  00128	76 34		 jbe	 SHORT $LN9@gz_look
  0012a	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  0012e	80 38 1f	 cmp	 BYTE PTR [rax], 31
  00131	75 2b		 jne	 SHORT $LN9@gz_look
  00133	80 78 01 8b	 cmp	 BYTE PTR [rax+1], 139	; 0000008bH
  00137	75 25		 jne	 SHORT $LN9@gz_look

; 141  :         inflateReset(strm);

  00139	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  0013d	e8 00 00 00 00	 call	 inflateReset

; 167  :     return 0;

  00142	33 c0		 xor	 eax, eax
  00144	c7 43 44 02 00
	00 00		 mov	 DWORD PTR [rbx+68], 2
  0014b	89 73 40	 mov	 DWORD PTR [rbx+64], esi

; 168  : }

  0014e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00153	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00158	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
$LN9@gz_look:

; 142  :         state->how = GZIP;
; 143  :         state->direct = 0;
; 144  :         return 0;
; 145  :     }
; 146  : 
; 147  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 148  :        garbage.  Ignore the trailing garbage and finish. */
; 149  :     if (state->direct == 0) {

  0015e	39 73 40	 cmp	 DWORD PTR [rbx+64], esi
  00161	75 21		 jne	 SHORT $LN10@gz_look

; 150  :         strm->avail_in = 0;

  00163	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi

; 167  :     return 0;

  00169	33 c0		 xor	 eax, eax
  0016b	c7 43 50 01 00
	00 00		 mov	 DWORD PTR [rbx+80], 1
  00172	89 33		 mov	 DWORD PTR [rbx], esi

; 168  : }

  00174	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00179	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0017e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00182	5f		 pop	 rdi
  00183	c3		 ret	 0
$LN10@gz_look:

; 151  :         state->eof = 1;
; 152  :         state->x.have = 0;
; 153  :         return 0;
; 154  :     }
; 155  : 
; 156  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 157  :        the output buffer is larger than the input buffer, which also assures
; 158  :        space for gzungetc() */
; 159  :     state->x.next = state->out;

  00184	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00188	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 160  :     if (strm->avail_in) {

  0018c	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  00192	85 c0		 test	 eax, eax
  00194	74 1a		 je	 SHORT $LN11@gz_look

; 161  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00196	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  0019a	44 8b c0	 mov	 r8d, eax
  0019d	e8 00 00 00 00	 call	 memcpy

; 162  :         state->x.have = strm->avail_in;

  001a2	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  001a8	89 03		 mov	 DWORD PTR [rbx], eax

; 163  :         strm->avail_in = 0;

  001aa	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi
$LN11@gz_look:

; 164  :     }
; 165  :     state->how = COPY;

  001b0	c7 43 44 01 00
	00 00		 mov	 DWORD PTR [rbx+68], 1

; 166  :     state->direct = 1;

  001b7	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN13@gz_look:

; 168  : }

  001be	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001c3	33 c0		 xor	 eax, eax
  001c5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5f		 pop	 rdi
  001cf	c3		 ret	 0
gz_look	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_decomp
_TEXT	SEGMENT
state$ = 48
gz_decomp PROC						; COMDAT

; 177  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 178  :     int ret = Z_OK;
; 179  :     unsigned had;
; 180  :     z_streamp strm = &(state->strm);
; 181  : 
; 182  :     /* fill output buffer up to end of deflate stream */
; 183  :     had = strm->avail_out;

  00014	8b a9 90 00 00
	00		 mov	 ebp, DWORD PTR [rcx+144]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL4@gz_decomp:

; 184  :     do {
; 185  :         /* get more input for inflate() */
; 186  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00020	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00027	75 1a		 jne	 SHORT $LN24@gz_decomp
  00029	48 8b ce	 mov	 rcx, rsi
  0002c	e8 00 00 00 00	 call	 gz_avail
  00031	83 f8 ff	 cmp	 eax, -1
  00034	0f 84 bc 00 00
	00		 je	 $LN17@gz_decomp

; 187  :             return -1;
; 188  :         if (strm->avail_in == 0) {

  0003a	83 be 80 00 00
	00 00		 cmp	 DWORD PTR [rsi+128], 0
  00041	74 39		 je	 SHORT $LN18@gz_decomp
$LN24@gz_decomp:

; 190  :             break;
; 191  :         }
; 192  : 
; 193  :         /* decompress and handle errors */
; 194  :         ret = inflate(strm, Z_NO_FLUSH);

  00043	33 d2		 xor	 edx, edx
  00045	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00049	e8 00 00 00 00	 call	 inflate
  0004e	8b d8		 mov	 ebx, eax

; 195  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00050	83 f8 fe	 cmp	 eax, -2
  00053	0f 84 89 00 00
	00		 je	 $LN8@gz_decomp
  00059	83 f8 02	 cmp	 eax, 2
  0005c	0f 84 80 00 00
	00		 je	 $LN8@gz_decomp

; 199  :         }
; 200  :         if (ret == Z_MEM_ERROR) {

  00062	83 f8 fc	 cmp	 eax, -4
  00065	74 6d		 je	 SHORT $LN20@gz_decomp

; 203  :         }
; 204  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  00067	83 f8 fd	 cmp	 eax, -3
  0006a	74 4c		 je	 SHORT $LN21@gz_decomp

; 208  :         }
; 209  :     } while (strm->avail_out && ret != Z_STREAM_END);

  0006c	83 be 90 00 00
	00 00		 cmp	 DWORD PTR [rsi+144], 0
  00073	74 1b		 je	 SHORT $LN3@gz_decomp
  00075	83 f8 01	 cmp	 eax, 1
  00078	75 a6		 jne	 SHORT $LL4@gz_decomp
  0007a	eb 14		 jmp	 SHORT $LN3@gz_decomp
$LN18@gz_decomp:

; 189  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  0007c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  00083	ba fb ff ff ff	 mov	 edx, -5
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	e8 00 00 00 00	 call	 gz_error
$LN3@gz_decomp:

; 210  : 
; 211  :     /* update available output */
; 212  :     state->x.have = had - strm->avail_out;

  00090	2b ae 90 00 00
	00		 sub	 ebp, DWORD PTR [rsi+144]
  00096	8b cd		 mov	 ecx, ebp
  00098	89 0e		 mov	 DWORD PTR [rsi], ecx

; 213  :     state->x.next = strm->next_out - state->x.have;

  0009a	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  000a1	48 2b c1	 sub	 rax, rcx
  000a4	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 214  : 
; 215  :     /* if the gzip stream completed successfully, look for another */
; 216  :     if (ret == Z_STREAM_END)

  000a8	83 fb 01	 cmp	 ebx, 1
  000ab	75 07		 jne	 SHORT $LN12@gz_decomp

; 217  :         state->how = LOOK;

  000ad	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [rsi+68], 0
$LN12@gz_decomp:

; 218  : 
; 219  :     /* good decompression */
; 220  :     return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 41		 jmp	 SHORT $LN1@gz_decomp
$LN21@gz_decomp:

; 205  :             gz_error(state, Z_DATA_ERROR,

  000b8	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000c6	48 85 c0	 test	 rax, rax
  000c9	ba fd ff ff ff	 mov	 edx, -3
  000ce	4c 0f 45 c0	 cmovne	 r8, rax

; 206  :                      strm->msg == NULL ? "compressed data error" : strm->msg);
; 207  :             return -1;

  000d2	eb 1a		 jmp	 SHORT $LN25@gz_decomp
$LN20@gz_decomp:

; 201  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000db	ba fc ff ff ff	 mov	 edx, -4

; 202  :             return -1;

  000e0	eb 0c		 jmp	 SHORT $LN25@gz_decomp
$LN8@gz_decomp:

; 196  :             gz_error(state, Z_STREAM_ERROR,

  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  000e9	ba fe ff ff ff	 mov	 edx, -2
$LN25@gz_decomp:
  000ee	48 8b ce	 mov	 rcx, rsi
  000f1	e8 00 00 00 00	 call	 gz_error
$LN17@gz_decomp:

; 197  :                      "internal error: inflate stream corrupt");
; 198  :             return -1;

  000f6	83 c8 ff	 or	 eax, -1
$LN1@gz_decomp:

; 221  : }

  000f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fe	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00103	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00108	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_fetch
_TEXT	SEGMENT
state$ = 48
gz_fetch PROC						; COMDAT

; 231  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@gz_fetch:

; 232  :     z_streamp strm = &(state->strm);
; 233  : 
; 234  :     do {
; 235  :         switch(state->how) {

  00010	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00013	85 c9		 test	 ecx, ecx
  00015	74 36		 je	 SHORT $LN7@gz_fetch
  00017	83 e9 01	 sub	 ecx, 1
  0001a	74 60		 je	 SHORT $LN10@gz_fetch
  0001c	83 f9 01	 cmp	 ecx, 1
  0001f	75 3f		 jne	 SHORT $LN2@gz_fetch

; 248  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 249  :             strm->avail_out = state->size << 1;

  00021	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 250  :             strm->next_out = state->out;
; 251  :             if (gz_decomp(state) == -1)

  00024	48 8b cb	 mov	 rcx, rbx
  00027	03 c0		 add	 eax, eax
  00029	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax
  0002f	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00033	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
  0003a	e8 00 00 00 00	 call	 gz_decomp
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	75 1c		 jne	 SHORT $LN2@gz_fetch
$LN19@gz_fetch:

; 238  :                 return -1;

  00044	83 c8 ff	 or	 eax, -1

; 255  :     return 0;
; 256  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN7@gz_fetch:

; 236  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 237  :             if (gz_look(state) == -1)

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 gz_look
  00055	83 f8 ff	 cmp	 eax, -1
  00058	74 ea		 je	 SHORT $LN19@gz_fetch

; 239  :             if (state->how == LOOK)

  0005a	83 7b 44 00	 cmp	 DWORD PTR [rbx+68], 0
  0005e	74 3f		 je	 SHORT $LN20@gz_fetch
$LN2@gz_fetch:

; 252  :                 return -1;
; 253  :         }
; 254  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  00060	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00063	75 3a		 jne	 SHORT $LN20@gz_fetch
  00065	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  00069	74 a5		 je	 SHORT $LL4@gz_fetch
  0006b	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00072	75 9c		 jne	 SHORT $LL4@gz_fetch

; 247  :             return 0;

  00074	33 c0		 xor	 eax, eax

; 255  :     return 0;
; 256  : }

  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
$LN10@gz_fetch:

; 240  :                 return 0;
; 241  :             break;
; 242  :         case COPY:      /* -> COPY */
; 243  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 244  :                     == -1)

  0007c	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00080	4c 8b cb	 mov	 r9, rbx
  00083	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00087	45 03 c0	 add	 r8d, r8d
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 gz_load
  00092	83 f8 ff	 cmp	 eax, -1
  00095	74 ad		 je	 SHORT $LN19@gz_fetch

; 245  :                 return -1;
; 246  :             state->x.next = state->out;

  00097	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0009b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN20@gz_fetch:

; 247  :             return 0;

  0009f	33 c0		 xor	 eax, eax

; 255  :     return 0;
; 256  : }

  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0
gz_fetch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_skip
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_skip	PROC						; COMDAT

; 262  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 263  :     unsigned n;
; 264  : 
; 265  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 266  :     while (len)

  00010	48 85 d2	 test	 rdx, rdx
  00013	74 47		 je	 SHORT $LN3@gz_skip
$LL2@gz_skip:

; 267  :         /* skip over whatever is in output buffer */
; 268  :         if (state->x.have) {

  00015	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00018	45 85 c0	 test	 r8d, r8d
  0001b	74 1e		 je	 SHORT $LN4@gz_skip

; 269  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?

  0001d	4c 3b c7	 cmp	 r8, rdi
  00020	8b cf		 mov	 ecx, edi
  00022	41 0f 4e c8	 cmovle	 ecx, r8d

; 270  :                 (unsigned)len : state->x.have;
; 271  :             state->x.have -= n;
; 272  :             state->x.next += n;

  00026	8b c1		 mov	 eax, ecx
  00028	44 2b c1	 sub	 r8d, ecx
  0002b	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 273  :             state->x.pos += n;

  0002f	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 274  :             len -= n;

  00033	48 2b f8	 sub	 rdi, rax
  00036	44 89 03	 mov	 DWORD PTR [rbx], r8d

; 275  :         }

  00039	eb 1c		 jmp	 SHORT $LN8@gz_skip
$LN4@gz_skip:

; 276  : 
; 277  :         /* output buffer empty -- return if we're at the end of the input */
; 278  :         else if (state->eof && state->strm.avail_in == 0)

  0003b	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0003f	74 09		 je	 SHORT $LN6@gz_skip
  00041	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00048	74 12		 je	 SHORT $LN3@gz_skip
$LN6@gz_skip:

; 279  :             break;
; 280  : 
; 281  :         /* need more data to skip -- load up output buffer */
; 282  :         else {
; 283  :             /* get more output, looking for header if required */
; 284  :             if (gz_fetch(state) == -1)

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 gz_fetch
  00052	83 f8 ff	 cmp	 eax, -1
  00055	74 12		 je	 SHORT $LN14@gz_skip
$LN8@gz_skip:

; 263  :     unsigned n;
; 264  : 
; 265  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 266  :     while (len)

  00057	48 85 ff	 test	 rdi, rdi
  0005a	75 b9		 jne	 SHORT $LL2@gz_skip
$LN3@gz_skip:

; 286  :         }
; 287  :     return 0;

  0005c	33 c0		 xor	 eax, eax

; 288  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN14@gz_skip:

; 285  :                 return -1;

  00069	83 c8 ff	 or	 eax, -1

; 288  : }

  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
gz_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_read
_TEXT	SEGMENT
state$ = 80
buf$ = 88
n$ = 96
len$ = 96
gz_read	PROC						; COMDAT

; 298  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	49 8b e8	 mov	 rbp, r8
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b d9	 mov	 rbx, rcx

; 299  :     z_size_t got;
; 300  :     unsigned n;
; 301  : 
; 302  :     /* if len is zero, avoid unnecessary operations */
; 303  :     if (len == 0)

  00012	4d 85 c0	 test	 r8, r8
  00015	75 0b		 jne	 SHORT $LN5@gz_read

; 304  :         return 0;

  00017	33 c0		 xor	 eax, eax

; 372  : }

  00019	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001d	41 5e		 pop	 r14
  0001f	5d		 pop	 rbp
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN5@gz_read:
  00022	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12

; 305  : 
; 306  :     /* process a skip request */
; 307  :     if (state->seek) {

  00027	45 33 e4	 xor	 r12d, r12d
  0002a	44 39 61 68	 cmp	 DWORD PTR [rcx+104], r12d
  0002e	74 22		 je	 SHORT $LN7@gz_read

; 308  :         state->seek = 0;
; 309  :         if (gz_skip(state, state->skip) == -1)

  00030	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00034	44 89 61 68	 mov	 DWORD PTR [rcx+104], r12d
  00038	e8 00 00 00 00	 call	 gz_skip
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	75 10		 jne	 SHORT $LN7@gz_read

; 310  :             return 0;

  00042	33 c0		 xor	 eax, eax
  00044	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]

; 372  : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	41 5e		 pop	 r14
  0004f	5d		 pop	 rbp
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN7@gz_read:
  00052	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00057	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13

; 311  :     }
; 312  : 
; 313  :     /* get len bytes to buf, or less than len if at the end */
; 314  :     got = 0;

  0005c	41 bd ff ff ff
	ff		 mov	 r13d, -1		; ffffffffH
  00062	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00067	4d 8b fc	 mov	 r15, r12
  0006a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0006f	90		 npad	 1
$LL4@gz_read:

; 315  :     do {
; 316  :         /* set n to the maximum amount of len that fits in an unsigned int */
; 317  :         n = -1;
; 318  :         if (n > len)
; 319  :             n = len;
; 320  : 
; 321  :         /* first just try copying data from the output buffer */
; 322  :         if (state->x.have) {

  00070	8b 03		 mov	 eax, DWORD PTR [rbx]
  00072	49 3b ed	 cmp	 rbp, r13
  00075	41 8b f5	 mov	 esi, r13d
  00078	0f 42 f5	 cmovb	 esi, ebp
  0007b	89 74 24 60	 mov	 DWORD PTR n$[rsp], esi
  0007f	85 c0		 test	 eax, eax
  00081	74 1e		 je	 SHORT $LN9@gz_read

; 323  :             if (state->x.have < n)
; 324  :                 n = state->x.have;
; 325  :             memcpy(buf, state->x.next, n);

  00083	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00087	3b c6		 cmp	 eax, esi
  00089	49 8b ce	 mov	 rcx, r14
  0008c	0f 42 f0	 cmovb	 esi, eax
  0008f	44 8b c6	 mov	 r8d, esi
  00092	8b fe		 mov	 edi, esi
  00094	e8 00 00 00 00	 call	 memcpy

; 326  :             state->x.next += n;

  00099	48 01 7b 08	 add	 QWORD PTR [rbx+8], rdi

; 327  :             state->x.have -= n;

  0009d	29 33		 sub	 DWORD PTR [rbx], esi

; 328  :         }

  0009f	eb 5e		 jmp	 SHORT $LN19@gz_read
$LN9@gz_read:

; 329  : 
; 330  :         /* output buffer empty -- return if we're at the end of the input */
; 331  :         else if (state->eof && state->strm.avail_in == 0) {

  000a1	44 39 63 50	 cmp	 DWORD PTR [rbx+80], r12d
  000a5	74 09		 je	 SHORT $LN12@gz_read
  000a7	44 39 a3 80 00
	00 00		 cmp	 DWORD PTR [rbx+128], r12d
  000ae	74 7b		 je	 SHORT $LN24@gz_read
$LN12@gz_read:

; 333  :             break;
; 334  :         }
; 335  : 
; 336  :         /* need output data -- for small len or new stream load up our output
; 337  :            buffer */
; 338  :         else if (state->how == LOOK || n < (state->size << 1)) {

  000b0	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  000b3	85 c9		 test	 ecx, ecx
  000b5	74 59		 je	 SHORT $LN16@gz_read
  000b7	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  000ba	03 c0		 add	 eax, eax
  000bc	3b f0		 cmp	 esi, eax
  000be	72 50		 jb	 SHORT $LN16@gz_read

; 342  :             continue;       /* no progress yet -- go back to copy above */
; 343  :             /* the copy above assures that we will leave with space in the
; 344  :                output buffer, allowing at least one gzungetc() to succeed */
; 345  :         }
; 346  : 
; 347  :         /* large len -- read directly into user buffer */
; 348  :         else if (state->how == COPY) {      /* read directly */

  000c0	83 f9 01	 cmp	 ecx, 1

; 349  :             if (gz_load(state, (unsigned char *)buf, n, &n) == -1)

  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	75 1b		 jne	 SHORT $LN18@gz_read
  000c8	4c 8d 4c 24 60	 lea	 r9, QWORD PTR n$[rsp]
  000cd	44 8b c6	 mov	 r8d, esi
  000d0	49 8b d6	 mov	 rdx, r14
  000d3	e8 00 00 00 00	 call	 gz_load
  000d8	83 f8 ff	 cmp	 eax, -1
  000db	74 5a		 je	 SHORT $LN27@gz_read

; 350  :                 return 0;
; 351  :         }

  000dd	8b 74 24 60	 mov	 esi, DWORD PTR n$[rsp]
  000e1	eb 1c		 jmp	 SHORT $LN19@gz_read
$LN18@gz_read:

; 352  : 
; 353  :         /* large len -- decompress directly into user buffer */
; 354  :         else {  /* state->how == GZIP */
; 355  :             state->strm.avail_out = n;

  000e3	89 b3 90 00 00
	00		 mov	 DWORD PTR [rbx+144], esi

; 356  :             state->strm.next_out = (unsigned char *)buf;

  000e9	4c 89 b3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r14

; 357  :             if (gz_decomp(state) == -1)

  000f0	e8 00 00 00 00	 call	 gz_decomp
  000f5	83 f8 ff	 cmp	 eax, -1
  000f8	74 3d		 je	 SHORT $LN27@gz_read

; 358  :                 return 0;
; 359  :             n = state->x.have;

  000fa	8b 33		 mov	 esi, DWORD PTR [rbx]

; 360  :             state->x.have = 0;

  000fc	44 89 23	 mov	 DWORD PTR [rbx], r12d
$LN19@gz_read:

; 361  :         }
; 362  : 
; 363  :         /* update progress */
; 364  :         len -= n;

  000ff	8b c6		 mov	 eax, esi
  00101	48 2b e8	 sub	 rbp, rax

; 365  :         buf = (char *)buf + n;

  00104	4c 03 f0	 add	 r14, rax

; 366  :         got += n;

  00107	4c 03 f8	 add	 r15, rax

; 367  :         state->x.pos += n;

  0010a	48 01 43 10	 add	 QWORD PTR [rbx+16], rax
  0010e	eb 0d		 jmp	 SHORT $LN2@gz_read
$LN16@gz_read:

; 339  :             /* get more output, looking for header if required */
; 340  :             if (gz_fetch(state) == -1)

  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 gz_fetch
  00118	83 f8 ff	 cmp	 eax, -1
  0011b	74 1a		 je	 SHORT $LN27@gz_read
$LN2@gz_read:

; 368  :     } while (len);

  0011d	48 85 ed	 test	 rbp, rbp
  00120	0f 85 4a ff ff
	ff		 jne	 $LL4@gz_read

; 369  : 
; 370  :     /* return number of bytes read into user buffer */
; 371  :     return got;

  00126	49 8b c7	 mov	 rax, r15
  00129	eb 0e		 jmp	 SHORT $LN34@gz_read
$LN24@gz_read:

; 332  :             state->past = 1;        /* tried to read past end */

  0012b	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [rbx+84], 1

; 369  : 
; 370  :     /* return number of bytes read into user buffer */
; 371  :     return got;

  00132	49 8b c7	 mov	 rax, r15
  00135	eb 02		 jmp	 SHORT $LN34@gz_read
$LN27@gz_read:

; 341  :                 return 0;

  00137	33 c0		 xor	 eax, eax
$LN34@gz_read:
  00139	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0013e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00143	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  00148	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0014d	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]

; 372  : }

  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	41 5e		 pop	 r14
  00158	5d		 pop	 rbp
  00159	5b		 pop	 rbx
  0015a	c3		 ret	 0
gz_read	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzread
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
gzread	PROC						; COMDAT

; 379  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 380  :     gz_statep state;
; 381  : 
; 382  :     /* get internal structure */
; 383  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 4c		 je	 SHORT $LN4@gzread

; 384  :         return -1;
; 385  :     state = (gz_statep)file;
; 386  : 
; 387  :     /* check that we're reading and that there's no (serious) error */
; 388  :     if (state->mode != GZ_READ ||

  0000e	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00015	75 43		 jne	 SHORT $LN4@gzread
  00017	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN3@gzread
  0001e	83 f8 fb	 cmp	 eax, -5
  00021	75 37		 jne	 SHORT $LN4@gzread
$LN3@gzread:

; 391  : 
; 392  :     /* since an int is returned, make sure len fits in one, otherwise return
; 393  :        with an error (this avoids a flaw in the interface) */
; 394  :     if ((int)len < 0) {

  00023	45 85 c0	 test	 r8d, r8d
  00026	79 1a		 jns	 SHORT $LN5@gzread

; 395  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");

  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int?$AA@
  0002f	ba fe ff ff ff	 mov	 edx, -2
  00034	e8 00 00 00 00	 call	 gz_error
  00039	83 c8 ff	 or	 eax, -1

; 404  :         return -1;
; 405  : 
; 406  :     /* return the number of bytes read (this is assured to fit in an int) */
; 407  :     return (int)len;
; 408  : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
$LN5@gzread:

; 396  :         return -1;
; 397  :     }
; 398  : 
; 399  :     /* read len or fewer bytes to buf */
; 400  :     len = gz_read(state, buf, len);

  00042	45 8b c0	 mov	 r8d, r8d
  00045	e8 00 00 00 00	 call	 gz_read

; 401  : 
; 402  :     /* check for an error */
; 403  :     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)

  0004a	85 c0		 test	 eax, eax
  0004c	75 0f		 jne	 SHORT $LN1@gzread
  0004e	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  00051	85 c9		 test	 ecx, ecx
  00053	74 08		 je	 SHORT $LN1@gzread
  00055	83 f9 fb	 cmp	 ecx, -5
  00058	74 03		 je	 SHORT $LN1@gzread
$LN4@gzread:

; 389  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 390  :         return -1;

  0005a	83 c8 ff	 or	 eax, -1
$LN1@gzread:

; 404  :         return -1;
; 405  : 
; 406  :     /* return the number of bytes read (this is assured to fit in an int) */
; 407  :     return (int)len;
; 408  : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzfread
_TEXT	SEGMENT
buf$ = 48
size$ = 56
nitems$ = 64
file$ = 72
gzfread	PROC						; COMDAT

; 416  : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b d0	 mov	 r10, r8
  00009	48 8b da	 mov	 rbx, rdx

; 417  :     z_size_t len;
; 418  :     gz_statep state;
; 419  : 
; 420  :     /* get internal structure */
; 421  :     if (file == NULL)

  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 44		 je	 SHORT $LN4@gzfread

; 422  :         return 0;
; 423  :     state = (gz_statep)file;
; 424  : 
; 425  :     /* check that we're reading and that there's no (serious) error */
; 426  :     if (state->mode != GZ_READ ||

  00011	41 81 79 18 4f
	1c 00 00	 cmp	 DWORD PTR [r9+24], 7247	; 00001c4fH
  00019	75 3a		 jne	 SHORT $LN4@gzfread
  0001b	41 8b 41 6c	 mov	 eax, DWORD PTR [r9+108]
  0001f	85 c0		 test	 eax, eax
  00021	74 05		 je	 SHORT $LN3@gzfread
  00023	83 f8 fb	 cmp	 eax, -5
  00026	75 2d		 jne	 SHORT $LN4@gzfread
$LN3@gzfread:

; 429  : 
; 430  :     /* compute bytes to read -- error on overflow */
; 431  :     len = nitems * size;

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	4d 0f af c2	 imul	 r8, r10

; 432  :     if (size && len / size != nitems) {

  0002f	48 85 db	 test	 rbx, rbx
  00032	74 29		 je	 SHORT $LN5@gzfread
  00034	33 d2		 xor	 edx, edx
  00036	49 8b c0	 mov	 rax, r8
  00039	48 f7 f3	 div	 rbx
  0003c	49 3b c2	 cmp	 rax, r10
  0003f	74 1c		 je	 SHORT $LN5@gzfread

; 433  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@
  00048	ba fe ff ff ff	 mov	 edx, -2
  0004d	49 8b c9	 mov	 rcx, r9
  00050	e8 00 00 00 00	 call	 gz_error
$LN4@gzfread:

; 427  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 428  :         return 0;

  00055	33 c0		 xor	 eax, eax

; 439  : }

  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$LN5@gzfread:

; 434  :         return 0;
; 435  :     }
; 436  : 
; 437  :     /* read len or fewer bytes to buf, return the number of full items read */
; 438  :     return len ? gz_read(state, buf, len) / size : 0;

  0005d	4d 85 c0	 test	 r8, r8
  00060	74 f3		 je	 SHORT $LN4@gzfread
  00062	48 8b d1	 mov	 rdx, rcx
  00065	49 8b c9	 mov	 rcx, r9
  00068	e8 00 00 00 00	 call	 gz_read
  0006d	33 d2		 xor	 edx, edx
  0006f	48 f7 f3	 div	 rbx

; 439  : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
gzfread	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgetc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
gzgetc	PROC						; COMDAT

; 449  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 450  :     int ret;
; 451  :     unsigned char buf[1];
; 452  :     gz_statep state;
; 453  : 
; 454  :     /* get internal structure */
; 455  :     if (file == NULL)

  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 57		 je	 SHORT $LN4@gzgetc

; 456  :         return -1;
; 457  :     state = (gz_statep)file;
; 458  : 
; 459  :     /* check that we're reading and that there's no (serious) error */
; 460  :     if (state->mode != GZ_READ ||

  0000c	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00013	75 4e		 jne	 SHORT $LN4@gzgetc
  00015	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN3@gzgetc
  0001c	83 f8 fb	 cmp	 eax, -5
  0001f	75 42		 jne	 SHORT $LN4@gzgetc
$LN3@gzgetc:

; 463  : 
; 464  :     /* try output buffer (no need to check for skip request) */
; 465  :     if (state->x.have) {

  00021	8b 01		 mov	 eax, DWORD PTR [rcx]
  00023	85 c0		 test	 eax, eax
  00025	74 1d		 je	 SHORT $LN5@gzgetc

; 466  :         state->x.have--;
; 467  :         state->x.pos++;

  00027	48 ff 41 10	 inc	 QWORD PTR [rcx+16]
  0002b	ff c8		 dec	 eax
  0002d	89 01		 mov	 DWORD PTR [rcx], eax

; 468  :         return *(state->x.next)++;

  0002f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00033	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00036	48 ff c0	 inc	 rax
  00039	49 89 41 08	 mov	 QWORD PTR [r9+8], rax
  0003d	8b c1		 mov	 eax, ecx

; 474  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN5@gzgetc:

; 469  :     }
; 470  : 
; 471  :     /* nothing there -- try gz_read() */
; 472  :     ret = gz_read(state, buf, 1);

  00044	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004a	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  0004f	e8 00 00 00 00	 call	 gz_read

; 473  :     return ret < 1 ? -1 : buf[0];

  00054	83 f8 01	 cmp	 eax, 1
  00057	7c 0a		 jl	 SHORT $LN4@gzgetc
  00059	0f b6 44 24 30	 movzx	 eax, BYTE PTR buf$[rsp]

; 474  : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
$LN4@gzgetc:

; 461  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 462  :         return -1;

  00063	83 c8 ff	 or	 eax, -1

; 474  : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgetc_
_TEXT	SEGMENT
file$ = 8
gzgetc_	PROC						; COMDAT

; 479  :     return gzgetc(file);

  00000	e9 00 00 00 00	 jmp	 gzgetc
gzgetc_	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzungetc
_TEXT	SEGMENT
c$ = 48
file$ = 56
gzungetc PROC						; COMDAT

; 486  : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 487  :     gz_statep state;
; 488  : 
; 489  :     /* get internal structure */
; 490  :     if (file == NULL)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	0f 84 91 00 00
	00		 je	 $LN6@gzungetc

; 491  :         return -1;
; 492  :     state = (gz_statep)file;
; 493  : 
; 494  :     /* check that we're reading and that there's no (serious) error */
; 495  :     if (state->mode != GZ_READ ||

  00018	81 7a 18 4f 1c
	00 00		 cmp	 DWORD PTR [rdx+24], 7247 ; 00001c4fH
  0001f	0f 85 84 00 00
	00		 jne	 $LN6@gzungetc
  00025	8b 42 6c	 mov	 eax, DWORD PTR [rdx+108]
  00028	85 c0		 test	 eax, eax
  0002a	74 05		 je	 SHORT $LN5@gzungetc
  0002c	83 f8 fb	 cmp	 eax, -5
  0002f	75 78		 jne	 SHORT $LN6@gzungetc
$LN5@gzungetc:

; 498  : 
; 499  :     /* process a skip request */
; 500  :     if (state->seek) {

  00031	83 7a 68 00	 cmp	 DWORD PTR [rdx+104], 0
  00035	74 18		 je	 SHORT $LN8@gzungetc

; 501  :         state->seek = 0;

  00037	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [rdx+104], 0

; 502  :         if (gz_skip(state, state->skip) == -1)

  0003e	48 8b cb	 mov	 rcx, rbx
  00041	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00045	e8 00 00 00 00	 call	 gz_skip
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	74 5a		 je	 SHORT $LN6@gzungetc
$LN8@gzungetc:

; 503  :             return -1;
; 504  :     }
; 505  : 
; 506  :     /* can't push EOF */
; 507  :     if (c < 0)

  0004f	85 ff		 test	 edi, edi
  00051	78 56		 js	 SHORT $LN6@gzungetc

; 508  :         return -1;
; 509  : 
; 510  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 511  :     if (state->x.have == 0) {

  00053	8b 0b		 mov	 ecx, DWORD PTR [rbx]

; 512  :         state->x.have = 1;
; 513  :         state->x.next = state->out + (state->size << 1) - 1;

  00055	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 32		 jne	 SHORT $LN10@gzungetc
  0005c	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00060	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00063	48 ff ca	 dec	 rdx
  00066	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  0006c	48 03 d1	 add	 rdx, rcx

; 514  :         state->x.next[0] = (unsigned char)c;
; 515  :         state->x.pos--;
; 516  :         state->past = 0;
; 517  :         return c;

  0006f	8b c7		 mov	 eax, edi
  00071	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  00075	40 88 3a	 mov	 BYTE PTR [rdx], dil
  00078	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  0007c	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 540  : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
$LN10@gzungetc:

; 518  :     }
; 519  : 
; 520  :     /* if no room, give up (must have already done a gzungetc()) */
; 521  :     if (state->x.have == (state->size << 1)) {

  0008e	8d 14 00	 lea	 edx, DWORD PTR [rax+rax]
  00091	3b ca		 cmp	 ecx, edx
  00093	75 22		 jne	 SHORT $LN11@gzungetc

; 522  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  0009c	ba fd ff ff ff	 mov	 edx, -3
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 gz_error
$LN6@gzungetc:

; 496  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 497  :         return -1;

  000a9	83 c8 ff	 or	 eax, -1

; 540  : }

  000ac	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
$LN11@gzungetc:

; 523  :         return -1;
; 524  :     }
; 525  : 
; 526  :     /* slide output data if needed and insert byte before existing data */
; 527  :     if (state->x.next == state->out) {

  000b7	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000bb	48 39 43 08	 cmp	 QWORD PTR [rbx+8], rax
  000bf	75 25		 jne	 SHORT $LN12@gzungetc

; 528  :         unsigned char *src = state->out + state->x.have;

  000c1	48 03 c8	 add	 rcx, rax

; 529  :         unsigned char *dest = state->out + (state->size << 1);

  000c4	48 03 d0	 add	 rdx, rax

; 530  :         while (src > state->out)

  000c7	48 3b c8	 cmp	 rcx, rax
  000ca	76 16		 jbe	 SHORT $LN3@gzungetc
  000cc	0f 1f 40 00	 npad	 4
$LL2@gzungetc:

; 531  :             *--dest = *--src;

  000d0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  000d4	48 ff c9	 dec	 rcx
  000d7	48 ff ca	 dec	 rdx
  000da	88 02		 mov	 BYTE PTR [rdx], al
  000dc	48 3b 4b 38	 cmp	 rcx, QWORD PTR [rbx+56]
  000e0	77 ee		 ja	 SHORT $LL2@gzungetc
$LN3@gzungetc:

; 532  :         state->x.next = dest;

  000e2	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
$LN12@gzungetc:

; 533  :     }
; 534  :     state->x.have++;
; 535  :     state->x.next--;

  000e6	48 ff 4b 08	 dec	 QWORD PTR [rbx+8]
  000ea	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ee	ff 03		 inc	 DWORD PTR [rbx]

; 536  :     state->x.next[0] = (unsigned char)c;

  000f0	40 88 38	 mov	 BYTE PTR [rax], dil

; 537  :     state->x.pos--;
; 538  :     state->past = 0;
; 539  :     return c;

  000f3	8b c7		 mov	 eax, edi
  000f5	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  000f9	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 540  : }

  00100	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgets
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzgets	PROC						; COMDAT

; 547  : {

$LN32:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	45 8b f8	 mov	 r15d, r8d
  0000d	4c 8b f2	 mov	 r14, rdx
  00010	48 8b f1	 mov	 rsi, rcx

; 548  :     unsigned left, n;
; 549  :     char *str;
; 550  :     unsigned char *eol;
; 551  :     gz_statep state;
; 552  : 
; 553  :     /* check parameters and get internal structure */
; 554  :     if (file == NULL || buf == NULL || len < 1)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 18 01 00
	00		 je	 $LN8@gzgets
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 0f 01 00
	00		 je	 $LN8@gzgets
  00025	41 83 f8 01	 cmp	 r8d, 1
  00029	0f 8c 05 01 00
	00		 jl	 $LN8@gzgets

; 555  :         return NULL;
; 556  :     state = (gz_statep)file;
; 557  : 
; 558  :     /* check that we're reading and that there's no (serious) error */
; 559  :     if (state->mode != GZ_READ ||

  0002f	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00036	0f 85 f8 00 00
	00		 jne	 $LN8@gzgets
  0003c	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN7@gzgets
  00043	83 f8 fb	 cmp	 eax, -5
  00046	0f 85 e8 00 00
	00		 jne	 $LN8@gzgets
$LN7@gzgets:

; 562  : 
; 563  :     /* process a skip request */
; 564  :     if (state->seek) {

  0004c	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00050	74 19		 je	 SHORT $LN10@gzgets

; 565  :         state->seek = 0;
; 566  :         if (gz_skip(state, state->skip) == -1)

  00052	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00056	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005d	e8 00 00 00 00	 call	 gz_skip
  00062	83 f8 ff	 cmp	 eax, -1
  00065	0f 84 c9 00 00
	00		 je	 $LN8@gzgets
$LN10@gzgets:
  0006b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00070	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00075	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0007a	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 567  :             return NULL;
; 568  :     }
; 569  : 
; 570  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 571  :        append a terminating zero to the string (we don't check for a zero in
; 572  :        the contents, let the user worry about that) */
; 573  :     str = buf;

  0007f	4d 8b e6	 mov	 r12, r14

; 574  :     left = (unsigned)len - 1;

  00082	41 83 ef 01	 sub	 r15d, 1

; 575  :     if (left) do {

  00086	0f 84 a4 00 00
	00		 je	 $LN25@gzgets
  0008c	0f 1f 40 00	 npad	 4
$LL4@gzgets:

; 576  :         /* assure that something is in the output buffer */
; 577  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00090	8b 1e		 mov	 ebx, DWORD PTR [rsi]
  00092	85 db		 test	 ebx, ebx
  00094	75 17		 jne	 SHORT $LN26@gzgets
  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 gz_fetch
  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	0f 84 89 00 00
	00		 je	 $LN25@gzgets

; 578  :             return NULL;                /* error */
; 579  :         if (state->x.have == 0) {       /* end of file */

  000a7	8b 1e		 mov	 ebx, DWORD PTR [rsi]
  000a9	85 db		 test	 ebx, ebx
  000ab	74 52		 je	 SHORT $LN22@gzgets
$LN26@gzgets:

; 581  :             break;                      /* return what we have */
; 582  :         }
; 583  : 
; 584  :         /* look for end-of-line in current output buffer */
; 585  :         n = state->x.have > left ? left : state->x.have;
; 586  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  000ad	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000b1	41 3b df	 cmp	 ebx, r15d
  000b4	ba 0a 00 00 00	 mov	 edx, 10
  000b9	41 0f 47 df	 cmova	 ebx, r15d
  000bd	44 8b c3	 mov	 r8d, ebx
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c6	48 8b e8	 mov	 rbp, rax

; 587  :         if (eol != NULL)

  000c9	48 85 c0	 test	 rax, rax
  000cc	74 07		 je	 SHORT $LN14@gzgets

; 588  :             n = (unsigned)(eol - state->x.next) + 1;

  000ce	8b dd		 mov	 ebx, ebp
  000d0	2b 5e 08	 sub	 ebx, DWORD PTR [rsi+8]
  000d3	ff c3		 inc	 ebx
$LN14@gzgets:

; 589  : 
; 590  :         /* copy through end-of-line, or remainder if not found */
; 591  :         memcpy(buf, state->x.next, n);

  000d5	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  000d9	49 8b ce	 mov	 rcx, r14
  000dc	44 8b c3	 mov	 r8d, ebx
  000df	8b fb		 mov	 edi, ebx
  000e1	e8 00 00 00 00	 call	 memcpy

; 592  :         state->x.have -= n;

  000e6	29 1e		 sub	 DWORD PTR [rsi], ebx

; 593  :         state->x.next += n;
; 594  :         state->x.pos += n;
; 595  :         left -= n;
; 596  :         buf += n;

  000e8	4c 03 f7	 add	 r14, rdi
  000eb	48 01 7e 08	 add	 QWORD PTR [rsi+8], rdi
  000ef	48 01 7e 10	 add	 QWORD PTR [rsi+16], rdi
  000f3	44 2b fb	 sub	 r15d, ebx

; 597  :     } while (left && eol == NULL);

  000f6	74 0e		 je	 SHORT $LN15@gzgets
  000f8	48 85 ed	 test	 rbp, rbp
  000fb	74 93		 je	 SHORT $LL4@gzgets
  000fd	eb 07		 jmp	 SHORT $LN15@gzgets
$LN22@gzgets:

; 580  :             state->past = 1;            /* read past end */

  000ff	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [rsi+84], 1
$LN15@gzgets:

; 598  : 
; 599  :     /* return terminated string, or if nothing, end of file */
; 600  :     if (buf == str)

  00106	4d 3b f4	 cmp	 r14, r12
  00109	74 25		 je	 SHORT $LN25@gzgets

; 602  :     buf[0] = 0;

  0010b	41 c6 06 00	 mov	 BYTE PTR [r14], 0

; 603  :     return str;

  0010f	49 8b c4	 mov	 rax, r12
$LN30@gzgets:
  00112	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00117	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0011c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00121	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 604  : }

  00126	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012a	41 5f		 pop	 r15
  0012c	41 5e		 pop	 r14
  0012e	5e		 pop	 rsi
  0012f	c3		 ret	 0
$LN25@gzgets:

; 601  :         return NULL;

  00130	33 c0		 xor	 eax, eax
  00132	eb de		 jmp	 SHORT $LN30@gzgets
$LN8@gzgets:

; 560  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 561  :         return NULL;

  00134	33 c0		 xor	 eax, eax

; 604  : }

  00136	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013a	41 5f		 pop	 r15
  0013c	41 5e		 pop	 r14
  0013e	5e		 pop	 rsi
  0013f	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzdirect
_TEXT	SEGMENT
file$ = 48
gzdirect PROC						; COMDAT

; 609  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 610  :     gz_statep state;
; 611  : 
; 612  :     /* get internal structure */
; 613  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN2@gzdirect

; 614  :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 624  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN2@gzdirect:

; 615  :     state = (gz_statep)file;
; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00016	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001d	75 10		 jne	 SHORT $LN3@gzdirect
  0001f	83 79 44 00	 cmp	 DWORD PTR [rcx+68], 0
  00023	75 0a		 jne	 SHORT $LN3@gzdirect
  00025	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00028	75 05		 jne	 SHORT $LN3@gzdirect

; 620  :         (void)gz_look(state);

  0002a	e8 00 00 00 00	 call	 gz_look
$LN3@gzdirect:

; 621  : 
; 622  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 623  :     return state->direct;

  0002f	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]

; 624  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
END
