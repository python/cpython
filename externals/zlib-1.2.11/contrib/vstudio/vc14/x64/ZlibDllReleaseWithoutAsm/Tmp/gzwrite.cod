; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
EXTRN	__imp__write:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
PUBLIC	gzsetparams
PUBLIC	gzflush
PUBLIC	gzprintf
PUBLIC	gzvprintf
PUBLIC	gzputs
PUBLIC	gzputc
PUBLIC	gzfwrite
PUBLIC	gzwrite
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN15
	DD	imagerel $LN15+192
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzvprintf DD imagerel $LN17
	DD	imagerel $LN17+318
	DD	imagerel $unwind$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN10
	DD	imagerel $LN10+30
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzputs DD imagerel $LN10+30
	DD	imagerel $LN10+79
	DD	imagerel $chain$0$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzputs DD imagerel $LN10+79
	DD	imagerel $LN10+89
	DD	imagerel $chain$1$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN14
	DD	imagerel $LN14+190
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfwrite DD imagerel $LN10
	DD	imagerel $LN10+114
	DD	imagerel $unwind$gzfwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN8
	DD	imagerel $LN8+65
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_write DD imagerel gz_write
	DD	imagerel gz_write+97
	DD	imagerel $unwind$gz_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_write DD imagerel gz_write+97
	DD	imagerel gz_write+228
	DD	imagerel $chain$1$gz_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_write DD imagerel gz_write+228
	DD	imagerel gz_write+317
	DD	imagerel $chain$3$gz_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_zero DD imagerel gz_zero+50
	DD	imagerel gz_zero+172
	DD	imagerel $chain$1$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_zero DD imagerel gz_zero+172
	DD	imagerel gz_zero+177
	DD	imagerel $chain$3$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+179
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_comp DD imagerel gz_comp+179
	DD	imagerel gz_comp+447
	DD	imagerel $chain$1$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_comp DD imagerel gz_comp+447
	DD	imagerel gz_comp+469
	DD	imagerel $chain$2$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+70
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_init DD imagerel gz_init+70
	DD	imagerel gz_init+240
	DD	imagerel $chain$0$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_init DD imagerel gz_init+240
	DD	imagerel gz_init+295
	DD	imagerel $chain$2$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN13
	DD	imagerel $LN13+194
	DD	imagerel $unwind$gzclose_w
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_init DD 020021H
	DD	0a6400H
	DD	imagerel gz_init
	DD	imagerel gz_init+70
	DD	imagerel $unwind$gz_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_init DD 020521H
	DD	0a6405H
	DD	imagerel gz_init
	DD	imagerel gz_init+70
	DD	imagerel $unwind$gz_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 040a01H
	DD	0b340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_comp DD 021H
	DD	imagerel gz_comp
	DD	imagerel gz_comp+179
	DD	imagerel $unwind$gz_comp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_comp DD 020521H
	DD	065405H
	DD	imagerel gz_comp
	DD	imagerel gz_comp+179
	DD	imagerel $unwind$gz_comp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 084201H
	DD	076442H
	DD	097410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_zero DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_zero DD 040f21H
	DD	07640fH
	DD	065405H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+50
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_write DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel gz_write
	DD	imagerel gz_write+97
	DD	imagerel $unwind$gz_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_write DD 040a21H
	DD	09740aH
	DD	086405H
	DD	imagerel gz_write
	DD	imagerel gz_write+97
	DD	imagerel $unwind$gz_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_write DD 060e01H
	DD	0a340eH
	DD	0f00a320eH
	DD	05006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfwrite DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzputs DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+30
	DD	imagerel $unwind$gzputs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzputs DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+30
	DD	imagerel $unwind$gzputs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzvprintf DD 088d01H
	DD	06648dH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 083b01H
	DD	06543bH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzclose_w
_TEXT	SEGMENT
file$ = 48
gzclose_w PROC						; COMDAT

; 629  : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 630  :     int ret = Z_OK;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 10		 jne	 SHORT $LN2@gzclose_w
$LN11@gzclose_w:

; 635  :         return Z_STREAM_ERROR;

  00014	b8 fe ff ff ff	 mov	 eax, -2

; 664  :     return ret;
; 665  : }

  00019	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN2@gzclose_w:

; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're writing */
; 639  :     if (state->mode != GZ_WRITE)

  00024	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0002b	75 e7		 jne	 SHORT $LN11@gzclose_w

; 640  :         return Z_STREAM_ERROR;
; 641  : 
; 642  :     /* check for seek request */
; 643  :     if (state->seek) {

  0002d	39 79 68	 cmp	 DWORD PTR [rcx+104], edi
  00030	74 14		 je	 SHORT $LN5@gzclose_w

; 644  :         state->seek = 0;
; 645  :         if (gz_zero(state, state->skip) == -1)

  00032	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00036	89 79 68	 mov	 DWORD PTR [rcx+104], edi
  00039	e8 00 00 00 00	 call	 gz_zero
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	75 03		 jne	 SHORT $LN5@gzclose_w

; 646  :             ret = state->err;

  00043	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN5@gzclose_w:

; 647  :     }
; 648  : 
; 649  :     /* flush, free memory, and close file */
; 650  :     if (gz_comp(state, Z_FINISH) == -1)

  00046	ba 04 00 00 00	 mov	 edx, 4
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 gz_comp
  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 03		 jne	 SHORT $LN6@gzclose_w

; 651  :         ret = state->err;

  00058	8b 7b 6c	 mov	 edi, DWORD PTR [rbx+108]
$LN6@gzclose_w:

; 652  :     if (state->size) {

  0005b	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0005f	74 23		 je	 SHORT $LN7@gzclose_w

; 653  :         if (!state->direct) {

  00061	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00065	75 13		 jne	 SHORT $LN8@gzclose_w

; 654  :             (void)deflateEnd(&(state->strm));

  00067	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  0006b	e8 00 00 00 00	 call	 deflateEnd

; 655  :             free(state->out);

  00070	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gzclose_w:

; 656  :         }
; 657  :         free(state->in);

  0007a	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@gzclose_w:

; 658  :     }
; 659  :     gz_error(state, Z_OK, NULL);

  00084	45 33 c0	 xor	 r8d, r8d
  00087	33 d2		 xor	 edx, edx
  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 gz_error

; 660  :     free(state->path);

  00091	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 661  :     if (close(state->fd) == -1)

  0009b	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  000a4	83 c9 ff	 or	 ecx, -1
  000a7	3b c1		 cmp	 eax, ecx
  000a9	0f 44 f9	 cmove	 edi, ecx

; 662  :         ret = Z_ERRNO;
; 663  :     free(state);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 664  :     return ret;
; 665  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	8b c7		 mov	 eax, edi
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_init
_TEXT	SEGMENT
state$ = 80
gz_init	PROC						; COMDAT

; 19   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 20   :     int ret;
; 21   :     z_streamp strm = &(state->strm);
; 22   : 
; 23   :     /* allocate input buffer (double size for gzprintf) */
; 24   :     state->in = (unsigned char *)malloc(state->want << 1);

  0000a	8b 41 2c	 mov	 eax, DWORD PTR [rcx+44]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00019	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 25   :     if (state->in == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 20		 jne	 SHORT $LN2@gz_init

; 26   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	8d 50 fc	 lea	 edx, QWORD PTR [rax-4]
  0002f	e8 00 00 00 00	 call	 gz_error

; 27   :         return -1;

  00034	83 c8 ff	 or	 eax, -1

; 65   : }

  00037	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN2@gz_init:

; 28   :     }
; 29   : 
; 30   :     /* only need output buffer and deflate state if compressing */
; 31   :     if (!state->direct) {

  00042	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00046	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0004b	0f 85 a3 00 00
	00		 jne	 $LN3@gz_init

; 32   :         /* allocate output buffer */
; 33   :         state->out = (unsigned char *)malloc(state->want);

  00051	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005a	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 34   :         if (state->out == NULL) {

  0005e	48 85 c0	 test	 rax, rax
  00061	74 5c		 je	 SHORT $LN9@gz_init

; 35   :             free(state->in);
; 36   :             gz_error(state, Z_MEM_ERROR, "out of memory");
; 37   :             return -1;
; 38   :         }
; 39   : 
; 40   :         /* allocate deflate memory, set up for gzip compression */
; 41   :         strm->zalloc = Z_NULL;

  00063	33 f6		 xor	 esi, esi

; 42   :         strm->zfree = Z_NULL;
; 43   :         strm->opaque = Z_NULL;
; 44   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,

  00065	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411?$AA@
  00074	48 89 b3 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rsi
  0007b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00080	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  00084	48 89 b3 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rsi
  0008b	48 89 b3 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rsi
  00092	44 8d 4e 1f	 lea	 r9d, QWORD PTR [rsi+31]
  00096	8b 43 5c	 mov	 eax, DWORD PTR [rbx+92]
  00099	44 8d 46 08	 lea	 r8d, QWORD PTR [rsi+8]
  0009d	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  000a0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a4	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000ac	e8 00 00 00 00	 call	 deflateInit2_

; 45   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
; 46   :         if (ret != Z_OK) {

  000b1	85 c0		 test	 eax, eax
  000b3	74 3b		 je	 SHORT $LN5@gz_init

; 47   :             free(state->out);

  000b5	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@gz_init:

; 48   :             free(state->in);

  000bf	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 49   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000d0	ba fc ff ff ff	 mov	 edx, -4
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	e8 00 00 00 00	 call	 gz_error
  000dd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 50   :             return -1;

  000e2	83 c8 ff	 or	 eax, -1

; 65   : }

  000e5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000ea	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
$LN5@gz_init:

; 51   :         }
; 52   :         strm->next_in = NULL;

  000f0	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
$LN3@gz_init:

; 53   :     }
; 54   : 
; 55   :     /* mark state as initialized */
; 56   :     state->size = state->want;
; 57   : 
; 58   :     /* initialize write buffer if compressing */
; 59   :     if (!state->direct) {

  000f4	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  000f8	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000fb	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  000fe	75 15		 jne	 SHORT $LN6@gz_init

; 60   :         strm->avail_out = state->size;

  00100	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax

; 61   :         strm->next_out = state->out;

  00106	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0010a	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 62   :         state->x.next = strm->next_out;

  00111	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN6@gz_init:

; 63   :     }
; 64   :     return 0;

  00115	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0011a	33 c0		 xor	 eax, eax

; 65   : }

  0011c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00121	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00125	5f		 pop	 rdi
  00126	c3		 ret	 0
gz_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_comp
_TEXT	SEGMENT
state$ = 48
flush$ = 56
gz_comp	PROC						; COMDAT

; 76   : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   :     int ret, writ;
; 78   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
; 79   :     z_streamp strm = &(state->strm);
; 80   : 
; 81   :     /* allocate memory if this is the first time through */
; 82   :     if (state->size == 0 && gz_init(state) == -1)

  00010	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00014	44 8b f2	 mov	 r14d, edx
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	75 1d		 jne	 SHORT $LN9@gz_comp
  0001c	e8 00 00 00 00	 call	 gz_init
  00021	83 f8 ff	 cmp	 eax, -1
  00024	75 13		 jne	 SHORT $LN9@gz_comp

; 83   :         return -1;

  00026	0b c0		 or	 eax, eax

; 141  : }

  00028	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	41 5e		 pop	 r14
  00038	c3		 ret	 0
$LN9@gz_comp:

; 84   : 
; 85   :     /* write directly if requested */
; 86   :     if (state->direct) {

  00039	83 7f 40 00	 cmp	 DWORD PTR [rdi+64], 0
  0003d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00042	74 6d		 je	 SHORT $LN10@gz_comp

; 87   :         while (strm->avail_in) {

  00044	83 bf 80 00 00
	00 00		 cmp	 DWORD PTR [rdi+128], 0
  0004b	74 39		 je	 SHORT $LN3@gz_comp
  0004d	be 00 00 00 40	 mov	 esi, 1073741824		; 40000000H
$LL2@gz_comp:

; 88   :             put = strm->avail_in > max ? max : strm->avail_in;

  00052	44 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [rdi+128]
  00059	44 3b c6	 cmp	 r8d, esi

; 89   :             writ = write(state->fd, strm->next_in, put);

  0005c	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  00060	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00063	44 0f 47 c6	 cmova	 r8d, esi
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write

; 90   :             if (writ < 0) {

  0006d	85 c0		 test	 eax, eax
  0006f	78 1c		 js	 SHORT $LN27@gz_comp

; 93   :             }
; 94   :             strm->avail_in -= (unsigned)writ;

  00071	29 87 80 00 00
	00		 sub	 DWORD PTR [rdi+128], eax

; 95   :             strm->next_in += writ;

  00077	48 98		 cdqe
  00079	48 01 47 78	 add	 QWORD PTR [rdi+120], rax
  0007d	83 bf 80 00 00
	00 00		 cmp	 DWORD PTR [rdi+128], 0
  00084	75 cc		 jne	 SHORT $LL2@gz_comp
$LN3@gz_comp:

; 96   :         }
; 97   :         return 0;

  00086	33 c0		 xor	 eax, eax
  00088	e9 32 01 00 00	 jmp	 $LN39@gz_comp
$LN27@gz_comp:

; 91   :                 gz_error(state, Z_ERRNO, zstrerror());

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00093	8b 08		 mov	 ecx, DWORD PTR [rax]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0009b	83 ca ff	 or	 edx, -1
  0009e	48 8b cf	 mov	 rcx, rdi
  000a1	4c 8b c0	 mov	 r8, rax
  000a4	e8 00 00 00 00	 call	 gz_error

; 92   :                 return -1;

  000a9	83 c8 ff	 or	 eax, -1
  000ac	e9 0e 01 00 00	 jmp	 $LN39@gz_comp
$LN10@gz_comp:

; 98   :     }
; 99   : 
; 100  :     /* run deflate() on provided input until it produces no more output */
; 101  :     ret = Z_OK;

  000b1	33 c0		 xor	 eax, eax
  000b3	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  000b8	be 00 00 00 40	 mov	 esi, 1073741824		; 40000000H
  000bd	0f 1f 00	 npad	 3
$LL6@gz_comp:

; 102  :     do {
; 103  :         /* write out current buffer contents if full, or if flushing, but if
; 104  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 105  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&

  000c0	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  000c7	74 14		 je	 SHORT $LN26@gz_comp
  000c9	45 85 f6	 test	 r14d, r14d
  000cc	0f 84 85 00 00
	00		 je	 $LN16@gz_comp
  000d2	41 83 fe 04	 cmp	 r14d, 4
  000d6	75 05		 jne	 SHORT $LN26@gz_comp
  000d8	83 f8 01	 cmp	 eax, 1
  000db	75 7a		 jne	 SHORT $LN16@gz_comp
$LN26@gz_comp:

; 106  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {
; 107  :             while (strm->next_out > state->x.next) {

  000dd	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000e1	48 39 87 88 00
	00 00		 cmp	 QWORD PTR [rdi+136], rax
  000e8	76 48		 jbe	 SHORT $LN8@gz_comp
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL7@gz_comp:

; 108  :                 put = strm->next_out - state->x.next > (int)max ? max :

  000f0	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000f4	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  000fb	48 2b c2	 sub	 rax, rdx
  000fe	48 3b c6	 cmp	 rax, rsi
  00101	7e 05		 jle	 SHORT $LN22@gz_comp
  00103	44 8b c6	 mov	 r8d, esi
  00106	eb 0a		 jmp	 SHORT $LN23@gz_comp
$LN22@gz_comp:
  00108	44 8b 87 88 00
	00 00		 mov	 r8d, DWORD PTR [rdi+136]
  0010f	44 2b c2	 sub	 r8d, edx
$LN23@gz_comp:

; 109  :                       (unsigned)(strm->next_out - state->x.next);
; 110  :                 writ = write(state->fd, state->x.next, put);

  00112	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write

; 111  :                 if (writ < 0) {

  0011b	85 c0		 test	 eax, eax
  0011d	78 6e		 js	 SHORT $LN28@gz_comp

; 114  :                 }
; 115  :                 state->x.next += writ;

  0011f	48 98		 cdqe
  00121	48 01 47 08	 add	 QWORD PTR [rdi+8], rax
  00125	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00129	48 39 87 88 00
	00 00		 cmp	 QWORD PTR [rdi+136], rax
  00130	77 be		 ja	 SHORT $LL7@gz_comp
$LN8@gz_comp:

; 116  :             }
; 117  :             if (strm->avail_out == 0) {

  00132	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  00139	75 1c		 jne	 SHORT $LN16@gz_comp

; 118  :                 strm->avail_out = state->size;

  0013b	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  0013e	89 87 90 00 00
	00		 mov	 DWORD PTR [rdi+144], eax

; 119  :                 strm->next_out = state->out;

  00144	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00148	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax

; 120  :                 state->x.next = state->out;

  0014f	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00153	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN16@gz_comp:

; 121  :             }
; 122  :         }
; 123  : 
; 124  :         /* compress */
; 125  :         have = strm->avail_out;

  00157	8b af 90 00 00
	00		 mov	 ebp, DWORD PTR [rdi+144]

; 126  :         ret = deflate(strm, flush);

  0015d	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00161	41 8b d6	 mov	 edx, r14d
  00164	e8 00 00 00 00	 call	 deflate

; 127  :         if (ret == Z_STREAM_ERROR) {

  00169	83 f8 fe	 cmp	 eax, -2
  0016c	74 35		 je	 SHORT $LN30@gz_comp

; 131  :         }
; 132  :         have -= strm->avail_out;

  0016e	3b af 90 00 00
	00		 cmp	 ebp, DWORD PTR [rdi+144]

; 133  :     } while (have);

  00174	0f 85 46 ff ff
	ff		 jne	 $LL6@gz_comp

; 134  : 
; 135  :     /* if that completed a deflate stream, allow another to start */
; 136  :     if (flush == Z_FINISH)

  0017a	41 83 fe 04	 cmp	 r14d, 4
  0017e	75 09		 jne	 SHORT $LN18@gz_comp

; 137  :         deflateReset(strm);

  00180	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00184	e8 00 00 00 00	 call	 deflateReset
$LN18@gz_comp:

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  00189	33 c0		 xor	 eax, eax
  0018b	eb 2d		 jmp	 SHORT $LN40@gz_comp
$LN28@gz_comp:

; 112  :                     gz_error(state, Z_ERRNO, zstrerror());

  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00193	8b 08		 mov	 ecx, DWORD PTR [rax]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0019b	4c 8b c0	 mov	 r8, rax
  0019e	83 ca ff	 or	 edx, -1

; 113  :                     return -1;

  001a1	eb 0c		 jmp	 SHORT $LN41@gz_comp
$LN30@gz_comp:

; 128  :             gz_error(state, Z_STREAM_ERROR,

  001a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  001aa	ba fe ff ff ff	 mov	 edx, -2
$LN41@gz_comp:
  001af	48 8b cf	 mov	 rcx, rdi
  001b2	e8 00 00 00 00	 call	 gz_error

; 129  :                       "internal error: deflate stream corrupt");
; 130  :             return -1;

  001b7	83 c8 ff	 or	 eax, -1
$LN40@gz_comp:
  001ba	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN39@gz_comp:
  001bf	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 141  : }

  001c4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001c9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d2	41 5e		 pop	 r14
  001d4	c3		 ret	 0
gz_comp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_zero
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_zero	PROC						; COMDAT

; 148  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 149  :     int first;
; 150  :     unsigned n;
; 151  :     z_streamp strm = &(state->strm);
; 152  : 
; 153  :     /* consume whatever's left in the input buffer */
; 154  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000a	83 b9 80 00 00
	00 00		 cmp	 DWORD PTR [rcx+128], 0
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	74 19		 je	 SHORT $LN4@gz_zero
  00019	33 d2		 xor	 edx, edx
  0001b	e8 00 00 00 00	 call	 gz_comp
  00020	83 f8 ff	 cmp	 eax, -1
  00023	75 0d		 jne	 SHORT $LN4@gz_zero

; 155  :         return -1;

  00025	0b c0		 or	 eax, eax

; 174  : }

  00027	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN4@gz_zero:
  00032	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;

  00037	bd 01 00 00 00	 mov	 ebp, 1
  0003c	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 159  :     while (len) {

  00041	48 85 ff	 test	 rdi, rdi
  00044	74 4f		 je	 SHORT $LN3@gz_zero
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@gz_zero:

; 160  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?

  00050	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00053	8b f7		 mov	 esi, edi
  00055	48 3b c7	 cmp	 rax, rdi
  00058	0f 4e f0	 cmovle	 esi, eax

; 161  :             (unsigned)len : state->size;
; 162  :         if (first) {

  0005b	85 ed		 test	 ebp, ebp
  0005d	74 10		 je	 SHORT $LN5@gz_zero

; 163  :             memset(state->in, 0, n);

  0005f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00063	33 d2		 xor	 edx, edx
  00065	44 8b c6	 mov	 r8d, esi
  00068	e8 00 00 00 00	 call	 memset

; 164  :             first = 0;

  0006d	33 ed		 xor	 ebp, ebp
$LN5@gz_zero:

; 165  :         }
; 166  :         strm->avail_in = n;

  0006f	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi

; 167  :         strm->next_in = state->in;
; 168  :         state->x.pos += n;
; 169  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00075	33 d2		 xor	 edx, edx
  00077	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
  00082	48 01 73 10	 add	 QWORD PTR [rbx+16], rsi
  00086	e8 00 00 00 00	 call	 gz_comp
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	74 1c		 je	 SHORT $LN11@gz_zero

; 171  :         len -= n;

  00090	48 2b fe	 sub	 rdi, rsi

; 159  :     while (len) {

  00093	75 bb		 jne	 SHORT $LL2@gz_zero
$LN3@gz_zero:

; 172  :     }
; 173  :     return 0;

  00095	33 c0		 xor	 eax, eax
$LN16@gz_zero:
  00097	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 174  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN11@gz_zero:

; 170  :             return -1;

  000ac	83 c8 ff	 or	 eax, -1
  000af	eb e6		 jmp	 SHORT $LN16@gz_zero
gz_zero	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_write
_TEXT	SEGMENT
state$ = 64
buf$ = 72
len$ = 80
gz_write PROC						; COMDAT

; 182  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	49 8b e8	 mov	 rbp, r8
  00011	4c 8b f2	 mov	 r14, rdx
  00014	48 8b d9	 mov	 rbx, rcx

; 183  :     z_size_t put = len;

  00017	4d 8b f8	 mov	 r15, r8

; 184  : 
; 185  :     /* if len is zero, avoid unnecessary operations */
; 186  :     if (len == 0)

  0001a	4d 85 c0	 test	 r8, r8
  0001d	75 11		 jne	 SHORT $LN8@gz_write
$LN32@gz_write:

; 187  :         return 0;

  0001f	33 c0		 xor	 eax, eax

; 243  : }

  00021	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	41 5f		 pop	 r15
  0002c	41 5e		 pop	 r14
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
$LN8@gz_write:

; 188  : 
; 189  :     /* allocate memory if this is the first time through */
; 190  :     if (state->size == 0 && gz_init(state) == -1)

  00030	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00034	75 0a		 jne	 SHORT $LN9@gz_write
  00036	e8 00 00 00 00	 call	 gz_init
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	74 df		 je	 SHORT $LN32@gz_write
$LN9@gz_write:

; 191  :         return 0;
; 192  : 
; 193  :     /* check for seek request */
; 194  :     if (state->seek) {

  00040	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00044	74 18		 je	 SHORT $LN11@gz_write

; 195  :         state->seek = 0;
; 196  :         if (gz_zero(state, state->skip) == -1)

  00046	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [rbx+104], 0
  00054	e8 00 00 00 00	 call	 gz_zero
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	74 c1		 je	 SHORT $LN32@gz_write
$LN11@gz_write:

; 197  :             return 0;
; 198  :     }
; 199  : 
; 200  :     /* for small len, copy to input buffer, otherwise compress directly */
; 201  :     if (len < state->size) {

  0005e	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00061	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00066	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0006b	48 3b e8	 cmp	 rbp, rax
  0006e	73 74		 jae	 SHORT $LN12@gz_write
$LL4@gz_write:

; 202  :         /* copy to input buffer, compress when full */
; 203  :         do {
; 204  :             unsigned have, copy;
; 205  : 
; 206  :             if (state->strm.avail_in == 0)

  00070	8b 93 80 00 00
	00		 mov	 edx, DWORD PTR [rbx+128]
  00076	85 d2		 test	 edx, edx
  00078	75 08		 jne	 SHORT $LN14@gz_write

; 207  :                 state->strm.next_in = state->in;

  0007a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0007e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN14@gz_write:

; 208  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -

  00082	8b 4b 78	 mov	 ecx, DWORD PTR [rbx+120]
  00085	2b 4b 30	 sub	 ecx, DWORD PTR [rbx+48]

; 209  :                               state->in);
; 210  :             copy = state->size - have;

  00088	8b 73 28	 mov	 esi, DWORD PTR [rbx+40]
  0008b	03 ca		 add	 ecx, edx
  0008d	2b f1		 sub	 esi, ecx

; 211  :             if (copy > len)
; 212  :                 copy = len;
; 213  :             memcpy(state->in + have, buf, copy);

  0008f	49 8b d6	 mov	 rdx, r14
  00092	8b c6		 mov	 eax, esi
  00094	48 3b c5	 cmp	 rax, rbp
  00097	0f 47 f5	 cmova	 esi, ebp
  0009a	48 03 4b 30	 add	 rcx, QWORD PTR [rbx+48]
  0009e	44 8b c6	 mov	 r8d, esi
  000a1	8b fe		 mov	 edi, esi
  000a3	e8 00 00 00 00	 call	 memcpy

; 214  :             state->strm.avail_in += copy;

  000a8	01 b3 80 00 00
	00		 add	 DWORD PTR [rbx+128], esi

; 215  :             state->x.pos += copy;
; 216  :             buf = (const char *)buf + copy;

  000ae	4c 03 f7	 add	 r14, rdi
  000b1	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 217  :             len -= copy;

  000b5	48 2b ef	 sub	 rbp, rdi

; 218  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000b8	74 7e		 je	 SHORT $LN6@gz_write
  000ba	33 d2		 xor	 edx, edx
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 gz_comp
  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	75 a7		 jne	 SHORT $LL4@gz_write
$LN25@gz_write:

; 236  :                 return 0;

  000c9	33 c0		 xor	 eax, eax
$LN31@gz_write:
  000cb	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 243  : }

  000d5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	41 5f		 pop	 r15
  000e0	41 5e		 pop	 r14
  000e2	5d		 pop	 rbp
  000e3	c3		 ret	 0
$LN12@gz_write:

; 219  :                 return 0;
; 220  :         } while (len);
; 221  :     }
; 222  :     else {
; 223  :         /* consume whatever's left in the input buffer */
; 224  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000e4	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  000eb	74 0f		 je	 SHORT $LN17@gz_write
  000ed	33 d2		 xor	 edx, edx
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 gz_comp
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	74 cd		 je	 SHORT $LN25@gz_write
$LN17@gz_write:

; 225  :             return 0;
; 226  : 
; 227  :         /* directly compress user buffer to file */
; 228  :         state->strm.next_in = (z_const Bytef *)buf;

  000fc	4c 89 73 78	 mov	 QWORD PTR [rbx+120], r14
  00100	be ff ff ff ff	 mov	 esi, -1			; ffffffffH
  00105	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@gz_write:

; 229  :         do {
; 230  :             unsigned n = (unsigned)-1;
; 231  :             if (n > len)

  00110	8b ce		 mov	 ecx, esi
  00112	48 3b ee	 cmp	 rbp, rsi
  00115	0f 42 cd	 cmovb	 ecx, ebp

; 232  :                 n = len;
; 233  :             state->strm.avail_in = n;
; 234  :             state->x.pos += n;
; 235  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  00118	33 d2		 xor	 edx, edx
  0011a	8b f9		 mov	 edi, ecx
  0011c	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi
  00120	89 8b 80 00 00
	00		 mov	 DWORD PTR [rbx+128], ecx
  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 gz_comp
  0012e	83 f8 ff	 cmp	 eax, -1
  00131	74 96		 je	 SHORT $LN25@gz_write

; 237  :             len -= n;

  00133	48 2b ef	 sub	 rbp, rdi

; 238  :         } while (len);

  00136	75 d8		 jne	 SHORT $LL7@gz_write
$LN6@gz_write:

; 239  :     }
; 240  : 
; 241  :     /* input was all buffered or compressed */
; 242  :     return put;

  00138	49 8b c7	 mov	 rax, r15
  0013b	eb 8e		 jmp	 SHORT $LN31@gz_write
gz_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzwrite
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
gzwrite	PROC						; COMDAT

; 250  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 251  :     gz_statep state;
; 252  : 
; 253  :     /* get internal structure */
; 254  :     if (file == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 25		 je	 SHORT $LN4@gzwrite

; 255  :         return 0;
; 256  :     state = (gz_statep)file;
; 257  : 
; 258  :     /* check that we're writing and that there's no error */
; 259  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00009	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00010	75 1c		 jne	 SHORT $LN4@gzwrite
  00012	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00016	75 16		 jne	 SHORT $LN4@gzwrite

; 261  : 
; 262  :     /* since an int is returned, make sure len fits in one, otherwise return
; 263  :        with an error (this avoids a flaw in the interface) */
; 264  :     if ((int)len < 0) {

  00018	45 85 c0	 test	 r8d, r8d
  0001b	79 18		 jns	 SHORT $LN5@gzwrite

; 265  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00024	ba fd ff ff ff	 mov	 edx, -3
  00029	e8 00 00 00 00	 call	 gz_error
$LN4@gzwrite:

; 260  :         return 0;

  0002e	33 c0		 xor	 eax, eax

; 271  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
$LN5@gzwrite:

; 266  :         return 0;
; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  00035	45 8b c0	 mov	 r8d, r8d

; 271  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 266  :         return 0;
; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  0003c	e9 00 00 00 00	 jmp	 gz_write
gzwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzfwrite
_TEXT	SEGMENT
buf$ = 48
size$ = 56
nitems$ = 64
file$ = 72
gzfwrite PROC						; COMDAT

; 279  : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b d0	 mov	 r10, r8
  00009	48 8b da	 mov	 rbx, rdx

; 280  :     z_size_t len;
; 281  :     gz_statep state;
; 282  : 
; 283  :     /* get internal structure */
; 284  :     if (file == NULL)

  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3e		 je	 SHORT $LN4@gzfwrite

; 285  :         return 0;
; 286  :     state = (gz_statep)file;
; 287  : 
; 288  :     /* check that we're writing and that there's no error */
; 289  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	41 81 79 18 b1
	79 00 00	 cmp	 DWORD PTR [r9+24], 31153 ; 000079b1H
  00019	75 34		 jne	 SHORT $LN4@gzfwrite
  0001b	41 83 79 6c 00	 cmp	 DWORD PTR [r9+108], 0
  00020	75 2d		 jne	 SHORT $LN4@gzfwrite

; 291  : 
; 292  :     /* compute bytes to read -- error on overflow */
; 293  :     len = nitems * size;

  00022	4c 8b c2	 mov	 r8, rdx
  00025	4d 0f af c2	 imul	 r8, r10

; 294  :     if (size && len / size != nitems) {

  00029	48 85 d2	 test	 rdx, rdx
  0002c	74 29		 je	 SHORT $LN5@gzfwrite
  0002e	33 d2		 xor	 edx, edx
  00030	49 8b c0	 mov	 rax, r8
  00033	48 f7 f3	 div	 rbx
  00036	49 3b c2	 cmp	 rax, r10
  00039	74 1c		 je	 SHORT $LN5@gzfwrite

; 295  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@
  00042	ba fe ff ff ff	 mov	 edx, -2
  00047	49 8b c9	 mov	 rcx, r9
  0004a	e8 00 00 00 00	 call	 gz_error
$LN4@gzfwrite:

; 290  :         return 0;

  0004f	33 c0		 xor	 eax, eax

; 301  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN5@gzfwrite:

; 296  :         return 0;
; 297  :     }
; 298  : 
; 299  :     /* write len bytes to buf, return the number of full items written */
; 300  :     return len ? gz_write(state, buf, len) / size : 0;

  00057	4d 85 c0	 test	 r8, r8
  0005a	74 f3		 je	 SHORT $LN4@gzfwrite
  0005c	48 8b d1	 mov	 rdx, rcx
  0005f	49 8b c9	 mov	 rcx, r9
  00062	e8 00 00 00 00	 call	 gz_write
  00067	33 d2		 xor	 edx, edx
  00069	48 f7 f3	 div	 rbx

; 301  : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
gzfwrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzputc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
c$ = 56
gzputc	PROC						; COMDAT

; 307  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 308  :     unsigned have;
; 309  :     unsigned char buf[1];
; 310  :     gz_statep state;
; 311  :     z_streamp strm;
; 312  : 
; 313  :     /* get internal structure */
; 314  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 98 00 00
	00		 je	 $LN4@gzputc

; 315  :         return -1;
; 316  :     state = (gz_statep)file;
; 317  :     strm = &(state->strm);
; 318  : 
; 319  :     /* check that we're writing and that there's no error */
; 320  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00018	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001f	0f 85 8b 00 00
	00		 jne	 $LN4@gzputc
  00025	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00029	0f 85 81 00 00
	00		 jne	 $LN4@gzputc

; 322  : 
; 323  :     /* check for seek request */
; 324  :     if (state->seek) {

  0002f	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00033	74 15		 je	 SHORT $LN6@gzputc

; 325  :         state->seek = 0;
; 326  :         if (gz_zero(state, state->skip) == -1)

  00035	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00039	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00040	e8 00 00 00 00	 call	 gz_zero
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 66		 je	 SHORT $LN4@gzputc
$LN6@gzputc:

; 327  :             return -1;
; 328  :     }
; 329  : 
; 330  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 331  :        initialized) */
; 332  :     if (state->size) {

  0004a	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0004e	74 42		 je	 SHORT $LN9@gzputc

; 333  :         if (strm->avail_in == 0)

  00050	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00056	85 c9		 test	 ecx, ecx
  00058	75 08		 jne	 SHORT $LN8@gzputc

; 334  :             strm->next_in = state->in;

  0005a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0005e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN8@gzputc:

; 335  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00062	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  00065	2b 43 30	 sub	 eax, DWORD PTR [rbx+48]
  00068	03 c1		 add	 eax, ecx

; 336  :         if (have < state->size) {

  0006a	3b 43 28	 cmp	 eax, DWORD PTR [rbx+40]
  0006d	73 23		 jae	 SHORT $LN9@gzputc

; 337  :             state->in[have] = (unsigned char)c;

  0006f	8b c8		 mov	 ecx, eax
  00071	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00075	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil

; 338  :             strm->avail_in++;

  00079	ff 83 80 00 00
	00		 inc	 DWORD PTR [rbx+128]

; 339  :             state->x.pos++;

  0007f	48 ff 43 10	 inc	 QWORD PTR [rbx+16]
$LN12@gzputc:

; 340  :             return c & 0xff;

  00083	40 0f b6 c7	 movzx	 eax, dil

; 347  :         return -1;
; 348  :     return c & 0xff;
; 349  : }

  00087	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
$LN9@gzputc:

; 341  :         }
; 342  :     }
; 343  : 
; 344  :     /* no room in buffer or not initialized, use gz_write() */
; 345  :     buf[0] = (unsigned char)c;
; 346  :     if (gz_write(state, buf, 1) != 1)

  00092	41 b8 01 00 00
	00		 mov	 r8d, 1
  00098	40 88 7c 24 30	 mov	 BYTE PTR buf$[rsp], dil
  0009d	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	e8 00 00 00 00	 call	 gz_write
  000aa	48 83 f8 01	 cmp	 rax, 1
  000ae	74 d3		 je	 SHORT $LN12@gzputc
$LN4@gzputc:

; 321  :         return -1;

  000b0	83 c8 ff	 or	 eax, -1

; 347  :         return -1;
; 348  :     return c & 0xff;
; 349  : }

  000b3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
str$ = 56
gzputs	PROC						; COMDAT

; 355  : {

$LN10:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 356  :     int ret;
; 357  :     z_size_t len;
; 358  :     gz_statep state;
; 359  : 
; 360  :     /* get internal structure */
; 361  :     if (file == NULL)

  00006	48 85 c9	 test	 rcx, rcx
  00009	74 44		 je	 SHORT $LN4@gzputs

; 362  :         return -1;
; 363  :     state = (gz_statep)file;
; 364  : 
; 365  :     /* check that we're writing and that there's no error */
; 366  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000b	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00012	75 3b		 jne	 SHORT $LN4@gzputs
  00014	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00018	75 35		 jne	 SHORT $LN4@gzputs

; 368  : 
; 369  :     /* write string */
; 370  :     len = strlen(str);

  0001a	48 83 cf ff	 or	 rdi, -1
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 8b df	 mov	 rbx, rdi
$LL8@gzputs:
  00026	48 ff c3	 inc	 rbx
  00029	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  0002d	75 f7		 jne	 SHORT $LL8@gzputs

; 371  :     ret = gz_write(state, str, len);

  0002f	4c 8b c3	 mov	 r8, rbx
  00032	e8 00 00 00 00	 call	 gz_write

; 372  :     return ret == 0 && len != 0 ? -1 : ret;

  00037	85 c0		 test	 eax, eax
  00039	75 05		 jne	 SHORT $LN6@gzputs
  0003b	48 85 db	 test	 rbx, rbx
  0003e	75 02		 jne	 SHORT $LN7@gzputs
$LN6@gzputs:
  00040	8b f8		 mov	 edi, eax
$LN7@gzputs:
  00042	8b c7		 mov	 eax, edi
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 373  : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
$LN4@gzputs:

; 367  :         return -1;

  0004f	48 83 c8 ff	 or	 rax, -1

; 373  : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzvprintf
_TEXT	SEGMENT
file$ = 48
format$ = 56
va$ = 64
gzvprintf PROC						; COMDAT

; 380  : {

$LN17:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b ea	 mov	 rbp, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 381  :     int len;
; 382  :     unsigned left;
; 383  :     char *next;
; 384  :     gz_statep state;
; 385  :     z_streamp strm;
; 386  : 
; 387  :     /* get internal structure */
; 388  :     if (file == NULL)

  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 15		 jne	 SHORT $LN2@gzvprintf
$LN4@gzvprintf:

; 389  :         return Z_STREAM_ERROR;

  0001d	b8 fe ff ff ff	 mov	 eax, -2

; 449  : }

  00022	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00027	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN2@gzvprintf:

; 390  :     state = (gz_statep)file;
; 391  :     strm = &(state->strm);
; 392  : 
; 393  :     /* check that we're writing and that there's no error */
; 394  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00032	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00039	75 e2		 jne	 SHORT $LN4@gzvprintf
  0003b	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0003f	75 dc		 jne	 SHORT $LN4@gzvprintf

; 395  :         return Z_STREAM_ERROR;
; 396  : 
; 397  :     /* make sure we have some buffer space */
; 398  :     if (state->size == 0 && gz_init(state) == -1)

  00041	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00045	75 1d		 jne	 SHORT $LN5@gzvprintf
  00047	e8 00 00 00 00	 call	 gz_init
  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	75 13		 jne	 SHORT $LN5@gzvprintf
$LN15@gzvprintf:

; 399  :         return state->err;

  00051	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]

; 449  : }

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
$LN5@gzvprintf:

; 400  : 
; 401  :     /* check for seek request */
; 402  :     if (state->seek) {

  00064	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00068	74 18		 je	 SHORT $LN7@gzvprintf

; 403  :         state->seek = 0;
; 404  :         if (gz_zero(state, state->skip) == -1)

  0006a	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [rbx+104], 0
  00078	e8 00 00 00 00	 call	 gz_zero
  0007d	83 f8 ff	 cmp	 eax, -1
  00080	74 cf		 je	 SHORT $LN15@gzvprintf
$LN7@gzvprintf:

; 405  :             return state->err;
; 406  :     }
; 407  : 
; 408  :     /* do the printf() into the input buffer, put length in len -- the input
; 409  :        buffer is double-sized just for this function, so there is guaranteed to
; 410  :        be state->size bytes available after the current contents */
; 411  :     if (strm->avail_in == 0)

  00082	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00088	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0008d	85 c9		 test	 ecx, ecx
  0008f	75 08		 jne	 SHORT $LN8@gzvprintf

; 412  :         strm->next_in = state->in;

  00091	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00095	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN8@gzvprintf:

; 413  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
; 414  :     next[state->size - 1] = 0;

  00099	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  0009c	48 8b f1	 mov	 rsi, rcx
  0009f	48 03 73 78	 add	 rsi, QWORD PTR [rbx+120]
  000a3	ff c8		 dec	 eax

; 415  : #ifdef NO_vsnprintf
; 416  : #  ifdef HAS_vsprintf_void
; 417  :     (void)vsprintf(next, format, va);
; 418  :     for (len = 0; len < state->size; len++)
; 419  :         if (next[len] == 0) break;
; 420  : #  else
; 421  :     len = vsprintf(next, format, va);
; 422  : #  endif
; 423  : #else
; 424  : #  ifdef HAS_vsnprintf_void
; 425  :     (void)vsnprintf(next, state->size, format, va);
; 426  :     len = strlen(next);
; 427  : #  else
; 428  :     len = vsnprintf(next, state->size, format, va);

  000a5	4c 8b cf	 mov	 r9, rdi
  000a8	4c 8b c5	 mov	 r8, rbp
  000ab	48 8b ce	 mov	 rcx, rsi
  000ae	c6 04 30 00	 mov	 BYTE PTR [rax+rsi], 0
  000b2	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000b5	e8 00 00 00 00	 call	 vsnprintf
  000ba	48 63 f8	 movsxd	 rdi, eax

; 429  : #  endif
; 430  : #endif
; 431  : 
; 432  :     /* check that printf() results fit in buffer */
; 433  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  000bd	85 c0		 test	 eax, eax
  000bf	74 66		 je	 SHORT $LN10@gzvprintf
  000c1	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000c4	3b f9		 cmp	 edi, ecx
  000c6	73 5f		 jae	 SHORT $LN10@gzvprintf
  000c8	ff c9		 dec	 ecx
  000ca	80 3c 31 00	 cmp	 BYTE PTR [rcx+rsi], 0
  000ce	75 57		 jne	 SHORT $LN10@gzvprintf

; 435  : 
; 436  :     /* update buffer and position, compress first half if past that */
; 437  :     strm->avail_in += (unsigned)len;

  000d0	01 bb 80 00 00
	00		 add	 DWORD PTR [rbx+128], edi

; 438  :     state->x.pos += len;

  000d6	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 439  :     if (strm->avail_in >= state->size) {

  000da	8b b3 80 00 00
	00		 mov	 esi, DWORD PTR [rbx+128]
  000e0	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  000e3	3b f0		 cmp	 esi, eax
  000e5	72 3c		 jb	 SHORT $LN11@gzvprintf

; 440  :         left = strm->avail_in - state->size;
; 441  :         strm->avail_in = state->size;
; 442  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000e7	33 d2		 xor	 edx, edx
  000e9	89 83 80 00 00
	00		 mov	 DWORD PTR [rbx+128], eax
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	2b f0		 sub	 esi, eax
  000f4	e8 00 00 00 00	 call	 gz_comp
  000f9	83 f8 ff	 cmp	 eax, -1
  000fc	75 05		 jne	 SHORT $LN12@gzvprintf

; 443  :             return state->err;

  000fe	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]
  00101	eb 26		 jmp	 SHORT $LN14@gzvprintf
$LN12@gzvprintf:

; 444  :         memcpy(state->in, state->in + state->size, left);

  00103	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00107	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0010a	48 03 d1	 add	 rdx, rcx
  0010d	44 8b c6	 mov	 r8d, esi
  00110	e8 00 00 00 00	 call	 memcpy

; 445  :         strm->next_in = state->in;

  00115	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00119	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 446  :         strm->avail_in = left;

  0011d	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi
$LN11@gzvprintf:

; 447  :     }
; 448  :     return len;

  00123	8b c7		 mov	 eax, edi
  00125	eb 02		 jmp	 SHORT $LN14@gzvprintf
$LN10@gzvprintf:

; 434  :         return 0;

  00127	33 c0		 xor	 eax, eax
$LN14@gzvprintf:
  00129	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 449  : }

  0012e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00133	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5f		 pop	 rdi
  0013d	c3		 ret	 0
gzvprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzprintf
_TEXT	SEGMENT
file$ = 48
format$ = 56
gzprintf PROC						; COMDAT

; 452  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 453  :     va_list va;
; 454  :     int ret;
; 455  : 
; 456  :     va_start(va, format);

  00013	4c 8d 44 24 40	 lea	 r8, QWORD PTR format$[rsp+8]

; 457  :     ret = gzvprintf(file, format, va);

  00018	e8 00 00 00 00	 call	 gzvprintf

; 458  :     va_end(va);
; 459  :     return ret;
; 460  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzflush
_TEXT	SEGMENT
file$ = 48
flush$ = 56
gzflush	PROC						; COMDAT

; 556  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 557  :     gz_statep state;
; 558  : 
; 559  :     /* get internal structure */
; 560  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	74 47		 je	 SHORT $LN4@gzflush

; 561  :         return Z_STREAM_ERROR;
; 562  :     state = (gz_statep)file;
; 563  : 
; 564  :     /* check that we're writing and that there's no error */
; 565  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00014	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001b	75 3e		 jne	 SHORT $LN4@gzflush
  0001d	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00021	75 38		 jne	 SHORT $LN4@gzflush

; 567  : 
; 568  :     /* check flush parameter */
; 569  :     if (flush < 0 || flush > Z_FINISH)

  00023	83 fa 04	 cmp	 edx, 4
  00026	77 33		 ja	 SHORT $LN4@gzflush

; 570  :         return Z_STREAM_ERROR;
; 571  : 
; 572  :     /* check for seek request */
; 573  :     if (state->seek) {

  00028	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  0002c	74 15		 je	 SHORT $LN8@gzflush

; 574  :         state->seek = 0;
; 575  :         if (gz_zero(state, state->skip) == -1)

  0002e	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00032	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  00039	e8 00 00 00 00	 call	 gz_zero
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 0a		 je	 SHORT $LN10@gzflush
$LN8@gzflush:

; 576  :             return state->err;
; 577  :     }
; 578  : 
; 579  :     /* compress remaining data with requested flush */
; 580  :     (void)gz_comp(state, flush);

  00043	8b d7		 mov	 edx, edi
  00045	48 8b cb	 mov	 rcx, rbx
  00048	e8 00 00 00 00	 call	 gz_comp
$LN10@gzflush:

; 581  :     return state->err;

  0004d	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]

; 582  : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN4@gzflush:

; 566  :         return Z_STREAM_ERROR;

  0005b	b8 fe ff ff ff	 mov	 eax, -2

; 582  : }

  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzsetparams
_TEXT	SEGMENT
file$ = 48
level$ = 56
strategy$ = 64
gzsetparams PROC					; COMDAT

; 589  : {

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f8	 mov	 edi, r8d
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 590  :     gz_statep state;
; 591  :     z_streamp strm;
; 592  : 
; 593  :     /* get internal structure */
; 594  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 13		 jne	 SHORT $LN2@gzsetparam

; 595  :         return Z_STREAM_ERROR;

  0001c	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 624  : }

  0001f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00024	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN2@gzsetparam:

; 596  :     state = (gz_statep)file;
; 597  :     strm = &(state->strm);
; 598  : 
; 599  :     /* check that we're writing and that there's no error */
; 600  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0002f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00036	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003b	75 69		 jne	 SHORT $LN4@gzsetparam
  0003d	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  00041	75 63		 jne	 SHORT $LN4@gzsetparam

; 602  : 
; 603  :     /* if no change is requested, then do nothing */
; 604  :     if (level == state->level && strategy == state->strategy)

  00043	3b 71 58	 cmp	 esi, DWORD PTR [rcx+88]
  00046	75 05		 jne	 SHORT $LN5@gzsetparam
  00048	3b 79 5c	 cmp	 edi, DWORD PTR [rcx+92]
  0004b	74 55		 je	 SHORT $LN12@gzsetparam
$LN5@gzsetparam:

; 605  :         return Z_OK;
; 606  : 
; 607  :     /* check for seek request */
; 608  :     if (state->seek) {

  0004d	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00051	74 15		 je	 SHORT $LN7@gzsetparam

; 609  :         state->seek = 0;
; 610  :         if (gz_zero(state, state->skip) == -1)

  00053	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00057	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [rcx+104], 0
  0005e	e8 00 00 00 00	 call	 gz_zero
  00063	83 f8 ff	 cmp	 eax, -1
  00066	74 21		 je	 SHORT $LN13@gzsetparam
$LN7@gzsetparam:

; 611  :             return state->err;
; 612  :     }
; 613  : 
; 614  :     /* change compression parameters for subsequent input */
; 615  :     if (state->size) {

  00068	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  0006c	74 2e		 je	 SHORT $LN8@gzsetparam

; 616  :         /* flush previous input with previous parameters before changing */
; 617  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  0006e	83 bb 80 00 00
	00 00		 cmp	 DWORD PTR [rbx+128], 0
  00075	74 17		 je	 SHORT $LN9@gzsetparam
  00077	ba 05 00 00 00	 mov	 edx, 5
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 gz_comp
  00084	83 f8 ff	 cmp	 eax, -1
  00087	75 05		 jne	 SHORT $LN9@gzsetparam
$LN13@gzsetparam:

; 618  :             return state->err;

  00089	8b 43 6c	 mov	 eax, DWORD PTR [rbx+108]
  0008c	eb 1d		 jmp	 SHORT $LN11@gzsetparam
$LN9@gzsetparam:

; 619  :         deflateParams(strm, level, strategy);

  0008e	44 8b c7	 mov	 r8d, edi
  00091	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  00095	8b d6		 mov	 edx, esi
  00097	e8 00 00 00 00	 call	 deflateParams
$LN8@gzsetparam:

; 620  :     }
; 621  :     state->level = level;

  0009c	89 73 58	 mov	 DWORD PTR [rbx+88], esi

; 622  :     state->strategy = strategy;

  0009f	89 7b 5c	 mov	 DWORD PTR [rbx+92], edi
$LN12@gzsetparam:

; 623  :     return Z_OK;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 05		 jmp	 SHORT $LN11@gzsetparam
$LN4@gzsetparam:

; 601  :         return Z_STREAM_ERROR;

  000a6	b8 fe ff ff ff	 mov	 eax, -2
$LN11@gzsetparam:
  000ab	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 624  : }

  000b0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
END
