; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

?my_version@?1??deflateInit2_@@9@9 DB '1.2.11', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+9
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
PUBLIC	deflateCopy
PUBLIC	deflateBound
PUBLIC	deflateTune
PUBLIC	deflateParams
PUBLIC	deflatePrime
PUBLIC	deflatePending
PUBLIC	deflateSetHeader
PUBLIC	deflateReset
PUBLIC	deflateResetKeep
PUBLIC	deflateGetDictionary
PUBLIC	deflateSetDictionary
PUBLIC	deflateInit2_
PUBLIC	deflateInit_
PUBLIC	deflateEnd
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+452
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+828
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+1294
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+1009
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+16
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflate_stored DD imagerel deflate_stored+16
	DD	imagerel deflate_stored+24
	DD	imagerel $chain$0$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflate_stored DD imagerel deflate_stored+24
	DD	imagerel deflate_stored+434
	DD	imagerel $chain$4$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate_stored DD imagerel deflate_stored+434
	DD	imagerel deflate_stored+633
	DD	imagerel $chain$5$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate_stored DD imagerel deflate_stored+633
	DD	imagerel deflate_stored+1038
	DD	imagerel $chain$6$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+516
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+454
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+176
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+160
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateCopy DD imagerel $LN13+41
	DD	imagerel $LN13+148
	DD	imagerel $chain$1$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateCopy DD imagerel $LN13+148
	DD	imagerel $LN13+597
	DD	imagerel $chain$4$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateCopy DD imagerel $LN13+597
	DD	imagerel $LN13+612
	DD	imagerel $chain$6$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateCopy DD imagerel $LN13+612
	DD	imagerel $LN13+623
	DD	imagerel $chain$7$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$flush_pending DD imagerel flush_pending+52
	DD	imagerel flush_pending+91
	DD	imagerel $chain$0$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$flush_pending DD imagerel flush_pending+91
	DD	imagerel flush_pending+115
	DD	imagerel $chain$1$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN30
	DD	imagerel $LN30+273
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN19
	DD	imagerel $LN19+44
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateParams DD imagerel $LN19+44
	DD	imagerel $LN19+89
	DD	imagerel $chain$1$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateParams DD imagerel $LN19+89
	DD	imagerel $LN19+169
	DD	imagerel $chain$2$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateParams DD imagerel $LN19+169
	DD	imagerel $LN19+190
	DD	imagerel $chain$3$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateParams DD imagerel $LN19+190
	DD	imagerel $LN19+360
	DD	imagerel $chain$5$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateParams DD imagerel $LN19+360
	DD	imagerel $LN19+370
	DD	imagerel $chain$6$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN16
	DD	imagerel $LN16+175
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePending DD imagerel $LN7
	DD	imagerel $LN7+69
	DD	imagerel $unwind$deflatePending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetHeader DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$deflateSetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateResetKeep DD imagerel $LN10
	DD	imagerel $LN10+174
	DD	imagerel $unwind$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateGetDictionary DD imagerel $LN8
	DD	imagerel $LN8+121
	DD	imagerel $unwind$deflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN27
	DD	imagerel $LN27+39
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateSetDictionary DD imagerel $LN27+39
	DD	imagerel $LN27+96
	DD	imagerel $chain$1$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateSetDictionary DD imagerel $LN27+96
	DD	imagerel $LN27+501
	DD	imagerel $chain$4$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateSetDictionary DD imagerel $LN27+501
	DD	imagerel $LN27+519
	DD	imagerel $chain$5$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateSetDictionary DD imagerel $LN27+519
	DD	imagerel $LN27+526
	DD	imagerel $chain$7$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$deflateSetDictionary DD imagerel $LN27+526
	DD	imagerel $LN27+539
	DD	imagerel $chain$8$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN25
	DD	imagerel $LN25+87
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateInit2_ DD imagerel $LN25+87
	DD	imagerel $LN25+275
	DD	imagerel $chain$2$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateInit2_ DD imagerel $LN25+275
	DD	imagerel $LN25+575
	DD	imagerel $chain$3$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateInit2_ DD imagerel $LN25+575
	DD	imagerel $LN25+601
	DD	imagerel $chain$4$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateInit2_ DD imagerel $LN25+601
	DD	imagerel $LN25+634
	DD	imagerel $chain$6$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateInit2_ DD imagerel $LN25+634
	DD	imagerel $LN25+641
	DD	imagerel $chain$7$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$deflateInit2_ DD imagerel $LN25+641
	DD	imagerel $LN25+657
	DD	imagerel $chain$8$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN9
	DD	imagerel $LN9+156
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflate DD imagerel $LN139+42
	DD	imagerel $LN139+126
	DD	imagerel $chain$0$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflate DD imagerel $LN139+126
	DD	imagerel $LN139+185
	DD	imagerel $chain$3$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate DD imagerel $LN139+185
	DD	imagerel $LN139+284
	DD	imagerel $chain$5$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflate DD imagerel $LN139+284
	DD	imagerel $LN139+731
	DD	imagerel $chain$7$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$deflate DD imagerel $LN139+731
	DD	imagerel $LN139+1050
	DD	imagerel $chain$9$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$deflate DD imagerel $LN139+1050
	DD	imagerel $LN139+2131
	DD	imagerel $chain$12$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$deflate DD imagerel $LN139+2131
	DD	imagerel $LN139+2352
	DD	imagerel $chain$14$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$deflate DD imagerel $LN139+2352
	DD	imagerel $LN139+2381
	DD	imagerel $chain$15$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$deflate DD imagerel $LN139+2381
	DD	imagerel $LN139+2394
	DD	imagerel $chain$16$deflate
;	COMDAT xdata
xdata	SEGMENT
$chain$16$deflate DD 021H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$deflate DD 020021H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$deflate DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$deflate DD 060f21H
	DD	04f40fH
	DD	0be40aH
	DD	095405H
	DD	imagerel $LN139+731
	DD	imagerel $LN139+1050
	DD	imagerel $chain$9$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$deflate DD 040021H
	DD	0a6400H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflate DD 040021H
	DD	0a6400H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate DD 040021H
	DD	0a6400H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflate DD 040821H
	DD	0a6408H
	DD	083400H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflate DD 020521H
	DD	083405H
	DD	imagerel $LN139
	DD	imagerel $LN139+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 030801H
	DD	0c0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 042601H
	DD	067426H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$deflateInit2_ DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+87
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateInit2_ DD 060021H
	DD	04d400H
	DD	0cc400H
	DD	0a5400H
	DD	imagerel $LN25
	DD	imagerel $LN25+87
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateInit2_ DD 080021H
	DD	04d400H
	DD	0cc400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel $LN25
	DD	imagerel $LN25+87
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateInit2_ DD 021H
	DD	imagerel $LN25+87
	DD	imagerel $LN25+275
	DD	imagerel $chain$2$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateInit2_ DD 020521H
	DD	0b6405H
	DD	imagerel $LN25+87
	DD	imagerel $LN25+275
	DD	imagerel $chain$2$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateInit2_ DD 066221H
	DD	0cc462H
	DD	04d40aH
	DD	0a5405H
	DD	imagerel $LN25
	DD	imagerel $LN25+87
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 050b01H
	DD	0f007420bH
	DD	07003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$deflateSetDictionary DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+39
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateSetDictionary DD 040021H
	DD	05e400H
	DD	0a3400H
	DD	imagerel $LN27
	DD	imagerel $LN27+39
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateSetDictionary DD 021H
	DD	imagerel $LN27+39
	DD	imagerel $LN27+96
	DD	imagerel $chain$1$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateSetDictionary DD 060f21H
	DD	04f40fH
	DD	0cd40aH
	DD	0bc405H
	DD	imagerel $LN27+39
	DD	imagerel $LN27+96
	DD	imagerel $chain$1$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateSetDictionary DD 040e21H
	DD	05e40eH
	DD	0a3405H
	DD	imagerel $LN27
	DD	imagerel $LN27+39
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 040801H
	DD	070045208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateGetDictionary DD 042c01H
	DD	06342cH
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateResetKeep DD 063201H
	DD	076432H
	DD	063429H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePending DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateParams DD 040021H
	DD	077400H
	DD	063400H
	DD	imagerel $LN19
	DD	imagerel $LN19+44
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateParams DD 060021H
	DD	08e400H
	DD	077400H
	DD	063400H
	DD	imagerel $LN19
	DD	imagerel $LN19+44
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateParams DD 021H
	DD	imagerel $LN19+44
	DD	imagerel $LN19+89
	DD	imagerel $chain$1$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateParams DD 020521H
	DD	08e405H
	DD	imagerel $LN19+44
	DD	imagerel $LN19+89
	DD	imagerel $chain$1$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateParams DD 041221H
	DD	077412H
	DD	063405H
	DD	imagerel $LN19
	DD	imagerel $LN19+44
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 040a01H
	DD	09540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$flush_pending DD 021H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$flush_pending DD 020521H
	DD	063405H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateCopy DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateCopy DD 060021H
	DD	08e400H
	DD	077400H
	DD	066400H
	DD	imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateCopy DD 060521H
	DD	08e405H
	DD	077400H
	DD	066400H
	DD	imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateCopy DD 041421H
	DD	077414H
	DD	066405H
	DD	imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 084701H
	DD	065447H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate_stored DD 020021H
	DD	0d7400H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+16
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate_stored DD 020021H
	DD	0d7400H
	DD	imagerel deflate_stored+16
	DD	imagerel deflate_stored+24
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflate_stored DD 083721H
	DD	0d7437H
	DD	0c6432H
	DD	0b541aH
	DD	04d405H
	DD	imagerel deflate_stored+16
	DD	imagerel deflate_stored+24
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflate_stored DD 020521H
	DD	05c405H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+16
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 040a01H
	DD	0f006520aH
	DD	03002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 0c1e01H
	DD	0a541eH
	DD	0c6417H
	DD	0b3417H
	DD	0f0133217H
	DD	0d00fe011H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate
_TEXT	SEGMENT
strm$ = 64
flush$ = 72
deflate	PROC						; COMDAT

; 766  : {

$LN139:
  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	44 8b e2	 mov	 r12d, edx
  0000b	48 8b f9	 mov	 rdi, rcx

; 767  :     int old_flush; /* value of flush param for previous deflate call */
; 768  :     deflate_state *s;
; 769  : 
; 770  :     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {

  0000e	e8 00 00 00 00	 call	 deflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 32 09 00
	00		 jne	 $LN29@deflate
  0001b	41 83 fc 05	 cmp	 r12d, 5
  0001f	0f 87 28 09 00
	00		 ja	 $LN29@deflate

; 772  :     }
; 773  :     s = strm->state;
; 774  : 
; 775  :     if (strm->next_out == Z_NULL ||
; 776  :         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||

  00025	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  0002a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0002f	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  00033	0f 84 f7 08 00
	00		 je	 $LN31@deflate
  00039	39 47 08	 cmp	 DWORD PTR [rdi+8], eax
  0003c	74 0a		 je	 SHORT $LN32@deflate
  0003e	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  00042	0f 84 e8 08 00
	00		 je	 $LN31@deflate
$LN32@deflate:
  00048	81 7b 08 9a 02
	00 00		 cmp	 DWORD PTR [rbx+8], 666	; 0000029aH
  0004f	75 0a		 jne	 SHORT $LN30@deflate
  00051	41 83 fc 04	 cmp	 r12d, 4
  00055	0f 85 d5 08 00
	00		 jne	 $LN31@deflate
$LN30@deflate:

; 779  :     }
; 780  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005b	83 7f 18 00	 cmp	 DWORD PTR [rdi+24], 0
  0005f	75 1d		 jne	 SHORT $LN33@deflate
  00061	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00068	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006d	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00071	b8 fb ff ff ff	 mov	 eax, -5

; 1073 : }

  00076	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007a	41 5c		 pop	 r12
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN33@deflate:

; 781  : 
; 782  :     old_flush = s->last_flush;

  0007e	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00081	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 783  :     s->last_flush = flush;
; 784  : 
; 785  :     /* Flush as much pending output as possible */
; 786  :     if (s->pending != 0) {

  00086	33 f6		 xor	 esi, esi
  00088	44 89 63 40	 mov	 DWORD PTR [rbx+64], r12d
  0008c	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  0008f	74 28		 je	 SHORT $LN34@deflate

; 787  :         flush_pending(strm);

  00091	48 8b cf	 mov	 rcx, rdi
  00094	e8 00 00 00 00	 call	 flush_pending

; 788  :         if (strm->avail_out == 0) {

  00099	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  0009c	75 4d		 jne	 SHORT $LN37@deflate

; 789  :             /* Since avail_out is 0, deflate will be called again with
; 790  :              * more output space, but possibly with both pending and
; 791  :              * avail_in equal to zero. There won't be anything to do,
; 792  :              * but this is not an error situation so make sure we
; 793  :              * return OK instead of BUF_ERROR at next call of deflate:
; 794  :              */
; 795  :             s->last_flush = -1;
; 796  :             return Z_OK;

  0009e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a3	33 c0		 xor	 eax, eax
  000a5	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
  000ac	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1073 : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	41 5c		 pop	 r12
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
$LN34@deflate:

; 797  :         }
; 798  : 
; 799  :     /* Make sure there is something to do and avoid duplicate consecutive
; 800  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 801  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 802  :      */
; 803  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&

  000b9	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000bc	75 2d		 jne	 SHORT $LN37@deflate
  000be	83 fa 04	 cmp	 edx, 4
  000c1	41 b8 09 00 00
	00		 mov	 r8d, 9
  000c7	8b c6		 mov	 eax, esi
  000c9	8b ce		 mov	 ecx, esi
  000cb	41 0f 4f c0	 cmovg	 eax, r8d
  000cf	03 d2		 add	 edx, edx
  000d1	2b d0		 sub	 edx, eax
  000d3	43 8d 04 24	 lea	 eax, DWORD PTR [r12+r12]
  000d7	41 83 fc 04	 cmp	 r12d, 4
  000db	41 0f 4f c8	 cmovg	 ecx, r8d
  000df	2b c1		 sub	 eax, ecx
  000e1	3b c2		 cmp	 eax, edx
  000e3	7f 06		 jg	 SHORT $LN37@deflate
  000e5	41 83 fc 04	 cmp	 r12d, 4
  000e9	75 0f		 jne	 SHORT $LN137@deflate
$LN37@deflate:

; 804  :                flush != Z_FINISH) {
; 805  :         ERR_RETURN(strm, Z_BUF_ERROR);
; 806  :     }
; 807  : 
; 808  :     /* User must not provide more input after the first FINISH: */
; 809  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  000eb	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  000ee	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  000f3	75 27		 jne	 SHORT $LN38@deflate
  000f5	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000f8	74 22		 je	 SHORT $LN38@deflate
$LN137@deflate:

; 810  :         ERR_RETURN(strm, Z_BUF_ERROR);

  000fa	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00101	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00106	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0010b	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  0010f	b8 fb ff ff ff	 mov	 eax, -5

; 1073 : }

  00114	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00118	41 5c		 pop	 r12
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
$LN38@deflate:

; 811  :     }
; 812  : 
; 813  :     /* Write the header */
; 814  :     if (s->status == INIT_STATE) {

  0011c	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0011f	0f 85 ac 00 00
	00		 jne	 $LN49@deflate

; 815  :         /* zlib header */
; 816  :         uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00125	8b 4b 48	 mov	 ecx, DWORD PTR [rbx+72]
  00128	c1 e1 0c	 shl	 ecx, 12
  0012b	81 e9 00 78 00
	00		 sub	 ecx, 30720		; 00007800H

; 817  :         uInt level_flags;
; 818  : 
; 819  :         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  00131	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00138	7d 24		 jge	 SHORT $LN42@deflate
  0013a	8b 93 ac 00 00
	00		 mov	 edx, DWORD PTR [rbx+172]
  00140	83 fa 02	 cmp	 edx, 2
  00143	7c 19		 jl	 SHORT $LN42@deflate

; 821  :         else if (s->level < 6)

  00145	83 fa 06	 cmp	 edx, 6
  00148	7d 07		 jge	 SHORT $LN43@deflate

; 822  :             level_flags = 1;

  0014a	b8 01 00 00 00	 mov	 eax, 1
  0014f	eb 0f		 jmp	 SHORT $LN46@deflate
$LN43@deflate:

; 823  :         else if (s->level == 6)

  00151	83 fa 06	 cmp	 edx, 6
  00154	8b c6		 mov	 eax, esi
  00156	0f 95 c0	 setne	 al
  00159	83 c0 02	 add	 eax, 2

; 824  :             level_flags = 2;
; 825  :         else
; 826  :             level_flags = 3;

  0015c	eb 02		 jmp	 SHORT $LN46@deflate
$LN42@deflate:

; 820  :             level_flags = 0;

  0015e	8b c6		 mov	 eax, esi
$LN46@deflate:

; 827  :         header |= (level_flags << 6);

  00160	c1 e0 06	 shl	 eax, 6
  00163	0b c1		 or	 eax, ecx
  00165	8b c8		 mov	 ecx, eax
  00167	83 c9 20	 or	 ecx, 32			; 00000020H
  0016a	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  00170	0f 44 c8	 cmove	 ecx, eax

; 828  :         if (s->strstart != 0) header |= PRESET_DICT;
; 829  :         header += 31 - (header % 31);

  00173	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00178	f7 e1		 mul	 ecx
  0017a	2b ca		 sub	 ecx, edx
  0017c	d1 e9		 shr	 ecx, 1
  0017e	03 ca		 add	 ecx, edx
  00180	c1 e9 04	 shr	 ecx, 4

; 830  : 
; 831  :         putShortMSB(s, header);

  00183	ff c1		 inc	 ecx
  00185	6b d1 1f	 imul	 edx, ecx, 31
  00188	48 8b cb	 mov	 rcx, rbx
  0018b	e8 00 00 00 00	 call	 putShortMSB

; 832  : 
; 833  :         /* Save the adler32 of the preset dictionary: */
; 834  :         if (s->strstart != 0) {

  00190	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  00196	74 12		 je	 SHORT $LN48@deflate

; 835  :             putShortMSB(s, (uInt)(strm->adler >> 16));

  00198	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  0019c	e8 00 00 00 00	 call	 putShortMSB

; 836  :             putShortMSB(s, (uInt)(strm->adler & 0xffff));

  001a1	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  001a5	e8 00 00 00 00	 call	 putShortMSB
$LN48@deflate:

; 837  :         }
; 838  :         strm->adler = adler32(0L, Z_NULL, 0);

  001aa	45 33 c0	 xor	 r8d, r8d
  001ad	33 d2		 xor	 edx, edx
  001af	33 c9		 xor	 ecx, ecx
  001b1	e8 00 00 00 00	 call	 adler32
  001b6	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 839  :         s->status = BUSY_STATE;
; 840  : 
; 841  :         /* Compression must start with an empty pending buffer */
; 842  :         flush_pending(strm);

  001b9	48 8b cf	 mov	 rcx, rdi
  001bc	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  001c3	e8 00 00 00 00	 call	 flush_pending

; 843  :         if (s->pending != 0) {

  001c8	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  001cb	0f 85 ef 00 00
	00		 jne	 $LN136@deflate
$LN49@deflate:

; 844  :             s->last_flush = -1;
; 845  :             return Z_OK;
; 846  :         }
; 847  :     }
; 848  : #ifdef GZIP
; 849  :     if (s->status == GZIP_STATE) {

  001d1	83 7b 08 39	 cmp	 DWORD PTR [rbx+8], 57	; 00000039H
  001d5	0f 85 3b 02 00
	00		 jne	 $LN52@deflate

; 850  :         /* gzip header */
; 851  :         strm->adler = crc32(0L, Z_NULL, 0);

  001db	45 33 c0	 xor	 r8d, r8d
  001de	33 d2		 xor	 edx, edx
  001e0	33 c9		 xor	 ecx, ecx
  001e2	e8 00 00 00 00	 call	 crc32
  001e7	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 852  :         put_byte(s, 31);

  001ea	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  001ed	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001f1	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  001f5	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001f8	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 853  :         put_byte(s, 139);

  001fb	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001ff	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  00203	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00206	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 854  :         put_byte(s, 8);

  00209	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0020d	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  00211	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 855  :         if (s->gzhead == Z_NULL) {

  00214	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  00218	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  0021c	4d 85 c0	 test	 r8, r8
  0021f	0f 85 b6 00 00
	00		 jne	 $LN51@deflate

; 856  :             put_byte(s, 0);

  00225	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00229	41 88 34 01	 mov	 BYTE PTR [r9+rax], sil
  0022d	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00230	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 857  :             put_byte(s, 0);

  00233	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00237	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  0023b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0023e	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 858  :             put_byte(s, 0);

  00241	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00245	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00249	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0024c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 859  :             put_byte(s, 0);

  0024f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00253	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00257	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0025a	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 860  :             put_byte(s, 0);

  0025d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00261	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00265	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 861  :             put_byte(s, s->level == 9 ? 2 :

  00268	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  0026e	83 f8 09	 cmp	 eax, 9
  00271	75 05		 jne	 SHORT $LN100@deflate
  00273	8d 50 f9	 lea	 edx, QWORD PTR [rax-7]
  00276	eb 15		 jmp	 SHORT $LN99@deflate
$LN100@deflate:
  00278	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  0027f	7d 07		 jge	 SHORT $LN98@deflate
  00281	8b d6		 mov	 edx, esi
  00283	83 f8 02	 cmp	 eax, 2
  00286	7d 05		 jge	 SHORT $LN99@deflate
$LN98@deflate:
  00288	ba 04 00 00 00	 mov	 edx, 4
$LN99@deflate:
  0028d	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00290	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00294	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00297	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0029a	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 862  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 863  :                       4 : 0));
; 864  :             put_byte(s, OS_CODE);

  0029d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002a1	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10

; 865  :             s->status = BUSY_STATE;
; 866  : 
; 867  :             /* Compression must start with an empty pending buffer */
; 868  :             flush_pending(strm);

  002a5	48 8b cf	 mov	 rcx, rdi
  002a8	ff 43 28	 inc	 DWORD PTR [rbx+40]
  002ab	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  002b2	e8 00 00 00 00	 call	 flush_pending

; 869  :             if (s->pending != 0) {

  002b7	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  002ba	0f 84 56 01 00
	00		 je	 $LN52@deflate
$LN136@deflate:
  002c0	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 870  :                 s->last_flush = -1;
; 871  :                 return Z_OK;

  002c5	33 c0		 xor	 eax, eax
  002c7	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
  002ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1073 : }

  002d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  002d7	41 5c		 pop	 r12
  002d9	5f		 pop	 rdi
  002da	c3		 ret	 0
$LN51@deflate:

; 872  :             }
; 873  :         }
; 874  :         else {
; 875  :             put_byte(s, (s->gzhead->text ? 1 : 0) +

  002db	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  002df	48 f7 d8	 neg	 rax
  002e2	41 8b 40 3c	 mov	 eax, DWORD PTR [r8+60]
  002e6	1a d2		 sbb	 dl, dl
  002e8	80 e2 10	 and	 dl, 16
  002eb	f7 d8		 neg	 eax
  002ed	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  002f1	1a c9		 sbb	 cl, cl
  002f3	80 e1 02	 and	 cl, 2
  002f6	02 d1		 add	 dl, cl
  002f8	48 f7 d8	 neg	 rax
  002fb	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  002ff	1a c9		 sbb	 cl, cl
  00301	80 e1 08	 and	 cl, 8
  00304	02 d1		 add	 dl, cl
  00306	48 f7 d8	 neg	 rax
  00309	1a c9		 sbb	 cl, cl
  0030b	80 e1 04	 and	 cl, 4
  0030e	02 d1		 add	 dl, cl
  00310	41 39 30	 cmp	 DWORD PTR [r8], esi
  00313	0f 95 c0	 setne	 al
  00316	02 d0		 add	 dl, al
  00318	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0031c	41 88 14 01	 mov	 BYTE PTR [r9+rax], dl
  00320	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00323	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 876  :                      (s->gzhead->hcrc ? 2 : 0) +
; 877  :                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 878  :                      (s->gzhead->name == Z_NULL ? 0 : 8) +
; 879  :                      (s->gzhead->comment == Z_NULL ? 0 : 16)
; 880  :                      );
; 881  :             put_byte(s, (Byte)(s->gzhead->time & 0xff));

  00326	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0032a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0032e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00332	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00335	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00338	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 882  :             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  0033b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0033f	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00343	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00347	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0034a	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0034d	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 883  :             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  00350	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00354	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00358	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0035c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0035f	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 884  :             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  00362	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00366	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00369	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0036d	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00371	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00374	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 885  :             put_byte(s, s->level == 9 ? 2 :

  00377	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  0037d	83 f8 09	 cmp	 eax, 9
  00380	75 05		 jne	 SHORT $LN104@deflate
  00382	8d 50 f9	 lea	 edx, QWORD PTR [rax-7]
  00385	eb 15		 jmp	 SHORT $LN103@deflate
$LN104@deflate:
  00387	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  0038e	7d 07		 jge	 SHORT $LN102@deflate
  00390	8b d6		 mov	 edx, esi
  00392	83 f8 02	 cmp	 eax, 2
  00395	7d 05		 jge	 SHORT $LN103@deflate
$LN102@deflate:
  00397	ba 04 00 00 00	 mov	 edx, 4
$LN103@deflate:
  0039c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0039f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  003a3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  003a6	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 886  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 887  :                       4 : 0));
; 888  :             put_byte(s, s->gzhead->os & 0xff);

  003a9	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003ad	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  003b0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003b4	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  003b8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003bb	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 889  :             if (s->gzhead->extra != Z_NULL) {

  003be	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003c2	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  003c6	48 39 70 10	 cmp	 QWORD PTR [rax+16], rsi
  003ca	74 28		 je	 SHORT $LN54@deflate

; 890  :                 put_byte(s, s->gzhead->extra_len & 0xff);

  003cc	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  003d0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003d4	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  003d8	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 891  :                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  003db	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003df	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  003e2	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003e6	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  003ea	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003ed	ff 43 28	 inc	 DWORD PTR [rbx+40]
  003f0	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
$LN54@deflate:

; 892  :             }
; 893  :             if (s->gzhead->hcrc)

  003f4	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003f8	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  003fb	74 0f		 je	 SHORT $LN55@deflate

; 894  :                 strm->adler = crc32(strm->adler, s->pending_buf,

  003fd	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00401	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00404	e8 00 00 00 00	 call	 crc32
  00409	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN55@deflate:

; 895  :                                     s->pending);
; 896  :             s->gzindex = 0;

  0040c	89 73 38	 mov	 DWORD PTR [rbx+56], esi

; 897  :             s->status = EXTRA_STATE;

  0040f	c7 43 08 45 00
	00 00		 mov	 DWORD PTR [rbx+8], 69	; 00000045H
$LN52@deflate:

; 898  :         }
; 899  :     }
; 900  :     if (s->status == EXTRA_STATE) {

  00416	83 7b 08 45	 cmp	 DWORD PTR [rbx+8], 69	; 00000045H
  0041a	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0041f	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00424	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00429	0f 85 ef 00 00
	00		 jne	 $LN56@deflate

; 901  :         if (s->gzhead->extra != Z_NULL) {

  0042f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00433	48 39 70 10	 cmp	 QWORD PTR [rax+16], rsi
  00437	0f 84 da 00 00
	00		 je	 $LN57@deflate

; 902  :             ulg beg = s->pending;   /* start of bytes to update crc */
; 903  :             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;

  0043d	44 0f b7 78 18	 movzx	 r15d, WORD PTR [rax+24]
  00442	44 2b 7b 38	 sub	 r15d, DWORD PTR [rbx+56]
  00446	44 8b 73 28	 mov	 r14d, DWORD PTR [rbx+40]

; 904  :             while (s->pending + left > s->pending_buf_size) {

  0044a	41 8b ce	 mov	 ecx, r14d
  0044d	41 03 cf	 add	 ecx, r15d
  00450	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  00453	76 7a		 jbe	 SHORT $LN3@deflate
  00455	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@deflate:

; 905  :                 uInt copy = s->pending_buf_size - s->pending;

  00460	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 906  :                 zmemcpy(s->pending_buf + s->pending,

  00463	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00467	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]
  0046a	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  0046d	2b e9		 sub	 ebp, ecx
  0046f	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  00473	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00477	44 8b c5	 mov	 r8d, ebp
  0047a	e8 00 00 00 00	 call	 memcpy

; 907  :                         s->gzhead->extra + s->gzindex, copy);
; 908  :                 s->pending = s->pending_buf_size;
; 909  :                 HCRC_UPDATE(beg);

  0047f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00483	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  00487	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  0048b	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0048e	74 1a		 je	 SHORT $LN4@deflate
  00490	45 3b c6	 cmp	 r8d, r14d
  00493	76 15		 jbe	 SHORT $LN4@deflate
  00495	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00498	45 2b c6	 sub	 r8d, r14d
  0049b	41 8b d6	 mov	 edx, r14d
  0049e	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  004a2	e8 00 00 00 00	 call	 crc32
  004a7	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN4@deflate:

; 910  :                 s->gzindex += copy;

  004aa	01 6b 38	 add	 DWORD PTR [rbx+56], ebp

; 911  :                 flush_pending(strm);

  004ad	48 8b cf	 mov	 rcx, rdi
  004b0	e8 00 00 00 00	 call	 flush_pending

; 912  :                 if (s->pending != 0) {

  004b5	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  004b8	0f 85 64 04 00
	00		 jne	 $LN135@deflate

; 913  :                     s->last_flush = -1;
; 914  :                     return Z_OK;
; 915  :                 }
; 916  :                 beg = 0;
; 917  :                 left -= copy;

  004be	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  004c1	44 2b fd	 sub	 r15d, ebp
  004c4	41 03 cf	 add	 ecx, r15d
  004c7	44 8b f6	 mov	 r14d, esi
  004ca	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  004cd	77 91		 ja	 SHORT $LL2@deflate
$LN3@deflate:

; 918  :             }
; 919  :             zmemcpy(s->pending_buf + s->pending,

  004cf	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004d3	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  004d6	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  004d9	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  004dd	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  004e1	45 8b c7	 mov	 r8d, r15d
  004e4	e8 00 00 00 00	 call	 memcpy

; 920  :                     s->gzhead->extra + s->gzindex, left);
; 921  :             s->pending += left;

  004e9	44 01 7b 28	 add	 DWORD PTR [rbx+40], r15d

; 922  :             HCRC_UPDATE(beg);

  004ed	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004f1	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  004f5	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  004f8	74 1a		 je	 SHORT $LN7@deflate
  004fa	45 3b c6	 cmp	 r8d, r14d
  004fd	76 15		 jbe	 SHORT $LN7@deflate
  004ff	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00502	45 2b c6	 sub	 r8d, r14d
  00505	41 8b d6	 mov	 edx, r14d
  00508	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0050c	e8 00 00 00 00	 call	 crc32
  00511	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN7@deflate:

; 923  :             s->gzindex = 0;

  00514	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN57@deflate:

; 924  :         }
; 925  :         s->status = NAME_STATE;

  00517	c7 43 08 49 00
	00 00		 mov	 DWORD PTR [rbx+8], 73	; 00000049H
$LN56@deflate:

; 926  :     }
; 927  :     if (s->status == NAME_STATE) {

  0051e	83 7b 08 49	 cmp	 DWORD PTR [rbx+8], 73	; 00000049H
  00522	0f 85 b6 00 00
	00		 jne	 $LN61@deflate

; 928  :         if (s->gzhead->name != Z_NULL) {

  00528	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0052c	48 39 70 20	 cmp	 QWORD PTR [rax+32], rsi
  00530	0f 84 a1 00 00
	00		 je	 $LN62@deflate

; 929  :             ulg beg = s->pending;   /* start of bytes to update crc */

  00536	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0053a	66 0f 1f 44 00
	00		 npad	 6
$LL12@deflate:

; 930  :             int val;
; 931  :             do {
; 932  :                 if (s->pending == s->pending_buf_size) {

  00540	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00543	39 43 28	 cmp	 DWORD PTR [rbx+40], eax
  00546	75 3d		 jne	 SHORT $LN63@deflate

; 933  :                     HCRC_UPDATE(beg);

  00548	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0054c	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0054f	74 20		 je	 SHORT $LN13@deflate
  00551	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00554	41 3b c0	 cmp	 eax, r8d
  00557	76 18		 jbe	 SHORT $LN13@deflate
  00559	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0055c	41 2b c0	 sub	 eax, r8d
  0055f	41 8b d0	 mov	 edx, r8d
  00562	44 8b c0	 mov	 r8d, eax
  00565	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00569	e8 00 00 00 00	 call	 crc32
  0056e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN13@deflate:

; 934  :                     flush_pending(strm);

  00571	48 8b cf	 mov	 rcx, rdi
  00574	e8 00 00 00 00	 call	 flush_pending

; 935  :                     if (s->pending != 0) {

  00579	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  0057c	0f 85 a0 03 00
	00		 jne	 $LN135@deflate

; 936  :                         s->last_flush = -1;
; 937  :                         return Z_OK;
; 938  :                     }
; 939  :                     beg = 0;

  00582	44 8b c6	 mov	 r8d, esi
$LN63@deflate:

; 940  :                 }
; 941  :                 val = s->gzhead->name[s->gzindex++];

  00585	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00588	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0058c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00590	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00594	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 942  :                 put_byte(s, val);

  00597	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0059a	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  0059d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  005a1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  005a4	ff 43 28	 inc	 DWORD PTR [rbx+40]
  005a7	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 943  :             } while (val != 0);

  005aa	85 d2		 test	 edx, edx
  005ac	75 92		 jne	 SHORT $LL12@deflate

; 944  :             HCRC_UPDATE(beg);

  005ae	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005b2	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  005b5	74 1d		 je	 SHORT $LN16@deflate
  005b7	41 3b c8	 cmp	 ecx, r8d
  005ba	76 18		 jbe	 SHORT $LN16@deflate
  005bc	41 2b c8	 sub	 ecx, r8d
  005bf	41 8b d0	 mov	 edx, r8d
  005c2	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  005c6	44 8b c1	 mov	 r8d, ecx
  005c9	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  005cc	e8 00 00 00 00	 call	 crc32
  005d1	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN16@deflate:

; 945  :             s->gzindex = 0;

  005d4	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN62@deflate:

; 946  :         }
; 947  :         s->status = COMMENT_STATE;

  005d7	c7 43 08 5b 00
	00 00		 mov	 DWORD PTR [rbx+8], 91	; 0000005bH
$LN61@deflate:

; 948  :     }
; 949  :     if (s->status == COMMENT_STATE) {

  005de	83 7b 08 5b	 cmp	 DWORD PTR [rbx+8], 91	; 0000005bH
  005e2	0f 85 b3 00 00
	00		 jne	 $LN67@deflate

; 950  :         if (s->gzhead->comment != Z_NULL) {

  005e8	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005ec	48 39 70 30	 cmp	 QWORD PTR [rax+48], rsi
  005f0	0f 84 9e 00 00
	00		 je	 $LN26@deflate

; 951  :             ulg beg = s->pending;   /* start of bytes to update crc */

  005f6	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  005fa	66 0f 1f 44 00
	00		 npad	 6
$LL21@deflate:

; 952  :             int val;
; 953  :             do {
; 954  :                 if (s->pending == s->pending_buf_size) {

  00600	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00603	39 43 28	 cmp	 DWORD PTR [rbx+40], eax
  00606	75 3d		 jne	 SHORT $LN69@deflate

; 955  :                     HCRC_UPDATE(beg);

  00608	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0060c	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0060f	74 20		 je	 SHORT $LN22@deflate
  00611	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00614	41 3b c0	 cmp	 eax, r8d
  00617	76 18		 jbe	 SHORT $LN22@deflate
  00619	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0061c	41 2b c0	 sub	 eax, r8d
  0061f	41 8b d0	 mov	 edx, r8d
  00622	44 8b c0	 mov	 r8d, eax
  00625	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00629	e8 00 00 00 00	 call	 crc32
  0062e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN22@deflate:

; 956  :                     flush_pending(strm);

  00631	48 8b cf	 mov	 rcx, rdi
  00634	e8 00 00 00 00	 call	 flush_pending

; 957  :                     if (s->pending != 0) {

  00639	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  0063c	0f 85 e0 02 00
	00		 jne	 $LN135@deflate

; 958  :                         s->last_flush = -1;
; 959  :                         return Z_OK;
; 960  :                     }
; 961  :                     beg = 0;

  00642	44 8b c6	 mov	 r8d, esi
$LN69@deflate:

; 962  :                 }
; 963  :                 val = s->gzhead->comment[s->gzindex++];

  00645	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00648	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0064c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00650	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00654	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 964  :                 put_byte(s, val);

  00657	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0065a	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  0065d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00661	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00664	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00667	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 965  :             } while (val != 0);

  0066a	85 d2		 test	 edx, edx
  0066c	75 92		 jne	 SHORT $LL21@deflate

; 966  :             HCRC_UPDATE(beg);

  0066e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00672	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00675	74 1d		 je	 SHORT $LN26@deflate
  00677	41 3b c8	 cmp	 ecx, r8d
  0067a	76 18		 jbe	 SHORT $LN26@deflate
  0067c	41 2b c8	 sub	 ecx, r8d
  0067f	41 8b d0	 mov	 edx, r8d
  00682	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00686	44 8b c1	 mov	 r8d, ecx
  00689	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0068c	e8 00 00 00 00	 call	 crc32
  00691	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN26@deflate:

; 967  :         }
; 968  :         s->status = HCRC_STATE;

  00694	c7 43 08 67 00
	00 00		 mov	 DWORD PTR [rbx+8], 103	; 00000067H
$LN67@deflate:

; 969  :     }
; 970  :     if (s->status == HCRC_STATE) {

  0069b	83 7b 08 67	 cmp	 DWORD PTR [rbx+8], 103	; 00000067H
  0069f	75 6e		 jne	 SHORT $LN77@deflate

; 971  :         if (s->gzhead->hcrc) {

  006a1	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  006a5	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  006a8	74 4d		 je	 SHORT $LN74@deflate

; 972  :             if (s->pending + 2 > s->pending_buf_size) {

  006aa	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  006ad	83 c0 02	 add	 eax, 2
  006b0	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  006b3	76 11		 jbe	 SHORT $LN76@deflate

; 973  :                 flush_pending(strm);

  006b5	48 8b cf	 mov	 rcx, rdi
  006b8	e8 00 00 00 00	 call	 flush_pending

; 974  :                 if (s->pending != 0) {

  006bd	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  006c0	0f 85 5c 02 00
	00		 jne	 $LN135@deflate
$LN76@deflate:

; 975  :                     s->last_flush = -1;
; 976  :                     return Z_OK;
; 977  :                 }
; 978  :             }
; 979  :             put_byte(s, (Byte)(strm->adler & 0xff));

  006c6	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]

; 980  :             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
; 981  :             strm->adler = crc32(0L, Z_NULL, 0);

  006ca	45 33 c0	 xor	 r8d, r8d
  006cd	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  006d0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  006d4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006d7	ff 43 28	 inc	 DWORD PTR [rbx+40]
  006da	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  006dd	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  006e1	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  006e5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006e8	33 d2		 xor	 edx, edx
  006ea	ff 43 28	 inc	 DWORD PTR [rbx+40]
  006ed	33 c9		 xor	 ecx, ecx
  006ef	e8 00 00 00 00	 call	 crc32
  006f4	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN74@deflate:

; 982  :         }
; 983  :         s->status = BUSY_STATE;
; 984  : 
; 985  :         /* Compression must start with an empty pending buffer */
; 986  :         flush_pending(strm);

  006f7	48 8b cf	 mov	 rcx, rdi
  006fa	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  00701	e8 00 00 00 00	 call	 flush_pending

; 987  :         if (s->pending != 0) {

  00706	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00709	0f 85 13 02 00
	00		 jne	 $LN135@deflate
$LN77@deflate:

; 988  :             s->last_flush = -1;
; 989  :             return Z_OK;
; 990  :         }
; 991  :     }
; 992  : #endif
; 993  : 
; 994  :     /* Start a new block or continue the current one.
; 995  :      */
; 996  :     if (strm->avail_in != 0 || s->lookahead != 0 ||

  0070f	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  00712	75 1e		 jne	 SHORT $LN79@deflate
  00714	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  0071a	75 16		 jne	 SHORT $LN79@deflate
  0071c	45 85 e4	 test	 r12d, r12d
  0071f	0f 84 f7 00 00
	00		 je	 $LN91@deflate
  00725	81 7b 08 9a 02
	00 00		 cmp	 DWORD PTR [rbx+8], 666	; 0000029aH
  0072c	0f 84 ea 00 00
	00		 je	 $LN91@deflate
$LN79@deflate:

; 997  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 998  :         block_state bstate;
; 999  : 
; 1000 :         bstate = s->level == 0 ? deflate_stored(s, flush) :

  00732	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00739	41 8b d4	 mov	 edx, r12d
  0073c	85 c9		 test	 ecx, ecx
  0073e	75 0a		 jne	 SHORT $LN110@deflate
  00740	48 8b cb	 mov	 rcx, rbx
  00743	e8 00 00 00 00	 call	 deflate_stored
  00748	eb 38		 jmp	 SHORT $LN134@deflate
$LN110@deflate:
  0074a	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [rbx+176]
  00750	83 f8 02	 cmp	 eax, 2
  00753	75 0a		 jne	 SHORT $LN108@deflate
  00755	48 8b cb	 mov	 rcx, rbx
  00758	e8 00 00 00 00	 call	 deflate_huff
  0075d	eb 23		 jmp	 SHORT $LN134@deflate
$LN108@deflate:
  0075f	83 f8 03	 cmp	 eax, 3
  00762	75 0a		 jne	 SHORT $LN106@deflate
  00764	48 8b cb	 mov	 rcx, rbx
  00767	e8 00 00 00 00	 call	 deflate_rle
  0076c	eb 14		 jmp	 SHORT $LN134@deflate
$LN106@deflate:
  0076e	48 8b c1	 mov	 rax, rcx
  00771	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_table+8
  00778	48 03 c0	 add	 rax, rax
  0077b	48 8b cb	 mov	 rcx, rbx
  0077e	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
$LN134@deflate:
  00782	8b c8		 mov	 ecx, eax
  00784	8d 40 fe	 lea	 eax, DWORD PTR [rax-2]
  00787	83 f8 01	 cmp	 eax, 1
  0078a	77 07		 ja	 SHORT $LN80@deflate

; 1001 :                  s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 1002 :                  s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 1003 :                  (*(configuration_table[s->level].func))(s, flush);
; 1004 : 
; 1005 :         if (bstate == finish_started || bstate == finish_done) {
; 1006 :             s->status = FINISH_STATE;

  0078c	c7 43 08 9a 02
	00 00		 mov	 DWORD PTR [rbx+8], 666	; 0000029aH
$LN80@deflate:
  00793	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  00799	0f 84 7e 01 00
	00		 je	 $LN83@deflate

; 1013 :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 1014 :              * of deflate should use the same flush parameter to make sure
; 1015 :              * that the flush is complete. So we don't have to output an
; 1016 :              * empty block here, this will be done at next call. This also
; 1017 :              * ensures that for a very small output buffer, we emit at most
; 1018 :              * one empty block.
; 1019 :              */
; 1020 :         }
; 1021 :         if (bstate == block_done) {

  0079f	83 f9 01	 cmp	 ecx, 1
  007a2	75 78		 jne	 SHORT $LN91@deflate

; 1022 :             if (flush == Z_PARTIAL_FLUSH) {

  007a4	44 3b e1	 cmp	 r12d, ecx
  007a7	75 0a		 jne	 SHORT $LN86@deflate

; 1023 :                 _tr_align(s);

  007a9	48 8b cb	 mov	 rcx, rbx
  007ac	e8 00 00 00 00	 call	 _tr_align
  007b1	eb 58		 jmp	 SHORT $LN90@deflate
$LN86@deflate:

; 1024 :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  007b3	41 83 fc 05	 cmp	 r12d, 5
  007b7	74 52		 je	 SHORT $LN90@deflate

; 1025 :                 _tr_stored_block(s, (char*)0, 0L, 0);

  007b9	45 33 c9	 xor	 r9d, r9d
  007bc	45 33 c0	 xor	 r8d, r8d
  007bf	33 d2		 xor	 edx, edx
  007c1	48 8b cb	 mov	 rcx, rbx
  007c4	e8 00 00 00 00	 call	 _tr_stored_block

; 1026 :                 /* For a full flush, this empty block will be recognized
; 1027 :                  * as a special marker by inflate_sync().
; 1028 :                  */
; 1029 :                 if (flush == Z_FULL_FLUSH) {

  007c9	41 83 fc 03	 cmp	 r12d, 3
  007cd	75 3c		 jne	 SHORT $LN90@deflate

; 1030 :                     CLEAR_HASH(s);             /* forget history */

  007cf	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  007d2	33 d2		 xor	 edx, edx
  007d4	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  007d8	ff c9		 dec	 ecx
  007da	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
  007de	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  007e2	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  007e6	41 ff c8	 dec	 r8d
  007e9	4d 03 c0	 add	 r8, r8
  007ec	e8 00 00 00 00	 call	 memset

; 1031 :                     if (s->lookahead == 0) {

  007f1	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  007f7	75 12		 jne	 SHORT $LN90@deflate

; 1032 :                         s->strstart = 0;

  007f9	89 b3 94 00 00
	00		 mov	 DWORD PTR [rbx+148], esi

; 1033 :                         s->block_start = 0L;

  007ff	89 b3 84 00 00
	00		 mov	 DWORD PTR [rbx+132], esi

; 1034 :                         s->insert = 0;

  00805	89 b3 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], esi
$LN90@deflate:

; 1035 :                     }
; 1036 :                 }
; 1037 :             }
; 1038 :             flush_pending(strm);

  0080b	48 8b cf	 mov	 rcx, rdi
  0080e	e8 00 00 00 00	 call	 flush_pending

; 1039 :             if (strm->avail_out == 0) {

  00813	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  00816	0f 84 06 01 00
	00		 je	 $LN135@deflate
$LN91@deflate:

; 1040 :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 1041 :               return Z_OK;
; 1042 :             }
; 1043 :         }
; 1044 :     }
; 1045 : 
; 1046 :     if (flush != Z_FINISH) return Z_OK;

  0081c	41 83 fc 04	 cmp	 r12d, 4
  00820	0f 85 03 01 00
	00		 jne	 $LN84@deflate

; 1047 :     if (s->wrap <= 0) return Z_STREAM_END;

  00826	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00829	85 c9		 test	 ecx, ecx
  0082b	7f 26		 jg	 SHORT $LN93@deflate
  0082d	41 8d 44 24 fd	 lea	 eax, QWORD PTR [r12-3]
$LN133@deflate:
  00832	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00837	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0083c	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00841	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00846	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1073 : }

  0084b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0084f	41 5c		 pop	 r12
  00851	5f		 pop	 rdi
  00852	c3		 ret	 0
$LN93@deflate:

; 1048 : 
; 1049 :     /* Write the trailer */
; 1050 : #ifdef GZIP
; 1051 :     if (s->wrap == 2) {

  00853	83 f9 02	 cmp	 ecx, 2
  00856	0f 85 8a 00 00
	00		 jne	 $LN94@deflate

; 1052 :         put_byte(s, (Byte)(strm->adler & 0xff));

  0085c	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0085f	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  00863	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00867	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0086a	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0086d	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1053 :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00870	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  00874	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00878	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0087b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0087e	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1054 :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  00881	0f b6 47 4e	 movzx	 eax, BYTE PTR [rdi+78]
  00885	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00889	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0088c	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0088f	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1055 :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  00892	0f b6 47 4f	 movzx	 eax, BYTE PTR [rdi+79]
  00896	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0089a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0089d	ff 43 28	 inc	 DWORD PTR [rbx+40]
  008a0	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1056 :         put_byte(s, (Byte)(strm->total_in & 0xff));

  008a3	0f b6 47 0c	 movzx	 eax, BYTE PTR [rdi+12]
  008a7	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008ab	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008ae	ff 43 28	 inc	 DWORD PTR [rbx+40]
  008b1	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1057 :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  008b4	0f b6 47 0d	 movzx	 eax, BYTE PTR [rdi+13]
  008b8	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008bc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008bf	ff 43 28	 inc	 DWORD PTR [rbx+40]
  008c2	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1058 :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  008c5	0f b6 47 0e	 movzx	 eax, BYTE PTR [rdi+14]
  008c9	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008cd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008d0	ff 43 28	 inc	 DWORD PTR [rbx+40]
  008d3	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1059 :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  008d6	0f b6 47 0f	 movzx	 eax, BYTE PTR [rdi+15]
  008da	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008de	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008e1	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 1060 :     }

  008e4	eb 15		 jmp	 SHORT $LN95@deflate
$LN94@deflate:

; 1061 :     else
; 1062 : #endif
; 1063 :     {
; 1064 :         putShortMSB(s, (uInt)(strm->adler >> 16));

  008e6	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  008ea	48 8b cb	 mov	 rcx, rbx
  008ed	e8 00 00 00 00	 call	 putShortMSB

; 1065 :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  008f2	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  008f6	e8 00 00 00 00	 call	 putShortMSB
$LN95@deflate:

; 1066 :     }
; 1067 :     flush_pending(strm);

  008fb	48 8b cf	 mov	 rcx, rdi
  008fe	e8 00 00 00 00	 call	 flush_pending

; 1068 :     /* If avail_out is zero, the application will call deflate again
; 1069 :      * to flush the rest.
; 1070 :      */
; 1071 :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  00903	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00906	85 c0		 test	 eax, eax
  00908	7e 05		 jle	 SHORT $LN96@deflate
  0090a	f7 d8		 neg	 eax
  0090c	89 43 2c	 mov	 DWORD PTR [rbx+44], eax
$LN96@deflate:

; 1072 :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0090f	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00912	40 0f 94 c6	 sete	 sil
  00916	8b c6		 mov	 eax, esi
  00918	e9 15 ff ff ff	 jmp	 $LN133@deflate
$LN83@deflate:

; 1007 :         }
; 1008 :         if (bstate == need_more || bstate == finish_started) {
; 1009 :             if (strm->avail_out == 0) {

  0091d	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  00920	75 07		 jne	 SHORT $LN84@deflate
$LN135@deflate:

; 1010 :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  00922	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
$LN84@deflate:

; 1011 :             }
; 1012 :             return Z_OK;

  00929	33 c0		 xor	 eax, eax
  0092b	e9 02 ff ff ff	 jmp	 $LN133@deflate
$LN31@deflate:

; 777  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {
; 778  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  00930	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  00937	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0093c	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00940	b8 fe ff ff ff	 mov	 eax, -2

; 1073 : }

  00945	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00949	41 5c		 pop	 r12
  0094b	5f		 pop	 rdi
  0094c	c3		 ret	 0
$LN29@deflate:

; 771  :         return Z_STREAM_ERROR;

  0094d	b8 fe ff ff ff	 mov	 eax, -2

; 1073 : }

  00952	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00956	41 5c		 pop	 r12
  00958	5f		 pop	 rdi
  00959	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateEnd
_TEXT	SEGMENT
strm$ = 48
deflateEnd PROC						; COMDAT

; 1078 : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1079 :     int status;
; 1080 : 
; 1081 :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateEnd
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1095 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@deflateEnd:

; 1082 : 
; 1083 :     status = strm->state->status;

  0001d	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00021	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1084 : 
; 1085 :     /* Deallocate in reverse order of allocations: */
; 1086 :     TRY_FREE(strm, strm->state->pending_buf);

  00026	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0002a	8b 78 08	 mov	 edi, DWORD PTR [rax+8]
  0002d	48 85 d2	 test	 rdx, rdx
  00030	74 07		 je	 SHORT $LN3@deflateEnd
  00032	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00036	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN3@deflateEnd:

; 1087 :     TRY_FREE(strm, strm->state->head);

  00039	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  0003d	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00041	48 85 d2	 test	 rdx, rdx
  00044	74 07		 je	 SHORT $LN4@deflateEnd
  00046	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004a	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN4@deflateEnd:

; 1088 :     TRY_FREE(strm, strm->state->prev);

  0004d	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00051	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00055	48 85 d2	 test	 rdx, rdx
  00058	74 07		 je	 SHORT $LN5@deflateEnd
  0005a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0005e	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN5@deflateEnd:

; 1089 :     TRY_FREE(strm, strm->state->window);

  00061	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00065	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  00069	48 85 d2	 test	 rdx, rdx
  0006c	74 07		 je	 SHORT $LN6@deflateEnd
  0006e	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00072	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN6@deflateEnd:

; 1090 : 
; 1091 :     ZFREE(strm, strm->state);

  00075	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00079	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0007d	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1092 :     strm->state = Z_NULL;

  00080	33 c0		 xor	 eax, eax

; 1093 : 
; 1094 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00082	b9 fd ff ff ff	 mov	 ecx, -3
  00087	83 ff 71	 cmp	 edi, 113		; 00000071H
  0008a	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  0008e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00093	0f 44 c1	 cmove	 eax, ecx

; 1095 : }

  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 233  : {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 234  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,

  00004	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00009	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0000f	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  00014	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0001c	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00024	45 8d 41 f9	 lea	 r8d, QWORD PTR [r9-7]
  00028	e8 00 00 00 00	 call	 deflateInit2_

; 235  :                          Z_DEFAULT_STRATEGY, version, stream_size);
; 236  :     /* To do: ignore strm->next_in if we use it as window */
; 237  : }

  0002d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00031	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT slide_hash
_TEXT	SEGMENT
s$ = 8
slide_hash PROC						; COMDAT

; 204  :     unsigned n, m;
; 205  :     Posf *p;
; 206  :     uInt wsize = s->w_size;
; 207  : 
; 208  :     n = s->hash_size;

  00000	44 8b 51 74	 mov	 r10d, DWORD PTR [rcx+116]

; 209  :     p = &s->head[n];

  00004	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00008	44 8b 49 44	 mov	 r9d, DWORD PTR [rcx+68]
  0000c	4e 8d 04 50	 lea	 r8, QWORD PTR [rax+r10*2]
$LL4@slide_hash:

; 210  :     do {
; 211  :         m = *--p;

  00010	41 0f b7 40 fe	 movzx	 eax, WORD PTR [r8-2]
  00015	4d 8d 40 fe	 lea	 r8, QWORD PTR [r8-2]

; 212  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00019	41 3b c1	 cmp	 eax, r9d
  0001c	72 05		 jb	 SHORT $LN9@slide_hash
  0001e	41 2b c1	 sub	 eax, r9d
  00021	eb 02		 jmp	 SHORT $LN10@slide_hash
$LN9@slide_hash:
  00023	33 c0		 xor	 eax, eax
$LN10@slide_hash:
  00025	66 41 89 00	 mov	 WORD PTR [r8], ax

; 213  :     } while (--n);

  00029	41 83 c2 ff	 add	 r10d, -1		; ffffffffH
  0002d	75 e1		 jne	 SHORT $LL4@slide_hash

; 214  :     n = wsize;
; 215  : #ifndef FASTEST
; 216  :     p = &s->prev[n];

  0002f	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00033	45 8b c1	 mov	 r8d, r9d
  00036	4a 8d 14 48	 lea	 rdx, QWORD PTR [rax+r9*2]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL7@slide_hash:

; 217  :     do {
; 218  :         m = *--p;

  00040	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  00044	48 8d 52 fe	 lea	 rdx, QWORD PTR [rdx-2]

; 219  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00048	41 3b c1	 cmp	 eax, r9d
  0004b	72 05		 jb	 SHORT $LN11@slide_hash
  0004d	41 2b c1	 sub	 eax, r9d
  00050	eb 02		 jmp	 SHORT $LN12@slide_hash
$LN11@slide_hash:
  00052	33 c0		 xor	 eax, eax
$LN12@slide_hash:
  00054	66 89 02	 mov	 WORD PTR [rdx], ax

; 220  :         /* If n is not on any hash chain, prev[n] is garbage but
; 221  :          * its value will never be used.
; 222  :          */
; 223  :     } while (--n);

  00057	41 83 c0 ff	 add	 r8d, -1			; ffffffffH
  0005b	75 e3		 jne	 SHORT $LL7@slide_hash

; 224  : #endif
; 225  : }

  0005d	c3		 ret	 0
slide_hash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit2_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 250  : {

$LN25:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 251  :     deflate_state *s;
; 252  :     int wrap = 1;
; 253  :     static const char my_version[] = ZLIB_VERSION;
; 254  : 
; 255  :     ushf *overlay;
; 256  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 257  :      * output size for (length,distance) codes is <= 24 bits.
; 258  :      */
; 259  : 
; 260  :     if (version == Z_NULL || version[0] != my_version[0] ||

  0000b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00013	41 bf 01 00 00
	00		 mov	 r15d, 1
  00019	41 8b f9	 mov	 edi, r9d
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	45 8b f7	 mov	 r14d, r15d
  00022	48 85 c0	 test	 rax, rax
  00025	0f 84 56 02 00
	00		 je	 $LN3@deflateIni
  0002b	80 38 31	 cmp	 BYTE PTR [rax], 49	; 00000031H
  0002e	0f 85 4d 02 00
	00		 jne	 $LN3@deflateIni
  00034	83 bc 24 88 00
	00 00 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0003c	0f 85 3f 02 00
	00		 jne	 $LN3@deflateIni

; 263  :     }
; 264  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00042	48 85 c9	 test	 rcx, rcx
  00045	75 0e		 jne	 SHORT $LN4@deflateIni
  00047	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 348  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	41 5f		 pop	 r15
  00050	41 5e		 pop	 r14
  00052	5f		 pop	 rdi
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN4@deflateIni:

; 265  : 
; 266  :     strm->msg = Z_NULL;

  00055	33 c9		 xor	 ecx, ecx
  00057	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0005c	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00061	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 267  :     if (strm->zalloc == (alloc_func)0) {

  00065	48 39 4b 30	 cmp	 QWORD PTR [rbx+48], rcx
  00069	75 0f		 jne	 SHORT $LN5@deflateIni

; 268  : #ifdef Z_SOLO
; 269  :         return Z_STREAM_ERROR;
; 270  : #else
; 271  :         strm->zalloc = zcalloc;

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 272  :         strm->opaque = (voidpf)0;

  00072	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  00076	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
$LN5@deflateIni:

; 273  : #endif
; 274  :     }
; 275  :     if (strm->zfree == (free_func)0)

  0007a	48 39 4b 38	 cmp	 QWORD PTR [rbx+56], rcx
  0007e	75 0b		 jne	 SHORT $LN6@deflateIni

; 276  : #ifdef Z_SOLO
; 277  :         return Z_STREAM_ERROR;
; 278  : #else
; 279  :         strm->zfree = zcfree;

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00087	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
$LN6@deflateIni:

; 280  : #endif
; 281  : 
; 282  : #ifdef FASTEST
; 283  :     if (level != 0) level = 1;
; 284  : #else
; 285  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 286  : #endif
; 287  : 
; 288  :     if (windowBits < 0) { /* suppress zlib wrapper */

  0008b	83 fa ff	 cmp	 edx, -1
  0008e	bd 06 00 00 00	 mov	 ebp, 6
  00093	0f 45 ea	 cmovne	 ebp, edx
  00096	85 ff		 test	 edi, edi
  00098	79 07		 jns	 SHORT $LN8@deflateIni

; 289  :         wrap = 0;

  0009a	44 8b f1	 mov	 r14d, ecx

; 290  :         windowBits = -windowBits;

  0009d	f7 df		 neg	 edi

; 291  :     }

  0009f	eb 0e		 jmp	 SHORT $LN10@deflateIni
$LN8@deflateIni:

; 292  : #ifdef GZIP
; 293  :     else if (windowBits > 15) {

  000a1	83 ff 0f	 cmp	 edi, 15
  000a4	7e 09		 jle	 SHORT $LN10@deflateIni

; 294  :         wrap = 2;       /* write gzip wrapper instead */

  000a6	41 be 02 00 00
	00		 mov	 r14d, 2

; 295  :         windowBits -= 16;

  000ac	83 ef 10	 sub	 edi, 16
$LN10@deflateIni:

; 296  :     }
; 297  : #endif
; 298  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 299  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 300  :         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {

  000af	44 8b 6c 24 70	 mov	 r13d, DWORD PTR memLevel$[rsp]
  000b4	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  000b9	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000bd	83 f8 08	 cmp	 eax, 8
  000c0	0f 87 b4 01 00
	00		 ja	 $LN12@deflateIni
  000c6	41 83 f8 08	 cmp	 r8d, 8
  000ca	0f 85 aa 01 00
	00		 jne	 $LN12@deflateIni
  000d0	8d 47 f8	 lea	 eax, DWORD PTR [rdi-8]
  000d3	83 f8 07	 cmp	 eax, 7
  000d6	0f 87 9e 01 00
	00		 ja	 $LN12@deflateIni
  000dc	83 fd 09	 cmp	 ebp, 9
  000df	0f 87 95 01 00
	00		 ja	 $LN12@deflateIni
  000e5	44 8b 64 24 78	 mov	 r12d, DWORD PTR strategy$[rsp]
  000ea	41 83 fc 04	 cmp	 r12d, 4
  000ee	0f 87 86 01 00
	00		 ja	 $LN12@deflateIni
  000f4	41 3b f8	 cmp	 edi, r8d
  000f7	75 0d		 jne	 SHORT $LN13@deflateIni
  000f9	45 3b f7	 cmp	 r14d, r15d
  000fc	0f 85 78 01 00
	00		 jne	 $LN12@deflateIni

; 302  :     }
; 303  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  00102	41 8d 78 01	 lea	 edi, QWORD PTR [r8+1]
$LN13@deflateIni:

; 304  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  00106	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0010a	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00110	41 8b d7	 mov	 edx, r15d
  00113	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00118	ff 53 30	 call	 QWORD PTR [rbx+48]
  0011b	48 8b f0	 mov	 rsi, rax

; 305  :     if (s == Z_NULL) return Z_MEM_ERROR;

  0011e	48 85 c0	 test	 rax, rax
  00121	0f 84 4c 01 00
	00		 je	 $LN23@deflateIni

; 306  :     strm->state = (struct internal_state FAR *)s;

  00127	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 307  :     s->strm = strm;
; 308  :     s->status = INIT_STATE;     /* to pass state test in deflateReset() */
; 309  : 
; 310  :     s->wrap = wrap;
; 311  :     s->gzhead = Z_NULL;
; 312  :     s->w_bits = (uInt)windowBits;
; 313  :     s->w_size = 1 << s->w_bits;

  0012b	8b cf		 mov	 ecx, edi
  0012d	44 89 70 2c	 mov	 DWORD PTR [rax+44], r14d
  00131	45 8b cf	 mov	 r9d, r15d
  00134	41 d3 e1	 shl	 r9d, cl
  00137	45 33 f6	 xor	 r14d, r14d
  0013a	48 89 18	 mov	 QWORD PTR [rax], rbx

; 314  :     s->w_mask = s->w_size - 1;
; 315  : 
; 316  :     s->hash_bits = (uInt)memLevel + 7;

  0013d	41 8d 4d 07	 lea	 ecx, DWORD PTR [r13+7]
  00141	c7 40 08 2a 00
	00 00		 mov	 DWORD PTR [rax+8], 42	; 0000002aH
  00148	4c 89 70 30	 mov	 QWORD PTR [rax+48], r14
  0014c	89 78 48	 mov	 DWORD PTR [rax+72], edi

; 317  :     s->hash_size = 1 << s->hash_bits;
; 318  :     s->hash_mask = s->hash_size - 1;
; 319  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
; 320  : 
; 321  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  0014f	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00153	44 89 48 44	 mov	 DWORD PTR [rax+68], r9d
  00157	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  0015b	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
  0015e	41 8b c7	 mov	 eax, r15d
  00161	d3 e0		 shl	 eax, cl
  00163	89 46 74	 mov	 DWORD PTR [rsi+116], eax
  00166	ff c8		 dec	 eax
  00168	89 46 7c	 mov	 DWORD PTR [rsi+124], eax
  0016b	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00170	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx
  00173	83 c1 02	 add	 ecx, 2
  00176	f7 e1		 mul	 ecx
  00178	d1 ea		 shr	 edx, 1
  0017a	89 96 80 00 00
	00		 mov	 DWORD PTR [rsi+128], edx
  00180	41 8b d1	 mov	 edx, r9d
  00183	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00187	ff 53 30	 call	 QWORD PTR [rbx+48]

; 322  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0018a	8b 56 44	 mov	 edx, DWORD PTR [rsi+68]
  0018d	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00191	48 89 46 50	 mov	 QWORD PTR [rsi+80], rax
  00195	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00199	ff 53 30	 call	 QWORD PTR [rbx+48]

; 323  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  0019c	8b 56 74	 mov	 edx, DWORD PTR [rsi+116]
  0019f	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  001a3	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
  001a7	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001ab	ff 53 30	 call	 QWORD PTR [rbx+48]

; 324  : 
; 325  :     s->high_water = 0;      /* nothing written to s->window yet */
; 326  : 
; 327  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  001ae	41 8d 4d 06	 lea	 ecx, DWORD PTR [r13+6]
  001b2	44 89 b6 18 17
	00 00		 mov	 DWORD PTR [rsi+5912], r14d
  001b9	41 d3 e7	 shl	 r15d, cl

; 328  : 
; 329  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  001bc	45 8d 46 04	 lea	 r8d, QWORD PTR [r14+4]
  001c0	44 89 be f0 16
	00 00		 mov	 DWORD PTR [rsi+5872], r15d
  001c7	41 8b d7	 mov	 edx, r15d
  001ca	48 89 46 68	 mov	 QWORD PTR [rsi+104], rax
  001ce	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001d2	ff 53 30	 call	 QWORD PTR [rbx+48]
  001d5	48 8b d0	 mov	 rdx, rax

; 330  :     s->pending_buf = (uchf *) overlay;

  001d8	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 331  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  001dc	8b 86 f0 16 00
	00		 mov	 eax, DWORD PTR [rsi+5872]
  001e2	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [rax*4]
  001e9	89 4e 18	 mov	 DWORD PTR [rsi+24], ecx

; 332  : 
; 333  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||

  001ec	4c 39 76 50	 cmp	 QWORD PTR [rsi+80], r14
  001f0	74 67		 je	 SHORT $LN16@deflateIni
  001f2	4c 39 76 60	 cmp	 QWORD PTR [rsi+96], r14
  001f6	74 61		 je	 SHORT $LN16@deflateIni
  001f8	4c 39 76 68	 cmp	 QWORD PTR [rsi+104], r14
  001fc	74 5b		 je	 SHORT $LN16@deflateIni
  001fe	48 85 d2	 test	 rdx, rdx
  00201	74 56		 je	 SHORT $LN16@deflateIni

; 339  :     }
; 340  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  00203	8b c8		 mov	 ecx, eax

; 341  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 342  : 
; 343  :     s->level = level;

  00205	89 ae ac 00 00
	00		 mov	 DWORD PTR [rsi+172], ebp
  0020b	48 d1 e8	 shr	 rax, 1

; 344  :     s->strategy = strategy;

  0020e	44 89 a6 b0 00
	00 00		 mov	 DWORD PTR [rsi+176], r12d

; 345  :     s->method = (Byte)method;

  00215	c6 46 3c 08	 mov	 BYTE PTR [rsi+60], 8
  00219	48 8d 04 42	 lea	 rax, QWORD PTR [rdx+rax*2]
  0021d	48 89 86 f8 16
	00 00		 mov	 QWORD PTR [rsi+5880], rax
  00224	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  00228	48 03 c8	 add	 rcx, rax
  0022b	48 89 8e e8 16
	00 00		 mov	 QWORD PTR [rsi+5864], rcx

; 346  : 
; 347  :     return deflateReset(strm);

  00232	48 8b cb	 mov	 rcx, rbx
  00235	e8 00 00 00 00	 call	 deflateReset
$LN22@deflateIni:
  0023a	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN21@deflateIni:
  0023f	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00244	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00249	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 348  : }

  0024e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00252	41 5f		 pop	 r15
  00254	41 5e		 pop	 r14
  00256	5f		 pop	 rdi
  00257	5b		 pop	 rbx
  00258	c3		 ret	 0
$LN16@deflateIni:

; 334  :         s->pending_buf == Z_NULL) {
; 335  :         s->status = FINISH_STATE;
; 336  :         strm->msg = ERR_MSG(Z_MEM_ERROR);

  00259	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48

; 337  :         deflateEnd (strm);

  00260	48 8b cb	 mov	 rcx, rbx
  00263	c7 46 08 9a 02
	00 00		 mov	 DWORD PTR [rsi+8], 666	; 0000029aH
  0026a	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0026e	e8 00 00 00 00	 call	 deflateEnd
$LN23@deflateIni:

; 338  :         return Z_MEM_ERROR;

  00273	b8 fc ff ff ff	 mov	 eax, -4
  00278	eb c0		 jmp	 SHORT $LN22@deflateIni
$LN12@deflateIni:

; 301  :         return Z_STREAM_ERROR;

  0027a	b8 fe ff ff ff	 mov	 eax, -2
  0027f	eb be		 jmp	 SHORT $LN21@deflateIni
$LN3@deflateIni:

; 261  :         stream_size != sizeof(z_stream)) {
; 262  :         return Z_VERSION_ERROR;

  00281	b8 fa ff ff ff	 mov	 eax, -6

; 348  : }

  00286	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0028a	41 5f		 pop	 r15
  0028c	41 5e		 pop	 r14
  0028e	5f		 pop	 rdi
  0028f	5b		 pop	 rbx
  00290	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateStateCheck
_TEXT	SEGMENT
strm$ = 8
deflateStateCheck PROC					; COMDAT

; 356  :     deflate_state *s;
; 357  :     if (strm == Z_NULL ||
; 358  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN3@deflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 40		 je	 SHORT $LN3@deflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 39		 je	 SHORT $LN3@deflateSta

; 360  :     s = strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 361  :     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&

  00017	48 85 c0	 test	 rax, rax
  0001a	74 30		 je	 SHORT $LN3@deflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 2b		 jne	 SHORT $LN3@deflateSta
  00021	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00024	8d 41 d6	 lea	 eax, DWORD PTR [rcx-42]
  00027	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0002a	77 10		 ja	 SHORT $LN7@deflateSta
  0002c	48 ba 01 80 00
	88 00 00 02 20	 mov	 rdx, 2306405961448849409 ; 2002000088008001H
  00036	48 0f a3 c2	 bt	 rdx, rax
  0003a	72 0d		 jb	 SHORT $LN4@deflateSta
$LN7@deflateSta:
  0003c	83 f9 71	 cmp	 ecx, 113		; 00000071H
  0003f	74 08		 je	 SHORT $LN4@deflateSta
  00041	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  00047	75 03		 jne	 SHORT $LN3@deflateSta
$LN4@deflateSta:

; 362  : #ifdef GZIP
; 363  :                                            s->status != GZIP_STATE &&
; 364  : #endif
; 365  :                                            s->status != EXTRA_STATE &&
; 366  :                                            s->status != NAME_STATE &&
; 367  :                                            s->status != COMMENT_STATE &&
; 368  :                                            s->status != HCRC_STATE &&
; 369  :                                            s->status != BUSY_STATE &&
; 370  :                                            s->status != FINISH_STATE))
; 371  :         return 1;
; 372  :     return 0;

  00049	33 c0		 xor	 eax, eax

; 373  : }

  0004b	c3		 ret	 0
$LN3@deflateSta:

; 359  :         return 1;

  0004c	b8 01 00 00 00	 mov	 eax, 1

; 373  : }

  00051	c3		 ret	 0
deflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 380  : {

$LN27:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00008	41 8b f8	 mov	 edi, r8d
  0000b	48 8b ea	 mov	 rbp, rdx
  0000e	48 8b f1	 mov	 rsi, rcx

; 381  :     deflate_state *s;
; 382  :     uInt str, n;
; 383  :     int wrap;
; 384  :     unsigned avail;
; 385  :     z_const unsigned char *next;
; 386  : 
; 387  :     if (deflateStateCheck(strm) || dictionary == Z_NULL)

  00011	e8 00 00 00 00	 call	 deflateStateCheck
  00016	85 c0		 test	 eax, eax
  00018	0f 85 f0 01 00
	00		 jne	 $LN8@deflateSet
  0001e	48 85 ed	 test	 rbp, rbp
  00021	0f 84 e7 01 00
	00		 je	 $LN8@deflateSet

; 389  :     s = strm->state;

  00027	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0002c	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]
  00030	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14

; 390  :     wrap = s->wrap;

  00035	44 8b 73 2c	 mov	 r14d, DWORD PTR [rbx+44]

; 391  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  00039	41 83 fe 02	 cmp	 r14d, 2
  0003d	0f 84 c4 01 00
	00		 je	 $LN10@deflateSet
  00043	41 83 fe 01	 cmp	 r14d, 1
  00047	75 0a		 jne	 SHORT $LN11@deflateSet
  00049	83 7b 08 2a	 cmp	 DWORD PTR [rbx+8], 42	; 0000002aH
  0004d	0f 85 b4 01 00
	00		 jne	 $LN10@deflateSet
$LN11@deflateSet:
  00053	83 bb 9c 00 00
	00 00		 cmp	 DWORD PTR [rbx+156], 0
  0005a	0f 85 a7 01 00
	00		 jne	 $LN10@deflateSet

; 393  : 
; 394  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 395  :     if (wrap == 1)

  00060	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  00065	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  0006a	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0006f	41 83 fe 01	 cmp	 r14d, 1
  00073	75 0e		 jne	 SHORT $LN12@deflateSet

; 396  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  00075	8b 4e 4c	 mov	 ecx, DWORD PTR [rsi+76]
  00078	48 8b d5	 mov	 rdx, rbp
  0007b	e8 00 00 00 00	 call	 adler32
  00080	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
$LN12@deflateSet:

; 397  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

  00083	45 33 ed	 xor	 r13d, r13d
  00086	44 89 6b 2c	 mov	 DWORD PTR [rbx+44], r13d

; 398  : 
; 399  :     /* if dictionary would fill window, just replace the history */
; 400  :     if (dictLength >= s->w_size) {

  0008a	3b 7b 44	 cmp	 edi, DWORD PTR [rbx+68]
  0008d	72 48		 jb	 SHORT $LN13@deflateSet

; 401  :         if (wrap == 0) {            /* already empty otherwise */

  0008f	45 85 f6	 test	 r14d, r14d
  00092	75 38		 jne	 SHORT $LN14@deflateSet

; 402  :             CLEAR_HASH(s);

  00094	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00097	33 d2		 xor	 edx, edx
  00099	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0009d	ff c9		 dec	 ecx
  0009f	66 44 89 2c 48	 mov	 WORD PTR [rax+rcx*2], r13w
  000a4	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000a8	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000ac	41 ff c8	 dec	 r8d
  000af	4d 03 c0	 add	 r8, r8
  000b2	e8 00 00 00 00	 call	 memset

; 403  :             s->strstart = 0;

  000b7	44 89 ab 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r13d

; 404  :             s->block_start = 0L;

  000be	44 89 ab 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r13d

; 405  :             s->insert = 0;

  000c5	44 89 ab 0c 17
	00 00		 mov	 DWORD PTR [rbx+5900], r13d
$LN14@deflateSet:

; 406  :         }
; 407  :         dictionary += dictLength - s->w_size;  /* use the tail */

  000cc	2b 7b 44	 sub	 edi, DWORD PTR [rbx+68]
  000cf	8b c7		 mov	 eax, edi

; 408  :         dictLength = s->w_size;

  000d1	8b 7b 44	 mov	 edi, DWORD PTR [rbx+68]
  000d4	48 03 e8	 add	 rbp, rax
$LN13@deflateSet:

; 409  :     }
; 410  : 
; 411  :     /* insert dictionary into window and hash */
; 412  :     avail = strm->avail_in;

  000d7	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]

; 413  :     next = strm->next_in;
; 414  :     strm->avail_in = dictLength;
; 415  :     strm->next_in = (z_const Bytef *)dictionary;
; 416  :     fill_window(s);

  000db	48 8b cb	 mov	 rcx, rbx
  000de	4c 8b 26	 mov	 r12, QWORD PTR [rsi]
  000e1	89 7e 08	 mov	 DWORD PTR [rsi+8], edi
  000e4	48 89 2e	 mov	 QWORD PTR [rsi], rbp
  000e7	e8 00 00 00 00	 call	 fill_window

; 417  :     while (s->lookahead >= MIN_MATCH) {

  000ec	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  000f3	0f 82 a0 00 00
	00		 jb	 $LN3@deflateSet
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@deflateSet:

; 418  :         str = s->strstart;

  00100	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 419  :         n = s->lookahead - (MIN_MATCH-1);

  00107	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  0010e	41 83 eb 02	 sub	 r11d, 2
  00112	41 8d 7a 02	 lea	 edi, DWORD PTR [r10+2]
  00116	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL6@deflateSet:

; 420  :         do {
; 421  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00120	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00124	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 422  : #ifndef FASTEST
; 423  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  0012a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0012e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00132	44 0f b6 0c 07	 movzx	 r9d, BYTE PTR [rdi+rax]

; 424  : #endif
; 425  :             s->head[s->ins_h] = (Pos)str;
; 426  :             str++;

  00137	8d 7f 01	 lea	 edi, DWORD PTR [rdi+1]
  0013a	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0013d	d3 e0		 shl	 eax, cl
  0013f	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00143	44 33 c8	 xor	 r9d, eax
  00146	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0014a	41 8b c2	 mov	 eax, r10d
  0014d	4c 23 c0	 and	 r8, rax
  00150	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00154	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00159	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0015e	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00161	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00165	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0016a	41 ff c2	 inc	 r10d

; 427  :         } while (--n);

  0016d	41 83 c3 ff	 add	 r11d, -1		; ffffffffH
  00171	75 ad		 jne	 SHORT $LL6@deflateSet

; 428  :         s->strstart = str;
; 429  :         s->lookahead = MIN_MATCH-1;
; 430  :         fill_window(s);

  00173	48 8b cb	 mov	 rcx, rbx
  00176	44 89 93 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r10d
  0017d	c7 83 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+156], 2
  00187	e8 00 00 00 00	 call	 fill_window
  0018c	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  00193	0f 83 67 ff ff
	ff		 jae	 $LL2@deflateSet
$LN3@deflateSet:

; 431  :     }
; 432  :     s->strstart += s->lookahead;

  00199	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  0019f	01 8b 94 00 00
	00		 add	 DWORD PTR [rbx+148], ecx
  001a5	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]

; 433  :     s->block_start = (long)s->strstart;

  001ab	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax

; 434  :     s->insert = s->lookahead;
; 435  :     s->lookahead = 0;
; 436  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 437  :     s->match_available = 0;
; 438  :     strm->next_in = next;
; 439  :     strm->avail_in = avail;
; 440  :     s->wrap = wrap;
; 441  :     return Z_OK;

  001b1	33 c0		 xor	 eax, eax
  001b3	44 89 ab 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r13d
  001ba	44 89 ab 90 00
	00 00		 mov	 DWORD PTR [rbx+144], r13d
  001c1	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  001c6	89 8b 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ecx
  001cc	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  001d6	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2
  001e0	4c 89 26	 mov	 QWORD PTR [rsi], r12
  001e3	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  001e8	44 89 7e 08	 mov	 DWORD PTR [rsi+8], r15d
  001ec	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  001f1	44 89 73 2c	 mov	 DWORD PTR [rbx+44], r14d
$LN25@deflateSet:
  001f5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001fa	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]

; 442  : }

  001ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00203	5f		 pop	 rdi
  00204	5e		 pop	 rsi
  00205	5d		 pop	 rbp
  00206	c3		 ret	 0
$LN10@deflateSet:

; 392  :         return Z_STREAM_ERROR;

  00207	b8 fe ff ff ff	 mov	 eax, -2
  0020c	eb e7		 jmp	 SHORT $LN25@deflateSet
$LN8@deflateSet:

; 388  :         return Z_STREAM_ERROR;

  0020e	b8 fe ff ff ff	 mov	 eax, -2

; 442  : }

  00213	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00217	5f		 pop	 rdi
  00218	5e		 pop	 rsi
  00219	5d		 pop	 rbp
  0021a	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
deflateGetDictionary PROC				; COMDAT

; 449  : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b f8	 mov	 rdi, r8
  00009	4c 8b ca	 mov	 r9, rdx
  0000c	4c 8b c1	 mov	 r8, rcx

; 450  :     deflate_state *s;
; 451  :     uInt len;
; 452  : 
; 453  :     if (deflateStateCheck(strm))

  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	74 0b		 je	 SHORT $LN2@deflateGet

; 454  :         return Z_STREAM_ERROR;

  00018	b8 fe ff ff ff	 mov	 eax, -2

; 464  : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
$LN2@deflateGet:

; 455  :     s = strm->state;

  00023	49 8b 50 28	 mov	 rdx, QWORD PTR [r8+40]
  00027	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 456  :     len = s->strstart + s->lookahead;

  0002c	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [rdx+156]
  00032	44 8b 92 94 00
	00 00		 mov	 r10d, DWORD PTR [rdx+148]
  00039	41 8d 1c 0a	 lea	 ebx, DWORD PTR [r10+rcx]

; 457  :     if (len > s->w_size)

  0003d	3b 5a 44	 cmp	 ebx, DWORD PTR [rdx+68]
  00040	0f 47 5a 44	 cmova	 ebx, DWORD PTR [rdx+68]

; 458  :         len = s->w_size;
; 459  :     if (dictionary != Z_NULL && len)

  00044	4d 85 c9	 test	 r9, r9
  00047	74 1c		 je	 SHORT $LN4@deflateGet
  00049	85 db		 test	 ebx, ebx
  0004b	74 18		 je	 SHORT $LN4@deflateGet

; 460  :         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);

  0004d	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00051	44 8b c3	 mov	 r8d, ebx
  00054	49 2b d0	 sub	 rdx, r8
  00057	49 03 d2	 add	 rdx, r10
  0005a	48 03 d1	 add	 rdx, rcx
  0005d	49 8b c9	 mov	 rcx, r9
  00060	e8 00 00 00 00	 call	 memcpy
$LN4@deflateGet:

; 461  :     if (dictLength != Z_NULL)

  00065	48 85 ff	 test	 rdi, rdi
  00068	74 02		 je	 SHORT $LN5@deflateGet

; 462  :         *dictLength = len;

  0006a	89 1f		 mov	 DWORD PTR [rdi], ebx
$LN5@deflateGet:

; 463  :     return Z_OK;

  0006c	33 c0		 xor	 eax, eax
  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 464  : }

  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
deflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateResetKeep
_TEXT	SEGMENT
strm$ = 48
deflateResetKeep PROC					; COMDAT

; 469  : {

$LN10:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 470  :     deflate_state *s;
; 471  : 
; 472  :     if (deflateStateCheck(strm)) {

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateRes

; 473  :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 502  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN2@deflateRes:

; 474  :     }
; 475  : 
; 476  :     strm->total_in = strm->total_out = 0;
; 477  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
; 478  :     strm->data_type = Z_UNKNOWN;

  0001d	c7 47 48 02 00
	00 00		 mov	 DWORD PTR [rdi+72], 2
  00024	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 479  : 
; 480  :     s = (deflate_state *)strm->state;

  00029	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  0002d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00032	33 f6		 xor	 esi, esi
  00034	89 77 1c	 mov	 DWORD PTR [rdi+28], esi
  00037	89 77 0c	 mov	 DWORD PTR [rdi+12], esi
  0003a	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi

; 481  :     s->pending = 0;
; 482  :     s->pending_out = s->pending_buf;

  0003e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00042	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 483  : 
; 484  :     if (s->wrap < 0) {

  00046	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00049	89 73 28	 mov	 DWORD PTR [rbx+40], esi
  0004c	85 c0		 test	 eax, eax
  0004e	79 05		 jns	 SHORT $LN3@deflateRes

; 485  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  00050	f7 d8		 neg	 eax
  00052	89 43 2c	 mov	 DWORD PTR [rbx+44], eax
$LN3@deflateRes:

; 486  :     }
; 487  :     s->status =

  00055	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00058	83 f9 02	 cmp	 ecx, 2
  0005b	75 05		 jne	 SHORT $LN5@deflateRes
  0005d	8d 41 37	 lea	 eax, QWORD PTR [rcx+55]
  00060	eb 0f		 jmp	 SHORT $LN6@deflateRes
$LN5@deflateRes:
  00062	85 c9		 test	 ecx, ecx
  00064	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  00069	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  0006e	0f 45 c2	 cmovne	 eax, edx
$LN6@deflateRes:

; 488  : #ifdef GZIP
; 489  :         s->wrap == 2 ? GZIP_STATE :
; 490  : #endif
; 491  :         s->wrap ? INIT_STATE : BUSY_STATE;
; 492  :     strm->adler =

  00071	45 33 c0	 xor	 r8d, r8d
  00074	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00077	33 d2		 xor	 edx, edx
  00079	83 f9 02	 cmp	 ecx, 2
  0007c	75 09		 jne	 SHORT $LN7@deflateRes
  0007e	33 c9		 xor	 ecx, ecx
  00080	e8 00 00 00 00	 call	 crc32
  00085	eb 07		 jmp	 SHORT $LN8@deflateRes
$LN7@deflateRes:
  00087	33 c9		 xor	 ecx, ecx
  00089	e8 00 00 00 00	 call	 adler32
$LN8@deflateRes:
  0008e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 493  : #ifdef GZIP
; 494  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 495  : #endif
; 496  :         adler32(0L, Z_NULL, 0);
; 497  :     s->last_flush = Z_NO_FLUSH;
; 498  : 
; 499  :     _tr_init(s);

  00091	48 8b cb	 mov	 rcx, rbx
  00094	89 73 40	 mov	 DWORD PTR [rbx+64], esi
  00097	e8 00 00 00 00	 call	 _tr_init
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 500  : 
; 501  :     return Z_OK;

  000a1	33 c0		 xor	 eax, eax
  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 502  : }

  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
deflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateReset
_TEXT	SEGMENT
strm$ = 48
deflateReset PROC					; COMDAT

; 507  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 508  :     int ret;
; 509  : 
; 510  :     ret = deflateResetKeep(strm);

  0000d	e8 00 00 00 00	 call	 deflateResetKeep
  00012	8b d8		 mov	 ebx, eax

; 511  :     if (ret == Z_OK)

  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@deflateRes

; 512  :         lm_init(strm->state);

  00018	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0001c	e8 00 00 00 00	 call	 lm_init

; 513  :     return ret;

  00021	8b c3		 mov	 eax, ebx
$LN2@deflateRes:

; 514  : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
deflateSetHeader PROC					; COMDAT

; 520  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx
  00007	4c 8b c1	 mov	 r8, rcx

; 521  :     if (deflateStateCheck(strm) || strm->state->wrap != 2)

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 15		 jne	 SHORT $LN3@deflateSet
  00013	49 8b 40 28	 mov	 rax, QWORD PTR [r8+40]
  00017	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0001b	75 0b		 jne	 SHORT $LN3@deflateSet

; 523  :     strm->state->gzhead = head;

  0001d	4c 89 48 30	 mov	 QWORD PTR [rax+48], r9

; 524  :     return Z_OK;

  00021	33 c0		 xor	 eax, eax

; 525  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN3@deflateSet:

; 522  :         return Z_STREAM_ERROR;

  00028	b8 fe ff ff ff	 mov	 eax, -2

; 525  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePending
_TEXT	SEGMENT
strm$ = 48
pending$ = 56
bits$ = 64
deflatePending PROC					; COMDAT

; 532  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b d2	 mov	 r10, rdx
  00007	4c 8b c9	 mov	 r9, rcx

; 533  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflatePen
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 539  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflatePen:

; 534  :     if (pending != Z_NULL)

  0001d	4d 85 d2	 test	 r10, r10
  00020	74 0a		 je	 SHORT $LN3@deflatePen

; 535  :         *pending = strm->state->pending;

  00022	49 8b 41 28	 mov	 rax, QWORD PTR [r9+40]
  00026	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00029	41 89 0a	 mov	 DWORD PTR [r10], ecx
$LN3@deflatePen:

; 536  :     if (bits != Z_NULL)

  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 0d		 je	 SHORT $LN4@deflatePen

; 537  :         *bits = strm->state->bi_valid;

  00031	49 8b 41 28	 mov	 rax, QWORD PTR [r9+40]
  00035	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  0003b	41 89 08	 mov	 DWORD PTR [r8], ecx
$LN4@deflatePen:

; 538  :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax

; 539  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
deflatePending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
deflatePrime PROC					; COMDAT

; 546  : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b f8	 mov	 edi, r8d
  0000d	8b da		 mov	 ebx, edx
  0000f	4c 8b d9	 mov	 r11, rcx

; 547  :     deflate_state *s;
; 548  :     int put;
; 549  : 
; 550  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00012	e8 00 00 00 00	 call	 deflateStateCheck
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN5@deflatePri
  0001b	b8 fe ff ff ff	 mov	 eax, -2

; 565  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN5@deflatePri:

; 551  :     s = strm->state;

  0002b	4d 8b 5b 28	 mov	 r11, QWORD PTR [r11+40]

; 552  :     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))

  0002f	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  00033	48 83 c0 02	 add	 rax, 2
  00037	49 39 83 f8 16
	00 00		 cmp	 QWORD PTR [r11+5880], rax
  0003e	73 10		 jae	 SHORT $LL4@deflatePri

; 553  :         return Z_BUF_ERROR;

  00040	b8 fb ff ff ff	 mov	 eax, -5

; 565  : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LL4@deflatePri:

; 554  :     do {
; 555  :         put = Buf_size - s->bi_valid;

  00050	41 8b 93 14 17
	00 00		 mov	 edx, DWORD PTR [r11+5908]

; 556  :         if (put > bits)
; 557  :             put = bits;
; 558  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	41 ba 10 00 00
	00		 mov	 r10d, 16
  00062	44 2b d2	 sub	 r10d, edx
  00065	44 3b d3	 cmp	 r10d, ebx
  00068	44 0f 4f d3	 cmovg	 r10d, ebx
  0006c	41 8b ca	 mov	 ecx, r10d
  0006f	66 d3 e0	 shl	 ax, cl
  00072	8b ca		 mov	 ecx, edx
  00074	66 ff c8	 dec	 ax
  00077	66 23 c7	 and	 ax, di
  0007a	66 d3 e0	 shl	 ax, cl

; 559  :         s->bi_valid += put;
; 560  :         _tr_flush_bits(s);

  0007d	49 8b cb	 mov	 rcx, r11
  00080	66 41 09 83 10
	17 00 00	 or	 WORD PTR [r11+5904], ax
  00088	42 8d 04 12	 lea	 eax, DWORD PTR [rdx+r10]
  0008c	41 89 83 14 17
	00 00		 mov	 DWORD PTR [r11+5908], eax
  00093	e8 00 00 00 00	 call	 _tr_flush_bits

; 561  :         value >>= put;

  00098	41 8b ca	 mov	 ecx, r10d
  0009b	d3 ff		 sar	 edi, cl

; 562  :         bits -= put;

  0009d	41 2b da	 sub	 ebx, r10d

; 563  :     } while (bits);

  000a0	75 ae		 jne	 SHORT $LL4@deflatePri

; 564  :     return Z_OK;

  000a2	33 c0		 xor	 eax, eax

; 565  : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateParams
_TEXT	SEGMENT
strm$ = 48
level$ = 56
strategy$ = 64
deflateParams PROC					; COMDAT

; 572  : {

$LN19:
  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b e8	 mov	 ebp, r8d
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	44 8b c2	 mov	 r8d, edx

; 573  :     deflate_state *s;
; 574  :     compress_func func;
; 575  : 
; 576  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00013	e8 00 00 00 00	 call	 deflateStateCheck
  00018	85 c0		 test	 eax, eax
  0001a	74 10		 je	 SHORT $LN2@deflatePar
  0001c	b8 fe ff ff ff	 mov	 eax, -2

; 614  : }

  00021	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5e		 pop	 rsi
  0002b	c3		 ret	 0
$LN2@deflatePar:
  0002c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00031	41 83 f8 ff	 cmp	 r8d, -1

; 577  :     s = strm->state;

  00035	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]
  00039	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003e	bf 06 00 00 00	 mov	 edi, 6
  00043	41 0f 45 f8	 cmovne	 edi, r8d

; 578  : 
; 579  : #ifdef FASTEST
; 580  :     if (level != 0) level = 1;
; 581  : #else
; 582  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 583  : #endif
; 584  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00047	83 ff 09	 cmp	 edi, 9
  0004a	0f 87 18 01 00
	00		 ja	 $LN5@deflatePar
  00050	83 fd 04	 cmp	 ebp, 4
  00053	0f 87 0f 01 00
	00		 ja	 $LN5@deflatePar

; 586  :     }
; 587  :     func = configuration_table[s->level].func;
; 588  : 
; 589  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&

  00059	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0005e	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:configuration_table
  00065	3b ab b0 00 00
	00		 cmp	 ebp, DWORD PTR [rbx+176]
  0006b	75 1c		 jne	 SHORT $LN7@deflatePar
  0006d	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00074	48 63 c7	 movsxd	 rax, edi
  00077	48 03 c9	 add	 rcx, rcx
  0007a	48 03 c0	 add	 rax, rax
  0007d	49 8b 44 c6 08	 mov	 rax, QWORD PTR [r14+rax*8+8]
  00082	49 39 44 ce 08	 cmp	 QWORD PTR [r14+rcx*8+8], rax
  00087	74 42		 je	 SHORT $LN9@deflatePar
$LN7@deflatePar:
  00089	83 bb 18 17 00
	00 00		 cmp	 DWORD PTR [rbx+5912], 0
  00090	74 39		 je	 SHORT $LN9@deflatePar

; 590  :         s->high_water) {
; 591  :         /* Flush the last buffer: */
; 592  :         int err = deflate(strm, Z_BLOCK);

  00092	ba 05 00 00 00	 mov	 edx, 5
  00097	48 8b ce	 mov	 rcx, rsi
  0009a	e8 00 00 00 00	 call	 deflate

; 593  :         if (err == Z_STREAM_ERROR)

  0009f	83 f8 fe	 cmp	 eax, -2
  000a2	75 1a		 jne	 SHORT $LN8@deflatePar
$LN17@deflatePar:
  000a4	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN16@deflatePar:
  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 614  : }

  000b3	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5e		 pop	 rsi
  000bd	c3		 ret	 0
$LN8@deflatePar:

; 594  :             return err;
; 595  :         if (strm->avail_out == 0)

  000be	83 7e 18 00	 cmp	 DWORD PTR [rsi+24], 0
  000c2	75 07		 jne	 SHORT $LN9@deflatePar

; 596  :             return Z_BUF_ERROR;

  000c4	b8 fb ff ff ff	 mov	 eax, -5
  000c9	eb d9		 jmp	 SHORT $LN17@deflatePar
$LN9@deflatePar:

; 597  :     }
; 598  :     if (s->level != level) {

  000cb	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  000d1	3b c7		 cmp	 eax, edi
  000d3	0f 84 82 00 00
	00		 je	 $LN10@deflatePar

; 599  :         if (s->level == 0 && s->matches != 0) {

  000d9	85 c0		 test	 eax, eax
  000db	75 43		 jne	 SHORT $LN11@deflatePar
  000dd	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  000e3	85 c0		 test	 eax, eax
  000e5	74 39		 je	 SHORT $LN11@deflatePar

; 600  :             if (s->matches == 1)

  000e7	33 f6		 xor	 esi, esi
  000e9	83 f8 01	 cmp	 eax, 1
  000ec	75 0a		 jne	 SHORT $LN12@deflatePar

; 601  :                 slide_hash(s);

  000ee	48 8b cb	 mov	 rcx, rbx
  000f1	e8 00 00 00 00	 call	 slide_hash
  000f6	eb 0d		 jmp	 SHORT $LN13@deflatePar
$LN12@deflatePar:

; 602  :             else
; 603  :                 CLEAR_HASH(s);

  000f8	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  000fb	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000ff	ff c9		 dec	 ecx
  00101	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
$LN13@deflatePar:
  00105	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  00109	33 d2		 xor	 edx, edx
  0010b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0010f	41 ff c8	 dec	 r8d
  00112	4d 03 c0	 add	 r8, r8
  00115	e8 00 00 00 00	 call	 memset

; 604  :             s->matches = 0;

  0011a	89 b3 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], esi
$LN11@deflatePar:

; 605  :         }
; 606  :         s->level = level;

  00120	89 bb ac 00 00
	00		 mov	 DWORD PTR [rbx+172], edi

; 607  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  00126	48 63 cf	 movsxd	 rcx, edi
  00129	48 03 c9	 add	 rcx, rcx
  0012c	41 0f b7 44 ce
	02		 movzx	 eax, WORD PTR [r14+rcx*8+2]
  00132	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 608  :         s->good_match       = configuration_table[level].good_length;

  00138	41 0f b7 04 ce	 movzx	 eax, WORD PTR [r14+rcx*8]
  0013d	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 609  :         s->nice_match       = configuration_table[level].nice_length;

  00143	41 0f b7 44 ce
	04		 movzx	 eax, WORD PTR [r14+rcx*8+4]
  00149	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 610  :         s->max_chain_length = configuration_table[level].max_chain;

  0014f	41 0f b7 44 ce
	06		 movzx	 eax, WORD PTR [r14+rcx*8+6]
  00155	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
$LN10@deflatePar:

; 611  :     }
; 612  :     s->strategy = strategy;

  0015b	89 ab b0 00 00
	00		 mov	 DWORD PTR [rbx+176], ebp

; 613  :     return Z_OK;

  00161	33 c0		 xor	 eax, eax
  00163	e9 3c ff ff ff	 jmp	 $LN17@deflatePar
$LN5@deflatePar:

; 585  :         return Z_STREAM_ERROR;

  00168	b8 fe ff ff ff	 mov	 eax, -2
  0016d	e9 37 ff ff ff	 jmp	 $LN16@deflatePar
deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateTune
_TEXT	SEGMENT
strm$ = 48
good_length$ = 56
max_lazy$ = 64
nice_length$ = 72
max_chain$ = 80
deflateTune PROC					; COMDAT

; 623  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 8b da	 mov	 r11d, edx
  00007	4c 8b d1	 mov	 r10, rcx

; 624  :     deflate_state *s;
; 625  : 
; 626  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflateTun
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 633  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflateTun:

; 627  :     s = strm->state;

  0001d	49 8b 4a 28	 mov	 rcx, QWORD PTR [r10+40]

; 628  :     s->good_match = (uInt)good_length;
; 629  :     s->max_lazy_match = (uInt)max_lazy;
; 630  :     s->nice_match = nice_length;
; 631  :     s->max_chain_length = (uInt)max_chain;

  00021	8b 44 24 50	 mov	 eax, DWORD PTR max_chain$[rsp]
  00025	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 632  :     return Z_OK;

  0002b	33 c0		 xor	 eax, eax
  0002d	44 89 99 b4 00
	00 00		 mov	 DWORD PTR [rcx+180], r11d
  00034	44 89 81 a8 00
	00 00		 mov	 DWORD PTR [rcx+168], r8d
  0003b	44 89 89 b8 00
	00 00		 mov	 DWORD PTR [rcx+184], r9d

; 633  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateBound
_TEXT	SEGMENT
strm$ = 48
sourceLen$ = 56
deflateBound PROC					; COMDAT

; 655  : {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 656  :     deflate_state *s;
; 657  :     uLong complen, wraplen;
; 658  : 
; 659  :     /* conservative upper bound for compressed data */
; 660  :     complen = sourceLen +

  00004	44 8d 5a 3f	 lea	 r11d, DWORD PTR [rdx+63]
  00008	44 8b d2	 mov	 r10d, edx
  0000b	44 8d 42 07	 lea	 r8d, DWORD PTR [rdx+7]
  0000f	41 c1 eb 06	 shr	 r11d, 6
  00013	44 03 da	 add	 r11d, edx
  00016	41 c1 e8 03	 shr	 r8d, 3
  0001a	41 83 c0 05	 add	 r8d, 5
  0001e	4c 8b c9	 mov	 r9, rcx
  00021	45 03 d8	 add	 r11d, r8d

; 661  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
; 662  : 
; 663  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 664  :     if (deflateStateCheck(strm))

  00024	e8 00 00 00 00	 call	 deflateStateCheck
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN10@deflateBou

; 665  :         return complen + 6;

  0002d	41 8d 43 06	 lea	 eax, DWORD PTR [r11+6]

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
$LN10@deflateBou:

; 666  : 
; 667  :     /* compute wrapper length */
; 668  :     s = strm->state;

  00036	4d 8b 49 28	 mov	 r9, QWORD PTR [r9+40]

; 669  :     switch (s->wrap) {

  0003a	41 8b 49 2c	 mov	 ecx, DWORD PTR [r9+44]
  0003e	85 c9		 test	 ecx, ecx
  00040	0f 84 8d 00 00
	00		 je	 $LN11@deflateBou
  00046	83 e9 01	 sub	 ecx, 1
  00049	74 6f		 je	 SHORT $LN12@deflateBou
  0004b	83 f9 01	 cmp	 ecx, 1
  0004e	74 0b		 je	 SHORT $LN13@deflateBou

; 697  : #endif
; 698  :     default:                                /* for compiler happiness */
; 699  :         wraplen = 6;

  00050	41 b8 06 00 00
	00		 mov	 r8d, 6
  00056	e9 7b 00 00 00	 jmp	 $LN2@deflateBou
$LN13@deflateBou:

; 676  : #ifdef GZIP
; 677  :     case 2:                                 /* gzip wrapper */
; 678  :         wraplen = 18;
; 679  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  0005b	49 8b 51 30	 mov	 rdx, QWORD PTR [r9+48]
  0005f	41 b8 12 00 00
	00		 mov	 r8d, 18
  00065	48 85 d2	 test	 rdx, rdx
  00068	74 6c		 je	 SHORT $LN2@deflateBou

; 680  :             Bytef *str;
; 681  :             if (s->gzhead->extra != Z_NULL)

  0006a	48 83 7a 10 00	 cmp	 QWORD PTR [rdx+16], 0
  0006f	74 08		 je	 SHORT $LN15@deflateBou

; 682  :                 wraplen += 2 + s->gzhead->extra_len;

  00071	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  00075	41 83 c0 14	 add	 r8d, 20
$LN15@deflateBou:

; 683  :             str = s->gzhead->name;

  00079	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]

; 684  :             if (str != Z_NULL)

  0007d	48 85 c9	 test	 rcx, rcx
  00080	74 0e		 je	 SHORT $LN5@deflateBou
$LL6@deflateBou:

; 685  :                 do {
; 686  :                     wraplen++;
; 687  :                 } while (*str++);

  00082	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00085	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00089	41 ff c0	 inc	 r8d
  0008c	84 c0		 test	 al, al
  0008e	75 f2		 jne	 SHORT $LL6@deflateBou
$LN5@deflateBou:

; 688  :             str = s->gzhead->comment;

  00090	48 8b 4a 30	 mov	 rcx, QWORD PTR [rdx+48]

; 689  :             if (str != Z_NULL)

  00094	48 85 c9	 test	 rcx, rcx
  00097	74 15		 je	 SHORT $LN8@deflateBou
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@deflateBou:

; 690  :                 do {
; 691  :                     wraplen++;
; 692  :                 } while (*str++);

  000a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000a3	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  000a7	41 ff c0	 inc	 r8d
  000aa	84 c0		 test	 al, al
  000ac	75 f2		 jne	 SHORT $LL9@deflateBou
$LN8@deflateBou:

; 693  :             if (s->gzhead->hcrc)

  000ae	83 7a 3c 00	 cmp	 DWORD PTR [rdx+60], 0
  000b2	74 22		 je	 SHORT $LN2@deflateBou

; 694  :                 wraplen += 2;

  000b4	41 83 c0 02	 add	 r8d, 2

; 695  :         }
; 696  :         break;

  000b8	eb 1c		 jmp	 SHORT $LN2@deflateBou
$LN12@deflateBou:
  000ba	41 83 b9 94 00
	00 00 00	 cmp	 DWORD PTR [r9+148], 0
  000c2	b8 0a 00 00 00	 mov	 eax, 10
  000c7	41 b8 06 00 00
	00		 mov	 r8d, 6
  000cd	44 0f 45 c0	 cmovne	 r8d, eax

; 672  :         break;
; 673  :     case 1:                                 /* zlib wrapper */
; 674  :         wraplen = 6 + (s->strstart ? 4 : 0);
; 675  :         break;

  000d1	eb 03		 jmp	 SHORT $LN2@deflateBou
$LN11@deflateBou:

; 670  :     case 0:                                 /* raw deflate */
; 671  :         wraplen = 0;

  000d3	45 33 c0	 xor	 r8d, r8d
$LN2@deflateBou:

; 700  :     }
; 701  : 
; 702  :     /* if not default parameters, return conservative bound */
; 703  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000d6	41 83 79 48 0f	 cmp	 DWORD PTR [r9+72], 15
  000db	75 2b		 jne	 SHORT $LN21@deflateBou
  000dd	41 83 79 78 0f	 cmp	 DWORD PTR [r9+120], 15
  000e2	75 24		 jne	 SHORT $LN21@deflateBou

; 705  : 
; 706  :     /* default settings: return tight bound for that case */
; 707  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +

  000e4	41 8b d2	 mov	 edx, r10d
  000e7	41 8b ca	 mov	 ecx, r10d
  000ea	c1 ea 0e	 shr	 edx, 14
  000ed	41 8b c2	 mov	 eax, r10d
  000f0	c1 e8 0c	 shr	 eax, 12
  000f3	41 03 d0	 add	 edx, r8d
  000f6	c1 e9 19	 shr	 ecx, 25
  000f9	83 c0 07	 add	 eax, 7
  000fc	03 d1		 add	 edx, ecx
  000fe	03 c2		 add	 eax, edx
  00100	41 03 c2	 add	 eax, r10d

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  00103	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00107	c3		 ret	 0
$LN21@deflateBou:

; 704  :         return complen + wraplen;

  00108	43 8d 04 18	 lea	 eax, DWORD PTR [r8+r11]

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  0010c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00110	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 720  :     put_byte(s, (Byte)(b >> 8));

  00000	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00004	44 8b ca	 mov	 r9d, edx
  00007	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0000b	41 c1 e9 08	 shr	 r9d, 8
  0000f	45 88 0c 00	 mov	 BYTE PTR [r8+rax], r9b
  00013	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00016	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]

; 721  :     put_byte(s, (Byte)(b & 0xff));

  0001a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001e	41 88 14 00	 mov	 BYTE PTR [r8+rax], dl
  00022	ff 41 28	 inc	 DWORD PTR [rcx+40]

; 722  : }

  00025	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT flush_pending
_TEXT	SEGMENT
strm$ = 48
flush_pending PROC					; COMDAT

; 732  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 733  :     unsigned len;
; 734  :     deflate_state *s = strm->state;

  0000f	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  00013	48 8b f1	 mov	 rsi, rcx

; 735  : 
; 736  :     _tr_flush_bits(s);

  00016	48 8b cf	 mov	 rcx, rdi
  00019	e8 00 00 00 00	 call	 _tr_flush_bits

; 737  :     len = s->pending;

  0001e	8b 6f 28	 mov	 ebp, DWORD PTR [rdi+40]

; 738  :     if (len > strm->avail_out) len = strm->avail_out;

  00021	3b 6e 18	 cmp	 ebp, DWORD PTR [rsi+24]
  00024	0f 47 6e 18	 cmova	 ebp, DWORD PTR [rsi+24]

; 739  :     if (len == 0) return;

  00028	85 ed		 test	 ebp, ebp
  0002a	74 37		 je	 SHORT $LN4@flush_pend

; 740  : 
; 741  :     zmemcpy(strm->next_out, s->pending_out, len);

  0002c	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00030	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00034	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00039	44 8b c5	 mov	 r8d, ebp
  0003c	8b dd		 mov	 ebx, ebp
  0003e	e8 00 00 00 00	 call	 memcpy

; 742  :     strm->next_out  += len;

  00043	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 743  :     s->pending_out  += len;

  00047	48 01 5f 20	 add	 QWORD PTR [rdi+32], rbx

; 744  :     strm->total_out += len;

  0004b	01 6e 1c	 add	 DWORD PTR [rsi+28], ebp

; 745  :     strm->avail_out -= len;

  0004e	29 6e 18	 sub	 DWORD PTR [rsi+24], ebp

; 746  :     s->pending      -= len;

  00051	29 6f 28	 sub	 DWORD PTR [rdi+40], ebp
  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 747  :     if (s->pending == 0) {

  00059	75 08		 jne	 SHORT $LN4@flush_pend

; 748  :         s->pending_out = s->pending_buf;

  0005b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0005f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
$LN4@flush_pend:

; 749  :     }
; 750  : }

  00063	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00068	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateCopy
_TEXT	SEGMENT
dest$ = 48
source$ = 56
deflateCopy PROC					; COMDAT

; 1105 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	4c 8b c2	 mov	 r8, rdx

; 1106 : #ifdef MAXSEG_64K
; 1107 :     return Z_STREAM_ERROR;
; 1108 : #else
; 1109 :     deflate_state *ds;
; 1110 :     deflate_state *ss;
; 1111 :     ushf *overlay;
; 1112 : 
; 1113 : 
; 1114 :     if (deflateStateCheck(source) || dest == Z_NULL) {

  0000c	48 8b ca	 mov	 rcx, rdx
  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	0f 85 48 02 00
	00		 jne	 $LN3@deflateCop
  0001c	48 85 db	 test	 rbx, rbx
  0001f	0f 84 3f 02 00
	00		 je	 $LN3@deflateCop

; 1116 :     }
; 1117 : 
; 1118 :     ss = source->state;
; 1119 : 
; 1120 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00025	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00029	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 1121 : 
; 1122 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0002e	8d 50 01	 lea	 edx, QWORD PTR [rax+1]
  00031	49 8b 70 28	 mov	 rsi, QWORD PTR [r8+40]
  00035	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00038	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003d	41 0f 10 48 10	 movups	 xmm1, XMMWORD PTR [r8+16]
  00042	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
  00046	41 0f 10 40 20	 movups	 xmm0, XMMWORD PTR [r8+32]
  0004b	0f 11 43 20	 movups	 XMMWORD PTR [rbx+32], xmm0
  0004f	41 0f 10 48 30	 movups	 xmm1, XMMWORD PTR [r8+48]
  00054	0f 11 4b 30	 movups	 XMMWORD PTR [rbx+48], xmm1
  00058	41 0f 10 40 40	 movups	 xmm0, XMMWORD PTR [r8+64]
  0005d	0f 11 43 40	 movups	 XMMWORD PTR [rbx+64], xmm0
  00061	f2 41 0f 10 48
	50		 movsd	 xmm1, QWORD PTR [r8+80]
  00067	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0006d	f2 0f 11 4b 50	 movsd	 QWORD PTR [rbx+80], xmm1
  00072	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00076	ff 53 30	 call	 QWORD PTR [rbx+48]
  00079	48 8b f8	 mov	 rdi, rax

; 1123 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  0007c	48 85 c0	 test	 rax, rax
  0007f	75 13		 jne	 SHORT $LN4@deflateCop
  00081	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00086	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
  00089	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
$LN4@deflateCop:
  00094	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 1124 :     dest->state = (struct internal_state FAR *) ds;
; 1125 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  00099	48 8b cf	 mov	 rcx, rdi
  0009c	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi
  000a0	48 8b c6	 mov	 rax, rsi
  000a3	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL8@deflateCop:
  000b0	48 8d 89 80 00
	00 00		 lea	 rcx, QWORD PTR [rcx+128]
  000b7	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000ba	48 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [rax+128]
  000c1	0f 11 41 80	 movups	 XMMWORD PTR [rcx-128], xmm0
  000c5	0f 10 48 90	 movups	 xmm1, XMMWORD PTR [rax-112]
  000c9	0f 11 49 90	 movups	 XMMWORD PTR [rcx-112], xmm1
  000cd	0f 10 40 a0	 movups	 xmm0, XMMWORD PTR [rax-96]
  000d1	0f 11 41 a0	 movups	 XMMWORD PTR [rcx-96], xmm0
  000d5	0f 10 48 b0	 movups	 xmm1, XMMWORD PTR [rax-80]
  000d9	0f 11 49 b0	 movups	 XMMWORD PTR [rcx-80], xmm1
  000dd	0f 10 40 c0	 movups	 xmm0, XMMWORD PTR [rax-64]
  000e1	0f 11 41 c0	 movups	 XMMWORD PTR [rcx-64], xmm0
  000e5	0f 10 48 d0	 movups	 xmm1, XMMWORD PTR [rax-48]
  000e9	0f 11 49 d0	 movups	 XMMWORD PTR [rcx-48], xmm1
  000ed	0f 10 40 e0	 movups	 xmm0, XMMWORD PTR [rax-32]
  000f1	0f 11 41 e0	 movups	 XMMWORD PTR [rcx-32], xmm0
  000f5	0f 10 48 f0	 movups	 xmm1, XMMWORD PTR [rax-16]
  000f9	0f 11 49 f0	 movups	 XMMWORD PTR [rcx-16], xmm1
  000fd	48 83 ea 01	 sub	 rdx, 1
  00101	75 ad		 jne	 SHORT $LL8@deflateCop
  00103	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]

; 1126 :     ds->strm = dest;
; 1127 : 
; 1128 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  00106	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  0010a	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  0010d	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00111	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1
  00115	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00118	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  0011b	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0011f	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1129 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00122	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00125	41 b8 02 00 00
	00		 mov	 r8d, 2
  0012b	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  0012f	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00133	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1130 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00136	8b 57 74	 mov	 edx, DWORD PTR [rdi+116]
  00139	41 b8 02 00 00
	00		 mov	 r8d, 2
  0013f	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  00143	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00147	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1131 :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  0014a	8b 97 f0 16 00
	00		 mov	 edx, DWORD PTR [rdi+5872]
  00150	41 b8 04 00 00
	00		 mov	 r8d, 4
  00156	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  0015a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0015e	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1132 :     ds->pending_buf = (uchf *) overlay;
; 1133 : 
; 1134 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||

  00161	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00165	4c 8b f0	 mov	 r14, rax
  00168	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0016c	48 85 c9	 test	 rcx, rcx
  0016f	0f 84 e0 00 00
	00		 je	 $LN6@deflateCop
  00175	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  0017a	0f 84 d5 00 00
	00		 je	 $LN6@deflateCop
  00180	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  00185	0f 84 ca 00 00
	00		 je	 $LN6@deflateCop
  0018b	48 85 c0	 test	 rax, rax
  0018e	0f 84 c1 00 00
	00		 je	 $LN6@deflateCop

; 1138 :     }
; 1139 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1140 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  00194	8b 47 44	 mov	 eax, DWORD PTR [rdi+68]
  00197	48 8b 56 50	 mov	 rdx, QWORD PTR [rsi+80]
  0019b	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  0019f	e8 00 00 00 00	 call	 memcpy

; 1141 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  001a4	44 8b 47 44	 mov	 r8d, DWORD PTR [rdi+68]
  001a8	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  001ac	4d 03 c0	 add	 r8, r8
  001af	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  001b3	e8 00 00 00 00	 call	 memcpy

; 1142 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  001b8	44 8b 47 74	 mov	 r8d, DWORD PTR [rdi+116]
  001bc	48 8b 56 68	 mov	 rdx, QWORD PTR [rsi+104]
  001c0	4d 03 c0	 add	 r8, r8
  001c3	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  001c7	e8 00 00 00 00	 call	 memcpy

; 1143 :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  001cc	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  001d0	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  001d4	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001d8	e8 00 00 00 00	 call	 memcpy

; 1144 : 
; 1145 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  001dd	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  001e1	48 2b 46 10	 sub	 rax, QWORD PTR [rsi+16]

; 1146 :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  001e5	8b 8f f0 16 00
	00		 mov	 ecx, DWORD PTR [rdi+5872]
  001eb	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001ef	48 03 c2	 add	 rax, rdx
  001f2	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  001f6	8b c1		 mov	 eax, ecx
  001f8	48 d1 e8	 shr	 rax, 1
  001fb	49 8d 04 46	 lea	 rax, QWORD PTR [r14+rax*2]
  001ff	48 89 87 f8 16
	00 00		 mov	 QWORD PTR [rdi+5880], rax

; 1147 :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  00206	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  0020a	48 03 c8	 add	 rcx, rax

; 1148 : 
; 1149 :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  0020d	48 8d 87 bc 00
	00 00		 lea	 rax, QWORD PTR [rdi+188]
  00214	48 89 87 40 0b
	00 00		 mov	 QWORD PTR [rdi+2880], rax

; 1150 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  0021b	48 8d 87 b0 09
	00 00		 lea	 rax, QWORD PTR [rdi+2480]
  00222	48 89 87 58 0b
	00 00		 mov	 QWORD PTR [rdi+2904], rax

; 1151 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  00229	48 8d 87 a4 0a
	00 00		 lea	 rax, QWORD PTR [rdi+2724]
  00230	48 89 87 70 0b
	00 00		 mov	 QWORD PTR [rdi+2928], rax

; 1152 : 
; 1153 :     return Z_OK;

  00237	33 c0		 xor	 eax, eax
  00239	48 89 8f e8 16
	00 00		 mov	 QWORD PTR [rdi+5864], rcx
$LN11@deflateCop:
  00240	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00245	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0024a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  0024f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00253	5b		 pop	 rbx
  00254	c3		 ret	 0
$LN6@deflateCop:

; 1135 :         ds->pending_buf == Z_NULL) {
; 1136 :         deflateEnd (dest);

  00255	48 8b cb	 mov	 rcx, rbx
  00258	e8 00 00 00 00	 call	 deflateEnd

; 1137 :         return Z_MEM_ERROR;

  0025d	b8 fc ff ff ff	 mov	 eax, -4
  00262	eb dc		 jmp	 SHORT $LN11@deflateCop
$LN3@deflateCop:

; 1115 :         return Z_STREAM_ERROR;

  00264	b8 fe ff ff ff	 mov	 eax, -2

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  00269	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0026d	5b		 pop	 rbx
  0026e	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT read_buf
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
size$ = 64
read_buf PROC						; COMDAT

; 1168 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1169 :     unsigned len = strm->avail_in;

  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	48 8b f2	 mov	 rsi, rdx

; 1170 : 
; 1171 :     if (len > size) len = size;

  00015	41 3b c0	 cmp	 eax, r8d
  00018	8b f8		 mov	 edi, eax
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 0f 47 f8	 cmova	 edi, r8d

; 1172 :     if (len == 0) return 0;

  00021	85 ff		 test	 edi, edi
  00023	75 12		 jne	 SHORT $LN3@read_buf
  00025	33 c0		 xor	 eax, eax

; 1189 : }

  00027	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN3@read_buf:

; 1173 : 
; 1174 :     strm->avail_in  -= len;
; 1175 : 
; 1176 :     zmemcpy(buf, strm->next_in, len);

  00037	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0003a	2b c7		 sub	 eax, edi
  0003c	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00047	44 8b c7	 mov	 r8d, edi
  0004a	8b ef		 mov	 ebp, edi
  0004c	e8 00 00 00 00	 call	 memcpy

; 1177 :     if (strm->state->wrap == 1) {

  00051	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00055	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00058	83 f9 01	 cmp	 ecx, 1
  0005b	75 10		 jne	 SHORT $LN4@read_buf

; 1178 :         strm->adler = adler32(strm->adler, buf, len);

  0005d	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00060	44 8b c7	 mov	 r8d, edi
  00063	48 8b d6	 mov	 rdx, rsi
  00066	e8 00 00 00 00	 call	 adler32

; 1179 :     }

  0006b	eb 13		 jmp	 SHORT $LN8@read_buf
$LN4@read_buf:

; 1180 : #ifdef GZIP
; 1181 :     else if (strm->state->wrap == 2) {

  0006d	83 f9 02	 cmp	 ecx, 2
  00070	75 11		 jne	 SHORT $LN6@read_buf

; 1182 :         strm->adler = crc32(strm->adler, buf, len);

  00072	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00075	44 8b c7	 mov	 r8d, edi
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	e8 00 00 00 00	 call	 crc32
$LN8@read_buf:
  00080	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN6@read_buf:

; 1183 :     }
; 1184 : #endif
; 1185 :     strm->next_in  += len;

  00083	48 01 2b	 add	 QWORD PTR [rbx], rbp

; 1186 :     strm->total_in += len;
; 1187 : 
; 1188 :     return len;

  00086	8b c7		 mov	 eax, edi
  00088	01 7b 0c	 add	 DWORD PTR [rbx+12], edi

; 1189 : }

  0008b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00090	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1196 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1197 :     s->window_size = (ulg)2L*s->w_size;

  0000a	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]
  0000d	48 8b d9	 mov	 rbx, rcx

; 1198 : 
; 1199 :     CLEAR_HASH(s);

  00010	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00013	03 c0		 add	 eax, eax
  00015	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  00018	ff ca		 dec	 edx
  0001a	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0001e	33 ff		 xor	 edi, edi
  00020	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00024	33 d2		 xor	 edx, edx
  00026	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  0002a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0002e	41 ff c8	 dec	 r8d
  00031	4d 03 c0	 add	 r8, r8
  00034	e8 00 00 00 00	 call	 memset

; 1200 : 
; 1201 :     /* Set the default configuration parameters:
; 1202 :      */
; 1203 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00039	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:configuration_table
  00047	48 03 c9	 add	 rcx, rcx
  0004a	0f b7 44 ca 02	 movzx	 eax, WORD PTR [rdx+rcx*8+2]
  0004f	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 1204 :     s->good_match       = configuration_table[s->level].good_length;

  00055	0f b7 04 ca	 movzx	 eax, WORD PTR [rdx+rcx*8]
  00059	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 1205 :     s->nice_match       = configuration_table[s->level].nice_length;

  0005f	0f b7 44 ca 04	 movzx	 eax, WORD PTR [rdx+rcx*8+4]
  00064	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 1206 :     s->max_chain_length = configuration_table[s->level].max_chain;

  0006a	0f b7 44 ca 06	 movzx	 eax, WORD PTR [rdx+rcx*8+6]
  0006f	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax

; 1207 : 
; 1208 :     s->strstart = 0;
; 1209 :     s->block_start = 0L;
; 1210 :     s->lookahead = 0;
; 1211 :     s->insert = 0;
; 1212 :     s->match_length = s->prev_length = MIN_MATCH-1;
; 1213 :     s->match_available = 0;

  00075	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  0007c	89 bb 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edi
  00082	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  00088	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi
  0008e	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  00098	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2

; 1214 :     s->ins_h = 0;

  000a2	89 7b 70	 mov	 DWORD PTR [rbx+112], edi

; 1215 : #ifndef FASTEST
; 1216 : #ifdef ASMV
; 1217 :     match_init(); /* initialize the asm code */
; 1218 : #endif
; 1219 : #endif
; 1220 : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT longest_match
_TEXT	SEGMENT
s$ = 40
cur_match$ = 48
longest_match PROC					; COMDAT

; 1239 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 1240 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */
; 1241 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	8b b9 94 00 00
	00		 mov	 edi, DWORD PTR [rcx+148]
  00022	44 8b da	 mov	 r11d, edx

; 1242 :     register Bytef *match;                      /* matched string */
; 1243 :     register int len;                           /* length of current match */
; 1244 :     int best_len = (int)s->prev_length;         /* best match length so far */
; 1245 :     int nice_match = s->nice_match;             /* stop if match long enough */
; 1246 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?

  00025	44 8b 49 44	 mov	 r9d, DWORD PTR [rcx+68]
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	4c 8b 69 50	 mov	 r13, QWORD PTR [rcx+80]
  00030	8b b1 a4 00 00
	00		 mov	 esi, DWORD PTR [rcx+164]
  00036	4c 63 91 a0 00
	00 00		 movsxd	 r10, DWORD PTR [rcx+160]
  0003d	44 8b a1 b8 00
	00 00		 mov	 r12d, DWORD PTR [rcx+184]
  00044	45 8d 81 fa fe
	ff ff		 lea	 r8d, DWORD PTR [r9-262]
  0004b	4a 8d 04 2f	 lea	 rax, QWORD PTR [rdi+r13]
  0004f	41 3b f8	 cmp	 edi, r8d
  00052	76 0b		 jbe	 SHORT $LN18@longest_ma
  00054	41 2b f9	 sub	 edi, r9d
  00057	81 c7 06 01 00
	00		 add	 edi, 262		; 00000106H
  0005d	eb 02		 jmp	 SHORT $LN19@longest_ma
$LN18@longest_ma:
  0005f	33 ff		 xor	 edi, edi
$LN19@longest_ma:

; 1247 :         s->strstart - (IPos)MAX_DIST(s) : NIL;
; 1248 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1249 :      * we prevent matches with the string of window index 0.
; 1250 :      */
; 1251 :     Posf *prev = s->prev;
; 1252 :     uInt wmask = s->w_mask;
; 1253 : 
; 1254 : #ifdef UNALIGNED_OK
; 1255 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1256 :      * Try with and without -DUNALIGNED_OK to check.
; 1257 :      */
; 1258 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1259 :     register ush scan_start = *(ushf*)scan;
; 1260 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1261 : #else
; 1262 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
; 1263 :     register Byte scan_end1  = scan[best_len-1];

  00061	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]

; 1264 :     register Byte scan_end   = scan[best_len];

  00065	45 0f b6 3c 02	 movzx	 r15d, BYTE PTR [r10+rax]
  0006a	4c 8d 88 02 01
	00 00		 lea	 r9, QWORD PTR [rax+258]
  00071	48 63 d1	 movsxd	 rdx, ecx
  00074	44 0f b6 34 02	 movzx	 r14d, BYTE PTR [rdx+rax]

; 1265 : #endif
; 1266 : 
; 1267 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1268 :      * It is easy to get rid of this optimization if necessary.
; 1269 :      */
; 1270 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1271 : 
; 1272 :     /* Do not waste too much time if we already have a good match: */
; 1273 :     if (s->prev_length >= s->good_match) {

  00079	44 3b 93 b4 00
	00 00		 cmp	 r10d, DWORD PTR [rbx+180]
  00080	72 03		 jb	 SHORT $LN8@longest_ma

; 1274 :         chain_length >>= 2;

  00082	c1 ee 02	 shr	 esi, 2
$LN8@longest_ma:

; 1275 :     }
; 1276 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1277 :      * to make deflate deterministic.
; 1278 :      */
; 1279 :     if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;

  00085	8b ab 9c 00 00
	00		 mov	 ebp, DWORD PTR [rbx+156]
  0008b	44 3b e5	 cmp	 r12d, ebp
  0008e	44 0f 47 e5	 cmova	 r12d, ebp
$LL4@longest_ma:

; 1280 : 
; 1281 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1282 : 
; 1283 :     do {
; 1284 :         Assert(cur_match < s->strstart, "no future");
; 1285 :         match = s->window + cur_match;

  00092	45 8b c3	 mov	 r8d, r11d
  00095	4d 03 c5	 add	 r8, r13

; 1286 : 
; 1287 :         /* Skip to next match if the match length cannot increase
; 1288 :          * or if the match length is less than 2.  Note that the checks below
; 1289 :          * for insufficient lookahead only occur occasionally for performance
; 1290 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1291 :          * conditional jumps will be made that depend on those values.
; 1292 :          * However the length of the match is limited to the lookahead, so
; 1293 :          * the output of deflate is not affected by the uninitialized values.
; 1294 :          */
; 1295 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1296 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1297 :          * UNALIGNED_OK if your compiler uses a different size.
; 1298 :          */
; 1299 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1300 :             *(ushf*)match != scan_start) continue;
; 1301 : 
; 1302 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1303 :          * always equal when the other bytes match, given that the hash keys
; 1304 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1305 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1306 :          * lookahead only every 4th comparison; the 128th check will be made
; 1307 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1308 :          * necessary to put more guard bytes at the end of the window, or
; 1309 :          * to check more often for insufficient lookahead.
; 1310 :          */
; 1311 :         Assert(scan[2] == match[2], "scan[2]?");
; 1312 :         scan++, match++;
; 1313 :         do {
; 1314 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1315 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1316 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1317 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1318 :                  scan < strend);
; 1319 :         /* The funny "do {}" generates better code on most compilers */
; 1320 : 
; 1321 :         /* Here, scan <= window+strstart+257 */
; 1322 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1323 :         if (*scan == *match) scan++;
; 1324 : 
; 1325 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1326 :         scan = strend - (MAX_MATCH-1);
; 1327 : 
; 1328 : #else /* UNALIGNED_OK */
; 1329 : 
; 1330 :         if (match[best_len]   != scan_end  ||
; 1331 :             match[best_len-1] != scan_end1 ||
; 1332 :             *match            != *scan     ||

  00098	49 63 ca	 movsxd	 rcx, r10d
  0009b	46 38 3c 01	 cmp	 BYTE PTR [rcx+r8], r15b
  0009f	0f 85 db 00 00
	00		 jne	 $LN2@longest_ma
  000a5	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  000a9	48 63 d1	 movsxd	 rdx, ecx
  000ac	46 38 34 02	 cmp	 BYTE PTR [rdx+r8], r14b
  000b0	0f 85 ca 00 00
	00		 jne	 $LN2@longest_ma
  000b6	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000b9	41 38 08	 cmp	 BYTE PTR [r8], cl
  000bc	0f 85 be 00 00
	00		 jne	 $LN2@longest_ma
  000c2	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000c6	41 38 48 01	 cmp	 BYTE PTR [r8+1], cl
  000ca	0f 85 b0 00 00
	00		 jne	 $LN2@longest_ma

; 1333 :             *++match          != scan[1])      continue;
; 1334 : 
; 1335 :         /* The check at best_len-1 can be removed because it will be made
; 1336 :          * again later. (This heuristic is not always a win.)
; 1337 :          * It is not necessary to compare scan[2] and match[2] since they
; 1338 :          * are always equal when the other bytes match, given that
; 1339 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1340 :          */
; 1341 :         scan += 2, match++;

  000d0	48 83 c0 02	 add	 rax, 2
  000d4	49 83 c0 02	 add	 r8, 2
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@longest_ma:

; 1342 :         Assert(*scan == *match, "match[2]?");
; 1343 : 
; 1344 :         /* We check for insufficient lookahead only every 8th comparison;
; 1345 :          * the 256th check will be made at strstart+258.
; 1346 :          */
; 1347 :         do {
; 1348 :         } while (*++scan == *++match && *++scan == *++match &&
; 1349 :                  *++scan == *++match && *++scan == *++match &&
; 1350 :                  *++scan == *++match && *++scan == *++match &&
; 1351 :                  *++scan == *++match && *++scan == *++match &&

  000e0	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  000e5	48 ff c0	 inc	 rax
  000e8	38 08		 cmp	 BYTE PTR [rax], cl
  000ea	75 5d		 jne	 SHORT $LN12@longest_ma
  000ec	41 0f b6 48 02	 movzx	 ecx, BYTE PTR [r8+2]
  000f1	48 ff c0	 inc	 rax
  000f4	38 08		 cmp	 BYTE PTR [rax], cl
  000f6	75 51		 jne	 SHORT $LN12@longest_ma
  000f8	41 0f b6 48 03	 movzx	 ecx, BYTE PTR [r8+3]
  000fd	48 ff c0	 inc	 rax
  00100	38 08		 cmp	 BYTE PTR [rax], cl
  00102	75 45		 jne	 SHORT $LN12@longest_ma
  00104	41 0f b6 48 04	 movzx	 ecx, BYTE PTR [r8+4]
  00109	48 ff c0	 inc	 rax
  0010c	38 08		 cmp	 BYTE PTR [rax], cl
  0010e	75 39		 jne	 SHORT $LN12@longest_ma
  00110	41 0f b6 48 05	 movzx	 ecx, BYTE PTR [r8+5]
  00115	48 ff c0	 inc	 rax
  00118	38 08		 cmp	 BYTE PTR [rax], cl
  0011a	75 2d		 jne	 SHORT $LN12@longest_ma
  0011c	41 0f b6 48 06	 movzx	 ecx, BYTE PTR [r8+6]
  00121	48 ff c0	 inc	 rax
  00124	38 08		 cmp	 BYTE PTR [rax], cl
  00126	75 21		 jne	 SHORT $LN12@longest_ma
  00128	41 0f b6 48 07	 movzx	 ecx, BYTE PTR [r8+7]
  0012d	48 ff c0	 inc	 rax
  00130	38 08		 cmp	 BYTE PTR [rax], cl
  00132	75 15		 jne	 SHORT $LN12@longest_ma
  00134	41 0f b6 48 08	 movzx	 ecx, BYTE PTR [r8+8]
  00139	49 83 c0 08	 add	 r8, 8
  0013d	48 ff c0	 inc	 rax
  00140	38 08		 cmp	 BYTE PTR [rax], cl
  00142	75 05		 jne	 SHORT $LN12@longest_ma
  00144	49 3b c1	 cmp	 rax, r9
  00147	72 97		 jb	 SHORT $LL7@longest_ma
$LN12@longest_ma:

; 1352 :                  scan < strend);
; 1353 : 
; 1354 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1355 : 
; 1356 :         len = MAX_MATCH - (int)(strend - scan);

  00149	41 2b c1	 sub	 eax, r9d
  0014c	05 02 01 00 00	 add	 eax, 258		; 00000102H
  00151	4c 63 c0	 movsxd	 r8, eax

; 1357 :         scan = strend - MAX_MATCH;

  00154	49 8d 81 fe fe
	ff ff		 lea	 rax, QWORD PTR [r9-258]

; 1358 : 
; 1359 : #endif /* UNALIGNED_OK */
; 1360 : 
; 1361 :         if (len > best_len) {

  0015b	45 3b c2	 cmp	 r8d, r10d
  0015e	7e 20		 jle	 SHORT $LN2@longest_ma

; 1362 :             s->match_start = cur_match;

  00160	44 89 9b 98 00
	00 00		 mov	 DWORD PTR [rbx+152], r11d

; 1363 :             best_len = len;

  00167	45 8b d0	 mov	 r10d, r8d

; 1364 :             if (len >= nice_match) break;

  0016a	45 3b c4	 cmp	 r8d, r12d
  0016d	7d 31		 jge	 SHORT $LN3@longest_ma

; 1365 : #ifdef UNALIGNED_OK
; 1366 :             scan_end = *(ushf*)(scan+best_len-1);
; 1367 : #else
; 1368 :             scan_end1  = scan[best_len-1];
; 1369 :             scan_end   = scan[best_len];

  0016f	45 0f b6 3c 00	 movzx	 r15d, BYTE PTR [r8+rax]
  00174	41 8d 48 ff	 lea	 ecx, DWORD PTR [r8-1]
  00178	48 63 d1	 movsxd	 rdx, ecx
  0017b	44 0f b6 34 02	 movzx	 r14d, BYTE PTR [rdx+rax]
$LN2@longest_ma:

; 1370 : #endif
; 1371 :         }
; 1372 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1373 :              && --chain_length != 0);

  00180	8b 53 4c	 mov	 edx, DWORD PTR [rbx+76]
  00183	41 8b cb	 mov	 ecx, r11d
  00186	48 23 d1	 and	 rdx, rcx
  00189	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0018d	44 0f b7 1c 51	 movzx	 r11d, WORD PTR [rcx+rdx*2]
  00192	44 3b df	 cmp	 r11d, edi
  00195	76 09		 jbe	 SHORT $LN3@longest_ma
  00197	83 c6 ff	 add	 esi, -1			; ffffffffH
  0019a	0f 85 f2 fe ff
	ff		 jne	 $LL4@longest_ma
$LN3@longest_ma:

; 1374 : 
; 1375 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
; 1376 :     return s->lookahead;
; 1377 : }

  001a0	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  001a5	44 3b d5	 cmp	 r10d, ebp
  001a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001ad	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001b2	41 0f 46 ea	 cmovbe	 ebp, r10d
  001b6	8b c5		 mov	 eax, ebp
  001b8	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001bd	41 5f		 pop	 r15
  001bf	41 5e		 pop	 r14
  001c1	41 5d		 pop	 r13
  001c3	41 5c		 pop	 r12
  001c5	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT fill_window
_TEXT	SEGMENT
s$ = 48
fill_window PROC					; COMDAT

; 1484 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1485 :     unsigned n;
; 1486 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1487 :     uInt wsize = s->w_size;

  0000f	8b 71 44	 mov	 esi, DWORD PTR [rcx+68]
  00012	48 8b d9	 mov	 rbx, rcx
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@fill_windo:

; 1488 : 
; 1489 :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 1490 : 
; 1491 :     do {
; 1492 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00020	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00026	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  00029	2b bb 9c 00 00
	00		 sub	 edi, DWORD PTR [rbx+156]

; 1493 : 
; 1494 :         /* Deal with !@#$% 64K limit: */
; 1495 :         if (sizeof(int) <= 2) {
; 1496 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1497 :                 more = wsize;
; 1498 : 
; 1499 :             } else if (more == (unsigned)(-1)) {
; 1500 :                 /* Very unlikely, but possible on 16 bit machine if
; 1501 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1502 :                  */
; 1503 :                 more--;
; 1504 :             }
; 1505 :         }
; 1506 : 
; 1507 :         /* If the window is almost full and there is insufficient lookahead,
; 1508 :          * move the upper half to the lower one to make room in the upper half.
; 1509 :          */
; 1510 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0002f	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00032	2b fa		 sub	 edi, edx
  00034	81 c1 fa fe ff
	ff		 add	 ecx, -262		; fffffefaH
  0003a	03 ce		 add	 ecx, esi
  0003c	3b d1		 cmp	 edx, ecx
  0003e	72 2f		 jb	 SHORT $LN11@fill_windo

; 1511 : 
; 1512 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);

  00040	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00044	44 8b c6	 mov	 r8d, esi
  00047	44 2b c7	 sub	 r8d, edi
  0004a	48 8d 14 31	 lea	 rdx, QWORD PTR [rcx+rsi]
  0004e	e8 00 00 00 00	 call	 memcpy

; 1513 :             s->match_start -= wsize;

  00053	29 b3 98 00 00
	00		 sub	 DWORD PTR [rbx+152], esi

; 1514 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1515 :             s->block_start -= (long) wsize;
; 1516 :             slide_hash(s);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	29 b3 94 00 00
	00		 sub	 DWORD PTR [rbx+148], esi
  00062	29 b3 84 00 00
	00		 sub	 DWORD PTR [rbx+132], esi
  00068	e8 00 00 00 00	 call	 slide_hash

; 1517 :             more += wsize;

  0006d	03 fe		 add	 edi, esi
$LN11@fill_windo:

; 1518 :         }
; 1519 :         if (s->strm->avail_in == 0) break;

  0006f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00072	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00076	0f 84 f8 00 00
	00		 je	 $LN3@fill_windo

; 1520 : 
; 1521 :         /* If there was no sliding:
; 1522 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1523 :          *    more == window_size - lookahead - strstart
; 1524 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1525 :          * => more >= window_size - 2*WSIZE + 2
; 1526 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1527 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1528 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1529 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1530 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1531 :          */
; 1532 :         Assert(more >= 2, "more < 2");
; 1533 : 
; 1534 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  0007c	8b 93 9c 00 00
	00		 mov	 edx, DWORD PTR [rbx+156]
  00082	44 8b c7	 mov	 r8d, edi
  00085	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0008b	48 03 d0	 add	 rdx, rax
  0008e	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00092	e8 00 00 00 00	 call	 read_buf

; 1535 :         s->lookahead += n;

  00097	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax
  0009d	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]

; 1536 : 
; 1537 :         /* Initialize the hash value now that we have some input: */
; 1538 :         if (s->lookahead + s->insert >= MIN_MATCH) {

  000a3	44 8b 8b 0c 17
	00 00		 mov	 r9d, DWORD PTR [rbx+5900]
  000aa	41 03 c1	 add	 eax, r9d
  000ad	83 f8 03	 cmp	 eax, 3
  000b0	0f 82 a5 00 00
	00		 jb	 $LN2@fill_windo

; 1539 :             uInt str = s->strstart - s->insert;

  000b6	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 1540 :             s->ins_h = s->window[str];

  000bd	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  000c1	45 2b d1	 sub	 r10d, r9d

; 1541 :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  000c4	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000ca	45 0f b6 04 12	 movzx	 r8d, BYTE PTR [r10+rdx]
  000cf	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000d3	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000d7	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000db	41 d3 e0	 shl	 r8d, cl
  000de	41 33 c0	 xor	 eax, r8d
  000e1	23 43 7c	 and	 eax, DWORD PTR [rbx+124]
  000e4	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 1542 : #if MIN_MATCH != 3
; 1543 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1544 : #endif
; 1545 :             while (s->insert) {

  000e7	45 85 c9	 test	 r9d, r9d
  000ea	74 6f		 je	 SHORT $LN2@fill_windo

; 1539 :             uInt str = s->strstart - s->insert;

  000ec	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
$LL5@fill_windo:

; 1546 :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  000f0	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000f4	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 1547 : #ifndef FASTEST
; 1548 :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  000fa	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  000fe	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00102	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]

; 1549 : #endif
; 1550 :                 s->head[s->ins_h] = (Pos)str;
; 1551 :                 str++;

  00107	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  0010b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0010e	d3 e0		 shl	 eax, cl
  00110	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00114	44 33 c8	 xor	 r9d, eax
  00117	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0011b	41 8b c2	 mov	 eax, r10d
  0011e	4c 23 c0	 and	 r8, rax
  00121	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00125	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  0012a	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0012f	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00132	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00136	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0013b	41 ff c2	 inc	 r10d

; 1552 :                 s->insert--;

  0013e	ff 8b 0c 17 00
	00		 dec	 DWORD PTR [rbx+5900]

; 1553 :                 if (s->lookahead + s->insert < MIN_MATCH)

  00144	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  0014a	8b 93 0c 17 00
	00		 mov	 edx, DWORD PTR [rbx+5900]
  00150	03 ca		 add	 ecx, edx
  00152	83 f9 03	 cmp	 ecx, 3
  00155	72 04		 jb	 SHORT $LN2@fill_windo

; 1542 : #if MIN_MATCH != 3
; 1543 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1544 : #endif
; 1545 :             while (s->insert) {

  00157	85 d2		 test	 edx, edx
  00159	75 95		 jne	 SHORT $LL5@fill_windo
$LN2@fill_windo:

; 1554 :                     break;
; 1555 :             }
; 1556 :         }
; 1557 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1558 :          * but this is not important since only literal bytes will be emitted.
; 1559 :          */
; 1560 : 
; 1561 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  0015b	81 bb 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rbx+156], 262 ; 00000106H
  00165	73 0d		 jae	 SHORT $LN3@fill_windo
  00167	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0016a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0016e	0f 85 ac fe ff
	ff		 jne	 $LL4@fill_windo
$LN3@fill_windo:

; 1562 : 
; 1563 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1564 :      * written, then zero those bytes in order to avoid memory check reports of
; 1565 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1566 :      * the longest match routines.  Update the high water mark for the next
; 1567 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1568 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1569 :      */
; 1570 :     if (s->high_water < s->window_size) {

  00174	8b 8b 18 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5912]
  0017a	8b 73 58	 mov	 esi, DWORD PTR [rbx+88]
  0017d	3b ce		 cmp	 ecx, esi
  0017f	73 73		 jae	 SHORT $LN20@fill_windo

; 1571 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  00181	8b bb 9c 00 00
	00		 mov	 edi, DWORD PTR [rbx+156]
  00187	03 bb 94 00 00
	00		 add	 edi, DWORD PTR [rbx+148]

; 1572 :         ulg init;
; 1573 : 
; 1574 :         if (s->high_water < curr) {

  0018d	3b cf		 cmp	 ecx, edi
  0018f	73 35		 jae	 SHORT $LN17@fill_windo

; 1575 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1576 :              * bytes or up to end of window, whichever is less.
; 1577 :              */
; 1578 :             init = s->window_size - curr;

  00191	2b f7		 sub	 esi, edi

; 1579 :             if (init > WIN_INIT)
; 1580 :                 init = WIN_INIT;
; 1581 :             zmemzero(s->window + curr, (unsigned)init);

  00193	8b cf		 mov	 ecx, edi
  00195	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  0019a	3b f0		 cmp	 esi, eax
  0019c	0f 47 f0	 cmova	 esi, eax
  0019f	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001a3	44 8b c6	 mov	 r8d, esi
  001a6	33 d2		 xor	 edx, edx
  001a8	e8 00 00 00 00	 call	 memset

; 1582 :             s->high_water = curr + init;

  001ad	8d 04 3e	 lea	 eax, DWORD PTR [rsi+rdi]
  001b0	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax

; 1594 :         }
; 1595 :     }
; 1596 : 
; 1597 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1598 :            "not enough room for search");
; 1599 : }

  001b6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001bb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c4	5f		 pop	 rdi
  001c5	c3		 ret	 0
$LN17@fill_windo:

; 1583 :         }
; 1584 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  001c6	8d 87 02 01 00
	00		 lea	 eax, DWORD PTR [rdi+258]
  001cc	3b c8		 cmp	 ecx, eax
  001ce	73 24		 jae	 SHORT $LN20@fill_windo

; 1585 :             /* High water mark at or above current data, but below current data
; 1586 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1587 :              * to end of window, whichever is less.
; 1588 :              */
; 1589 :             init = (ulg)curr + WIN_INIT - s->high_water;

  001d0	2b f9		 sub	 edi, ecx

; 1590 :             if (init > s->window_size - s->high_water)

  001d2	2b f1		 sub	 esi, ecx
  001d4	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  001d9	03 f8		 add	 edi, eax
  001db	3b fe		 cmp	 edi, esi
  001dd	0f 47 fe	 cmova	 edi, esi

; 1591 :                 init = s->window_size - s->high_water;
; 1592 :             zmemzero(s->window + s->high_water, (unsigned)init);

  001e0	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001e4	44 8b c7	 mov	 r8d, edi
  001e7	33 d2		 xor	 edx, edx
  001e9	e8 00 00 00 00	 call	 memset

; 1593 :             s->high_water += init;

  001ee	01 bb 18 17 00
	00		 add	 DWORD PTR [rbx+5912], edi
$LN20@fill_windo:

; 1594 :         }
; 1595 :     }
; 1596 : 
; 1597 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1598 :            "not enough room for search");
; 1599 : }

  001f4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00202	5f		 pop	 rdi
  00203	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_stored
_TEXT	SEGMENT
used$1$ = 80
s$ = 80
flush$ = 88
deflate_stored PROC					; COMDAT

; 1646 : {

  00000	40 53		 push	 rbx
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1647 :     /* Smallest worthy block size when not flushing or finishing. By default
; 1648 :      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
; 1649 :      * large input and output buffers, the stored block size will be larger.
; 1650 :      */
; 1651 :     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
; 1652 : 
; 1653 :     /* Copy as many min_block or larger stored blocks directly to next_out as
; 1654 :      * possible. If flushing, copy the remaining available input to next_out as
; 1655 :      * stored blocks, if there is enough space.
; 1656 :      */
; 1657 :     unsigned len, left, have, last = 0;
; 1658 :     unsigned used = s->strm->avail_in;

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	44 8b fa	 mov	 r15d, edx
  00010	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00015	48 8b d9	 mov	 rbx, rcx
  00018	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0001d	44 8b 69 18	 mov	 r13d, DWORD PTR [rcx+24]
  00021	44 8b 60 08	 mov	 r12d, DWORD PTR [rax+8]
  00025	41 83 c5 fb	 add	 r13d, -5		; fffffffbH
  00029	44 3b 69 44	 cmp	 r13d, DWORD PTR [rcx+68]
  0002d	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00032	44 0f 47 69 44	 cmova	 r13d, DWORD PTR [rcx+68]
  00037	45 33 f6	 xor	 r14d, r14d
  0003a	44 89 64 24 50	 mov	 DWORD PTR used$1$[rsp], r12d
  0003f	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  00045	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0004a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  0004f	90		 npad	 1
$LL4@deflate_st:

; 1659 :     do {
; 1660 :         /* Set len to the maximum size block that we can copy directly with the
; 1661 :          * available input data and output space. Set left to how much of that
; 1662 :          * would be copied from what's left in the window.
; 1663 :          */
; 1664 :         len = MAX_STORED;       /* maximum deflate stored block length */
; 1665 :         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00050	8b 83 14 17 00
	00		 mov	 eax, DWORD PTR [rbx+5908]

; 1666 :         if (s->strm->avail_out < have)          /* need room for header */

  00056	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00059	83 c0 2a	 add	 eax, 42			; 0000002aH
  0005c	c1 f8 03	 sar	 eax, 3
  0005f	8b 4a 18	 mov	 ecx, DWORD PTR [rdx+24]
  00062	3b c8		 cmp	 ecx, eax
  00064	0f 82 27 01 00
	00		 jb	 $LN3@deflate_st

; 1667 :             break;
; 1668 :             /* maximum stored block length that will fit in avail_out: */
; 1669 :         have = s->strm->avail_out - have;
; 1670 :         left = s->strstart - s->block_start;    /* bytes left in window */

  0006a	8b ab 94 00 00
	00		 mov	 ebp, DWORD PTR [rbx+148]
  00070	2b c8		 sub	 ecx, eax
  00072	2b ab 84 00 00
	00		 sub	 ebp, DWORD PTR [rbx+132]

; 1671 :         if (len > (ulg)left + s->strm->avail_in)

  00078	41 8b f4	 mov	 esi, r12d
  0007b	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0007e	03 d5		 add	 edx, ebp
  00080	41 3b d4	 cmp	 edx, r12d
  00083	0f 42 f2	 cmovb	 esi, edx

; 1672 :             len = left + s->strm->avail_in;     /* limit len to the input */
; 1673 :         if (len > have)

  00086	3b f1		 cmp	 esi, ecx
  00088	0f 47 f1	 cmova	 esi, ecx

; 1674 :             len = have;                         /* limit len to the output */
; 1675 : 
; 1676 :         /* If the stored block would be less than min_block in length, or if
; 1677 :          * unable to copy all of the available input when flushing, then try
; 1678 :          * copying to the window and the pending buffer instead. Also don't
; 1679 :          * write an empty block when flushing -- deflate() does that.
; 1680 :          */
; 1681 :         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||

  0008b	41 3b f5	 cmp	 esi, r13d
  0008e	73 1f		 jae	 SHORT $LN8@deflate_st
  00090	85 f6		 test	 esi, esi
  00092	75 0a		 jne	 SHORT $LN10@deflate_st
  00094	41 83 ff 04	 cmp	 r15d, 4
  00098	0f 85 f3 00 00
	00		 jne	 $LN3@deflate_st
$LN10@deflate_st:
  0009e	45 85 ff	 test	 r15d, r15d
  000a1	0f 84 ea 00 00
	00		 je	 $LN3@deflate_st
  000a7	3b f2		 cmp	 esi, edx
  000a9	0f 85 e2 00 00
	00		 jne	 $LN3@deflate_st
$LN8@deflate_st:

; 1682 :                                 flush == Z_NO_FLUSH ||
; 1683 :                                 len != left + s->strm->avail_in))
; 1684 :             break;
; 1685 : 
; 1686 :         /* Make a dummy stored block in pending to get the header bytes,
; 1687 :          * including any pending bits. This also updates the debugging counts.
; 1688 :          */
; 1689 :         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;

  000af	41 83 ff 04	 cmp	 r15d, 4
  000b3	75 0a		 jne	 SHORT $LN33@deflate_st
  000b5	3b f2		 cmp	 esi, edx
  000b7	75 06		 jne	 SHORT $LN33@deflate_st
  000b9	45 8d 77 fd	 lea	 r14d, QWORD PTR [r15-3]
  000bd	eb 03		 jmp	 SHORT $LN34@deflate_st
$LN33@deflate_st:
  000bf	45 33 f6	 xor	 r14d, r14d
$LN34@deflate_st:

; 1690 :         _tr_stored_block(s, (char *)0, 0L, last);

  000c2	45 8b ce	 mov	 r9d, r14d
  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 _tr_stored_block

; 1691 : 
; 1692 :         /* Replace the lengths in the dummy stored block with len. */
; 1693 :         s->pending_buf[s->pending - 4] = len;

  000d2	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 1694 :         s->pending_buf[s->pending - 3] = len >> 8;

  000d5	8b d6		 mov	 edx, esi
  000d7	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000db	83 e9 04	 sub	 ecx, 4
  000de	c1 ea 08	 shr	 edx, 8
  000e1	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  000e5	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000e8	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ec	83 e9 03	 sub	 ecx, 3
  000ef	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1695 :         s->pending_buf[s->pending - 2] = ~len;

  000f2	40 0f b6 d6	 movzx	 edx, sil
  000f6	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000f9	f6 d2		 not	 dl
  000fb	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ff	83 e9 02	 sub	 ecx, 2
  00102	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1696 :         s->pending_buf[s->pending - 1] = ~len >> 8;

  00105	8b d6		 mov	 edx, esi
  00107	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0010a	f7 d2		 not	 edx
  0010c	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00110	ff c9		 dec	 ecx
  00112	c1 ea 08	 shr	 edx, 8
  00115	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1697 : 
; 1698 :         /* Write the stored block header bytes. */
; 1699 :         flush_pending(s->strm);

  00118	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0011b	e8 00 00 00 00	 call	 flush_pending

; 1700 : 
; 1701 : #ifdef ZLIB_DEBUG
; 1702 :         /* Update debugging counts for the data about to be copied. */
; 1703 :         s->compressed_len += len << 3;
; 1704 :         s->bits_sent += len << 3;
; 1705 : #endif
; 1706 : 
; 1707 :         /* Copy uncompressed bytes from the window to next_out. */
; 1708 :         if (left) {

  00120	85 ed		 test	 ebp, ebp
  00122	74 3c		 je	 SHORT $LN11@deflate_st

; 1709 :             if (left > len)
; 1710 :                 left = len;
; 1711 :             zmemcpy(s->strm->next_out, s->window + s->block_start, left);

  00124	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00127	3b ee		 cmp	 ebp, esi
  00129	48 63 93 84 00
	00 00		 movsxd	 rdx, DWORD PTR [rbx+132]
  00130	0f 47 ee	 cmova	 ebp, esi
  00133	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00137	44 8b c5	 mov	 r8d, ebp
  0013a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0013e	8b fd		 mov	 edi, ebp
  00140	e8 00 00 00 00	 call	 memcpy

; 1712 :             s->strm->next_out += left;

  00145	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00148	48 01 78 10	 add	 QWORD PTR [rax+16], rdi

; 1713 :             s->strm->avail_out -= left;

  0014c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0014f	29 68 18	 sub	 DWORD PTR [rax+24], ebp

; 1714 :             s->strm->total_out += left;

  00152	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00155	01 68 1c	 add	 DWORD PTR [rax+28], ebp

; 1715 :             s->block_start += left;

  00158	01 ab 84 00 00
	00		 add	 DWORD PTR [rbx+132], ebp

; 1716 :             len -= left;

  0015e	2b f5		 sub	 esi, ebp
$LN11@deflate_st:

; 1717 :         }
; 1718 : 
; 1719 :         /* Copy uncompressed bytes directly from next_in to next_out, updating
; 1720 :          * the check value.
; 1721 :          */
; 1722 :         if (len) {

  00160	85 f6		 test	 esi, esi
  00162	74 24		 je	 SHORT $LN2@deflate_st

; 1723 :             read_buf(s->strm, s->strm->next_out, len);

  00164	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00167	44 8b c6	 mov	 r8d, esi
  0016a	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0016e	e8 00 00 00 00	 call	 read_buf

; 1724 :             s->strm->next_out += len;

  00173	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00176	8b c6		 mov	 eax, esi
  00178	48 01 41 10	 add	 QWORD PTR [rcx+16], rax

; 1725 :             s->strm->avail_out -= len;

  0017c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0017f	29 70 18	 sub	 DWORD PTR [rax+24], esi

; 1726 :             s->strm->total_out += len;

  00182	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00185	01 70 1c	 add	 DWORD PTR [rax+28], esi
$LN2@deflate_st:

; 1727 :         }
; 1728 :     } while (last == 0);

  00188	45 85 f6	 test	 r14d, r14d
  0018b	0f 84 bf fe ff
	ff		 je	 $LL4@deflate_st
$LN3@deflate_st:

; 1729 : 
; 1730 :     /* Update the sliding window with the last s->w_size bytes of the copied
; 1731 :      * data, or append all of the copied data to the existing window if less
; 1732 :      * than s->w_size bytes were copied. Also update the number of bytes to
; 1733 :      * insert in the hash tables, in the event that deflateParams() switches to
; 1734 :      * a non-zero compression level.
; 1735 :      */
; 1736 :     used -= s->strm->avail_in;      /* number of input bytes directly copied */

  00191	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00194	44 8b 64 24 50	 mov	 r12d, DWORD PTR used$1$[rsp]
  00199	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  0019e	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a3	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001a8	44 2b 60 08	 sub	 r12d, DWORD PTR [rax+8]

; 1737 :     if (used) {

  001ac	0f 84 b4 00 00
	00		 je	 $LN14@deflate_st

; 1738 :         /* If any input was used, then no unused input remains in the window,
; 1739 :          * therefore s->block_start == s->strstart.
; 1740 :          */
; 1741 :         if (used >= s->w_size) {    /* supplant the previous history */

  001b2	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]
  001b5	44 3b e2	 cmp	 r12d, edx
  001b8	72 27		 jb	 SHORT $LN15@deflate_st

; 1742 :             s->matches = 2;         /* clear hash */
; 1743 :             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);

  001ba	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001be	44 8b c2	 mov	 r8d, edx
  001c1	c7 83 08 17 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+5896], 2
  001cb	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001ce	49 2b d0	 sub	 rdx, r8
  001d1	e8 00 00 00 00	 call	 memcpy

; 1744 :             s->strstart = s->w_size;

  001d6	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  001d9	89 83 94 00 00
	00		 mov	 DWORD PTR [rbx+148], eax

; 1745 :         }

  001df	eb 5d		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:

; 1746 :         else {
; 1747 :             if (s->window_size - s->strstart <= used) {

  001e1	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  001e4	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001ea	2b c1		 sub	 eax, ecx
  001ec	41 3b c4	 cmp	 eax, r12d
  001ef	77 2b		 ja	 SHORT $LN18@deflate_st

; 1748 :                 /* Slide the window down. */
; 1749 :                 s->strstart -= s->w_size;

  001f1	2b ca		 sub	 ecx, edx
  001f3	44 8b c1	 mov	 r8d, ecx

; 1750 :                 zmemcpy(s->window, s->window + s->w_size, s->strstart);

  001f6	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001fa	48 03 d1	 add	 rdx, rcx
  001fd	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00204	e8 00 00 00 00	 call	 memcpy

; 1751 :                 if (s->matches < 2)

  00209	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  0020f	83 f8 02	 cmp	 eax, 2
  00212	73 08		 jae	 SHORT $LN18@deflate_st

; 1752 :                     s->matches++;   /* add a pending slide_hash() */

  00214	ff c0		 inc	 eax
  00216	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN18@deflate_st:

; 1753 :             }
; 1754 :             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);

  0021c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0021f	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00225	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  00229	45 8b c4	 mov	 r8d, r12d
  0022c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0022f	49 2b d0	 sub	 rdx, r8
  00232	e8 00 00 00 00	 call	 memcpy

; 1755 :             s->strstart += used;

  00237	44 01 a3 94 00
	00 00		 add	 DWORD PTR [rbx+148], r12d
$LN16@deflate_st:

; 1756 :         }
; 1757 :         s->block_start = s->strstart;
; 1758 :         s->insert += MIN(used, s->w_size - s->insert);

  0023e	8b 8b 0c 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5900]
  00244	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0024a	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00250	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00253	2b c1		 sub	 eax, ecx
  00255	44 3b e0	 cmp	 r12d, eax
  00258	44 0f 47 e0	 cmova	 r12d, eax
  0025c	42 8d 04 21	 lea	 eax, DWORD PTR [rcx+r12]
  00260	89 83 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], eax
$LN14@deflate_st:

; 1759 :     }
; 1760 :     if (s->high_water < s->strstart)

  00266	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0026c	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  00271	39 83 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], eax
  00277	73 06		 jae	 SHORT $LN19@deflate_st

; 1761 :         s->high_water = s->strstart;

  00279	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax
$LN19@deflate_st:

; 1762 : 
; 1763 :     /* If the last block was written to next_out, then done. */
; 1764 :     if (last)

  0027f	45 85 f6	 test	 r14d, r14d
  00282	74 14		 je	 SHORT $LN20@deflate_st

; 1765 :         return finish_done;

  00284	b8 03 00 00 00	 mov	 eax, 3
  00289	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 1815 : }

  0028e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00292	41 5f		 pop	 r15
  00294	41 5e		 pop	 r14
  00296	5b		 pop	 rbx
  00297	c3		 ret	 0
$LN20@deflate_st:
  00298	41 f7 c7 fb ff
	ff ff		 test	 r15d, -5		; fffffffbH
  0029f	74 25		 je	 SHORT $LN21@deflate_st

; 1766 : 
; 1767 :     /* If flushing and all input has been consumed, then done. */
; 1768 :     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
; 1769 :         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)

  002a1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002a4	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  002a8	75 1c		 jne	 SHORT $LN21@deflate_st
  002aa	3b 83 84 00 00
	00		 cmp	 eax, DWORD PTR [rbx+132]
  002b0	75 14		 jne	 SHORT $LN21@deflate_st

; 1770 :         return block_done;

  002b2	b8 01 00 00 00	 mov	 eax, 1
  002b7	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 1815 : }

  002bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002c0	41 5f		 pop	 r15
  002c2	41 5e		 pop	 r14
  002c4	5b		 pop	 rbx
  002c5	c3		 ret	 0
$LN21@deflate_st:

; 1771 : 
; 1772 :     /* Fill the window with any remaining input. */
; 1773 :     have = s->window_size - s->strstart - 1;

  002c6	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  002c9	2b f8		 sub	 edi, eax

; 1774 :     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {

  002cb	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002ce	ff cf		 dec	 edi
  002d0	39 78 08	 cmp	 DWORD PTR [rax+8], edi
  002d3	76 45		 jbe	 SHORT $LN22@deflate_st
  002d5	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  002d8	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  002de	3b c8		 cmp	 ecx, eax
  002e0	7c 38		 jl	 SHORT $LN22@deflate_st

; 1775 :         /* Slide the window down. */
; 1776 :         s->block_start -= s->w_size;
; 1777 :         s->strstart -= s->w_size;

  002e2	29 83 94 00 00
	00		 sub	 DWORD PTR [rbx+148], eax
  002e8	2b c8		 sub	 ecx, eax
  002ea	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002f1	89 8b 84 00 00
	00		 mov	 DWORD PTR [rbx+132], ecx

; 1778 :         zmemcpy(s->window, s->window + s->w_size, s->strstart);

  002f7	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  002fb	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  002ff	e8 00 00 00 00	 call	 memcpy

; 1779 :         if (s->matches < 2)

  00304	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  0030a	83 f8 02	 cmp	 eax, 2
  0030d	73 08		 jae	 SHORT $LN23@deflate_st

; 1780 :             s->matches++;           /* add a pending slide_hash() */

  0030f	ff c0		 inc	 eax
  00311	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN23@deflate_st:

; 1781 :         have += s->w_size;          /* more space now */

  00317	03 7b 44	 add	 edi, DWORD PTR [rbx+68]
$LN22@deflate_st:

; 1782 :     }
; 1783 :     if (have > s->strm->avail_in)

  0031a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0031d	3b 79 08	 cmp	 edi, DWORD PTR [rcx+8]
  00320	0f 47 79 08	 cmova	 edi, DWORD PTR [rcx+8]

; 1784 :         have = s->strm->avail_in;
; 1785 :     if (have) {

  00324	85 ff		 test	 edi, edi
  00326	74 18		 je	 SHORT $LN25@deflate_st

; 1786 :         read_buf(s->strm, s->window + s->strstart, have);

  00328	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  0032e	44 8b c7	 mov	 r8d, edi
  00331	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00335	e8 00 00 00 00	 call	 read_buf

; 1787 :         s->strstart += have;

  0033a	01 bb 94 00 00
	00		 add	 DWORD PTR [rbx+148], edi
$LN25@deflate_st:

; 1788 :     }
; 1789 :     if (s->high_water < s->strstart)

  00340	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00346	39 83 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], eax
  0034c	73 06		 jae	 SHORT $LN26@deflate_st

; 1790 :         s->high_water = s->strstart;

  0034e	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax
$LN26@deflate_st:

; 1791 : 
; 1792 :     /* There was not enough avail_out to write a complete worthy or flushed
; 1793 :      * stored block to next_out. Write a stored block to pending instead, if we
; 1794 :      * have enough input for a worthy block, or if flushing and there is enough
; 1795 :      * room for the remaining input as a stored block in the pending buffer.
; 1796 :      */
; 1797 :     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00354	8b 83 14 17 00
	00		 mov	 eax, DWORD PTR [rbx+5908]

; 1798 :         /* maximum stored block length that will fit in pending: */
; 1799 :     have = MIN(s->pending_buf_size - have, MAX_STORED);

  0035a	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  0035e	83 c0 2a	 add	 eax, 42			; 0000002aH

; 1800 :     min_block = MIN(have, s->w_size);
; 1801 :     left = s->strstart - s->block_start;

  00361	4c 63 8b 84 00
	00 00		 movsxd	 r9, DWORD PTR [rbx+132]
  00368	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  0036e	c1 f8 03	 sar	 eax, 3
  00371	44 2b c0	 sub	 r8d, eax
  00374	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00379	44 3b c0	 cmp	 r8d, eax
  0037c	44 0f 47 c0	 cmova	 r8d, eax
  00380	44 3b 43 44	 cmp	 r8d, DWORD PTR [rbx+68]
  00384	41 8b c8	 mov	 ecx, r8d
  00387	0f 47 4b 44	 cmova	 ecx, DWORD PTR [rbx+68]
  0038b	41 2b d1	 sub	 edx, r9d

; 1802 :     if (left >= min_block ||

  0038e	3b d1		 cmp	 edx, ecx
  00390	73 1d		 jae	 SHORT $LN28@deflate_st
  00392	85 d2		 test	 edx, edx
  00394	75 06		 jne	 SHORT $LN29@deflate_st
  00396	41 83 ff 04	 cmp	 r15d, 4
  0039a	75 5b		 jne	 SHORT $LN27@deflate_st
$LN29@deflate_st:
  0039c	45 85 ff	 test	 r15d, r15d
  0039f	74 56		 je	 SHORT $LN27@deflate_st
  003a1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003a4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003a8	75 4d		 jne	 SHORT $LN27@deflate_st
  003aa	41 3b d0	 cmp	 edx, r8d
  003ad	77 48		 ja	 SHORT $LN27@deflate_st
$LN28@deflate_st:

; 1803 :         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
; 1804 :          s->strm->avail_in == 0 && left <= have)) {
; 1805 :         len = MIN(left, have);

  003af	41 3b d0	 cmp	 edx, r8d
  003b2	8b fa		 mov	 edi, edx
  003b4	41 0f 47 f8	 cmova	 edi, r8d

; 1806 :         last = flush == Z_FINISH && s->strm->avail_in == 0 &&

  003b8	41 83 ff 04	 cmp	 r15d, 4
  003bc	75 13		 jne	 SHORT $LN41@deflate_st
  003be	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003c1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003c5	75 0a		 jne	 SHORT $LN41@deflate_st
  003c7	3b fa		 cmp	 edi, edx
  003c9	75 06		 jne	 SHORT $LN41@deflate_st
  003cb	45 8d 77 fd	 lea	 r14d, QWORD PTR [r15-3]
  003cf	eb 03		 jmp	 SHORT $LN42@deflate_st
$LN41@deflate_st:
  003d1	45 33 f6	 xor	 r14d, r14d
$LN42@deflate_st:

; 1807 :                len == left ? 1 : 0;
; 1808 :         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);

  003d4	49 8b d1	 mov	 rdx, r9
  003d7	44 8b c7	 mov	 r8d, edi
  003da	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003de	45 8b ce	 mov	 r9d, r14d
  003e1	48 8b cb	 mov	 rcx, rbx
  003e4	e8 00 00 00 00	 call	 _tr_stored_block

; 1809 :         s->block_start += len;
; 1810 :         flush_pending(s->strm);

  003e9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003ec	01 bb 84 00 00
	00		 add	 DWORD PTR [rbx+132], edi
  003f2	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate_st:

; 1811 :     }
; 1812 : 
; 1813 :     /* We've done all we can with the available input and output. */
; 1814 :     return last ? finish_started : need_more;

  003f7	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  003fc	41 f7 de	 neg	 r14d
  003ff	1b c0		 sbb	 eax, eax
  00401	83 e0 02	 and	 eax, 2

; 1815 : }

  00404	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00408	41 5f		 pop	 r15
  0040a	41 5e		 pop	 r14
  0040c	5b		 pop	 rbx
  0040d	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_fast
_TEXT	SEGMENT
s$ = 64
flush$ = 72
deflate_fast PROC					; COMDAT

; 1827 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	8b f2		 mov	 esi, edx
  0001a	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  00021	48 8b d9	 mov	 rbx, rcx
  00024	41 bf ff ff 00
	00		 mov	 r15d, 65535		; 0000ffffH
  0002a	33 ff		 xor	 edi, edi
  0002c	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
$LL2@deflate_fa:

; 1828 :     IPos hash_head;       /* head of the hash chain */
; 1829 :     int bflush;           /* set if current block must be flushed */
; 1830 : 
; 1831 :     for (;;) {
; 1832 :         /* Make sure that we always have enough lookahead, except
; 1833 :          * at the end of the input file. We need MAX_MATCH bytes
; 1834 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1835 :          * string following the next match.
; 1836 :          */
; 1837 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00032	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00038	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0003d	73 25		 jae	 SHORT $LN10@deflate_fa

; 1838 :             fill_window(s);

  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 fill_window

; 1839 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00047	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0004d	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00052	73 08		 jae	 SHORT $LN9@deflate_fa
  00054	85 f6		 test	 esi, esi
  00056	0f 84 be 02 00
	00		 je	 $LN39@deflate_fa
$LN9@deflate_fa:

; 1840 :                 return need_more;
; 1841 :             }
; 1842 :             if (s->lookahead == 0) break; /* flush the current block */

  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 d1 02 00
	00		 je	 $LN38@deflate_fa
$LN10@deflate_fa:

; 1843 :         }
; 1844 : 
; 1845 :         /* Insert the string window[strstart .. strstart+2] in the
; 1846 :          * dictionary, and set hash_head to the head of the hash chain:
; 1847 :          */
; 1848 :         hash_head = NIL;
; 1849 :         if (s->lookahead >= MIN_MATCH) {

  00064	83 f8 03	 cmp	 eax, 3
  00067	0f 82 90 00 00
	00		 jb	 $LN12@deflate_fa

; 1850 :             INSERT_STRING(s, s->strstart, hash_head);

  0006d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00071	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00078	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0007c	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  00080	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00085	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00088	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0008e	d3 e0		 shl	 eax, cl
  00090	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00094	44 33 c0	 xor	 r8d, eax
  00097	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0009b	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  0009e	4c 23 c8	 and	 r9, rax
  000a1	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000a5	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000aa	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000af	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000b2	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000b8	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  000bc	48 23 c8	 and	 rcx, rax
  000bf	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000c3	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  000c7	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000cb	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000d2	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax

; 1851 :         }
; 1852 : 
; 1853 :         /* Find the longest match, discarding those <= prev_length.
; 1854 :          * At this point we have always match_length < MIN_MATCH
; 1855 :          */
; 1856 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  000d7	85 d2		 test	 edx, edx
  000d9	74 22		 je	 SHORT $LN12@deflate_fa
  000db	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000e1	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000e4	2b ca		 sub	 ecx, edx
  000e6	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000eb	3b c8		 cmp	 ecx, eax
  000ed	77 0e		 ja	 SHORT $LN12@deflate_fa

; 1857 :             /* To simplify the code, we prevent matches with the string
; 1858 :              * of window index 0 (in particular we have to avoid a match
; 1859 :              * of the string with itself at the start of the input file).
; 1860 :              */
; 1861 :             s->match_length = longest_match (s, hash_head);

  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 longest_match
  000f7	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LN12@deflate_fa:

; 1862 :             /* longest_match() sets match_start */
; 1863 :         }
; 1864 :         if (s->match_length >= MIN_MATCH) {

  000fd	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  00104	0f 82 5f 01 00
	00		 jb	 $LN13@deflate_fa

; 1865 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1866 : 
; 1867 :             _tr_tally_dist(s, s->strstart - s->match_start,

  0010a	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00110	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00117	44 0f b7 83 94
	00 00 00	 movzx	 r8d, WORD PTR [rbx+148]
  0011f	66 44 2b 83 98
	00 00 00	 sub	 r8w, WORD PTR [rbx+152]
  00127	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  0012e	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  00133	80 ea 03	 sub	 dl, 3
  00136	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0013c	66 45 03 c7	 add	 r8w, r15w
  00140	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00147	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0014a	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00150	0f b6 c2	 movzx	 eax, dl
  00153	0f b6 84 28 00
	00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+rbp]
  0015b	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00163	66 45 3b c6	 cmp	 r8w, r14w
  00167	73 06		 jae	 SHORT $LN24@deflate_fa
  00169	41 0f b7 c0	 movzx	 eax, r8w
  0016d	eb 0a		 jmp	 SHORT $LN44@deflate_fa
$LN24@deflate_fa:
  0016f	41 0f b7 c0	 movzx	 eax, r8w
  00173	c1 e8 07	 shr	 eax, 7
  00176	41 03 c6	 add	 eax, r14d
$LN44@deflate_fa:
  00179	0f b6 8c 28 00
	00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+rbp]
  00181	44 8b d7	 mov	 r10d, edi
  00184	0f b6 c1	 movzx	 eax, cl
  00187	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]
  0018f	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00195	ff c8		 dec	 eax
  00197	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1868 :                            s->match_length - MIN_MATCH, bflush);
; 1869 : 
; 1870 :             s->lookahead -= s->match_length;

  0019d	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  001a3	41 0f 94 c2	 sete	 r10b
  001a7	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax

; 1871 : 
; 1872 :             /* Insert new strings in the hash table only if the match length
; 1873 :              * is not too large. This saves time but degrades compression.
; 1874 :              */
; 1875 : #ifndef FASTEST
; 1876 :             if (s->match_length <= s->max_insert_length &&

  001ad	3b 83 a8 00 00
	00		 cmp	 eax, DWORD PTR [rbx+168]
  001b3	77 79		 ja	 SHORT $LN15@deflate_fa
  001b5	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  001bc	72 70		 jb	 SHORT $LN15@deflate_fa

; 1877 :                 s->lookahead >= MIN_MATCH) {
; 1878 :                 s->match_length--; /* string at strstart already in table */

  001be	ff c8		 dec	 eax
  001c0	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LL7@deflate_fa:

; 1879 :                 do {
; 1880 :                     s->strstart++;

  001c6	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1881 :                     INSERT_STRING(s, s->strstart, hash_head);

  001cc	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001d0	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  001d7	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  001db	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  001df	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  001e4	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001e7	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  001ed	d3 e0		 shl	 eax, cl
  001ef	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  001f3	44 33 c0	 xor	 r8d, eax
  001f6	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  001fa	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  001fd	4c 23 c8	 and	 r9, rax
  00200	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  00204	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  00209	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  0020e	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00211	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00215	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  0021c	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1882 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1883 :                      * always MIN_MATCH bytes ahead.
; 1884 :                      */
; 1885 :                 } while (--s->match_length != 0);

  00220	83 83 88 00 00
	00 ff		 add	 DWORD PTR [rbx+136], -1	; ffffffffH
  00227	75 9d		 jne	 SHORT $LL7@deflate_fa

; 1886 :                 s->strstart++;
; 1887 :             } else

  00229	e9 93 00 00 00	 jmp	 $LN45@deflate_fa
$LN15@deflate_fa:

; 1888 : #endif
; 1889 :             {
; 1890 :                 s->strstart += s->match_length;

  0022e	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1891 :                 s->match_length = 0;
; 1892 :                 s->ins_h = s->window[s->strstart];

  00234	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0023a	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]

; 1893 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  0023e	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00244	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  0024a	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  0024f	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  00253	41 d3 e0	 shl	 r8d, cl
  00256	ff c0		 inc	 eax
  00258	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  0025c	44 33 c0	 xor	 r8d, eax
  0025f	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  00263	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d

; 1894 : #if MIN_MATCH != 3
; 1895 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1896 : #endif
; 1897 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1898 :                  * matter since it will be recomputed at next deflate call.
; 1899 :                  */
; 1900 :             }
; 1901 :         } else {

  00267	eb 5e		 jmp	 SHORT $LN14@deflate_fa
$LN13@deflate_fa:

; 1902 :             /* No match, output a literal byte */
; 1903 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1904 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00269	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0026f	44 8b d7	 mov	 r10d, edi
  00272	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00276	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0027a	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00280	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00287	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  0028b	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00291	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00298	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0029b	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  002a1	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  002a9	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  002af	ff c8		 dec	 eax
  002b1	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  002b7	41 0f 94 c2	 sete	 r10b

; 1905 :             s->lookahead--;

  002bb	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
$LN45@deflate_fa:

; 1906 :             s->strstart++;

  002c1	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN14@deflate_fa:
  002c7	45 85 d2	 test	 r10d, r10d

; 1907 :         }
; 1908 :         if (bflush) FLUSH_BLOCK(s, 0);

  002ca	0f 84 62 fd ff
	ff		 je	 $LL2@deflate_fa
  002d0	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002d6	85 c0		 test	 eax, eax
  002d8	78 08		 js	 SHORT $LN26@deflate_fa
  002da	8b d0		 mov	 edx, eax
  002dc	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e0	eb 03		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  002e2	48 8b d7	 mov	 rdx, rdi
$LN27@deflate_fa:
  002e5	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002ec	45 33 c9	 xor	 r9d, r9d
  002ef	44 2b c0	 sub	 r8d, eax
  002f2	48 8b cb	 mov	 rcx, rbx
  002f5	e8 00 00 00 00	 call	 _tr_flush_block
  002fa	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00300	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00303	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00309	e8 00 00 00 00	 call	 flush_pending
  0030e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00311	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00314	0f 85 18 fd ff
	ff		 jne	 $LL2@deflate_fa
$LN39@deflate_fa:
  0031a	33 c0		 xor	 eax, eax
$LN1@deflate_fa:

; 1918 : }

  0031c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00321	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00326	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0032b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0032f	41 5f		 pop	 r15
  00331	41 5e		 pop	 r14
  00333	5f		 pop	 rdi
  00334	c3		 ret	 0
$LN38@deflate_fa:

; 1909 :     }
; 1910 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00335	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0033b	b8 02 00 00 00	 mov	 eax, 2
  00340	3b c8		 cmp	 ecx, eax
  00342	0f 42 c1	 cmovb	 eax, ecx
  00345	89 83 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], eax

; 1911 :     if (flush == Z_FINISH) {

  0034b	83 fe 04	 cmp	 esi, 4
  0034e	75 4b		 jne	 SHORT $LN19@deflate_fa

; 1912 :         FLUSH_BLOCK(s, 1);

  00350	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00356	85 c0		 test	 eax, eax
  00358	78 08		 js	 SHORT $LN30@deflate_fa
  0035a	8b d0		 mov	 edx, eax
  0035c	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00360	eb 03		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  00362	48 8b d7	 mov	 rdx, rdi
$LN31@deflate_fa:
  00365	2b c8		 sub	 ecx, eax
  00367	41 b9 01 00 00
	00		 mov	 r9d, 1
  0036d	44 8b c1	 mov	 r8d, ecx
  00370	48 8b cb	 mov	 rcx, rbx
  00373	e8 00 00 00 00	 call	 _tr_flush_block
  00378	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0037e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00381	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00387	e8 00 00 00 00	 call	 flush_pending
  0038c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0038f	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00392	40 0f 95 c7	 setne	 dil
  00396	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1913 :         return finish_done;

  00399	eb 81		 jmp	 SHORT $LN1@deflate_fa
$LN19@deflate_fa:

; 1914 :     }
; 1915 :     if (s->last_lit)

  0039b	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  003a1	74 44		 je	 SHORT $LN22@deflate_fa

; 1916 :         FLUSH_BLOCK(s, 0);

  003a3	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003a9	85 c0		 test	 eax, eax
  003ab	78 06		 js	 SHORT $LN32@deflate_fa
  003ad	8b f8		 mov	 edi, eax
  003af	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN32@deflate_fa:
  003b3	2b c8		 sub	 ecx, eax
  003b5	45 33 c9	 xor	 r9d, r9d
  003b8	44 8b c1	 mov	 r8d, ecx
  003bb	48 8b d7	 mov	 rdx, rdi
  003be	48 8b cb	 mov	 rcx, rbx
  003c1	e8 00 00 00 00	 call	 _tr_flush_block
  003c6	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003cc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003cf	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003d5	e8 00 00 00 00	 call	 flush_pending
  003da	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003dd	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  003e1	0f 84 33 ff ff
	ff		 je	 $LN39@deflate_fa
$LN22@deflate_fa:

; 1917 :     return block_done;

  003e7	b8 01 00 00 00	 mov	 eax, 1
  003ec	e9 2b ff ff ff	 jmp	 $LN1@deflate_fa
deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_slow
_TEXT	SEGMENT
s$ = 80
flush$ = 88
deflate_slow PROC					; COMDAT

; 1929 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00017	33 ff		 xor	 edi, edi
  00019	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0001e	44 8b fa	 mov	 r15d, edx
  00021	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  00030	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
  00036	44 8d 77 02	 lea	 r14d, QWORD PTR [rdi+2]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@deflate_sl:

; 1930 :     IPos hash_head;          /* head of hash chain */
; 1931 :     int bflush;              /* set if current block must be flushed */
; 1932 : 
; 1933 :     /* Process the input block. */
; 1934 :     for (;;) {
; 1935 :         /* Make sure that we always have enough lookahead, except
; 1936 :          * at the end of the input file. We need MAX_MATCH bytes
; 1937 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1938 :          * string following the next match.
; 1939 :          */
; 1940 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00040	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00046	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004b	73 26		 jae	 SHORT $LN10@deflate_sl

; 1941 :             fill_window(s);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 fill_window

; 1942 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00060	73 09		 jae	 SHORT $LN9@deflate_sl
  00062	45 85 ff	 test	 r15d, r15d
  00065	0f 84 a8 02 00
	00		 je	 $LN48@deflate_sl
$LN9@deflate_sl:

; 1943 :                 return need_more;
; 1944 :             }
; 1945 :             if (s->lookahead == 0) break; /* flush the current block */

  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 90 03 00
	00		 je	 $LN46@deflate_sl
$LN10@deflate_sl:

; 1946 :         }
; 1947 : 
; 1948 :         /* Insert the string window[strstart .. strstart+2] in the
; 1949 :          * dictionary, and set hash_head to the head of the hash chain:
; 1950 :          */
; 1951 :         hash_head = NIL;

  00073	44 8b c7	 mov	 r8d, edi

; 1952 :         if (s->lookahead >= MIN_MATCH) {

  00076	83 f8 03	 cmp	 eax, 3
  00079	72 69		 jb	 SHORT $LN11@deflate_sl

; 1953 :             INSERT_STRING(s, s->strstart, hash_head);

  0007b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0007f	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00086	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0008a	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0008e	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00093	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00096	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0009c	d3 e0		 shl	 eax, cl
  0009e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000a2	44 33 c0	 xor	 r8d, eax
  000a5	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000a9	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000ac	4c 23 c8	 and	 r9, rax
  000af	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000b3	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000b8	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000bd	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000c0	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000c6	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  000c9	48 23 c8	 and	 rcx, rax
  000cc	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d0	44 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+rcx*2]
  000d5	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000d9	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000e0	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN11@deflate_sl:

; 1954 :         }
; 1955 : 
; 1956 :         /* Find the longest match, discarding those <= prev_length.
; 1957 :          */
; 1958 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  000e4	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  000ea	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [rbx+152]
  000f0	89 8b a0 00 00
	00		 mov	 DWORD PTR [rbx+160], ecx
  000f6	89 83 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], eax

; 1959 :         s->match_length = MIN_MATCH-1;

  000fc	44 89 b3 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r14d

; 1960 : 
; 1961 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&

  00103	45 85 c0	 test	 r8d, r8d
  00106	74 5b		 je	 SHORT $LN13@deflate_sl
  00108	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  0010e	73 53		 jae	 SHORT $LN13@deflate_sl
  00110	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00116	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00119	41 2b c8	 sub	 ecx, r8d
  0011c	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00121	3b c8		 cmp	 ecx, eax
  00123	77 3e		 ja	 SHORT $LN13@deflate_sl

; 1962 :             s->strstart - hash_head <= MAX_DIST(s)) {
; 1963 :             /* To simplify the code, we prevent matches with the string
; 1964 :              * of window index 0 (in particular we have to avoid a match
; 1965 :              * of the string with itself at the start of the input file).
; 1966 :              */
; 1967 :             s->match_length = longest_match (s, hash_head);

  00125	41 8b d0	 mov	 edx, r8d
  00128	48 8b cb	 mov	 rcx, rbx
  0012b	e8 00 00 00 00	 call	 longest_match
  00130	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1968 :             /* longest_match() sets match_start */
; 1969 : 
; 1970 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED

  00136	83 f8 05	 cmp	 eax, 5
  00139	77 28		 ja	 SHORT $LN13@deflate_sl
  0013b	83 bb b0 00 00
	00 01		 cmp	 DWORD PTR [rbx+176], 1
  00142	74 18		 je	 SHORT $LN14@deflate_sl
  00144	83 f8 03	 cmp	 eax, 3
  00147	75 1a		 jne	 SHORT $LN13@deflate_sl
  00149	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0014f	2b 83 98 00 00
	00		 sub	 eax, DWORD PTR [rbx+152]
  00155	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0015a	76 07		 jbe	 SHORT $LN13@deflate_sl
$LN14@deflate_sl:

; 1971 : #if TOO_FAR <= 32767
; 1972 :                 || (s->match_length == MIN_MATCH &&
; 1973 :                     s->strstart - s->match_start > TOO_FAR)
; 1974 : #endif
; 1975 :                 )) {
; 1976 : 
; 1977 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1978 :                  * but we will ignore the current match anyway.
; 1979 :                  */
; 1980 :                 s->match_length = MIN_MATCH-1;

  0015c	44 89 b3 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r14d
$LN13@deflate_sl:

; 1981 :             }
; 1982 :         }
; 1983 :         /* If there was a match at the previous step and the current
; 1984 :          * match is not better, output the previous match:
; 1985 :          */
; 1986 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00163	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [rbx+160]
  00169	83 f8 03	 cmp	 eax, 3
  0016c	0f 82 c0 01 00
	00		 jb	 $LN15@deflate_sl
  00172	39 83 88 00 00
	00		 cmp	 DWORD PTR [rbx+136], eax
  00178	0f 87 b4 01 00
	00		 ja	 $LN15@deflate_sl

; 1987 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0017e	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]

; 1988 :             /* Do not insert strings in hash table beyond this. */
; 1989 : 
; 1990 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1991 : 
; 1992 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,

  00184	0f b6 d0	 movzx	 edx, al
  00187	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  0018e	83 c1 fd	 add	 ecx, -3			; fffffffdH
  00191	44 0f b7 83 94
	00 00 00	 movzx	 r8d, WORD PTR [rbx+148]
  00199	44 03 d9	 add	 r11d, ecx
  0019c	66 44 2b 83 8c
	00 00 00	 sub	 r8w, WORD PTR [rbx+140]
  001a4	80 ea 03	 sub	 dl, 3
  001a7	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001ad	66 41 ff c8	 dec	 r8w
  001b1	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001b8	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  001bd	66 44 03 c6	 add	 r8w, si
  001c1	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001c7	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001ce	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001d1	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001d7	0f b6 c2	 movzx	 eax, dl
  001da	42 0f b6 84 20
	00 00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+r12]
  001e3	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  001eb	66 45 3b c5	 cmp	 r8w, r13w
  001ef	73 06		 jae	 SHORT $LN30@deflate_sl
  001f1	41 0f b7 c0	 movzx	 eax, r8w
  001f5	eb 0a		 jmp	 SHORT $LN55@deflate_sl
$LN30@deflate_sl:
  001f7	41 0f b7 c0	 movzx	 eax, r8w
  001fb	c1 e8 07	 shr	 eax, 7
  001fe	41 03 c5	 add	 eax, r13d
$LN55@deflate_sl:
  00201	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r12]
  0020a	0f b6 c1	 movzx	 eax, cl
  0020d	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1993 :                            s->prev_length - MIN_MATCH, bflush);
; 1994 : 
; 1995 :             /* Insert in hash table all strings up to the end of the match.
; 1996 :              * strstart-1 and strstart are already inserted. If there is not
; 1997 :              * enough lookahead, the last two strings are not inserted in
; 1998 :              * the hash table.
; 1999 :              */
; 2000 :             s->lookahead -= s->prev_length-1;

  00215	b8 01 00 00 00	 mov	 eax, 1
  0021a	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+160]
  00220	2b c1		 sub	 eax, ecx
  00222	8b b3 f0 16 00
	00		 mov	 esi, DWORD PTR [rbx+5872]
  00228	8b ab f4 16 00
	00		 mov	 ebp, DWORD PTR [rbx+5876]
  0022e	ff ce		 dec	 esi
  00230	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax

; 2001 :             s->prev_length -= 2;

  00236	8d 41 fe	 lea	 eax, DWORD PTR [rcx-2]
  00239	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
  0023f	90		 npad	 1
$LL7@deflate_sl:

; 2002 :             do {
; 2003 :                 if (++s->strstart <= max_insert) {

  00240	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  00246	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]
  0024d	45 3b d3	 cmp	 r10d, r11d
  00250	77 4e		 ja	 SHORT $LN5@deflate_sl

; 2004 :                     INSERT_STRING(s, s->strstart, hash_head);

  00252	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00256	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  0025a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0025e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00262	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  00267	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0026a	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00270	d3 e0		 shl	 eax, cl
  00272	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00276	44 33 c8	 xor	 r9d, eax
  00279	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0027d	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00281	4d 23 c2	 and	 r8, r10
  00284	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00289	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0028e	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00291	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00295	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  0029c	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN5@deflate_sl:

; 2005 :                 }
; 2006 :             } while (--s->prev_length != 0);

  002a0	83 83 a0 00 00
	00 ff		 add	 DWORD PTR [rbx+160], -1	; ffffffffH
  002a7	75 97		 jne	 SHORT $LL7@deflate_sl

; 2007 :             s->match_available = 0;
; 2008 :             s->match_length = MIN_MATCH-1;
; 2009 :             s->strstart++;

  002a9	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  002af	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002b6	3b ee		 cmp	 ebp, esi

; 2010 : 
; 2011 :             if (bflush) FLUSH_BLOCK(s, 0);

  002b8	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  002bd	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
  002c3	44 89 b3 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r14d
  002ca	0f 85 70 fd ff
	ff		 jne	 $LL2@deflate_sl
  002d0	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002d6	85 c0		 test	 eax, eax
  002d8	78 08		 js	 SHORT $LN32@deflate_sl
  002da	8b d0		 mov	 edx, eax
  002dc	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e0	eb 03		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  002e2	48 8b d7	 mov	 rdx, rdi
$LN33@deflate_sl:
  002e5	44 2b c0	 sub	 r8d, eax
  002e8	45 33 c9	 xor	 r9d, r9d
  002eb	48 8b cb	 mov	 rcx, rbx
  002ee	e8 00 00 00 00	 call	 _tr_flush_block
  002f3	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  002f9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002fc	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00302	e8 00 00 00 00	 call	 flush_pending
  00307	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0030a	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0030d	0f 85 2d fd ff
	ff		 jne	 $LL2@deflate_sl
$LN48@deflate_sl:

; 2022 :             }
; 2023 :             s->strstart++;
; 2024 :             s->lookahead--;
; 2025 :             if (s->strm->avail_out == 0) return need_more;

  00313	33 c0		 xor	 eax, eax
$LN1@deflate_sl:
  00315	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 2049 : }

  0031a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0031f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00324	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00328	41 5f		 pop	 r15
  0032a	41 5e		 pop	 r14
  0032c	41 5d		 pop	 r13
  0032e	41 5c		 pop	 r12
  00330	5f		 pop	 rdi
  00331	c3		 ret	 0
$LN15@deflate_sl:

; 2012 : 
; 2013 :         } else if (s->match_available) {

  00332	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00338	0f 84 aa 00 00
	00		 je	 $LN20@deflate_sl

; 2014 :             /* If there was no match at the previous position, output a
; 2015 :              * single literal. If there was a match but the current match
; 2016 :              * is longer, truncate the previous match to a single literal.
; 2017 :              */
; 2018 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2019 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  0033e	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00344	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00348	ff c9		 dec	 ecx
  0034a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0034e	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00354	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0035b	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  0035f	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00365	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0036c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0036f	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00375	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  0037d	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00383	ff c8		 dec	 eax
  00385	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2020 :             if (bflush) {

  0038b	75 3e		 jne	 SHORT $LN22@deflate_sl

; 2021 :                 FLUSH_BLOCK_ONLY(s, 0);

  0038d	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00393	85 c0		 test	 eax, eax
  00395	78 08		 js	 SHORT $LN34@deflate_sl
  00397	8b d0		 mov	 edx, eax
  00399	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0039d	eb 03		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  0039f	48 8b d7	 mov	 rdx, rdi
$LN35@deflate_sl:
  003a2	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  003a9	45 33 c9	 xor	 r9d, r9d
  003ac	44 2b c0	 sub	 r8d, eax
  003af	48 8b cb	 mov	 rcx, rbx
  003b2	e8 00 00 00 00	 call	 _tr_flush_block
  003b7	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003bd	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003c0	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003c6	e8 00 00 00 00	 call	 flush_pending
$LN22@deflate_sl:

; 2022 :             }
; 2023 :             s->strstart++;
; 2024 :             s->lookahead--;
; 2025 :             if (s->strm->avail_out == 0) return need_more;

  003cb	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ce	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  003d4	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003da	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  003dd	0f 85 5d fc ff
	ff		 jne	 $LL2@deflate_sl

; 2026 :         } else {

  003e3	e9 2b ff ff ff	 jmp	 $LN48@deflate_sl
$LN20@deflate_sl:

; 2027 :             /* There is no previous match to compare with, wait for
; 2028 :              * the next step to decide.
; 2029 :              */
; 2030 :             s->match_available = 1;
; 2031 :             s->strstart++;

  003e8	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 2032 :             s->lookahead--;

  003ee	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003f4	c7 83 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+144], 1

; 2033 :         }
; 2034 :     }

  003fe	e9 3d fc ff ff	 jmp	 $LL2@deflate_sl
$LN46@deflate_sl:

; 2035 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 2036 :     if (s->match_available) {

  00403	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00409	74 45		 je	 SHORT $LN24@deflate_sl

; 2037 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2038 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  0040b	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00411	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00415	ff c9		 dec	 ecx
  00417	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0041b	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00421	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00428	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  0042c	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00432	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00439	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0043c	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00442	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2039 :         s->match_available = 0;

  0044a	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
$LN24@deflate_sl:

; 2040 :     }
; 2041 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00450	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00456	41 3b c6	 cmp	 eax, r14d
  00459	44 0f 42 f0	 cmovb	 r14d, eax
  0045d	44 89 b3 0c 17
	00 00		 mov	 DWORD PTR [rbx+5900], r14d

; 2042 :     if (flush == Z_FINISH) {

  00464	41 83 ff 04	 cmp	 r15d, 4
  00468	75 4e		 jne	 SHORT $LN25@deflate_sl

; 2043 :         FLUSH_BLOCK(s, 1);

  0046a	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  00470	85 c9		 test	 ecx, ecx
  00472	78 08		 js	 SHORT $LN38@deflate_sl
  00474	8b d1		 mov	 edx, ecx
  00476	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0047a	eb 03		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  0047c	48 8b d7	 mov	 rdx, rdi
$LN39@deflate_sl:
  0047f	2b c1		 sub	 eax, ecx
  00481	41 b9 01 00 00
	00		 mov	 r9d, 1
  00487	44 8b c0	 mov	 r8d, eax
  0048a	48 8b cb	 mov	 rcx, rbx
  0048d	e8 00 00 00 00	 call	 _tr_flush_block
  00492	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00498	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0049b	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004a1	e8 00 00 00 00	 call	 flush_pending
  004a6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004a9	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  004ac	40 0f 95 c7	 setne	 dil
  004b0	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2044 :         return finish_done;

  004b3	e9 5d fe ff ff	 jmp	 $LN1@deflate_sl
$LN25@deflate_sl:

; 2045 :     }
; 2046 :     if (s->last_lit)

  004b8	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  004be	74 44		 je	 SHORT $LN28@deflate_sl

; 2047 :         FLUSH_BLOCK(s, 0);

  004c0	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  004c6	85 c9		 test	 ecx, ecx
  004c8	78 06		 js	 SHORT $LN40@deflate_sl
  004ca	8b f9		 mov	 edi, ecx
  004cc	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN40@deflate_sl:
  004d0	2b c1		 sub	 eax, ecx
  004d2	45 33 c9	 xor	 r9d, r9d
  004d5	44 8b c0	 mov	 r8d, eax
  004d8	48 8b d7	 mov	 rdx, rdi
  004db	48 8b cb	 mov	 rcx, rbx
  004de	e8 00 00 00 00	 call	 _tr_flush_block
  004e3	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  004e9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  004ec	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004f2	e8 00 00 00 00	 call	 flush_pending
  004f7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004fa	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  004fe	0f 84 0f fe ff
	ff		 je	 $LN48@deflate_sl
$LN28@deflate_sl:

; 2048 :     return block_done;

  00504	b8 01 00 00 00	 mov	 eax, 1
  00509	e9 07 fe ff ff	 jmp	 $LN1@deflate_sl
deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_rle
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_rle PROC					; COMDAT

; 2060 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	33 ff		 xor	 edi, edi
  0001c	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_length_code
  00023	8b f2		 mov	 esi, edx
  00025	48 8b d9	 mov	 rbx, rcx
  00028	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  0002b	0f 1f 44 00 00	 npad	 5
$LL2@deflate_rl:

; 2061 :     int bflush;             /* set if current block must be flushed */
; 2062 :     uInt prev;              /* byte at distance one to match */
; 2063 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 2064 : 
; 2065 :     for (;;) {
; 2066 :         /* Make sure that we always have enough lookahead, except
; 2067 :          * at the end of the input file. We need MAX_MATCH bytes
; 2068 :          * for the longest run, plus one for the unrolled loop.
; 2069 :          */
; 2070 :         if (s->lookahead <= MAX_MATCH) {

  00030	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  00037	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  0003e	77 29		 ja	 SHORT $LN10@deflate_rl

; 2071 :             fill_window(s);

  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 fill_window

; 2072 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  00048	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  0004f	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  00056	77 08		 ja	 SHORT $LN9@deflate_rl
  00058	85 f6		 test	 esi, esi
  0005a	0f 84 0f 02 00
	00		 je	 $LN37@deflate_rl
$LN9@deflate_rl:

; 2073 :                 return need_more;
; 2074 :             }
; 2075 :             if (s->lookahead == 0) break; /* flush the current block */

  00060	45 85 c0	 test	 r8d, r8d
  00063	0f 84 23 02 00
	00		 je	 $LN36@deflate_rl
$LN10@deflate_rl:

; 2076 :         }
; 2077 : 
; 2078 :         /* See how many times the previous byte repeats */
; 2079 :         s->match_length = 0;

  00069	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi

; 2080 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0006f	41 83 f8 03	 cmp	 r8d, 3
  00073	0f 82 ca 00 00
	00		 jb	 $LN14@deflate_rl
  00079	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 bc 00 00
	00		 je	 $LN14@deflate_rl

; 2081 :             scan = s->window + s->strstart - 1;

  00087	4c 8b 4b 50	 mov	 r9, QWORD PTR [rbx+80]
  0008b	4c 03 c8	 add	 r9, rax

; 2082 :             prev = *scan;

  0008e	41 0f b6 51 ff	 movzx	 edx, BYTE PTR [r9-1]
  00093	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]

; 2083 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00097	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0009b	3b d1		 cmp	 edx, ecx
  0009d	0f 85 a0 00 00
	00		 jne	 $LN14@deflate_rl
  000a3	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000a7	3b d1		 cmp	 edx, ecx
  000a9	0f 85 94 00 00
	00		 jne	 $LN14@deflate_rl
  000af	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  000b3	48 83 c0 03	 add	 rax, 3
  000b7	3b d1		 cmp	 edx, ecx
  000b9	0f 85 84 00 00
	00		 jne	 $LN14@deflate_rl

; 2084 :                 strend = s->window + s->strstart + MAX_MATCH;

  000bf	49 81 c1 02 01
	00 00		 add	 r9, 258			; 00000102H
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@deflate_rl:

; 2085 :                 do {
; 2086 :                 } while (prev == *++scan && prev == *++scan &&
; 2087 :                          prev == *++scan && prev == *++scan &&
; 2088 :                          prev == *++scan && prev == *++scan &&
; 2089 :                          prev == *++scan && prev == *++scan &&

  000d0	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d4	48 ff c0	 inc	 rax
  000d7	3b d1		 cmp	 edx, ecx
  000d9	75 52		 jne	 SHORT $LN13@deflate_rl
  000db	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000df	48 ff c0	 inc	 rax
  000e2	3b d1		 cmp	 edx, ecx
  000e4	75 47		 jne	 SHORT $LN13@deflate_rl
  000e6	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000ea	48 ff c0	 inc	 rax
  000ed	3b d1		 cmp	 edx, ecx
  000ef	75 3c		 jne	 SHORT $LN13@deflate_rl
  000f1	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000f5	48 ff c0	 inc	 rax
  000f8	3b d1		 cmp	 edx, ecx
  000fa	75 31		 jne	 SHORT $LN13@deflate_rl
  000fc	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00100	48 ff c0	 inc	 rax
  00103	3b d1		 cmp	 edx, ecx
  00105	75 26		 jne	 SHORT $LN13@deflate_rl
  00107	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  0010b	48 ff c0	 inc	 rax
  0010e	3b d1		 cmp	 edx, ecx
  00110	75 1b		 jne	 SHORT $LN13@deflate_rl
  00112	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00116	48 ff c0	 inc	 rax
  00119	3b d1		 cmp	 edx, ecx
  0011b	75 10		 jne	 SHORT $LN13@deflate_rl
  0011d	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00121	48 ff c0	 inc	 rax
  00124	3b d1		 cmp	 edx, ecx
  00126	75 05		 jne	 SHORT $LN13@deflate_rl
  00128	49 3b c1	 cmp	 rax, r9
  0012b	72 a3		 jb	 SHORT $LL7@deflate_rl
$LN13@deflate_rl:

; 2090 :                          scan < strend);
; 2091 :                 s->match_length = MAX_MATCH - (uInt)(strend - scan);

  0012d	41 2b c1	 sub	 eax, r9d
  00130	8d 88 02 01 00
	00		 lea	 ecx, DWORD PTR [rax+258]

; 2092 :                 if (s->match_length > s->lookahead)

  00136	41 3b c8	 cmp	 ecx, r8d
  00139	41 0f 47 c8	 cmova	 ecx, r8d
  0013d	89 8b 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ecx
$LN14@deflate_rl:

; 2093 :                     s->match_length = s->lookahead;
; 2094 :             }
; 2095 :             Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
; 2096 :         }
; 2097 : 
; 2098 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 2099 :         if (s->match_length >= MIN_MATCH) {

  00143	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  0014a	72 75		 jb	 SHORT $LN15@deflate_rl

; 2100 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 2101 : 
; 2102 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  0014c	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00152	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  00159	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00160	80 ea 03	 sub	 dl, 3
  00163	66 89 2c 48	 mov	 WORD PTR [rax+rcx*2], bp
  00167	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0016d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00174	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00177	8b cf		 mov	 ecx, edi
  00179	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0017f	0f b6 c2	 movzx	 eax, dl
  00182	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  00187	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  0018f	66 ff 83 b0 09
	00 00		 inc	 WORD PTR [rbx+2480]
  00196	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  0019c	ff c8		 dec	 eax
  0019e	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2103 : 
; 2104 :             s->lookahead -= s->match_length;

  001a4	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  001aa	0f 94 c1	 sete	 cl

; 2105 :             s->strstart += s->match_length;
; 2106 :             s->match_length = 0;

  001ad	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  001b3	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax
  001b9	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 2107 :         } else {

  001bf	eb 5c		 jmp	 SHORT $LN16@deflate_rl
$LN15@deflate_rl:

; 2108 :             /* No match, output a literal byte */
; 2109 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 2110 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001c1	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001c7	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001cb	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001cf	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001d5	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001dc	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  001e0	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001e6	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001ed	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001f0	8b cf		 mov	 ecx, edi
  001f2	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001f8	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  00200	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00206	ff c8		 dec	 eax
  00208	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  0020e	0f 94 c1	 sete	 cl

; 2111 :             s->lookahead--;

  00211	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 2112 :             s->strstart++;

  00217	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN16@deflate_rl:
  0021d	85 c9		 test	 ecx, ecx

; 2113 :         }
; 2114 :         if (bflush) FLUSH_BLOCK(s, 0);

  0021f	0f 84 0b fe ff
	ff		 je	 $LL2@deflate_rl
  00225	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0022b	85 c0		 test	 eax, eax
  0022d	78 08		 js	 SHORT $LN26@deflate_rl
  0022f	8b d0		 mov	 edx, eax
  00231	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00235	eb 03		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  00237	48 8b d7	 mov	 rdx, rdi
$LN27@deflate_rl:
  0023a	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00241	45 33 c9	 xor	 r9d, r9d
  00244	44 2b c0	 sub	 r8d, eax
  00247	48 8b cb	 mov	 rcx, rbx
  0024a	e8 00 00 00 00	 call	 _tr_flush_block
  0024f	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00255	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00258	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0025e	e8 00 00 00 00	 call	 flush_pending
  00263	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00266	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00269	0f 85 c1 fd ff
	ff		 jne	 $LL2@deflate_rl
$LN37@deflate_rl:
  0026f	33 c0		 xor	 eax, eax
$LN1@deflate_rl:

; 2124 : }

  00271	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00276	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0027b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00280	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00285	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00289	41 5e		 pop	 r14
  0028b	c3		 ret	 0
$LN36@deflate_rl:

; 2115 :     }
; 2116 :     s->insert = 0;

  0028c	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 2117 :     if (flush == Z_FINISH) {

  00292	83 fe 04	 cmp	 esi, 4
  00295	75 4d		 jne	 SHORT $LN19@deflate_rl

; 2118 :         FLUSH_BLOCK(s, 1);

  00297	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0029d	85 c0		 test	 eax, eax
  0029f	78 08		 js	 SHORT $LN28@deflate_rl
  002a1	8b d0		 mov	 edx, eax
  002a3	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002a7	eb 03		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  002a9	48 8b d7	 mov	 rdx, rdi
$LN29@deflate_rl:
  002ac	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002b3	44 8b cd	 mov	 r9d, ebp
  002b6	44 2b c0	 sub	 r8d, eax
  002b9	48 8b cb	 mov	 rcx, rbx
  002bc	e8 00 00 00 00	 call	 _tr_flush_block
  002c1	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  002c7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002ca	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  002d0	e8 00 00 00 00	 call	 flush_pending
  002d5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002d8	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  002db	40 0f 95 c7	 setne	 dil
  002df	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2119 :         return finish_done;

  002e2	eb 8d		 jmp	 SHORT $LN1@deflate_rl
$LN19@deflate_rl:

; 2120 :     }
; 2121 :     if (s->last_lit)

  002e4	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  002ea	74 49		 je	 SHORT $LN22@deflate_rl

; 2122 :         FLUSH_BLOCK(s, 0);

  002ec	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002f2	85 c0		 test	 eax, eax
  002f4	78 06		 js	 SHORT $LN30@deflate_rl
  002f6	8b f8		 mov	 edi, eax
  002f8	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN30@deflate_rl:
  002fc	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00303	45 33 c9	 xor	 r9d, r9d
  00306	44 2b c0	 sub	 r8d, eax
  00309	48 8b d7	 mov	 rdx, rdi
  0030c	48 8b cb	 mov	 rcx, rbx
  0030f	e8 00 00 00 00	 call	 _tr_flush_block
  00314	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0031a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0031d	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00323	e8 00 00 00 00	 call	 flush_pending
  00328	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0032b	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0032f	0f 84 3a ff ff
	ff		 je	 $LN37@deflate_rl
$LN22@deflate_rl:

; 2123 :     return block_done;

  00335	8b c5		 mov	 eax, ebp
  00337	e9 35 ff ff ff	 jmp	 $LN1@deflate_rl
deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_huff
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_huff PROC					; COMDAT

; 2133 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	33 ff		 xor	 edi, edi
$LL2@deflate_hu:

; 2134 :     int bflush;             /* set if current block must be flushed */
; 2135 : 
; 2136 :     for (;;) {
; 2137 :         /* Make sure that we have a literal to write. */
; 2138 :         if (s->lookahead == 0) {

  00016	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0001c	75 14		 jne	 SHORT $LN6@deflate_hu

; 2139 :             fill_window(s);

  0001e	48 8b cb	 mov	 rcx, rbx
  00021	e8 00 00 00 00	 call	 fill_window

; 2140 :             if (s->lookahead == 0) {

  00026	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0002c	0f 84 bf 00 00
	00		 je	 $LN23@deflate_hu
$LN6@deflate_hu:

; 2142 :                     return need_more;
; 2143 :                 break;      /* flush the current block */
; 2144 :             }
; 2145 :         }
; 2146 : 
; 2147 :         /* Output a literal byte */
; 2148 :         s->match_length = 0;
; 2149 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 2150 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00032	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00038	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0003c	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00042	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00046	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0004c	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00053	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00057	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0005d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0006d	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2151 :         s->lookahead--;
; 2152 :         s->strstart++;

  00075	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  0007b	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00081	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  00087	ff c8		 dec	 eax
  00089	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00090	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2153 :         if (bflush) FLUSH_BLOCK(s, 0);

  00096	0f 85 7a ff ff
	ff		 jne	 $LL2@deflate_hu
  0009c	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000a2	85 c0		 test	 eax, eax
  000a4	78 08		 js	 SHORT $LN15@deflate_hu
  000a6	8b d0		 mov	 edx, eax
  000a8	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000ac	eb 03		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  000ae	48 8b d7	 mov	 rdx, rdi
$LN16@deflate_hu:
  000b1	44 2b c0	 sub	 r8d, eax
  000b4	45 33 c9	 xor	 r9d, r9d
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 _tr_flush_block
  000bf	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000c5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c8	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  000ce	e8 00 00 00 00	 call	 flush_pending
  000d3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d6	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  000d9	0f 85 37 ff ff
	ff		 jne	 $LL2@deflate_hu
$LN24@deflate_hu:
  000df	33 c0		 xor	 eax, eax

; 2162 :     return block_done;
; 2163 : }

  000e1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
$LN23@deflate_hu:

; 2141 :                 if (flush == Z_NO_FLUSH)

  000f1	85 f6		 test	 esi, esi
  000f3	74 ea		 je	 SHORT $LN24@deflate_hu

; 2154 :     }
; 2155 :     s->insert = 0;

  000f5	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 2156 :     if (flush == Z_FINISH) {

  000fb	83 fe 04	 cmp	 esi, 4
  000fe	75 5e		 jne	 SHORT $LN10@deflate_hu

; 2157 :         FLUSH_BLOCK(s, 1);

  00100	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00106	85 c0		 test	 eax, eax
  00108	78 08		 js	 SHORT $LN17@deflate_hu
  0010a	8b d0		 mov	 edx, eax
  0010c	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00110	eb 03		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  00112	48 8b d7	 mov	 rdx, rdi
$LN18@deflate_hu:
  00115	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0011c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00122	44 2b c0	 sub	 r8d, eax
  00125	48 8b cb	 mov	 rcx, rbx
  00128	e8 00 00 00 00	 call	 _tr_flush_block
  0012d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00133	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00136	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0013c	e8 00 00 00 00	 call	 flush_pending
  00141	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00144	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00147	40 0f 95 c7	 setne	 dil
  0014b	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2162 :     return block_done;
; 2163 : }

  0014e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00153	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00158	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
$LN10@deflate_hu:

; 2158 :         return finish_done;
; 2159 :     }
; 2160 :     if (s->last_lit)

  0015e	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  00164	74 49		 je	 SHORT $LN13@deflate_hu

; 2161 :         FLUSH_BLOCK(s, 0);

  00166	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0016c	85 c0		 test	 eax, eax
  0016e	78 06		 js	 SHORT $LN19@deflate_hu
  00170	8b f8		 mov	 edi, eax
  00172	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN19@deflate_hu:
  00176	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0017d	45 33 c9	 xor	 r9d, r9d
  00180	44 2b c0	 sub	 r8d, eax
  00183	48 8b d7	 mov	 rdx, rdi
  00186	48 8b cb	 mov	 rcx, rbx
  00189	e8 00 00 00 00	 call	 _tr_flush_block
  0018e	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00194	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00197	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0019d	e8 00 00 00 00	 call	 flush_pending
  001a2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a5	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001a9	0f 84 30 ff ff
	ff		 je	 $LN24@deflate_hu
$LN13@deflate_hu:

; 2162 :     return block_done;
; 2163 : }

  001af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c2	5f		 pop	 rdi
  001c3	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
