; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+50
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN7
	DD	imagerel $LN7+53
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN16+48
	DD	imagerel $LN16+92
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN16+92
	DD	imagerel $LN16+151
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN16+151
	DD	imagerel $LN16+173
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN16+173
	DD	imagerel $LN16+544
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN16+544
	DD	imagerel $LN16+556
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN17
	DD	imagerel $LN17+33
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN17+33
	DD	imagerel $LN17+66
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN17+66
	DD	imagerel $LN17+278
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+104
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+194
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$updatewindow DD imagerel updatewindow+78
	DD	imagerel updatewindow+233
	DD	imagerel $chain$0$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$updatewindow DD imagerel updatewindow+233
	DD	imagerel updatewindow+254
	DD	imagerel $chain$1$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN8
	DD	imagerel $LN8+101
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN14
	DD	imagerel $LN14+163
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+76
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN970
	DD	imagerel $LN970+65
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflate DD imagerel $LN970+65
	DD	imagerel $LN970+5542
	DD	imagerel $chain$5$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflate DD imagerel $LN970+5542
	DD	imagerel $LN970+5911
	DD	imagerel $chain$7$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflate DD imagerel $LN970+5911
	DD	imagerel $LN970+6052
	DD	imagerel $chain$8$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN13+63
	DD	imagerel $LN13+167
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN13+167
	DD	imagerel $LN13+219
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN13+219
	DD	imagerel $LN13+235
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflate DD 021H
	DD	imagerel $LN970
	DD	imagerel $LN970+65
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflate DD 0c0021H
	DD	0bf400H
	DD	0ce400H
	DD	0dd400H
	DD	0ec400H
	DD	0f6400H
	DD	0103400H
	DD	imagerel $LN970
	DD	imagerel $LN970+65
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflate DD 0c2521H
	DD	0bf425H
	DD	0ce420H
	DD	0dd417H
	DD	0ec412H
	DD	0f640dH
	DD	0103408H
	DD	imagerel $LN970
	DD	imagerel $LN970+65
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 041701H
	DD	0110117H
	DD	0500a700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 083601H
	DD	077436H
	DD	06642dH
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$updatewindow DD 021H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$updatewindow DD 020521H
	DD	06e405H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+78
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 083b01H
	DD	06343bH
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 061121H
	DD	085411H
	DD	06340cH
	DD	097400H
	DD	imagerel $LN17
	DD	imagerel $LN17+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	097405H
	DD	imagerel $LN17
	DD	imagerel $LN17+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 080021H
	DD	04f400H
	DD	0ae400H
	DD	097400H
	DD	086400H
	DD	imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 021H
	DD	imagerel $LN16+48
	DD	imagerel $LN16+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 020521H
	DD	0ae405H
	DD	imagerel $LN16+48
	DD	imagerel $LN16+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061321H
	DD	04f413H
	DD	09740eH
	DD	086405H
	DD	imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030701H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 146  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 155  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 151  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 155  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 154  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 200  : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 c3 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 b9 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 af 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN4@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 237  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN4@inflateIni:
  0003f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004b	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp

; 209  :     if (strm->zalloc == (alloc_func)0) {

  0004f	48 39 69 30	 cmp	 QWORD PTR [rcx+48], rbp
  00053	75 0f		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 214  :         strm->opaque = (voidpf)0;

  0005c	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00060	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  00064	48 39 69 38	 cmp	 QWORD PTR [rcx+56], rbp
  00068	75 0b		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00071	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00075	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00084	ff 53 30	 call	 QWORD PTR [rbx+48]
  00087	48 8b f8	 mov	 rdi, rax

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0008a	48 85 c0	 test	 rax, rax
  0008d	75 18		 jne	 SHORT $LN7@inflateIni
  0008f	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN11@inflateIni:
  00092	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00097	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 237  : }

  0009c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  000a7	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  000ab	8b d6		 mov	 edx, esi
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	48 89 18	 mov	 QWORD PTR [rax], rbx
  000b3	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000b7	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000be	e8 00 00 00 00	 call	 inflateReset2
  000c3	8b f0		 mov	 esi, eax

; 232  :     if (ret != Z_OK) {

  000c5	85 c0		 test	 eax, eax
  000c7	74 0e		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  000c9	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000cd	48 8b d7	 mov	 rdx, rdi
  000d0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 234  :         strm->state = Z_NULL;

  000d3	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000d7	8b c6		 mov	 eax, esi
  000d9	eb b7		 jmp	 SHORT $LN11@inflateIni
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000db	b8 fa ff ff ff	 mov	 eax, -6

; 237  : }

  000e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e9	5e		 pop	 rsi
  000ea	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
out$1$ = 52
last$ = 56
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 625  : {

$LN970:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 8d 6c 24 b1	 lea	 rbp, QWORD PTR [rsp-79]
  00010	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00017	48 8b f9	 mov	 rdi, rcx

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  0001a	e8 00 00 00 00	 call	 inflateStateCheck
  0001f	85 c0		 test	 eax, eax
  00021	0f 85 f0 16 00
	00		 jne	 $LN333@inflate
  00027	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  0002c	0f 84 e5 16 00
	00		 je	 $LN333@inflate
  00032	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00036	75 09		 jne	 SHORT $LN332@inflate
  00038	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0003b	0f 85 d6 16 00
	00		 jne	 $LN333@inflate
$LN332@inflate:
  00041	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00049	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  0004e	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00053	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  00058	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]
  0005c	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00061	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00066	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  0006e	75 08		 jne	 SHORT $LN4@inflate
  00070	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  00078	44 8b 59 18	 mov	 r11d, DWORD PTR [rcx+24]

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;

  0007c	45 33 e4	 xor	 r12d, r12d

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0007f	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00083	45 8b d3	 mov	 r10d, r11d
  00086	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0008a	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  0008f	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]
  00092	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
  00095	45 8b 7d 48	 mov	 r15d, DWORD PTR [r13+72]
  00099	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  0009d	4c 89 4d 07	 mov	 QWORD PTR put$1$[rbp-57], r9
  000a1	44 89 5d 7f	 mov	 DWORD PTR left$1$[rbp-57], r11d
  000a5	89 75 03	 mov	 DWORD PTR in$1$[rbp-57], esi
  000a8	44 89 5d fb	 mov	 DWORD PTR out$1$[rbp-57], r11d
  000ac	44 89 65 77	 mov	 DWORD PTR ret$1$[rbp-57], r12d
  000b0	83 f8 1e	 cmp	 eax, 30
  000b3	0f 87 54 16 00
	00		 ja	 $LN499@inflate
$LN964@inflate:
  000b9	48 98		 cdqe
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  000c2	49 8d 55 74	 lea	 rdx, QWORD PTR [r13+116]
  000c6	4d 8d 45 70	 lea	 r8, QWORD PTR [r13+112]
  000ca	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN800@inflate[rcx+rax*4]
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000d8	48 03 c8	 add	 rcx, rax
  000db	ff e1		 jmp	 rcx
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000dd	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  000e1	85 d2		 test	 edx, edx
  000e3	75 0d		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000e5	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 660  :                 break;

  000ed	e9 5e 06 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000f2	83 fb 10	 cmp	 ebx, 16
  000f5	73 20		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000f7	85 f6		 test	 esi, esi
  000f9	0f 84 d4 14 00
	00		 je	 $LN919@inflate
  000ff	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00103	8b cb		 mov	 ecx, ebx
  00105	d3 e0		 shl	 eax, cl
  00107	ff ce		 dec	 esi
  00109	44 03 f8	 add	 r15d, eax
  0010c	49 ff c6	 inc	 r14
  0010f	83 c3 08	 add	 ebx, 8
  00112	83 fb 10	 cmp	 ebx, 16
  00115	72 e0		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00117	f6 c2 02	 test	 dl, 2
  0011a	74 56		 je	 SHORT $LN338@inflate
  0011c	41 81 ff 1f 8b
	00 00		 cmp	 r15d, 35615		; 00008b1fH
  00123	75 4d		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  00125	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  0012a	75 08		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  0012c	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  00134	45 33 c0	 xor	 r8d, r8d
  00137	33 d2		 xor	 edx, edx
  00139	33 c9		 xor	 ecx, ecx
  0013b	e8 00 00 00 00	 call	 crc32

; 668  :                 CRC2(state->check, hold);

  00140	41 b8 02 00 00
	00		 mov	 r8d, 2
  00146	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0014a	48 8d 55 f7	 lea	 rdx, QWORD PTR hbuf$[rbp-57]
  0014e	66 c7 45 f7 1f
	8b		 mov	 WORD PTR hbuf$[rbp-57], 35615 ; 00008b1fH
  00154	8b c8		 mov	 ecx, eax
  00156	e8 00 00 00 00	 call	 crc32
  0015b	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 669  :                 INITBITS();

  0015f	45 8b fc	 mov	 r15d, r12d
  00162	41 8b dc	 mov	 ebx, r12d

; 670  :                 state->mode = FLAGS;

  00165	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 671  :                 break;

  0016d	e9 d6 05 00 00	 jmp	 $LN961@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00172	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00176	45 89 65 18	 mov	 DWORD PTR [r13+24], r12d
  0017a	48 85 c0	 test	 rax, rax
  0017d	74 07		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  0017f	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00186	41 f6 45 10 01	 test	 BYTE PTR [r13+16], 1
  0018b	0f 84 ca 00 00
	00		 je	 $LN342@inflate
  00191	41 0f b6 cf	 movzx	 ecx, r15b
  00195	41 8b c7	 mov	 eax, r15d
  00198	c1 e8 08	 shr	 eax, 8
  0019b	c1 e1 08	 shl	 ecx, 8
  0019e	03 c8		 add	 ecx, eax
  001a0	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  001a5	f7 e1		 mul	 ecx
  001a7	8b c1		 mov	 eax, ecx
  001a9	2b c2		 sub	 eax, edx
  001ab	d1 e8		 shr	 eax, 1
  001ad	03 c2		 add	 eax, edx
  001af	c1 e8 04	 shr	 eax, 4
  001b2	6b c0 1f	 imul	 eax, eax, 31
  001b5	3b c8		 cmp	 ecx, eax
  001b7	0f 85 9e 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  001bd	41 8b c7	 mov	 eax, r15d
  001c0	24 0f		 and	 al, 15
  001c2	3c 08		 cmp	 al, 8
  001c4	74 18		 je	 SHORT $LN26@inflate
$LN962@inflate:

; 686  :                 strm->msg = (char *)"unknown compression method";

  001c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  001cd	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 687  :                 state->mode = BAD;

  001d1	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 688  :                 break;

  001d9	e9 72 05 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  001de	41 c1 ef 04	 shr	 r15d, 4
  001e2	83 c3 fc	 add	 ebx, -4			; fffffffcH

; 691  :             len = BITS(4) + 8;

  001e5	41 8b cf	 mov	 ecx, r15d
  001e8	83 e1 0f	 and	 ecx, 15
  001eb	83 c1 08	 add	 ecx, 8

; 692  :             if (state->wbits == 0)

  001ee	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  001f3	75 04		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001f5	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001f9	83 f9 0f	 cmp	 ecx, 15
  001fc	77 45		 ja	 SHORT $LN346@inflate
  001fe	41 3b 4d 30	 cmp	 ecx, DWORD PTR [r13+48]
  00202	77 3f		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  00204	b8 01 00 00 00	 mov	 eax, 1

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00209	45 33 c0	 xor	 r8d, r8d
  0020c	d3 e0		 shl	 eax, cl
  0020e	33 d2		 xor	 edx, edx
  00210	33 c9		 xor	 ecx, ecx
  00212	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  00216	e8 00 00 00 00	 call	 adler32

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  0021b	41 c1 ef 08	 shr	 r15d, 8

; 703  :             INITBITS();

  0021f	41 8b dc	 mov	 ebx, r12d
  00222	41 f7 d7	 not	 r15d
  00225	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00229	41 83 e7 02	 and	 r15d, 2
  0022d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
  00230	41 81 cf 3d 3f
	00 00		 or	 r15d, 16189		; 00003f3dH
  00237	45 89 7d 08	 mov	 DWORD PTR [r13+8], r15d
  0023b	45 8b fc	 mov	 r15d, r12d

; 704  :             break;

  0023e	e9 05 05 00 00	 jmp	 $LN961@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00243	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0024a	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 696  :                 state->mode = BAD;

  0024e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 697  :                 break;

  00256	e9 f5 04 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  0025b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  00262	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 682  :                 state->mode = BAD;

  00266	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 683  :                 break;

  0026e	e9 dd 04 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  00273	83 fb 10	 cmp	 ebx, 16
  00276	73 20		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00278	85 f6		 test	 esi, esi
  0027a	0f 84 4a 13 00
	00		 je	 $LN918@inflate
  00280	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00284	8b cb		 mov	 ecx, ebx
  00286	d3 e0		 shl	 eax, cl
  00288	ff ce		 dec	 esi
  0028a	44 03 f8	 add	 r15d, eax
  0028d	49 ff c6	 inc	 r14
  00290	83 c3 08	 add	 ebx, 8
  00293	83 fb 10	 cmp	 ebx, 16
  00296	72 e0		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  00298	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  0029c	41 80 ff 08	 cmp	 r15b, 8

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  002a0	0f 85 20 ff ff
	ff		 jne	 $LN962@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";
; 711  :                 state->mode = BAD;
; 712  :                 break;
; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  002a6	41 f7 c7 00 e0
	00 00		 test	 r15d, 57344		; 0000e000H
  002ad	74 18		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  002af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  002b6	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  002ba	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  002c2	e9 89 04 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 716  :                 state->mode = BAD;
; 717  :                 break;
; 718  :             }
; 719  :             if (state->head != Z_NULL)

  002c7	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  002cb	48 85 c9	 test	 rcx, rcx
  002ce	74 0b		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  002d0	41 8b c7	 mov	 eax, r15d
  002d3	c1 e8 08	 shr	 eax, 8
  002d6	83 e0 01	 and	 eax, 1
  002d9	89 01		 mov	 DWORD PTR [rcx], eax
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002db	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  002e3	74 2a		 je	 SHORT $LN39@inflate
  002e5	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  002ea	74 23		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002ec	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  002f0	48 8d 55 f7	 lea	 rdx, QWORD PTR hbuf$[rbp-57]
  002f4	44 88 7d f7	 mov	 BYTE PTR hbuf$[rbp-57], r15b
  002f8	41 b8 02 00 00
	00		 mov	 r8d, 2
  002fe	41 c1 ef 08	 shr	 r15d, 8
  00302	44 88 7d f8	 mov	 BYTE PTR hbuf$[rbp-56], r15b
  00306	e8 00 00 00 00	 call	 crc32
  0030b	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 723  :             INITBITS();

  0030f	45 8b fc	 mov	 r15d, r12d

; 724  :             state->mode = TIME;

  00312	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  0031a	41 8b dc	 mov	 ebx, r12d

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0031d	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  0031f	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00322	73 20		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00324	85 f6		 test	 esi, esi
  00326	0f 84 a7 12 00
	00		 je	 $LN919@inflate
  0032c	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00330	8b cb		 mov	 ecx, ebx
  00332	d3 e0		 shl	 eax, cl
  00334	ff ce		 dec	 esi
  00336	44 03 f8	 add	 r15d, eax
  00339	49 ff c6	 inc	 r14
  0033c	83 c3 08	 add	 ebx, 8
  0033f	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00342	72 e0		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00344	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00348	48 85 c0	 test	 rax, rax
  0034b	74 04		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  0034d	44 89 78 04	 mov	 DWORD PTR [rax+4], r15d
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00351	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00359	74 3c		 je	 SHORT $LN53@inflate
  0035b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00360	74 35		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00362	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00366	48 8d 55 f7	 lea	 rdx, QWORD PTR hbuf$[rbp-57]
  0036a	41 8b c7	 mov	 eax, r15d
  0036d	44 88 7d f7	 mov	 BYTE PTR hbuf$[rbp-57], r15b
  00371	c1 e8 08	 shr	 eax, 8
  00374	41 b8 04 00 00
	00		 mov	 r8d, 4
  0037a	88 45 f8	 mov	 BYTE PTR hbuf$[rbp-56], al
  0037d	41 8b c7	 mov	 eax, r15d
  00380	c1 e8 10	 shr	 eax, 16
  00383	41 c1 ef 18	 shr	 r15d, 24
  00387	88 45 f9	 mov	 BYTE PTR hbuf$[rbp-55], al
  0038a	44 88 7d fa	 mov	 BYTE PTR hbuf$[rbp-54], r15b
  0038e	e8 00 00 00 00	 call	 crc32
  00393	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 731  :             INITBITS();

  00397	45 8b fc	 mov	 r15d, r12d

; 732  :             state->mode = OS;

  0039a	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003a2	41 8b dc	 mov	 ebx, r12d

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  003a5	eb 09		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003a7	83 fb 10	 cmp	 ebx, 16
  003aa	73 24		 jae	 SHORT $LN58@inflate
  003ac	0f 1f 40 00	 npad	 4
$LL61@inflate:
  003b0	85 f6		 test	 esi, esi
  003b2	0f 84 1b 12 00
	00		 je	 $LN919@inflate
  003b8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  003bc	8b cb		 mov	 ecx, ebx
  003be	d3 e0		 shl	 eax, cl
  003c0	ff ce		 dec	 esi
  003c2	44 03 f8	 add	 r15d, eax
  003c5	49 ff c6	 inc	 r14
  003c8	83 c3 08	 add	 ebx, 8
  003cb	83 fb 10	 cmp	 ebx, 16
  003ce	72 e0		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  003d0	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  003d4	48 85 c9	 test	 rcx, rcx
  003d7	74 14		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  003d9	41 0f b6 c7	 movzx	 eax, r15b
  003dd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  003e0	41 8b cf	 mov	 ecx, r15d
  003e3	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  003e7	c1 e9 08	 shr	 ecx, 8
  003ea	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003ed	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  003f5	74 2a		 je	 SHORT $LN67@inflate
  003f7	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  003fc	74 23		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003fe	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00402	48 8d 55 f7	 lea	 rdx, QWORD PTR hbuf$[rbp-57]
  00406	44 88 7d f7	 mov	 BYTE PTR hbuf$[rbp-57], r15b
  0040a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00410	41 c1 ef 08	 shr	 r15d, 8
  00414	44 88 7d f8	 mov	 BYTE PTR hbuf$[rbp-56], r15b
  00418	e8 00 00 00 00	 call	 crc32
  0041d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 741  :             INITBITS();

  00421	45 8b fc	 mov	 r15d, r12d

; 742  :             state->mode = EXLEN;

  00424	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  0042c	41 8b dc	 mov	 ebx, r12d
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  0042f	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00437	74 74		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  00439	83 fb 10	 cmp	 ebx, 16
  0043c	73 22		 jae	 SHORT $LN72@inflate
  0043e	66 90		 npad	 2
$LL75@inflate:
  00440	85 f6		 test	 esi, esi
  00442	0f 84 8b 11 00
	00		 je	 $LN919@inflate
  00448	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0044c	8b cb		 mov	 ecx, ebx
  0044e	d3 e0		 shl	 eax, cl
  00450	ff ce		 dec	 esi
  00452	44 03 f8	 add	 r15d, eax
  00455	49 ff c6	 inc	 r14
  00458	83 c3 08	 add	 ebx, 8
  0045b	83 fb 10	 cmp	 ebx, 16
  0045e	72 e0		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00460	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00464	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d
  00468	48 85 c0	 test	 rax, rax
  0046b	74 04		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  0046d	44 89 78 18	 mov	 DWORD PTR [rax+24], r15d
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00471	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00479	74 2a		 je	 SHORT $LN81@inflate
  0047b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00480	74 23		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00482	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00486	48 8d 55 f7	 lea	 rdx, QWORD PTR hbuf$[rbp-57]
  0048a	44 88 7d f7	 mov	 BYTE PTR hbuf$[rbp-57], r15b
  0048e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00494	41 c1 ef 08	 shr	 r15d, 8
  00498	44 88 7d f8	 mov	 BYTE PTR hbuf$[rbp-56], r15b
  0049c	e8 00 00 00 00	 call	 crc32
  004a1	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 751  :                 INITBITS();

  004a5	45 8b fc	 mov	 r15d, r12d
  004a8	41 8b dc	 mov	 ebx, r12d

; 752  :             }

  004ab	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  004ad	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004b1	48 85 c0	 test	 rax, rax
  004b4	74 04		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  004b6	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  004ba	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  004c2	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  004ca	0f 84 80 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  004d0	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]

; 759  :                 if (copy > have) copy = have;

  004d4	3b ce		 cmp	 ecx, esi
  004d6	8b f9		 mov	 edi, ecx
  004d8	0f 47 fe	 cmova	 edi, esi

; 760  :                 if (copy) {

  004db	85 ff		 test	 edi, edi
  004dd	74 66		 je	 SHORT $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  004df	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004e3	48 85 c0	 test	 rax, rax
  004e6	74 2e		 je	 SHORT $LN372@inflate
  004e8	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  004ec	4d 85 c9	 test	 r9, r9
  004ef	74 25		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004f1	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  004f4	2b d1		 sub	 edx, ecx

; 764  :                         zmemcpy(state->head->extra + len, next,

  004f6	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004f9	8d 04 17	 lea	 eax, DWORD PTR [rdi+rdx]
  004fc	3b c1		 cmp	 eax, ecx
  004fe	76 04		 jbe	 SHORT $LN509@inflate
  00500	2b ca		 sub	 ecx, edx
  00502	eb 02		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  00504	8b cf		 mov	 ecx, edi
$LN510@inflate:
  00506	44 8b c1	 mov	 r8d, ecx
  00509	8b ca		 mov	 ecx, edx
  0050b	49 8b d6	 mov	 rdx, r14
  0050e	49 03 c9	 add	 rcx, r9
  00511	e8 00 00 00 00	 call	 memcpy
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00516	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0051e	74 1a		 je	 SHORT $LN373@inflate
  00520	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00525	74 13		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00527	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0052b	44 8b c7	 mov	 r8d, edi
  0052e	49 8b d6	 mov	 rdx, r14
  00531	e8 00 00 00 00	 call	 crc32
  00536	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 770  :                     have -= copy;
; 771  :                     next += copy;

  0053a	8b c7		 mov	 eax, edi
  0053c	2b f7		 sub	 esi, edi
  0053e	4c 03 f0	 add	 r14, rax

; 772  :                     state->length -= copy;

  00541	41 29 7d 50	 sub	 DWORD PTR [r13+80], edi
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00545	41 83 7d 50 00	 cmp	 DWORD PTR [r13+80], 0
  0054a	0f 85 83 10 00
	00		 jne	 $LN919@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00550	45 89 65 50	 mov	 DWORD PTR [r13+80], r12d

; 777  :             state->mode = NAME;

  00554	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  0055c	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  00564	0f 84 84 00 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  0056a	85 f6		 test	 esi, esi
  0056c	0f 84 61 10 00
	00		 je	 $LN919@inflate

; 781  :                 copy = 0;

  00572	41 8b fc	 mov	 edi, r12d
  00575	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00580	8b c7		 mov	 eax, edi
  00582	ff c7		 inc	 edi
  00584	46 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+r14]

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  00589	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0058d	48 85 c0	 test	 rax, rax
  00590	74 1a		 je	 SHORT $LN86@inflate
  00592	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00596	48 85 d2	 test	 rdx, rdx
  00599	74 11		 je	 SHORT $LN86@inflate
  0059b	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  0059f	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005a2	73 08		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  005a4	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  005a8	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  005ac	45 85 e4	 test	 r12d, r12d
  005af	74 04		 je	 SHORT $LN380@inflate
  005b1	3b fe		 cmp	 edi, esi
  005b3	72 cb		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005b5	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005bd	74 1a		 je	 SHORT $LN381@inflate
  005bf	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005c4	74 13		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  005c6	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005ca	44 8b c7	 mov	 r8d, edi
  005cd	49 8b d6	 mov	 rdx, r14
  005d0	e8 00 00 00 00	 call	 crc32
  005d5	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 791  :                 have -= copy;
; 792  :                 next += copy;

  005d9	8b c7		 mov	 eax, edi
  005db	2b f7		 sub	 esi, edi
  005dd	4c 03 f0	 add	 r14, rax

; 793  :                 if (len) goto inf_leave;

  005e0	45 85 e4	 test	 r12d, r12d
  005e3	0f 85 ea 0f 00
	00		 jne	 $LN919@inflate

; 794  :             }

  005e9	45 33 e4	 xor	 r12d, r12d
  005ec	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  005ee	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  005f2	48 85 c0	 test	 rax, rax
  005f5	74 04		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  005f7	4c 89 60 20	 mov	 QWORD PTR [rax+32], r12
$LN383@inflate:

; 797  :             state->length = 0;

  005fb	45 89 65 50	 mov	 DWORD PTR [r13+80], r12d

; 798  :             state->mode = COMMENT;

  005ff	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00607	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  0060f	74 7d		 je	 SHORT $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00611	85 f6		 test	 esi, esi
  00613	0f 84 ba 0f 00
	00		 je	 $LN919@inflate

; 802  :                 copy = 0;

  00619	41 8b fc	 mov	 edi, r12d
  0061c	0f 1f 40 00	 npad	 4
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00620	8b c7		 mov	 eax, edi
  00622	ff c7		 inc	 edi
  00624	46 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+r14]

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  00629	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0062d	48 85 c0	 test	 rax, rax
  00630	74 1a		 je	 SHORT $LN89@inflate
  00632	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00636	48 85 d2	 test	 rdx, rdx
  00639	74 11		 je	 SHORT $LN89@inflate
  0063b	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  0063f	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00642	73 08		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00644	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  00648	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  0064c	45 85 e4	 test	 r12d, r12d
  0064f	74 04		 je	 SHORT $LN389@inflate
  00651	3b fe		 cmp	 edi, esi
  00653	72 cb		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00655	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0065d	74 1a		 je	 SHORT $LN390@inflate
  0065f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00664	74 13		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00666	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0066a	44 8b c7	 mov	 r8d, edi
  0066d	49 8b d6	 mov	 rdx, r14
  00670	e8 00 00 00 00	 call	 crc32
  00675	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 812  :                 have -= copy;
; 813  :                 next += copy;

  00679	8b c7		 mov	 eax, edi
  0067b	2b f7		 sub	 esi, edi
  0067d	4c 03 f0	 add	 r14, rax

; 814  :                 if (len) goto inf_leave;

  00680	45 85 e4	 test	 r12d, r12d
  00683	0f 85 4a 0f 00
	00		 jne	 $LN919@inflate

; 815  :             }

  00689	45 33 e4	 xor	 r12d, r12d
  0068c	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  0068e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00692	48 85 c0	 test	 rax, rax
  00695	74 04		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  00697	4c 89 60 30	 mov	 QWORD PTR [rax+48], r12
$LN392@inflate:
  0069b	48 8b 7d 67	 mov	 rdi, QWORD PTR strm$[rbp-57]
  0069f	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  006a3	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]

; 818  :             state->mode = HCRC;

  006a7	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  006af	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  006b7	74 53		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  006b9	83 fb 10	 cmp	 ebx, 16
  006bc	73 22		 jae	 SHORT $LN92@inflate
  006be	66 90		 npad	 2
$LL95@inflate:
  006c0	85 f6		 test	 esi, esi
  006c2	0f 84 0b 0f 00
	00		 je	 $LN919@inflate
  006c8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  006cc	8b cb		 mov	 ecx, ebx
  006ce	d3 e0		 shl	 eax, cl
  006d0	ff ce		 dec	 esi
  006d2	44 03 f8	 add	 r15d, eax
  006d5	49 ff c6	 inc	 r14
  006d8	83 c3 08	 add	 ebx, 8
  006db	83 fb 10	 cmp	 ebx, 16
  006de	72 e0		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  006e0	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  006e5	74 1f		 je	 SHORT $LN102@inflate
  006e7	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  006ec	44 3b f8	 cmp	 r15d, eax
  006ef	74 15		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  006f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  006f8	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  006fc	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00704	eb 4a		 jmp	 SHORT $LN8@inflate
$LN102@inflate:

; 824  :                     state->mode = BAD;
; 825  :                     break;
; 826  :                 }
; 827  :                 INITBITS();

  00706	45 8b fc	 mov	 r15d, r12d
  00709	41 8b dc	 mov	 ebx, r12d
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  0070c	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  00710	48 85 c9	 test	 rcx, rcx
  00713	74 18		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00715	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
  00719	c1 f8 09	 sar	 eax, 9
  0071c	83 e0 01	 and	 eax, 1
  0071f	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 831  :                 state->head->done = 1;

  00722	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00726	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0072d	45 33 c0	 xor	 r8d, r8d
  00730	33 d2		 xor	 edx, edx
  00732	33 c9		 xor	 ecx, ecx
  00734	e8 00 00 00 00	 call	 crc32
  00739	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0073d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN968@inflate:

; 1083 :                 state->mode = TYPE;

  00740	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN961@inflate:

; 704  :             break;

  00748	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
$LN885@inflate:
  0074c	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
$LN8@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00750	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00754	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00759	83 f8 1e	 cmp	 eax, 30
  0075c	0f 87 ab 0f 00
	00		 ja	 $LN499@inflate
  00762	44 8b 55 fb	 mov	 r10d, DWORD PTR out$1$[rbp-57]
  00766	45 33 e4	 xor	 r12d, r12d
  00769	e9 4b f9 ff ff	 jmp	 $LN964@inflate
$LN105@inflate:

; 834  :             state->mode = TYPE;
; 835  :             break;
; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  0076e	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00771	73 20		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  00773	85 f6		 test	 esi, esi
  00775	0f 84 58 0e 00
	00		 je	 $LN919@inflate
  0077b	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0077f	8b cb		 mov	 ecx, ebx
  00781	d3 e0		 shl	 eax, cl
  00783	ff ce		 dec	 esi
  00785	44 03 f8	 add	 r15d, eax
  00788	49 ff c6	 inc	 r14
  0078b	83 c3 08	 add	 ebx, 8
  0078e	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00791	72 e0		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00793	41 8b cf	 mov	 ecx, r15d
  00796	41 8b c7	 mov	 eax, r15d
  00799	c1 e0 10	 shl	 eax, 16
  0079c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007a2	03 c8		 add	 ecx, eax

; 840  :             INITBITS();

  007a4	41 8b dc	 mov	 ebx, r12d
  007a7	41 8b c7	 mov	 eax, r15d
  007aa	c1 e1 08	 shl	 ecx, 8
  007ad	c1 e8 08	 shr	 eax, 8
  007b0	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007b5	41 c1 ef 18	 shr	 r15d, 24
  007b9	03 c1		 add	 eax, ecx
  007bb	41 03 c7	 add	 eax, r15d
  007be	45 8b fc	 mov	 r15d, r12d
  007c1	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  007c5	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 841  :             state->mode = DICT;

  007c8	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  007d0	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  007d5	0f 84 85 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007db	45 33 c0	 xor	 r8d, r8d
  007de	33 d2		 xor	 edx, edx
  007e0	33 c9		 xor	 ecx, ecx
  007e2	e8 00 00 00 00	 call	 adler32
  007e7	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  007eb	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
  007ef	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  007f3	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 848  :             state->mode = TYPE;

  007f6	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:
  007fe	8b 45 6f	 mov	 eax, DWORD PTR flush$[rbp-57]
  00801	83 c0 fb	 add	 eax, -5			; fffffffbH
  00804	83 f8 01	 cmp	 eax, 1
  00807	0f 86 c6 0d 00
	00		 jbe	 $LN919@inflate
$LN403@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  0080d	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00812	74 17		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  00814	8b cb		 mov	 ecx, ebx

; 854  :                 state->mode = CHECK;

  00816	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  0081e	83 e1 07	 and	 ecx, 7
  00821	41 d3 ef	 shr	 r15d, cl
  00824	2b d9		 sub	 ebx, ecx

; 855  :                 break;

  00826	e9 25 ff ff ff	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  0082b	83 fb 03	 cmp	 ebx, 3
  0082e	73 20		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00830	85 f6		 test	 esi, esi
  00832	0f 84 9b 0d 00
	00		 je	 $LN919@inflate
  00838	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0083c	8b cb		 mov	 ecx, ebx
  0083e	d3 e0		 shl	 eax, cl
  00840	ff ce		 dec	 esi
  00842	44 03 f8	 add	 r15d, eax
  00845	49 ff c6	 inc	 r14
  00848	83 c3 08	 add	 ebx, 8
  0084b	83 fb 03	 cmp	 ebx, 3
  0084e	72 e0		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 858  :             state->last = BITS(1);

  00850	41 8b c7	 mov	 eax, r15d

; 859  :             DROPBITS(1);

  00853	ff cb		 dec	 ebx
  00855	83 e0 01	 and	 eax, 1
  00858	41 d1 ef	 shr	 r15d, 1
  0085b	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 860  :             switch (BITS(2)) {

  0085f	41 8b c7	 mov	 eax, r15d
  00862	83 e0 03	 and	 eax, 3
  00865	74 66		 je	 SHORT $LN408@inflate
  00867	83 e8 01	 sub	 eax, 1
  0086a	74 3d		 je	 SHORT $LN409@inflate
  0086c	83 e8 01	 sub	 eax, 1
  0086f	74 24		 je	 SHORT $LN411@inflate
  00871	83 f8 01	 cmp	 eax, 1
  00874	75 5f		 jne	 SHORT $LN138@inflate

; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  00876	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  0087d	41 c1 ef 02	 shr	 r15d, 2
  00881	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00885	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00888	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 886  :             break;

  00890	e9 bb fe ff ff	 jmp	 $LN8@inflate
$LN411@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  00895	41 c1 ef 02	 shr	 r15d, 2
  00899	83 c3 fe	 add	 ebx, -2			; fffffffeH
  0089c	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 886  :             break;

  008a4	e9 a7 fe ff ff	 jmp	 $LN8@inflate
$LN409@inflate:

; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008a9	49 8b cd	 mov	 rcx, r13
  008ac	e8 00 00 00 00	 call	 fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  008b1	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
  008b4	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  008bc	83 f9 06	 cmp	 ecx, 6
  008bf	75 14		 jne	 SHORT $LN138@inflate

; 872  :                     DROPBITS(2);

  008c1	41 c1 ef 02	 shr	 r15d, 2
  008c5	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 873  :                     goto inf_leave;

  008c8	e9 09 0d 00 00	 jmp	 $LN965@inflate
$LN408@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  008cd	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  008d5	41 c1 ef 02	 shr	 r15d, 2
  008d9	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 886  :             break;

  008dc	e9 6f fe ff ff	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  008e1	8b cb		 mov	 ecx, ebx
  008e3	83 e1 07	 and	 ecx, 7
  008e6	41 d3 ef	 shr	 r15d, cl
  008e9	2b d9		 sub	 ebx, ecx

; 889  :             NEEDBITS(32);

  008eb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  008ee	73 20		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  008f0	85 f6		 test	 esi, esi
  008f2	0f 84 db 0c 00
	00		 je	 $LN919@inflate
  008f8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  008fc	8b cb		 mov	 ecx, ebx
  008fe	d3 e0		 shl	 eax, cl
  00900	ff ce		 dec	 esi
  00902	44 03 f8	 add	 r15d, eax
  00905	49 ff c6	 inc	 r14
  00908	83 c3 08	 add	 ebx, 8
  0090b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0090e	72 e0		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00910	41 8b c7	 mov	 eax, r15d
  00913	41 0f b7 cf	 movzx	 ecx, r15w
  00917	f7 d0		 not	 eax
  00919	c1 e8 10	 shr	 eax, 16
  0091c	3b c8		 cmp	 ecx, eax
  0091e	74 18		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00920	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00927	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  0092b	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00933	e9 18 fe ff ff	 jmp	 $LN8@inflate
$LN415@inflate:

; 892  :                 state->mode = BAD;
; 893  :                 break;
; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  00938	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  0093c	45 8b fc	 mov	 r15d, r12d

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  0093f	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
  00942	41 8b dc	 mov	 ebx, r12d
  00945	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  0094d	83 f9 06	 cmp	 ecx, 6
  00950	0f 84 80 0c 00
	00		 je	 $LN965@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00956	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  0095e	45 8b 65 50	 mov	 r12d, DWORD PTR [r13+80]

; 905  :             if (copy) {

  00962	45 85 e4	 test	 r12d, r12d
  00965	74 51		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  00967	44 3b e6	 cmp	 r12d, esi
  0096a	44 0f 47 e6	 cmova	 r12d, esi

; 907  :                 if (copy > left) copy = left;

  0096e	45 3b e3	 cmp	 r12d, r11d
  00971	45 0f 47 e3	 cmova	 r12d, r11d

; 908  :                 if (copy == 0) goto inf_leave;

  00975	45 85 e4	 test	 r12d, r12d
  00978	0f 84 55 0c 00
	00		 je	 $LN919@inflate

; 909  :                 zmemcpy(put, next, copy);

  0097e	45 8b c4	 mov	 r8d, r12d
  00981	49 8b d6	 mov	 rdx, r14
  00984	49 8b c9	 mov	 rcx, r9
  00987	41 8b fc	 mov	 edi, r12d
  0098a	e8 00 00 00 00	 call	 memcpy

; 910  :                 have -= copy;
; 911  :                 next += copy;
; 912  :                 left -= copy;

  0098f	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
  00993	4c 03 f7	 add	 r14, rdi

; 913  :                 put += copy;

  00996	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  0099a	45 2b dc	 sub	 r11d, r12d
  0099d	4c 03 cf	 add	 r9, rdi
  009a0	44 89 5d 7f	 mov	 DWORD PTR left$1$[rbp-57], r11d

; 914  :                 state->length -= copy;
; 915  :                 break;

  009a4	48 8b 7d 67	 mov	 rdi, QWORD PTR strm$[rbp-57]
  009a8	41 2b f4	 sub	 esi, r12d
  009ab	45 29 65 50	 sub	 DWORD PTR [r13+80], r12d
  009af	4c 89 4d 07	 mov	 QWORD PTR put$1$[rbp-57], r9
  009b3	e9 98 fd ff ff	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  009b8	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 919  :             break;

  009c0	e9 8b fd ff ff	 jmp	 $LN8@inflate
$LN155@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  009c5	83 fb 0e	 cmp	 ebx, 14
  009c8	73 26		 jae	 SHORT $LN153@inflate
  009ca	66 0f 1f 44 00
	00		 npad	 6
$LL156@inflate:
  009d0	85 f6		 test	 esi, esi
  009d2	0f 84 fb 0b 00
	00		 je	 $LN919@inflate
  009d8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  009dc	8b cb		 mov	 ecx, ebx
  009de	d3 e0		 shl	 eax, cl
  009e0	ff ce		 dec	 esi
  009e2	44 03 f8	 add	 r15d, eax
  009e5	49 ff c6	 inc	 r14
  009e8	83 c3 08	 add	 ebx, 8
  009eb	83 fb 0e	 cmp	 ebx, 14
  009ee	72 e0		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  009f0	41 8b cf	 mov	 ecx, r15d

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  009f3	83 c3 f2	 add	 ebx, -14		; fffffff2H
  009f6	41 c1 ef 05	 shr	 r15d, 5
  009fa	83 e1 1f	 and	 ecx, 31
  009fd	41 8b d7	 mov	 edx, r15d
  00a00	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a06	41 c1 ef 05	 shr	 r15d, 5
  00a0a	83 e2 1f	 and	 edx, 31
  00a0d	41 8b c7	 mov	 eax, r15d
  00a10	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00a14	83 e0 0f	 and	 eax, 15
  00a17	41 c1 ef 04	 shr	 r15d, 4
  00a1b	83 c0 04	 add	 eax, 4
  00a1e	ff c2		 inc	 edx
  00a20	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00a27	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00a2b	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a31	0f 87 24 01 00
	00		 ja	 $LN426@inflate
  00a37	83 fa 1e	 cmp	 edx, 30
  00a3a	0f 87 1b 01 00
	00		 ja	 $LN426@inflate

; 931  :                 state->mode = BAD;
; 932  :                 break;
; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00a40	45 89 a5 84 00
	00 00		 mov	 DWORD PTR [r13+132], r12d

; 937  :             state->mode = LENLENS;

  00a47	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00a4f	41 8b 45 78	 mov	 eax, DWORD PTR [r13+120]
  00a53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00a5a	41 39 85 84 00
	00 00		 cmp	 DWORD PTR [r13+132], eax
  00a61	73 60		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00a63	83 fb 03	 cmp	 ebx, 3
  00a66	73 20		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00a68	85 f6		 test	 esi, esi
  00a6a	0f 84 63 0b 00
	00		 je	 $LN919@inflate
  00a70	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00a74	8b cb		 mov	 ecx, ebx
  00a76	d3 e0		 shl	 eax, cl
  00a78	ff ce		 dec	 esi
  00a7a	44 03 f8	 add	 r15d, eax
  00a7d	49 ff c6	 inc	 r14
  00a80	83 c3 08	 add	 ebx, 8
  00a83	83 fb 03	 cmp	 ebx, 3
  00a86	72 e0		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a88	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00a8f	41 0f b7 cf	 movzx	 ecx, r15w
  00a93	66 83 e1 07	 and	 cx, 7

; 942  :                 DROPBITS(3);

  00a97	41 c1 ef 03	 shr	 r15d, 3
  00a9b	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00a9e	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00aa6	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00aaf	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00ab6	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00abd	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00ac1	72 a0		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00ac3	41 83 bd 84 00
	00 00 13	 cmp	 DWORD PTR [r13+132], 19
  00acb	73 2c		 jae	 SHORT $LN184@inflate
  00acd	0f 1f 00	 npad	 3
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00ad0	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00ad7	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00adf	66 45 89 a4 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r12w
  00ae8	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00aef	41 83 bd 84 00
	00 00 13	 cmp	 DWORD PTR [r13+132], 19
  00af7	72 d7		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  00af9	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00b00	41 c7 00 07 00
	00 00		 mov	 DWORD PTR [r8], 7
  00b07	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00b0e	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00b12	49 89 01	 mov	 QWORD PTR [r9], rax

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b15	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00b1c	33 c9		 xor	 ecx, ecx
  00b1e	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00b25	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b2a	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00b2f	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00b33	e8 00 00 00 00	 call	 inflate_table

; 954  :                 break;

  00b38	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
  00b3c	89 45 77	 mov	 DWORD PTR ret$1$[rbp-57], eax
  00b3f	85 c0		 test	 eax, eax
  00b41	74 30		 je	 SHORT $LN429@inflate

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {
; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00b43	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  00b4a	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 953  :                 state->mode = BAD;

  00b4e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 954  :                 break;

  00b56	e9 f1 fb ff ff	 jmp	 $LN885@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00b5b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b62	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00b66	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00b6e	e9 dd fb ff ff	 jmp	 $LN8@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00b73	45 89 a5 84 00
	00 00		 mov	 DWORD PTR [r13+132], r12d
  00b7a	4d 8d 45 70	 lea	 r8, QWORD PTR [r13+112]

; 958  :             state->mode = CODELENS;

  00b7e	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00b86	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00b8d	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00b91	41 39 85 84 00
	00 00		 cmp	 DWORD PTR [r13+132], eax
  00b98	0f 83 0c 02 00
	00		 jae	 $LN186@inflate
  00b9e	66 90		 npad	 2
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00ba0	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00ba3	b8 01 00 00 00	 mov	 eax, 1
  00ba8	d3 e0		 shl	 eax, cl
  00baa	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bad	41 8b c7	 mov	 eax, r15d
  00bb0	48 23 c8	 and	 rcx, rax
  00bb3	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  00bb7	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00bba	8b c8		 mov	 ecx, eax
  00bbc	c1 e9 08	 shr	 ecx, 8
  00bbf	0f b6 c9	 movzx	 ecx, cl
  00bc2	89 45 ff	 mov	 DWORD PTR here$[rbp-57], eax
  00bc5	3b cb		 cmp	 ecx, ebx
  00bc7	76 4b		 jbe	 SHORT $LN562@inflate
  00bc9	0f 1f 80 00 00
	00 00		 npad	 7
$LL187@inflate:

; 964  :                     PULLBYTE();

  00bd0	85 f6		 test	 esi, esi
  00bd2	0f 84 fb 09 00
	00		 je	 $LN919@inflate
  00bd8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00bdc	8b cb		 mov	 ecx, ebx
  00bde	d3 e0		 shl	 eax, cl
  00be0	ff ce		 dec	 esi
  00be2	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00be5	44 03 f8	 add	 r15d, eax
  00be8	b8 01 00 00 00	 mov	 eax, 1
  00bed	49 ff c6	 inc	 r14
  00bf0	d3 e0		 shl	 eax, cl
  00bf2	83 c3 08	 add	 ebx, 8
  00bf5	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bf8	41 8b c7	 mov	 eax, r15d
  00bfb	48 23 c8	 and	 rcx, rax
  00bfe	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  00c02	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00c05	8b c8		 mov	 ecx, eax
  00c07	c1 e9 08	 shr	 ecx, 8
  00c0a	0f b6 c9	 movzx	 ecx, cl
  00c0d	89 45 ff	 mov	 DWORD PTR here$[rbp-57], eax
  00c10	3b cb		 cmp	 ecx, ebx
  00c12	77 bc		 ja	 SHORT $LL187@inflate
$LN562@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00c14	8b d0		 mov	 edx, eax
  00c16	c1 ea 10	 shr	 edx, 16
  00c19	66 83 fa 10	 cmp	 dx, 16
  00c1d	73 2e		 jae	 SHORT $LN955@inflate

; 967  :                     DROPBITS(here.bits);

  00c1f	c1 e8 08	 shr	 eax, 8
  00c22	0f b6 c8	 movzx	 ecx, al

; 968  :                     state->lens[state->have++] = here.val;

  00c25	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00c2c	2b d9		 sub	 ebx, ecx
  00c2e	41 d3 ef	 shr	 r15d, cl
  00c31	66 41 89 94 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], dx
  00c3a	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00c41	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]

; 969  :                 }

  00c48	e9 4a 01 00 00	 jmp	 $LN610@inflate
$LN955@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00c4d	75 68		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00c4f	c1 e8 08	 shr	 eax, 8
  00c52	0f b6 d0	 movzx	 edx, al
  00c55	83 c2 02	 add	 edx, 2
  00c58	3b da		 cmp	 ebx, edx
  00c5a	73 23		 jae	 SHORT $LN196@inflate
  00c5c	0f 1f 40 00	 npad	 4
$LL199@inflate:
  00c60	85 f6		 test	 esi, esi
  00c62	0f 84 6b 09 00
	00		 je	 $LN919@inflate
  00c68	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00c6c	8b cb		 mov	 ecx, ebx
  00c6e	d3 e0		 shl	 eax, cl
  00c70	ff ce		 dec	 esi
  00c72	44 03 f8	 add	 r15d, eax
  00c75	49 ff c6	 inc	 r14
  00c78	83 c3 08	 add	 ebx, 8
  00c7b	3b da		 cmp	 ebx, edx
  00c7d	72 e1		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00c7f	0f b6 4d 00	 movzx	 ecx, BYTE PTR here$[rbp-56]

; 974  :                         if (state->have == 0) {

  00c83	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00c8a	2b d9		 sub	 ebx, ecx
  00c8c	41 d3 ef	 shr	 r15d, cl
  00c8f	85 c0		 test	 eax, eax
  00c91	0f 84 44 01 00
	00		 je	 $LN567@inflate

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];
; 980  :                         copy = 3 + BITS(2);

  00c97	41 8b d7	 mov	 edx, r15d
  00c9a	ff c8		 dec	 eax
  00c9c	83 e2 03	 and	 edx, 3

; 981  :                         DROPBITS(2);

  00c9f	41 c1 ef 02	 shr	 r15d, 2
  00ca3	83 c2 03	 add	 edx, 3
  00ca6	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00ca9	45 0f b7 84 45
	90 00 00 00	 movzx	 r8d, WORD PTR [r13+rax*2+144]

; 982  :                     }

  00cb2	e9 99 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00cb7	66 83 7d 01 11	 cmp	 WORD PTR here$[rbp-55], 17

; 984  :                         NEEDBITS(here.bits + 3);

  00cbc	44 0f b6 4d 00	 movzx	 r9d, BYTE PTR here$[rbp-56]
  00cc1	75 46		 jne	 SHORT $LN226@inflate
  00cc3	41 8d 51 03	 lea	 edx, DWORD PTR [r9+3]
  00cc7	3b da		 cmp	 ebx, edx
  00cc9	73 24		 jae	 SHORT $LN210@inflate
  00ccb	0f 1f 44 00 00	 npad	 5
$LL213@inflate:
  00cd0	85 f6		 test	 esi, esi
  00cd2	0f 84 fb 08 00
	00		 je	 $LN919@inflate
  00cd8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00cdc	8b cb		 mov	 ecx, ebx
  00cde	d3 e0		 shl	 eax, cl
  00ce0	ff ce		 dec	 esi
  00ce2	44 03 f8	 add	 r15d, eax
  00ce5	49 ff c6	 inc	 r14
  00ce8	83 c3 08	 add	 ebx, 8
  00ceb	3b da		 cmp	 ebx, edx
  00ced	72 e1		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00cef	41 8b c9	 mov	 ecx, r9d

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);
; 988  :                         DROPBITS(3);

  00cf2	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00cf7	41 d3 ef	 shr	 r15d, cl
  00cfa	41 8b d7	 mov	 edx, r15d
  00cfd	83 e2 07	 and	 edx, 7
  00d00	83 c2 03	 add	 edx, 3
  00d03	41 c1 ef 03	 shr	 r15d, 3

; 989  :                     }

  00d07	eb 3f		 jmp	 SHORT $LN956@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00d09	41 8d 51 07	 lea	 edx, DWORD PTR [r9+7]
  00d0d	3b da		 cmp	 ebx, edx
  00d0f	73 1f		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00d11	85 f6		 test	 esi, esi
  00d13	0f 84 ba 08 00
	00		 je	 $LN919@inflate
  00d19	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00d1d	8b cb		 mov	 ecx, ebx
  00d1f	d3 e0		 shl	 eax, cl
  00d21	ff ce		 dec	 esi
  00d23	44 03 f8	 add	 r15d, eax
  00d26	49 ff c6	 inc	 r14
  00d29	83 c3 08	 add	 ebx, 8
  00d2c	3b da		 cmp	 ebx, edx
  00d2e	72 e1		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00d30	41 8b c9	 mov	 ecx, r9d

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);
; 995  :                         DROPBITS(7);

  00d33	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d38	41 d3 ef	 shr	 r15d, cl
  00d3b	41 8b d7	 mov	 edx, r15d
  00d3e	83 e2 7f	 and	 edx, 127		; 0000007fH
  00d41	83 c2 0b	 add	 edx, 11
  00d44	41 c1 ef 07	 shr	 r15d, 7
$LN956@inflate:
  00d48	41 2b c1	 sub	 eax, r9d
  00d4b	45 8b c4	 mov	 r8d, r12d
  00d4e	03 d8		 add	 ebx, eax
$LN236@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d50	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00d57	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00d5e	03 ca		 add	 ecx, edx
  00d60	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00d64	3b c8		 cmp	 ecx, eax
  00d66	77 73		 ja	 SHORT $LN567@inflate
  00d68	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00d70	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d77	66 45 89 84 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r8w
  00d80	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00d87	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00d8e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00d91	75 dd		 jne	 SHORT $LL238@inflate
  00d93	4d 8d 45 70	 lea	 r8, QWORD PTR [r13+112]
$LN610@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00d97	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00d9e	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00da2	3b c8		 cmp	 ecx, eax
  00da4	0f 82 f6 fd ff
	ff		 jb	 $LL185@inflate
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00daa	41 81 7d 08 51
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00db2	0f 84 94 f9 ff
	ff		 je	 $LN885@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00db8	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00dc1	75 30		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00dc3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00dca	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1013 :                 state->mode = BAD;

  00dce	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1014 :                 break;

  00dd6	e9 71 f9 ff ff	 jmp	 $LN885@inflate
$LN567@inflate:

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  00ddb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00de2	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 976  :                             state->mode = BAD;

  00de6	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 977  :                             break;

  00dee	e9 59 f9 ff ff	 jmp	 $LN885@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00df3	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00dfa	41 c7 00 09 00
	00 00		 mov	 DWORD PTR [r8], 9

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e01	4d 8d a5 10 03
	00 00		 lea	 r12, QWORD PTR [r13+784]
  00e08	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax
  00e0f	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00e14	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00e1b	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00e20	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00e27	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00e2b	b9 01 00 00 00	 mov	 ecx, 1
  00e30	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00e34	e8 00 00 00 00	 call	 inflate_table
  00e39	89 45 77	 mov	 DWORD PTR ret$1$[rbp-57], eax

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00e3c	85 c0		 test	 eax, eax
  00e3e	74 1c		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e40	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
$LN967@inflate:
  00e47	48 8b 7d 67	 mov	 rdi, QWORD PTR strm$[rbp-57]
  00e4b	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1027 :                 state->mode = BAD;

  00e4f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1028 :                 break;

  00e57	e9 ec f8 ff ff	 jmp	 $LN961@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00e5c	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1031 :             state->distbits = 6;

  00e63	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e67	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00e6e	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00e75	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00e79	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00e7d	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00e83	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00e88	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00e8d	b9 02 00 00 00	 mov	 ecx, 2
  00e92	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00e9a	49 03 d5	 add	 rdx, r13
  00e9d	e8 00 00 00 00	 call	 inflate_table
  00ea2	89 45 77	 mov	 DWORD PTR ret$1$[rbp-57], eax
  00ea5	44 8b e0	 mov	 r12d, eax

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  00ea8	85 c0		 test	 eax, eax
  00eaa	74 09		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  00eac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1036 :                 state->mode = BAD;
; 1037 :                 break;

  00eb3	eb 92		 jmp	 SHORT $LN967@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00eb5	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
  00eb8	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00ec0	83 f9 06	 cmp	 ecx, 6
  00ec3	0f 84 11 07 00
	00		 je	 $inf_leave$971
  00ec9	48 8b 7d 67	 mov	 rdi, QWORD PTR strm$[rbp-57]
  00ecd	4d 8d 45 70	 lea	 r8, QWORD PTR [r13+112]
  00ed1	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  00ed5	45 33 e4	 xor	 r12d, r12d
  00ed8	44 8b 55 fb	 mov	 r10d, DWORD PTR out$1$[rbp-57]
  00edc	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00ee0	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00ee8	83 fe 06	 cmp	 esi, 6
  00eeb	72 66		 jb	 SHORT $LN451@inflate
  00eed	41 81 fb 02 01
	00 00		 cmp	 r11d, 258		; 00000102H
  00ef4	72 5d		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00ef6	4c 89 4f 10	 mov	 QWORD PTR [rdi+16], r9

; 1047 :                 inflate_fast(strm, out);

  00efa	41 8b d2	 mov	 edx, r10d
  00efd	44 89 5f 18	 mov	 DWORD PTR [rdi+24], r11d
  00f01	48 8b cf	 mov	 rcx, rdi
  00f04	4c 89 37	 mov	 QWORD PTR [rdi], r14
  00f07	89 77 08	 mov	 DWORD PTR [rdi+8], esi
  00f0a	45 89 7d 48	 mov	 DWORD PTR [r13+72], r15d
  00f0e	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00f12	e8 00 00 00 00	 call	 inflate_fast

; 1048 :                 LOAD();
; 1049 :                 if (state->mode == TYPE)

  00f17	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  00f1f	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00f23	44 8b 5f 18	 mov	 r11d, DWORD PTR [rdi+24]
  00f27	4c 8b 37	 mov	 r14, QWORD PTR [rdi]
  00f2a	8b 77 08	 mov	 esi, DWORD PTR [rdi+8]
  00f2d	45 8b 7d 48	 mov	 r15d, DWORD PTR [r13+72]
  00f31	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  00f35	4c 89 4d 07	 mov	 QWORD PTR put$1$[rbp-57], r9
  00f39	44 89 5d 7f	 mov	 DWORD PTR left$1$[rbp-57], r11d
  00f3d	0f 85 0d f8 ff
	ff		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00f43	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1051 :                 break;

  00f4e	e9 fd f7 ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00f53	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00f56	b8 01 00 00 00	 mov	 eax, 1
  00f5b	4d 8b 5d 60	 mov	 r11, QWORD PTR [r13+96]
  00f5f	d3 e0		 shl	 eax, cl
  00f61	45 89 a5 e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r12d
  00f68	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f6b	41 8b c7	 mov	 eax, r15d
  00f6e	48 23 c8	 and	 rcx, rax
  00f71	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00f75	8b c8		 mov	 ecx, eax
  00f77	c1 e9 08	 shr	 ecx, 8
  00f7a	0f b6 c9	 movzx	 ecx, cl
  00f7d	3b cb		 cmp	 ecx, ebx
  00f7f	76 41		 jbe	 SHORT $LN569@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  00f81	85 f6		 test	 esi, esi
  00f83	0f 84 4a 06 00
	00		 je	 $LN919@inflate
  00f89	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00f8d	8b cb		 mov	 ecx, ebx
  00f8f	d3 e0		 shl	 eax, cl
  00f91	ff ce		 dec	 esi
  00f93	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00f96	44 03 f8	 add	 r15d, eax
  00f99	b8 01 00 00 00	 mov	 eax, 1
  00f9e	49 ff c6	 inc	 r14
  00fa1	d3 e0		 shl	 eax, cl
  00fa3	83 c3 08	 add	 ebx, 8
  00fa6	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00fa9	41 8b c7	 mov	 eax, r15d
  00fac	48 23 c8	 and	 rcx, rax
  00faf	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  00fb3	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00fb6	8b c8		 mov	 ecx, eax
  00fb8	c1 e9 08	 shr	 ecx, 8
  00fbb	0f b6 c9	 movzx	 ecx, cl
  00fbe	3b cb		 cmp	 ecx, ebx
  00fc0	77 bf		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00fc2	84 c0		 test	 al, al
  00fc4	0f 84 c6 00 00
	00		 je	 $LN263@inflate
  00fca	a8 f0		 test	 al, 240			; 000000f0H
  00fcc	0f 85 be 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;
; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  00fd2	44 8b d0	 mov	 r10d, eax
  00fd5	0f b6 c8	 movzx	 ecx, al
  00fd8	41 c1 ea 08	 shr	 r10d, 8
  00fdc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00fe2	45 0f b6 c2	 movzx	 r8d, r10b
  00fe6	8b d0		 mov	 edx, eax
  00fe8	41 03 c8	 add	 ecx, r8d
  00feb	89 45 ff	 mov	 DWORD PTR last$[rbp-57], eax
  00fee	41 d3 e1	 shl	 r9d, cl
  00ff1	41 8b c8	 mov	 ecx, r8d
  00ff4	41 ff c9	 dec	 r9d
  00ff7	c1 e8 10	 shr	 eax, 16
  00ffa	45 23 cf	 and	 r9d, r15d
  00ffd	41 d3 e9	 shr	 r9d, cl
  01000	44 03 c8	 add	 r9d, eax
  01003	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01007	8b c8		 mov	 ecx, eax
  01009	44 0f b6 5d 00	 movzx	 r11d, BYTE PTR last$[rbp-56]
  0100e	c1 e9 08	 shr	 ecx, 8
  01011	44 0f b6 c1	 movzx	 r8d, cl
  01015	41 0f b6 ca	 movzx	 ecx, r10b
  01019	44 03 c1	 add	 r8d, ecx
  0101c	44 3b c3	 cmp	 r8d, ebx
  0101f	76 5f		 jbe	 SHORT $LN260@inflate
  01021	44 0f b7 55 01	 movzx	 r10d, WORD PTR last$[rbp-55]
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01026	85 f6		 test	 esi, esi
  01028	0f 84 a5 05 00
	00		 je	 $LN919@inflate
  0102e	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  01032	8b cb		 mov	 ecx, ebx
  01034	d3 e0		 shl	 eax, cl
  01036	41 b8 01 00 00
	00		 mov	 r8d, 1
  0103c	44 03 f8	 add	 r15d, eax
  0103f	45 0f b6 cb	 movzx	 r9d, r11b
  01043	41 0f b7 c2	 movzx	 eax, r10w
  01047	ff ce		 dec	 esi
  01049	0f b6 ca	 movzx	 ecx, dl
  0104c	49 ff c6	 inc	 r14
  0104f	41 03 c9	 add	 ecx, r9d
  01052	83 c3 08	 add	 ebx, 8
  01055	41 d3 e0	 shl	 r8d, cl
  01058	41 8b c9	 mov	 ecx, r9d
  0105b	41 ff c8	 dec	 r8d
  0105e	45 23 c7	 and	 r8d, r15d
  01061	41 d3 e8	 shr	 r8d, cl
  01064	44 03 c0	 add	 r8d, eax
  01067	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  0106b	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0106f	8b c8		 mov	 ecx, eax
  01071	c1 e9 08	 shr	 ecx, 8
  01074	44 0f b6 c1	 movzx	 r8d, cl
  01078	45 03 c1	 add	 r8d, r9d
  0107b	44 3b c3	 cmp	 r8d, ebx
  0107e	77 a6		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);

  01080	41 0f b6 cb	 movzx	 ecx, r11b
  01084	41 d3 ef	 shr	 r15d, cl
  01087	2b d9		 sub	 ebx, ecx

; 1068 :                 state->back += last.bits;

  01089	41 89 8d e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], ecx
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  01090	8b c8		 mov	 ecx, eax
  01092	c1 e9 08	 shr	 ecx, 8
  01095	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  01098	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0109f	2b d9		 sub	 ebx, ecx
  010a1	41 d3 ef	 shr	 r15d, cl

; 1072 :             state->length = (unsigned)here.val;

  010a4	8b c8		 mov	 ecx, eax
  010a6	c1 e9 10	 shr	 ecx, 16
  010a9	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1073 :             if ((int)(here.op) == 0) {

  010ad	84 c0		 test	 al, al
  010af	75 0d		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  010b1	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1078 :                 break;

  010b9	e9 8a f6 ff ff	 jmp	 $LN961@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  010be	a8 20		 test	 al, 32			; 00000020H
  010c0	74 10		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  010c2	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1084 :                 break;

  010cd	e9 6e f6 ff ff	 jmp	 $LN968@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  010d2	a8 40		 test	 al, 64			; 00000040H
  010d4	74 18		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  010d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010dd	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  010e1	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  010e9	e9 5a f6 ff ff	 jmp	 $LN961@inflate
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  010ee	0f b6 c8	 movzx	 ecx, al
  010f1	83 e1 0f	 and	 ecx, 15

; 1092 :             state->mode = LENEXT;

  010f4	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  010fc	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  01100	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  01104	85 d2		 test	 edx, edx
  01106	74 45		 je	 SHORT $LN462@inflate

; 1095 :                 NEEDBITS(state->extra);

  01108	3b da		 cmp	 ebx, edx
  0110a	73 23		 jae	 SHORT $LN264@inflate
  0110c	0f 1f 40 00	 npad	 4
$LL267@inflate:
  01110	85 f6		 test	 esi, esi
  01112	0f 84 bb 04 00
	00		 je	 $LN919@inflate
  01118	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0111c	8b cb		 mov	 ecx, ebx
  0111e	d3 e0		 shl	 eax, cl
  01120	ff ce		 dec	 esi
  01122	44 03 f8	 add	 r15d, eax
  01125	49 ff c6	 inc	 r14
  01128	83 c3 08	 add	 ebx, 8
  0112b	3b da		 cmp	 ebx, edx
  0112d	72 e1		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  0112f	8b ca		 mov	 ecx, edx
  01131	b8 01 00 00 00	 mov	 eax, 1
  01136	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  01138	2b da		 sub	 ebx, edx
  0113a	ff c8		 dec	 eax
  0113c	41 23 c7	 and	 eax, r15d
  0113f	41 d3 ef	 shr	 r15d, cl
  01142	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1098 :                 state->back += state->extra;

  01146	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0114d	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  01151	49 8d 55 74	 lea	 rdx, QWORD PTR [r13+116]
  01155	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1102 :             state->mode = DIST;

  0115c	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  01164	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  01166	b8 01 00 00 00	 mov	 eax, 1
  0116b	4d 8b 5d 68	 mov	 r11, QWORD PTR [r13+104]
  0116f	d3 e0		 shl	 eax, cl
  01171	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01174	41 8b c7	 mov	 eax, r15d
  01177	48 23 c8	 and	 rcx, rax
  0117a	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  0117e	8b c8		 mov	 ecx, eax
  01180	c1 e9 08	 shr	 ecx, 8
  01183	0f b6 c9	 movzx	 ecx, cl
  01186	3b cb		 cmp	 ecx, ebx
  01188	76 46		 jbe	 SHORT $LN574@inflate
  0118a	66 0f 1f 44 00
	00		 npad	 6
$LL275@inflate:

; 1107 :                 PULLBYTE();

  01190	85 f6		 test	 esi, esi
  01192	0f 84 3b 04 00
	00		 je	 $LN919@inflate
  01198	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0119c	8b cb		 mov	 ecx, ebx
  0119e	d3 e0		 shl	 eax, cl
  011a0	ff ce		 dec	 esi
  011a2	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  011a4	44 03 f8	 add	 r15d, eax
  011a7	b8 01 00 00 00	 mov	 eax, 1
  011ac	49 ff c6	 inc	 r14
  011af	d3 e0		 shl	 eax, cl
  011b1	83 c3 08	 add	 ebx, 8
  011b4	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  011b7	41 8b c7	 mov	 eax, r15d
  011ba	48 23 c8	 and	 rcx, rax
  011bd	49 8b 45 68	 mov	 rax, QWORD PTR [r13+104]
  011c1	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  011c4	8b c8		 mov	 ecx, eax
  011c6	c1 e9 08	 shr	 ecx, 8
  011c9	0f b6 c9	 movzx	 ecx, cl
  011cc	3b cb		 cmp	 ecx, ebx
  011ce	77 c0		 ja	 SHORT $LL275@inflate
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  011d0	a8 f0		 test	 al, 240			; 000000f0H
  011d2	0f 85 c2 00 00
	00		 jne	 $LN292@inflate

; 1110 :                 last = here;
; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  011d8	44 8b d0	 mov	 r10d, eax
  011db	0f b6 c8	 movzx	 ecx, al
  011de	41 c1 ea 08	 shr	 r10d, 8
  011e2	41 b9 01 00 00
	00		 mov	 r9d, 1
  011e8	45 0f b6 c2	 movzx	 r8d, r10b
  011ec	8b d0		 mov	 edx, eax
  011ee	41 03 c8	 add	 ecx, r8d
  011f1	89 45 ff	 mov	 DWORD PTR last$[rbp-57], eax
  011f4	41 d3 e1	 shl	 r9d, cl
  011f7	41 8b c8	 mov	 ecx, r8d
  011fa	41 ff c9	 dec	 r9d
  011fd	c1 e8 10	 shr	 eax, 16
  01200	45 23 cf	 and	 r9d, r15d
  01203	41 d3 e9	 shr	 r9d, cl
  01206	44 03 c8	 add	 r9d, eax
  01209	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0120d	8b c8		 mov	 ecx, eax
  0120f	44 0f b6 5d 00	 movzx	 r11d, BYTE PTR last$[rbp-56]
  01214	c1 e9 08	 shr	 ecx, 8
  01217	44 0f b6 c1	 movzx	 r8d, cl
  0121b	41 0f b6 ca	 movzx	 ecx, r10b
  0121f	44 03 c1	 add	 r8d, ecx
  01222	44 3b c3	 cmp	 r8d, ebx
  01225	76 63		 jbe	 SHORT $LN289@inflate
  01227	44 0f b7 55 01	 movzx	 r10d, WORD PTR last$[rbp-55]
  0122c	0f 1f 40 00	 npad	 4
$LL281@inflate:

; 1115 :                     PULLBYTE();

  01230	85 f6		 test	 esi, esi
  01232	0f 84 9b 03 00
	00		 je	 $LN919@inflate
  01238	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0123c	8b cb		 mov	 ecx, ebx
  0123e	d3 e0		 shl	 eax, cl
  01240	41 b8 01 00 00
	00		 mov	 r8d, 1
  01246	44 03 f8	 add	 r15d, eax
  01249	45 0f b6 cb	 movzx	 r9d, r11b
  0124d	41 0f b7 c2	 movzx	 eax, r10w
  01251	ff ce		 dec	 esi
  01253	0f b6 ca	 movzx	 ecx, dl
  01256	49 ff c6	 inc	 r14
  01259	41 03 c9	 add	 ecx, r9d
  0125c	83 c3 08	 add	 ebx, 8
  0125f	41 d3 e0	 shl	 r8d, cl
  01262	41 8b c9	 mov	 ecx, r9d
  01265	41 ff c8	 dec	 r8d
  01268	45 23 c7	 and	 r8d, r15d
  0126b	41 d3 e8	 shr	 r8d, cl
  0126e	44 03 c0	 add	 r8d, eax
  01271	49 8b 45 68	 mov	 rax, QWORD PTR [r13+104]
  01275	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  01279	8b c8		 mov	 ecx, eax
  0127b	c1 e9 08	 shr	 ecx, 8
  0127e	44 0f b6 c1	 movzx	 r8d, cl
  01282	45 03 c1	 add	 r8d, r9d
  01285	44 3b c3	 cmp	 r8d, ebx
  01288	77 a6		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);

  0128a	41 0f b6 cb	 movzx	 ecx, r11b
  0128e	41 d3 ef	 shr	 r15d, cl
  01291	2b d9		 sub	 ebx, ecx

; 1118 :                 state->back += last.bits;

  01293	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {
; 1123 :                 strm->msg = (char *)"invalid distance code";
; 1124 :                 state->mode = BAD;
; 1125 :                 break;

  0129a	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  0129e	8b c8		 mov	 ecx, eax
  012a0	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
  012a4	c1 e9 08	 shr	 ecx, 8
  012a7	0f b6 c9	 movzx	 ecx, cl
  012aa	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  012b1	2b d9		 sub	 ebx, ecx
  012b3	41 d3 ef	 shr	 r15d, cl
  012b6	a8 40		 test	 al, 64			; 00000040H
  012b8	74 18		 je	 SHORT $LN470@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  012ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  012c1	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 687  :                 state->mode = BAD;

  012c5	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 688  :                 break;

  012cd	e9 7e f4 ff ff	 jmp	 $LN8@inflate
$LN470@inflate:
  012d2	44 8b 55 fb	 mov	 r10d, DWORD PTR out$1$[rbp-57]

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  012d6	8b c8		 mov	 ecx, eax
  012d8	c1 e9 10	 shr	 ecx, 16
  012db	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  012df	0f b6 c8	 movzx	 ecx, al
  012e2	83 e1 0f	 and	 ecx, 15

; 1129 :             state->mode = DISTEXT;

  012e5	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  012ed	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  012f1	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  012f5	85 d2		 test	 edx, edx
  012f7	74 44		 je	 SHORT $LN472@inflate

; 1132 :                 NEEDBITS(state->extra);

  012f9	3b da		 cmp	 ebx, edx
  012fb	73 22		 jae	 SHORT $LN293@inflate
  012fd	0f 1f 00	 npad	 3
$LL296@inflate:
  01300	85 f6		 test	 esi, esi
  01302	0f 84 cb 02 00
	00		 je	 $LN919@inflate
  01308	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0130c	8b cb		 mov	 ecx, ebx
  0130e	d3 e0		 shl	 eax, cl
  01310	ff ce		 dec	 esi
  01312	44 03 f8	 add	 r15d, eax
  01315	49 ff c6	 inc	 r14
  01318	83 c3 08	 add	 ebx, 8
  0131b	3b da		 cmp	 ebx, edx
  0131d	72 e1		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  0131f	8b ca		 mov	 ecx, edx
  01321	b8 01 00 00 00	 mov	 eax, 1
  01326	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  01328	2b da		 sub	 ebx, edx
  0132a	ff c8		 dec	 eax
  0132c	41 23 c7	 and	 eax, r15d
  0132f	41 d3 ef	 shr	 r15d, cl
  01332	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1135 :                 state->back += state->extra;

  01336	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  0133d	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01345	45 85 db	 test	 r11d, r11d
  01348	0f 84 85 02 00
	00		 je	 $LN919@inflate

; 1148 :             copy = out - left;
; 1149 :             if (state->offset > copy) {         /* copy from window */

  0134e	41 8b 4d 54	 mov	 ecx, DWORD PTR [r13+84]
  01352	41 8b c2	 mov	 eax, r10d
  01355	41 2b c3	 sub	 eax, r11d
  01358	3b c8		 cmp	 ecx, eax
  0135a	76 4e		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  0135c	2b c8		 sub	 ecx, eax

; 1151 :                 if (copy > state->whave) {

  0135e	41 3b 4d 38	 cmp	 ecx, DWORD PTR [r13+56]
  01362	76 22		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  01364	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  0136c	74 18		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  0136e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  01375	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  01379	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  01381	e9 ca f3 ff ff	 jmp	 $LN8@inflate
$LN479@inflate:

; 1154 :                         state->mode = BAD;
; 1155 :                         break;
; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01386	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  0138a	3b c8		 cmp	 ecx, eax
  0138c	76 0a		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;
; 1173 :                     from = state->window + (state->wsize - copy);

  0138e	41 8b 55 34	 mov	 edx, DWORD PTR [r13+52]
  01392	2b c8		 sub	 ecx, eax
  01394	2b d1		 sub	 edx, ecx

; 1174 :                 }

  01396	eb 04		 jmp	 SHORT $LN957@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  01398	2b c1		 sub	 eax, ecx
  0139a	8b d0		 mov	 edx, eax
$LN957@inflate:
  0139c	49 03 55 40	 add	 rdx, QWORD PTR [r13+64]

; 1177 :                 if (copy > state->length) copy = state->length;

  013a0	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  013a4	3b c8		 cmp	 ecx, eax
  013a6	76 0e		 jbe	 SHORT $LN477@inflate

; 1178 :             }

  013a8	eb 0a		 jmp	 SHORT $LN958@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;
; 1181 :                 copy = state->length;

  013aa	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  013ae	49 8b d1	 mov	 rdx, r9
  013b1	48 2b d1	 sub	 rdx, rcx
$LN958@inflate:
  013b4	8b c8		 mov	 ecx, eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  013b6	41 3b cb	 cmp	 ecx, r11d
  013b9	41 0f 47 cb	 cmova	 ecx, r11d

; 1184 :             left -= copy;

  013bd	44 2b d9	 sub	 r11d, ecx

; 1185 :             state->length -= copy;

  013c0	2b c1		 sub	 eax, ecx
  013c2	44 89 5d 7f	 mov	 DWORD PTR left$1$[rbp-57], r11d

; 1188 :             } while (--copy);

  013c6	49 2b d1	 sub	 rdx, r9
  013c9	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  013cd	0f 1f 00	 npad	 3
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  013d0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  013d5	41 88 01	 mov	 BYTE PTR [r9], al
  013d8	49 ff c1	 inc	 r9

; 1188 :             } while (--copy);

  013db	83 c1 ff	 add	 ecx, -1			; ffffffffH
  013de	75 f0		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  013e0	4c 89 4d 07	 mov	 QWORD PTR put$1$[rbp-57], r9
  013e4	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  013e8	0f 85 62 f3 ff
	ff		 jne	 $LN8@inflate
  013ee	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1190 :             break;

  013f6	e9 55 f3 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  013fb	45 85 db	 test	 r11d, r11d
  013fe	0f 84 cf 01 00
	00		 je	 $LN919@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  01404	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  01409	41 88 01	 mov	 BYTE PTR [r9], al
  0140c	49 ff c1	 inc	 r9

; 1194 :             left--;

  0140f	41 ff cb	 dec	 r11d
  01412	4c 89 4d 07	 mov	 QWORD PTR put$1$[rbp-57], r9
  01416	44 89 5d 7f	 mov	 DWORD PTR left$1$[rbp-57], r11d

; 1195 :             state->mode = LEN;

  0141a	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1196 :             break;

  01422	e9 29 f3 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01427	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  0142c	0f 84 cd 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  01432	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01435	73 20		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01437	85 f6		 test	 esi, esi
  01439	0f 84 94 01 00
	00		 je	 $LN919@inflate
  0143f	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  01443	8b cb		 mov	 ecx, ebx
  01445	d3 e0		 shl	 eax, cl
  01447	ff ce		 dec	 esi
  01449	44 03 f8	 add	 r15d, eax
  0144c	49 ff c6	 inc	 r14
  0144f	83 c3 08	 add	 ebx, 8
  01452	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01455	72 e0		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1200 :                 out -= left;

  01457	45 2b d3	 sub	 r10d, r11d

; 1201 :                 strm->total_out += out;

  0145a	44 01 57 1c	 add	 DWORD PTR [rdi+28], r10d

; 1202 :                 state->total += out;

  0145e	45 01 55 24	 add	 DWORD PTR [r13+36], r10d

; 1203 :                 if ((state->wrap & 4) && out)

  01462	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01467	74 37		 je	 SHORT $LN490@inflate
  01469	45 85 d2	 test	 r10d, r10d
  0146c	74 32		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  0146e	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  01472	49 8b d1	 mov	 rdx, r9
  01475	41 8b c2	 mov	 eax, r10d
  01478	45 8b c2	 mov	 r8d, r10d
  0147b	48 2b d0	 sub	 rdx, rax
  0147e	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01483	74 07		 je	 SHORT $LN511@inflate
  01485	e8 00 00 00 00	 call	 crc32
  0148a	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  0148c	e8 00 00 00 00	 call	 adler32
$LN512@inflate:
  01491	4c 8b 4d 07	 mov	 r9, QWORD PTR put$1$[rbp-57]
  01495	44 8b 5d 7f	 mov	 r11d, DWORD PTR left$1$[rbp-57]
  01499	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0149d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (

  014a0	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  014a5	44 89 5d fb	 mov	 DWORD PTR out$1$[rbp-57], r11d
  014a9	74 4e		 je	 SHORT $LN317@inflate
  014ab	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  014b0	41 8b cf	 mov	 ecx, r15d
  014b3	75 26		 jne	 SHORT $LN514@inflate
  014b5	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  014bb	41 8b c7	 mov	 eax, r15d
  014be	c1 e0 10	 shl	 eax, 16
  014c1	03 c8		 add	 ecx, eax
  014c3	41 8b c7	 mov	 eax, r15d
  014c6	c1 e8 08	 shr	 eax, 8
  014c9	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014ce	c1 e1 08	 shl	 ecx, 8
  014d1	03 c8		 add	 ecx, eax
  014d3	41 8b c7	 mov	 eax, r15d
  014d6	c1 e8 18	 shr	 eax, 24
  014d9	03 c8		 add	 ecx, eax
$LN514@inflate:
  014db	41 3b 4d 20	 cmp	 ecx, DWORD PTR [r13+32]
  014df	74 18		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  014e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014e8	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  014ec	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  014f4	e9 57 f2 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  014f9	45 8b fc	 mov	 r15d, r12d
  014fc	41 8b dc	 mov	 ebx, r12d
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  014ff	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01507	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  0150c	0f 84 9a 00 00
	00		 je	 $LN327@inflate
  01512	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01517	0f 84 8f 00 00
	00		 je	 $LN327@inflate

; 1223 :                 NEEDBITS(32);

  0151d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01520	73 20		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01522	85 f6		 test	 esi, esi
  01524	0f 84 a9 00 00
	00		 je	 $LN919@inflate
  0152a	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0152e	8b cb		 mov	 ecx, ebx
  01530	d3 e0		 shl	 eax, cl
  01532	ff ce		 dec	 esi
  01534	44 03 f8	 add	 r15d, eax
  01537	49 ff c6	 inc	 r14
  0153a	83 c3 08	 add	 ebx, 8
  0153d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01540	72 e0		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01542	45 3b 7d 24	 cmp	 r15d, DWORD PTR [r13+36]
  01546	74 5e		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01548	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  0154f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  01553	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  0155b	e9 f0 f1 ff ff	 jmp	 $LN8@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  01560	4c 89 4f 10	 mov	 QWORD PTR [rdi+16], r9

; 845  :                 return Z_NEED_DICT;

  01564	b8 02 00 00 00	 mov	 eax, 2
  01569	44 89 5f 18	 mov	 DWORD PTR [rdi+24], r11d
  0156d	4c 89 37	 mov	 QWORD PTR [rdi], r14
  01570	89 77 08	 mov	 DWORD PTR [rdi+8], esi
  01573	45 89 7d 48	 mov	 DWORD PTR [r13+72], r15d
  01577	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
$LN954@inflate:
  0157b	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  01580	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  01585	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  0158a	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0158f	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  01597	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1275 : }

  0159c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  015a3	5f		 pop	 rdi
  015a4	5d		 pop	 rbp
  015a5	c3		 ret	 0
$LN328@inflate:

; 1226 :                     state->mode = BAD;
; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015a6	45 8b fc	 mov	 r15d, r12d
  015a9	41 8b dc	 mov	 ebx, r12d
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  015ac	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;
; 1236 :             goto inf_leave;

  015b4	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
  015b7	41 bc 01 00 00
	00		 mov	 r12d, 1
  015bd	eb 1b		 jmp	 SHORT $inf_leave$971
$LN497@inflate:
  015bf	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  015c2	41 bc fd ff ff
	ff		 mov	 r12d, -3
  015c8	eb 10		 jmp	 SHORT $inf_leave$971
$LN918@inflate:
  015ca	44 8b 65 77	 mov	 r12d, DWORD PTR ret$1$[rbp-57]
  015ce	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
  015d1	eb 07		 jmp	 SHORT $inf_leave$971
$LN919@inflate:
  015d3	8b 4d 6f	 mov	 ecx, DWORD PTR flush$[rbp-57]
$LN965@inflate:
  015d6	44 8b 65 77	 mov	 r12d, DWORD PTR ret$1$[rbp-57]
$inf_leave$971:

; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  015da	48 8b 7d 67	 mov	 rdi, QWORD PTR strm$[rbp-57]
  015de	48 8b 45 07	 mov	 rax, QWORD PTR put$1$[rbp-57]
  015e2	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  015e6	8b 45 7f	 mov	 eax, DWORD PTR left$1$[rbp-57]
  015e9	89 47 18	 mov	 DWORD PTR [rdi+24], eax
  015ec	4c 89 37	 mov	 QWORD PTR [rdi], r14
  015ef	89 77 08	 mov	 DWORD PTR [rdi+8], esi

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  015f2	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  015f7	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  015fb	8b 5d fb	 mov	 ebx, DWORD PTR out$1$[rbp-57]
  015fe	45 89 7d 48	 mov	 DWORD PTR [r13+72], r15d
  01602	75 1c		 jne	 SHORT $LN502@inflate
  01604	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  01607	74 40		 je	 SHORT $LN503@inflate
  01609	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0160d	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  01612	7d 35		 jge	 SHORT $LN503@inflate
  01614	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  01619	7c 05		 jl	 SHORT $LN502@inflate
  0161b	83 f9 04	 cmp	 ecx, 4
  0161e	74 29		 je	 SHORT $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01620	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  01624	44 8b c3	 mov	 r8d, ebx
  01627	44 2b 47 18	 sub	 r8d, DWORD PTR [rdi+24]
  0162b	48 8b cf	 mov	 rcx, rdi
  0162e	e8 00 00 00 00	 call	 updatewindow
  01633	85 c0		 test	 eax, eax
  01635	74 12		 je	 SHORT $LN503@inflate

; 1258 :             state->mode = MEM;

  01637	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1259 :             return Z_MEM_ERROR;

  0163f	b8 fc ff ff ff	 mov	 eax, -4
  01644	e9 32 ff ff ff	 jmp	 $LN954@inflate
$LN503@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;
; 1262 :     out -= strm->avail_out;

  01649	2b 5f 18	 sub	 ebx, DWORD PTR [rdi+24]
  0164c	44 8b 55 03	 mov	 r10d, DWORD PTR in$1$[rbp-57]
  01650	44 2b 57 08	 sub	 r10d, DWORD PTR [rdi+8]

; 1263 :     strm->total_in += in;

  01654	44 01 57 0c	 add	 DWORD PTR [rdi+12], r10d

; 1264 :     strm->total_out += out;

  01658	01 5f 1c	 add	 DWORD PTR [rdi+28], ebx

; 1265 :     state->total += out;

  0165b	41 01 5d 24	 add	 DWORD PTR [r13+36], ebx

; 1266 :     if ((state->wrap & 4) && out)

  0165f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01664	44 89 55 03	 mov	 DWORD PTR in$1$[rbp-57], r10d
  01668	74 32		 je	 SHORT $LN504@inflate
  0166a	85 db		 test	 ebx, ebx
  0166c	74 2e		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  0166e	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  01672	44 8b c3	 mov	 r8d, ebx
  01675	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  01679	8b c3		 mov	 eax, ebx
  0167b	48 2b d0	 sub	 rdx, rax
  0167e	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01683	74 07		 je	 SHORT $LN515@inflate
  01685	e8 00 00 00 00	 call	 crc32
  0168a	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  0168c	e8 00 00 00 00	 call	 adler32
$LN516@inflate:
  01691	44 8b 55 03	 mov	 r10d, DWORD PTR in$1$[rbp-57]
  01695	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01699	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  0169c	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  016a0	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  016a6	74 10		 je	 SHORT $LN517@inflate
  016a8	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  016ae	74 08		 je	 SHORT $LN517@inflate
  016b0	45 33 c9	 xor	 r9d, r9d
  016b3	45 8b c1	 mov	 r8d, r9d
  016b6	eb 09		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  016b8	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  016be	45 33 c9	 xor	 r9d, r9d
$LN518@inflate:
  016c1	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  016c5	f7 d8		 neg	 eax
  016c7	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  016cc	1b c9		 sbb	 ecx, ecx
  016ce	83 e1 40	 and	 ecx, 64			; 00000040H
  016d1	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  016d7	44 0f 44 c8	 cmove	 r9d, eax
  016db	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  016df	44 03 c8	 add	 r9d, eax
  016e2	45 03 4d 4c	 add	 r9d, DWORD PTR [r13+76]
  016e6	44 89 4f 48	 mov	 DWORD PTR [rdi+72], r9d

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  016ea	45 85 d2	 test	 r10d, r10d
  016ed	75 04		 jne	 SHORT $LN507@inflate
  016ef	85 db		 test	 ebx, ebx
  016f1	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  016f3	83 7d 6f 04	 cmp	 DWORD PTR flush$[rbp-57], 4
  016f7	75 0c		 jne	 SHORT $LN505@inflate
$LN506@inflate:
  016f9	45 85 e4	 test	 r12d, r12d
  016fc	b8 fb ff ff ff	 mov	 eax, -5
  01701	44 0f 44 e0	 cmove	 r12d, eax
$LN505@inflate:

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;

  01705	41 8b c4	 mov	 eax, r12d
  01708	e9 6e fe ff ff	 jmp	 $LN954@inflate
$LN499@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  0170d	b8 fe ff ff ff	 mov	 eax, -2
  01712	e9 64 fe ff ff	 jmp	 $LN954@inflate
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  01717	b8 fe ff ff ff	 mov	 eax, -2

; 1275 : }

  0171c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  01723	5f		 pop	 rdi
  01724	5d		 pop	 rbp
  01725	c3		 ret	 0
  01726	66 90		 npad	 2
$LN800@inflate:
  01728	00 00 00 00	 DD	 $LN335@inflate
  0172c	00 00 00 00	 DD	 $LN32@inflate
  01730	00 00 00 00	 DD	 $LN46@inflate
  01734	00 00 00 00	 DD	 $LN60@inflate
  01738	00 00 00 00	 DD	 $LN361@inflate
  0173c	00 00 00 00	 DD	 $LN368@inflate
  01740	00 00 00 00	 DD	 $LN375@inflate
  01744	00 00 00 00	 DD	 $LN384@inflate
  01748	00 00 00 00	 DD	 $LN393@inflate
  0174c	00 00 00 00	 DD	 $LN105@inflate
  01750	00 00 00 00	 DD	 $LN400@inflate
  01754	00 00 00 00	 DD	 $LN402@inflate
  01758	00 00 00 00	 DD	 $LN403@inflate
  0175c	00 00 00 00	 DD	 $LN141@inflate
  01760	00 00 00 00	 DD	 $LN416@inflate
  01764	00 00 00 00	 DD	 $LN418@inflate
  01768	00 00 00 00	 DD	 $LN155@inflate
  0176c	00 00 00 00	 DD	 $LN532@inflate
  01770	00 00 00 00	 DD	 $LN535@inflate
  01774	00 00 00 00	 DD	 $LN448@inflate
  01778	00 00 00 00	 DD	 $LN450@inflate
  0177c	00 00 00 00	 DD	 $LN461@inflate
  01780	00 00 00 00	 DD	 $LN464@inflate
  01784	00 00 00 00	 DD	 $LN471@inflate
  01788	00 00 00 00	 DD	 $LN474@inflate
  0178c	00 00 00 00	 DD	 $LN485@inflate
  01790	00 00 00 00	 DD	 $LN487@inflate
  01794	00 00 00 00	 DD	 $LN492@inflate
  01798	00 00 00 00	 DD	 $LN496@inflate
  0179c	00 00 00 00	 DD	 $LN497@inflate
  017a0	00 00 00 00	 DD	 $LN498@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1279 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1289 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00021	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  00025	48 85 d2	 test	 rdx, rdx
  00028	74 07		 je	 SHORT $LN3@inflateEnd
  0002a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002e	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00031	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00035	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00039	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1286 :     strm->state = Z_NULL;
; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  0003c	33 c0		 xor	 eax, eax
  0003e	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1289 : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 117  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 121  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 142  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 127  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00069	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  0006d	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00071	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  0007b	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 142  : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 160  : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b e9	 mov	 rbp, rcx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000f	e8 00 00 00 00	 call	 inflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	74 10		 je	 SHORT $LN2@inflateRes
  00018	b8 fe ff ff ff	 mov	 eax, -2

; 193  : }

  0001d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5d		 pop	 rbp
  00027	c3		 ret	 0
$LN2@inflateRes:
  00028	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 166  :     state = (struct inflate_state FAR *)strm->state;

  0002d	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]
  00031	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00036	85 db		 test	 ebx, ebx
  00038	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0003a	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0003c	f7 db		 neg	 ebx

; 172  :     }

  0003e	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00040	8b fb		 mov	 edi, ebx
  00042	c1 ff 04	 sar	 edi, 4
  00045	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00048	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0004b	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0004d	83 e3 0f	 and	 ebx, 15
$LN5@inflateRes:
  00050	85 db		 test	 ebx, ebx
  00052	74 0f		 je	 SHORT $LN6@inflateRes
  00054	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00057	83 f8 07	 cmp	 eax, 7
  0005a	76 07		 jbe	 SHORT $LN6@inflateRes

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))
; 183  :         return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2
  00061	eb 2b		 jmp	 SHORT $LN12@inflateRes
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00063	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00067	48 85 d2	 test	 rdx, rdx
  0006a	74 14		 je	 SHORT $LN8@inflateRes
  0006c	39 5e 30	 cmp	 DWORD PTR [rsi+48], ebx
  0006f	74 0f		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  00071	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00075	ff 55 38	 call	 QWORD PTR [rbp+56]

; 186  :         state->window = Z_NULL;

  00078	48 c7 46 40 00
	00 00 00	 mov	 QWORD PTR [rsi+64], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00080	48 8b cd	 mov	 rcx, rbp
  00083	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  00086	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  00089	e8 00 00 00 00	 call	 inflateReset
$LN12@inflateRes:

; 193  : }

  0008e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00093	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5d		 pop	 rbp
  000a2	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 251  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d
  00007	44 8b ca	 mov	 r9d, edx

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 48		 jne	 SHORT $LN5@inflatePri

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]

; 256  :     if (bits < 0) {

  00017	45 85 c9	 test	 r9d, r9d
  0001a	79 09		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  0001c	48 89 42 48	 mov	 QWORD PTR [rdx+72], rax

; 266  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
$LN3@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00025	41 83 f9 10	 cmp	 r9d, 16
  00029	7f 30		 jg	 SHORT $LN5@inflatePri
  0002b	44 8b 42 4c	 mov	 r8d, DWORD PTR [rdx+76]
  0002f	47 8d 14 08	 lea	 r10d, DWORD PTR [r8+r9]
  00033	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00037	77 22		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00039	41 8b c9	 mov	 ecx, r9d

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  0003c	44 89 52 4c	 mov	 DWORD PTR [rdx+76], r10d
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	d3 e0		 shl	 eax, cl
  00047	41 8b c8	 mov	 ecx, r8d
  0004a	ff c8		 dec	 eax
  0004c	41 23 c3	 and	 eax, r11d
  0004f	d3 e0		 shl	 eax, cl
  00051	01 42 48	 add	 DWORD PTR [rdx+72], eax

; 265  :     return Z_OK;

  00054	33 c0		 xor	 eax, eax

; 266  : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
$LN5@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0005b	b8 fe ff ff ff	 mov	 eax, -2

; 266  : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 317  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 318  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 319  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
end$ = 56
copy$ = 64
updatewindow PROC					; COMDAT

; 400  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  00014	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00018	48 8b f2	 mov	 rsi, rdx
  0001b	41 8b e8	 mov	 ebp, r8d
  0001e	48 8b c1	 mov	 rax, rcx

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  00021	bf 01 00 00 00	 mov	 edi, 1
  00026	48 83 7b 40 00	 cmp	 QWORD PTR [rbx+64], 0
  0002b	75 21		 jne	 SHORT $LN3@updatewind

; 408  :         state->window = (unsigned char FAR *)

  0002d	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00030	8b d7		 mov	 edx, edi
  00032	d3 e2		 shl	 edx, cl
  00034	44 8b c7	 mov	 r8d, edi
  00037	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0003b	ff 50 30	 call	 QWORD PTR [rax+48]
  0003e	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00042	48 85 c0	 test	 rax, rax
  00045	75 07		 jne	 SHORT $LN3@updatewind
  00047	8b c7		 mov	 eax, edi
  00049	e9 9b 00 00 00	 jmp	 $LN1@updatewind
$LN3@updatewind:
  0004e	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00053	45 33 f6	 xor	 r14d, r14d
  00056	44 39 73 34	 cmp	 DWORD PTR [rbx+52], r14d
  0005a	75 0c		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0005c	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  0005f	d3 e7		 shl	 edi, cl
  00061	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 417  :         state->wnext = 0;
; 418  :         state->whave = 0;

  00064	4c 89 73 38	 mov	 QWORD PTR [rbx+56], r14
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00068	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  0006b	3b ef		 cmp	 ebp, edi
  0006d	72 1b		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0006f	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00073	48 2b f7	 sub	 rsi, rdi
  00076	48 8b d6	 mov	 rdx, rsi
  00079	44 8b c7	 mov	 r8d, edi
  0007c	e8 00 00 00 00	 call	 memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00081	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00084	44 89 73 3c	 mov	 DWORD PTR [rbx+60], r14d

; 426  :     }

  00088	eb 55		 jmp	 SHORT $LN13@updatewind
$LN5@updatewind:

; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0008a	2b 7b 3c	 sub	 edi, DWORD PTR [rbx+60]

; 429  :         if (dist > copy) dist = copy;
; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0008d	48 8b d6	 mov	 rdx, rsi
  00090	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]
  00093	3b fd		 cmp	 edi, ebp
  00095	0f 47 fd	 cmova	 edi, ebp
  00098	48 03 4b 40	 add	 rcx, QWORD PTR [rbx+64]
  0009c	44 8b c7	 mov	 r8d, edi
  0009f	48 2b d5	 sub	 rdx, rbp
  000a2	e8 00 00 00 00	 call	 memcpy

; 431  :         copy -= dist;

  000a7	2b ef		 sub	 ebp, edi

; 432  :         if (copy) {

  000a9	74 1a		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000ab	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000af	44 8b c5	 mov	 r8d, ebp
  000b2	49 2b f0	 sub	 rsi, r8
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	e8 00 00 00 00	 call	 memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000bd	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000c0	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 436  :         }

  000c3	eb 1a		 jmp	 SHORT $LN13@updatewind
$LN8@updatewind:

; 437  :         else {
; 438  :             state->wnext += dist;

  000c5	01 7b 3c	 add	 DWORD PTR [rbx+60], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c8	8b 43 3c	 mov	 eax, DWORD PTR [rbx+60]
  000cb	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000ce	41 0f 44 c6	 cmove	 eax, r14d
  000d2	89 43 3c	 mov	 DWORD PTR [rbx+60], eax

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000d5	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  000d8	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000db	73 05		 jae	 SHORT $LN11@updatewind
  000dd	03 c7		 add	 eax, edi
$LN13@updatewind:
  000df	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000e2	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000e7	33 c0		 xor	 eax, eax
$LN1@updatewind:

; 444  : }

  000e9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ee	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1295 : {

$LN7:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1312 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1312 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1318 : {

$LN12:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f0	 mov	 esi, r8d
  00012	48 8b ea	 mov	 rbp, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00018	e8 00 00 00 00	 call	 inflateStateCheck
  0001d	85 c0		 test	 eax, eax
  0001f	74 15		 je	 SHORT $LN2@inflateSet
  00021	b8 fe ff ff ff	 mov	 eax, -2

; 1347 : }

  00026	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0002b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN2@inflateSet:
  00036	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0003b	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  0003f	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0
  00043	74 10		 je	 SHORT $LN3@inflateSet
  00045	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  0004c	74 10		 je	 SHORT $LN10@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0004e	b8 fe ff ff ff	 mov	 eax, -2
  00053	eb 58		 jmp	 SHORT $LN8@inflateSet
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00055	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  0005c	75 25		 jne	 SHORT $LN5@inflateSet
$LN10@inflateSet:

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  0005e	45 33 c0	 xor	 r8d, r8d
  00061	33 d2		 xor	 edx, edx
  00063	33 c9		 xor	 ecx, ecx
  00065	e8 00 00 00 00	 call	 adler32
  0006a	8b c8		 mov	 ecx, eax

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0006c	44 8b c6	 mov	 r8d, esi
  0006f	48 8b d5	 mov	 rdx, rbp
  00072	e8 00 00 00 00	 call	 adler32

; 1333 :         if (dictid != state->check)

  00077	3b 43 20	 cmp	 eax, DWORD PTR [rbx+32]
  0007a	74 07		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0007c	b8 fd ff ff ff	 mov	 eax, -3
  00081	eb 2a		 jmp	 SHORT $LN8@inflateSet
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00083	48 8d 14 2e	 lea	 rdx, QWORD PTR [rsi+rbp]
  00087	44 8b c6	 mov	 r8d, esi
  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	e8 00 00 00 00	 call	 updatewindow

; 1340 :     if (ret) {

  00092	85 c0		 test	 eax, eax
  00094	74 0e		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  00096	c7 43 08 52 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  0009d	b8 fc ff ff ff	 mov	 eax, -4
  000a2	eb 09		 jmp	 SHORT $LN8@inflateSet
$LN6@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  000a4	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [rbx+20], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  000ab	33 c0		 xor	 eax, eax
$LN8@inflateSet:

; 1347 : }

  000ad	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1352 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateGet
$LN5@inflateGet:
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1364 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0001b	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  0001f	74 ec		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00021	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1362 :     head->done = 0;
; 1363 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax
  00027	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1364 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1381 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1386 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d8	 mov	 r11d, r8d
  0000c	4c 8b d1	 mov	 r10, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1387 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 46		 je	 SHORT $LN13@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 35		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 12		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])

  00034	45 84 c0	 test	 r8b, r8b
  00037	74 04		 je	 SHORT $LN6@syncsearch

; 1391 :             got = 0;

  00039	8b c3		 mov	 eax, ebx
  0003b	eb 09		 jmp	 SHORT $LN7@syncsearch
$LN6@syncsearch:

; 1392 :         else
; 1393 :             got = 4 - got;

  0003d	b9 04 00 00 00	 mov	 ecx, 4
  00042	2b c8		 sub	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
$LN7@syncsearch:

; 1394 :         next++;

  00046	41 ff c1	 inc	 r9d
  00049	48 ff c2	 inc	 rdx
  0004c	45 3b cb	 cmp	 r9d, r11d
  0004f	72 c6		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00051	41 89 02	 mov	 DWORD PTR [r10], eax

; 1397 :     return next;

  00054	41 8b c1	 mov	 eax, r9d

; 1398 : }

  00057	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005c	c3		 ret	 0
$LN13@syncsearch:
  0005d	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00062	89 01		 mov	 DWORD PTR [rcx], eax
  00064	41 8b c1	 mov	 eax, r9d
  00067	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
inflateSync PROC					; COMDAT

; 1402 : {

$LN17:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1441 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5e		 pop	 rsi
  0001c	c3		 ret	 0
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00021	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00026	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0002a	75 16		 jne	 SHORT $LN5@inflateSyn
  0002c	83 7f 4c 08	 cmp	 DWORD PTR [rdi+76], 8
  00030	73 10		 jae	 SHORT $LN5@inflateSyn
  00032	b8 fb ff ff ff	 mov	 eax, -5
  00037	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1441 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5e		 pop	 rsi
  00041	c3		 ret	 0
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00042	81 7f 08 53 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16211 ; 00003f53H
  00049	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004e	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00053	74 61		 je	 SHORT $LN6@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00055	8b 57 4c	 mov	 edx, DWORD PTR [rdi+76]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  00058	45 33 c0	 xor	 r8d, r8d
  0005b	8b ca		 mov	 ecx, edx
  0005d	c7 47 08 53 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16211 ; 00003f53H
  00064	83 e1 07	 and	 ecx, 7
  00067	d3 67 48	 shl	 DWORD PTR [rdi+72], cl
  0006a	2b d1		 sub	 edx, ecx
  0006c	89 57 4c	 mov	 DWORD PTR [rdi+76], edx

; 1419 :         while (state->bits >= 8) {

  0006f	83 fa 08	 cmp	 edx, 8
  00072	72 2b		 jb	 SHORT $LN3@inflateSyn
  00074	44 8b 4f 48	 mov	 r9d, DWORD PTR [rdi+72]
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00080	0f b6 47 48	 movzx	 eax, BYTE PTR [rdi+72]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00084	83 c2 f8	 add	 edx, -8			; fffffff8H
  00087	41 c1 e9 08	 shr	 r9d, 8
  0008b	42 88 44 04 38	 mov	 BYTE PTR buf$[rsp+r8], al
  00090	41 ff c0	 inc	 r8d
  00093	44 89 4f 48	 mov	 DWORD PTR [rdi+72], r9d
  00097	83 fa 08	 cmp	 edx, 8
  0009a	73 e4		 jae	 SHORT $LL2@inflateSyn
  0009c	89 57 4c	 mov	 DWORD PTR [rdi+76], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0009f	48 8d 8f 84 00
	00 00		 lea	 rcx, QWORD PTR [rdi+132]

; 1425 :         syncsearch(&(state->have), buf, len);

  000a6	48 8d 54 24 38	 lea	 rdx, QWORD PTR buf$[rsp]
  000ab	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  000b1	e8 00 00 00 00	 call	 syncsearch
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000b6	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000ba	48 8d 8f 84 00
	00 00		 lea	 rcx, QWORD PTR [rdi+132]
  000c1	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000c4	e8 00 00 00 00	 call	 syncsearch

; 1430 :     strm->avail_in -= len;
; 1431 :     strm->next_in += len;
; 1432 :     strm->total_in += len;

  000c9	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000cc	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000cf	8b 6e 0c	 mov	 ebp, DWORD PTR [rsi+12]
  000d2	8b c8		 mov	 ecx, eax
  000d4	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000d7	83 bf 84 00 00
	00 04		 cmp	 DWORD PTR [rdi+132], 4
  000de	74 07		 je	 SHORT $LN7@inflateSyn
  000e0	b8 fd ff ff ff	 mov	 eax, -3
  000e5	eb 1a		 jmp	 SHORT $LN15@inflateSyn
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000e7	8b 5e 1c	 mov	 ebx, DWORD PTR [rsi+28]

; 1437 :     inflateReset(strm);

  000ea	48 8b ce	 mov	 rcx, rsi
  000ed	e8 00 00 00 00	 call	 inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000f2	89 6e 0c	 mov	 DWORD PTR [rsi+12], ebp

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000f5	33 c0		 xor	 eax, eax
  000f7	89 5e 1c	 mov	 DWORD PTR [rsi+28], ebx
  000fa	c7 47 08 3f 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16191 ; 00003f3fH
$LN15@inflateSyn:
  00101	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00106	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1441 : }

  00110	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00114	5e		 pop	 rsi
  00115	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1453 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1459 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1459 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1464 : {

$LN16:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b e9	 mov	 rbp, rcx
  0000a	48 8b da	 mov	 rbx, rdx

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	0f 85 03 02 00
	00		 jne	 $LN3@inflateCop
  0001d	48 85 ed	 test	 rbp, rbp
  00020	0f 84 fa 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  00026	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002a	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00030	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00035	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00039	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0003e	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00043	41 bf 01 00 00
	00		 mov	 r15d, 1
  00049	41 8b d7	 mov	 edx, r15d
  0004c	ff 53 30	 call	 QWORD PTR [rbx+48]
  0004f	48 8b f8	 mov	 rdi, rax

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00052	48 85 c0	 test	 rax, rax
  00055	75 05		 jne	 SHORT $LN4@inflateCop
  00057	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
  0005a	eb 3b		 jmp	 SHORT $LN13@inflateCop
$LN4@inflateCop:
  0005c	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14

; 1479 :     window = Z_NULL;

  00061	45 33 f6	 xor	 r14d, r14d

; 1480 :     if (state->window != Z_NULL) {

  00064	4c 39 76 40	 cmp	 QWORD PTR [rsi+64], r14
  00068	74 43		 je	 SHORT $LN6@inflateCop

; 1481 :         window = (unsigned char FAR *)

  0006a	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  0006d	41 8b d7	 mov	 edx, r15d
  00070	d3 e2		 shl	 edx, cl
  00072	45 8b c7	 mov	 r8d, r15d
  00075	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00079	ff 53 30	 call	 QWORD PTR [rbx+48]
  0007c	4c 8b f0	 mov	 r14, rax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  0007f	48 85 c0	 test	 rax, rax
  00082	75 29		 jne	 SHORT $LN6@inflateCop

; 1484 :             ZFREE(source, copy);

  00084	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00088	48 8b d7	 mov	 rdx, rdi
  0008b	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1485 :             return Z_MEM_ERROR;

  0008e	41 8d 46 fc	 lea	 eax, QWORD PTR [r14-4]
$LN14@inflateCop:
  00092	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
$LN13@inflateCop:
  00097	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a1	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 1506 : }

  000a6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000aa	5d		 pop	 rbp
  000ab	5b		 pop	 rbx
  000ac	c3		 ret	 0
$LN6@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000ad	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000b0	48 8b c7	 mov	 rax, rdi
  000b3	48 8b ce	 mov	 rcx, rsi
  000b6	ba 37 00 00 00	 mov	 edx, 55			; 00000037H
  000bb	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000bf	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  000c3	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000c7	0f 10 43 20	 movups	 xmm0, XMMWORD PTR [rbx+32]
  000cb	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000cf	0f 10 4b 30	 movups	 xmm1, XMMWORD PTR [rbx+48]
  000d3	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000d7	0f 10 43 40	 movups	 xmm0, XMMWORD PTR [rbx+64]
  000db	0f 11 45 40	 movups	 XMMWORD PTR [rbp+64], xmm0
  000df	f2 0f 10 4b 50	 movsd	 xmm1, QWORD PTR [rbx+80]
  000e4	f2 0f 11 4d 50	 movsd	 QWORD PTR [rbp+80], xmm1
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@inflateCop:
  000f0	48 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [rax+128]
  000f7	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  000fa	48 8d 89 80 00
	00 00		 lea	 rcx, QWORD PTR [rcx+128]
  00101	0f 11 40 80	 movups	 XMMWORD PTR [rax-128], xmm0
  00105	0f 10 49 90	 movups	 xmm1, XMMWORD PTR [rcx-112]
  00109	0f 11 48 90	 movups	 XMMWORD PTR [rax-112], xmm1
  0010d	0f 10 41 a0	 movups	 xmm0, XMMWORD PTR [rcx-96]
  00111	0f 11 40 a0	 movups	 XMMWORD PTR [rax-96], xmm0
  00115	0f 10 49 b0	 movups	 xmm1, XMMWORD PTR [rcx-80]
  00119	0f 11 48 b0	 movups	 XMMWORD PTR [rax-80], xmm1
  0011d	0f 10 41 c0	 movups	 xmm0, XMMWORD PTR [rcx-64]
  00121	0f 11 40 c0	 movups	 XMMWORD PTR [rax-64], xmm0
  00125	0f 10 49 d0	 movups	 xmm1, XMMWORD PTR [rcx-48]
  00129	0f 11 48 d0	 movups	 XMMWORD PTR [rax-48], xmm1
  0012d	0f 10 41 e0	 movups	 xmm0, XMMWORD PTR [rcx-32]
  00131	0f 11 40 e0	 movups	 XMMWORD PTR [rax-32], xmm0
  00135	0f 10 49 f0	 movups	 xmm1, XMMWORD PTR [rcx-16]
  00139	0f 11 48 f0	 movups	 XMMWORD PTR [rax-16], xmm1
  0013d	49 2b d7	 sub	 rdx, r15
  00140	75 ae		 jne	 SHORT $LL10@inflateCop
  00142	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00145	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00148	0f 10 49 10	 movups	 xmm1, XMMWORD PTR [rcx+16]
  0014c	0f 11 48 10	 movups	 XMMWORD PTR [rax+16], xmm1
  00150	0f 10 41 20	 movups	 xmm0, XMMWORD PTR [rcx+32]
  00154	0f 11 40 20	 movups	 XMMWORD PTR [rax+32], xmm0
  00158	0f 10 49 30	 movups	 xmm1, XMMWORD PTR [rcx+48]
  0015c	0f 11 48 30	 movups	 XMMWORD PTR [rax+48], xmm1
  00160	0f 10 41 40	 movups	 xmm0, XMMWORD PTR [rcx+64]
  00164	0f 11 40 40	 movups	 XMMWORD PTR [rax+64], xmm0
  00168	0f 10 49 50	 movups	 xmm1, XMMWORD PTR [rcx+80]
  0016c	0f 11 48 50	 movups	 XMMWORD PTR [rax+80], xmm1
  00170	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  00174	0f 11 40 60	 movups	 XMMWORD PTR [rax+96], xmm0

; 1492 :     copy->strm = dest;

  00178	48 89 2f	 mov	 QWORD PTR [rdi], rbp

; 1493 :     if (state->lencode >= state->codes &&

  0017b	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  00182	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00186	48 3b c8	 cmp	 rcx, rax
  00189	72 47		 jb	 SHORT $LN7@inflateCop
  0018b	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  00192	48 3b c8	 cmp	 rcx, rax
  00195	77 3b		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00197	48 2b ce	 sub	 rcx, rsi
  0019a	48 8d 81 b0 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1360]
  001a1	48 c1 f8 02	 sar	 rax, 2
  001a5	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  001ab	48 8d 04 87	 lea	 rax, QWORD PTR [rdi+rax*4]
  001af	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  001b3	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  001b7	48 2b c6	 sub	 rax, rsi
  001ba	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  001c0	48 c1 f8 02	 sar	 rax, 2
  001c4	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  001ca	48 8d 04 87	 lea	 rax, QWORD PTR [rdi+rax*4]
  001ce	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  001d2	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  001d9	48 2b c6	 sub	 rax, rsi
  001dc	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  001e2	48 c1 f8 02	 sar	 rax, 2
  001e6	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  001ec	48 8d 04 87	 lea	 rax, QWORD PTR [rdi+rax*4]
  001f0	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax

; 1499 :     if (window != Z_NULL) {

  001f7	4d 85 f6	 test	 r14, r14
  001fa	74 15		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  001fc	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1501 :         zmemcpy(window, state->window, wsize);

  001ff	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00203	41 d3 e7	 shl	 r15d, cl
  00206	49 8b ce	 mov	 rcx, r14
  00209	45 8b c7	 mov	 r8d, r15d
  0020c	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00211	4c 89 77 40	 mov	 QWORD PTR [rdi+64], r14

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00215	33 c0		 xor	 eax, eax
  00217	48 89 7d 28	 mov	 QWORD PTR [rbp+40], rdi
  0021b	e9 72 fe ff ff	 jmp	 $LN14@inflateCop
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00220	b8 fe ff ff ff	 mov	 eax, -2

; 1506 : }

  00225	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00229	5d		 pop	 rbp
  0022a	5b		 pop	 rbx
  0022b	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1511 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1523 : #endif
; 1524 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1523 : #endif
; 1524 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1529 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateVal
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1539 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1534 :     if (check)

  0001b	85 d2		 test	 edx, edx
  0001d	74 0b		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  0001f	83 48 10 04	 or	 DWORD PTR [rax+16], 4

; 1538 :     return Z_OK;

  00023	33 c0		 xor	 eax, eax

; 1539 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  0002a	83 60 10 fb	 and	 DWORD PTR [rax+16], -5

; 1538 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1539 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1543 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1556 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 08		 je	 SHORT $LN2@inflateCod
  0000d	83 c8 ff	 or	 eax, -1			; ffffffffH

; 1561 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00015	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00020	48 2b c1	 sub	 rax, rcx
  00023	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  00029	48 c1 f8 02	 sar	 rax, 2

; 1561 : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
