; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	c:\cpython\externals\zlib-1.2.11\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress@16
PUBLIC	_uncompress2@16
; Function compile flags: /Ogtp
; File C:\CPython\externals\zlib-1.2.11\uncompr.c
;	COMDAT _uncompress2@16
_TEXT	SEGMENT
_buf$ = -57						; size = 1
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress2@16 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;
; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;
; 40   :     if (*destLen) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00009	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0000c	53		 push	 ebx
  0000d	8b 5d 14	 mov	 ebx, DWORD PTR _sourceLen$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 38		 mov	 edi, DWORD PTR [eax]
  00014	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00016	85 ff		 test	 edi, edi
  00018	74 0b		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;
; 42   :         *destLen = 0;
; 43   :     }

  0001a	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00023	eb 0c		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;
; 46   :         dest = buf;

  00025	8d 74 24 0f	 lea	 esi, DWORD PTR _buf$[esp+72]
  00029	bf 01 00 00 00	 mov	 edi, 1
  0002e	89 75 08	 mov	 DWORD PTR _dest$[ebp], esi
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  00031	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]

; 50   :     stream.avail_in = 0;
; 51   :     stream.zalloc = (alloc_func)0;
; 52   :     stream.zfree = (free_func)0;
; 53   :     stream.opaque = (voidpf)0;
; 54   : 
; 55   :     err = inflateInit(&stream);

  00034	6a 38		 push	 56			; 00000038H
  00036	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax
  0003a	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  00043	50		 push	 eax
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+88], 0
  0004c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+116], 0
  00054	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+120], 0
  0005c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+124], 0
  00064	e8 00 00 00 00	 call	 _inflateInit_@12

; 56   :     if (err != Z_OK) return err;

  00069	85 c0		 test	 eax, eax
  0006b	0f 85 b6 00 00
	00		 jne	 $LN1@uncompress

; 57   : 
; 58   :     stream.next_out = dest;

  00071	89 74 24 1c	 mov	 DWORD PTR _stream$[esp+84], esi

; 59   :     stream.avail_out = 0;

  00075	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax
$LN28@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  00079	83 c9 ff	 or	 ecx, -1
  0007c	85 c0		 test	 eax, eax
  0007e	75 0d		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00080	3b f9		 cmp	 edi, ecx
  00082	8b c7		 mov	 eax, edi
  00084	0f 47 c1	 cmova	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR _stream$[esp+88], eax

; 64   :             left -= stream.avail_out;

  0008b	2b f8		 sub	 edi, eax
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  0008d	83 7c 24 14 00	 cmp	 DWORD PTR _stream$[esp+76], 0
  00092	75 0e		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  00094	83 fb ff	 cmp	 ebx, -1
  00097	8b c3		 mov	 eax, ebx
  00099	0f 47 c1	 cmova	 eax, ecx
  0009c	89 44 24 14	 mov	 DWORD PTR _stream$[esp+76], eax

; 68   :             len -= stream.avail_in;

  000a0	2b d8		 sub	 ebx, eax
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000a2	6a 00		 push	 0
  000a4	8d 44 24 14	 lea	 eax, DWORD PTR _stream$[esp+76]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _inflate@8
  000ae	8b f0		 mov	 esi, eax

; 71   :     } while (err == Z_OK);

  000b0	85 f6		 test	 esi, esi
  000b2	75 06		 jne	 SHORT $LN27@uncompress
  000b4	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  000b8	eb bf		 jmp	 SHORT $LN28@uncompress
$LN27@uncompress:

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000ba	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  000bd	8b 44 24 14	 mov	 eax, DWORD PTR _stream$[esp+76]
  000c1	03 c3		 add	 eax, ebx
  000c3	29 01		 sub	 DWORD PTR [ecx], eax

; 74   :     if (dest != buf)

  000c5	8d 44 24 0f	 lea	 eax, DWORD PTR _buf$[esp+72]
  000c9	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  000cc	74 25		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000d1	8b 44 24 24	 mov	 eax, DWORD PTR _stream$[esp+92]
  000d5	89 01		 mov	 DWORD PTR [ecx], eax
$LN12@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  000d7	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _inflateEnd@4

; 80   :     return err == Z_STREAM_END ? Z_OK :

  000e1	83 fe 01	 cmp	 esi, 1
  000e4	75 28		 jne	 SHORT $LN18@uncompress
  000e6	33 f6		 xor	 esi, esi
  000e8	8b c6		 mov	 eax, esi

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 10 00	 ret	 16			; 00000010H
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  000f3	83 7c 24 24 00	 cmp	 DWORD PTR _stream$[esp+92], 0
  000f8	74 dd		 je	 SHORT $LN12@uncompress
  000fa	83 fe fb	 cmp	 esi, -5			; fffffffbH
  000fd	75 d8		 jne	 SHORT $LN12@uncompress

; 77   :         left = 1;

  000ff	8d 44 24 10	 lea	 eax, DWORD PTR _stream$[esp+72]
  00103	50		 push	 eax
  00104	8d 7e 06	 lea	 edi, DWORD PTR [esi+6]
  00107	e8 00 00 00 00	 call	 _inflateEnd@4
  0010c	eb 0a		 jmp	 SHORT $LN23@uncompress
$LN18@uncompress:

; 80   :     return err == Z_STREAM_END ? Z_OK :

  0010e	83 fe 02	 cmp	 esi, 2
  00111	74 0d		 je	 SHORT $LN29@uncompress
  00113	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00116	75 0d		 jne	 SHORT $LN15@uncompress
$LN23@uncompress:
  00118	8b 44 24 20	 mov	 eax, DWORD PTR _stream$[esp+88]
  0011c	03 c7		 add	 eax, edi
  0011e	74 05		 je	 SHORT $LN15@uncompress
$LN29@uncompress:
  00120	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
$LN15@uncompress:
  00125	8b c6		 mov	 eax, esi
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 10 00	 ret	 16			; 00000010H
_uncompress2@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\CPython\externals\zlib-1.2.11\uncompr.c
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00003	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR _source$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _destLen$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  00010	e8 00 00 00 00	 call	 _uncompress2@16

; 93   : }

  00015	5d		 pop	 ebp
  00016	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
_TEXT	ENDS
END
