; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	c:\cpython\externals\zlib-1.2.11\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File C:\CPython\externals\zlib-1.2.11\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -72						; size = 4
_op$7$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_end$1$ = -60						; size = 4
_last$1$ = -56						; size = 4
_window$1$ = -52					; size = 4
_wsize$1$ = -48						; size = 4
_dcode$1$ = -44						; size = 4
_lcode$1$ = -40						; size = 4
_op$6$ = -36						; size = 4
_op$3$ = -36						; size = 4
_bits$1$ = -36						; size = 4
_wnext$1$ = -32						; size = 4
_dmask$1$ = -28						; size = 4
_lmask$1$ = -24						; size = 4
_state$1$ = -20						; size = 4
_strm$1$ = -16						; size = 4
$T1 = -12						; size = 4
_dist$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d f0	 mov	 DWORD PTR _strm$1$[ebp], edi

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);

  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	83 c0 fb	 add	 eax, -5			; fffffffbH

; 84   :     out = strm->next_out;

  00019	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001c	03 c3		 add	 eax, ebx
  0001e	89 45 c8	 mov	 DWORD PTR _last$1$[ebp], eax

; 85   :     beg = out - (start - strm->avail_out);

  00021	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00024	8b f8		 mov	 edi, eax

; 86   :     end = out + (strm->avail_out - 257);

  00026	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0002b	89 4d ec	 mov	 DWORD PTR _state$1$[ebp], ecx
  0002e	03 c6		 add	 eax, esi
  00030	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	89 45 c4	 mov	 DWORD PTR _end$1$[ebp], eax
  00036	2b fa		 sub	 edi, edx

; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;

  00038	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003b	03 fe		 add	 edi, esi

; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;

  0003d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00040	89 45 d0	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00043	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00046	89 45 b8	 mov	 DWORD PTR _whave$1$[ebp], eax
  00049	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004c	89 45 e0	 mov	 DWORD PTR _wnext$1$[ebp], eax
  0004f	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00052	89 45 cc	 mov	 DWORD PTR _window$1$[ebp], eax

; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;

  00055	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00058	89 45 d8	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 97   :     dcode = state->distcode;

  0005b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0005e	89 45 d4	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 98   :     lmask = (1U << state->lenbits) - 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 99   :     dmask = (1U << state->distbits) - 1;

  00069	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0006f	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00072	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  00075	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00078	d3 65 e8	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0007e	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00081	ff 4d e8	 dec	 DWORD PTR _lmask$1$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	48		 dec	 eax
  00087	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  00095	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00098	8b cf		 mov	 ecx, edi
  0009a	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  0009c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0009f	03 d0		 add	 edx, eax
  000a1	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  000a5	d3 e0		 shl	 eax, cl
  000a7	83 c3 02	 add	 ebx, 2
  000aa	03 d0		 add	 edx, eax
  000ac	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx

; 108  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000bd	8b c8		 mov	 ecx, eax
  000bf	c1 e9 08	 shr	 ecx, 8
  000c2	0f b6 c9	 movzx	 ecx, cl

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);
; 113  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 114  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000cc	0f b6 c8	 movzx	 ecx, al

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  000cf	84 c0		 test	 al, al
  000d1	74 4a		 je	 SHORT $LN72@inflate_fa

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000d3	8b d8		 mov	 ebx, eax
  000d5	c1 eb 10	 shr	 ebx, 16			; 00000010H
$dolen$106:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000d8	f6 c1 10	 test	 cl, 16			; 00000010H
  000db	75 4b		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000dd	f6 c1 40	 test	 cl, 64			; 00000040H
  000e0	0f 85 04 03 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000e6	ba 01 00 00 00	 mov	 edx, 1
  000eb	c1 e8 10	 shr	 eax, 16			; 00000010H
  000ee	d3 e2		 shl	 edx, cl
  000f0	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000f3	4a		 dec	 edx
  000f4	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  000f7	03 d0		 add	 edx, eax
  000f9	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000fc	8b d8		 mov	 ebx, eax
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00101	8b cb		 mov	 ecx, ebx
  00103	c1 e9 08	 shr	 ecx, 8
  00106	0f b6 c9	 movzx	 ecx, cl
  00109	d3 ea		 shr	 edx, cl
  0010b	2b f9		 sub	 edi, ecx
  0010d	0f b6 cb	 movzx	 ecx, bl
  00110	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00113	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00116	85 c9		 test	 ecx, ecx
  00118	75 be		 jne	 SHORT $dolen$106

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  0011a	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  0011d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00120	88 06		 mov	 BYTE PTR [esi], al
  00122	46		 inc	 esi

; 244  :                     }
; 245  :                     if (len) {

  00123	e9 6c 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);
; 124  :             op &= 15;                           /* number of extra bits */

  00128	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0012b	89 4d dc	 mov	 DWORD PTR _op$3$[ebp], ecx

; 125  :             if (op) {

  0012e	74 29		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  00130	3b f9		 cmp	 edi, ecx
  00132	73 15		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00137	8b cf		 mov	 ecx, edi
  00139	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  0013c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0013f	d3 e0		 shl	 eax, cl
  00141	8b 4d dc	 mov	 ecx, DWORD PTR _op$3$[ebp]
  00144	03 d0		 add	 edx, eax

; 128  :                     bits += 8;

  00146	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	d3 e0		 shl	 eax, cl
  00150	48		 dec	 eax
  00151	23 c2		 and	 eax, edx

; 131  :                 hold >>= op;

  00153	d3 ea		 shr	 edx, cl
  00155	03 d8		 add	 ebx, eax

; 132  :                 bits -= op;

  00157	2b f9		 sub	 edi, ecx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  00159	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0015c	73 23		 jae	 SHORT $LN29@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00161	8b cf		 mov	 ecx, edi
  00163	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00166	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00168	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0016b	03 d0		 add	 edx, eax
  0016d	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00170	40		 inc	 eax
  00171	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00174	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00177	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0017a	d3 e0		 shl	 eax, cl
  0017c	03 d0		 add	 edx, eax

; 139  :                 bits += 8;

  0017e	83 c7 10	 add	 edi, 16			; 00000010H
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  00181	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00184	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00187	23 c2		 and	 eax, edx
  00189	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0018c	8b c8		 mov	 ecx, eax
  0018e	c1 e9 08	 shr	 ecx, 8
  00191	0f b6 c9	 movzx	 ecx, cl

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);
; 144  :             hold >>= op;

  00194	d3 ea		 shr	 edx, cl

; 145  :             bits -= op;

  00196	2b f9		 sub	 edi, ecx
  00198	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0019b	c1 6d f4 10	 shr	 DWORD PTR $T1[ebp], 16	; 00000010H
  0019f	0f b6 c8	 movzx	 ecx, al
  001a2	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 146  :             op = (unsigned)(here.op);
; 147  :             if (op & 16) {                      /* distance base */

  001a5	f6 c1 10	 test	 cl, 16			; 00000010H
  001a8	75 48		 jne	 SHORT $LN74@inflate_fa
  001aa	66 0f 1f 44 00
	00		 npad	 6
$dodist$107:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001b0	f6 c1 40	 test	 cl, 64			; 00000040H
  001b3	0f 85 58 02 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001b9	ba 01 00 00 00	 mov	 edx, 1
  001be	c1 e8 10	 shr	 eax, 16			; 00000010H
  001c1	d3 e2		 shl	 edx, cl
  001c3	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  001c6	4a		 dec	 edx
  001c7	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  001ca	03 d0		 add	 edx, eax
  001cc	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001cf	8b c8		 mov	 ecx, eax
  001d1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001d4	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  001d7	c1 6d f4 10	 shr	 DWORD PTR $T1[ebp], 16	; 00000010H
  001db	c1 e9 08	 shr	 ecx, 8
  001de	0f b6 c9	 movzx	 ecx, cl
  001e1	d3 ea		 shr	 edx, cl
  001e3	2b f9		 sub	 edi, ecx
  001e5	8b c8		 mov	 ecx, eax
  001e7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001ea	0f b6 c9	 movzx	 ecx, cl
  001ed	f6 c1 10	 test	 cl, 16			; 00000010H
  001f0	74 be		 je	 SHORT $dodist$107
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);
; 149  :                 op &= 15;                       /* number of extra bits */

  001f2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f5	89 4d dc	 mov	 DWORD PTR _op$6$[ebp], ecx

; 150  :                 if (bits < op) {

  001f8	3b f9		 cmp	 edi, ecx
  001fa	73 2f		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  001fc	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  001ff	8b cf		 mov	 ecx, edi

; 152  :                     bits += 8;

  00201	83 c7 08	 add	 edi, 8
  00204	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00207	d3 e0		 shl	 eax, cl

; 153  :                     if (bits < op) {

  00209	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  0020c	03 d0		 add	 edx, eax
  0020e	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00211	40		 inc	 eax
  00212	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00215	3b f9		 cmp	 edi, ecx
  00217	73 12		 jae	 SHORT $LN33@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  00219	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0021c	8b cf		 mov	 ecx, edi
  0021e	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00221	d3 e0		 shl	 eax, cl
  00223	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  00226	03 d0		 add	 edx, eax

; 155  :                         bits += 8;

  00228	83 c7 08	 add	 edi, 8
$LN33@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0022b	b8 01 00 00 00	 mov	 eax, 1

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;

  00230	2b f9		 sub	 edi, ecx
  00232	d3 e0		 shl	 eax, cl
  00234	48		 dec	 eax
  00235	89 7d dc	 mov	 DWORD PTR _bits$1$[ebp], edi
  00238	23 c2		 and	 eax, edx
  0023a	d3 ea		 shr	 edx, cl
  0023c	03 45 f4	 add	 eax, DWORD PTR $T1[ebp]

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  0023f	8b ce		 mov	 ecx, esi
  00241	2b 4d c0	 sub	 ecx, DWORD PTR _beg$1$[ebp]
  00244	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax
  00247	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0024a	89 4d bc	 mov	 DWORD PTR _op$7$[ebp], ecx

; 170  :                 if (dist > op) {                /* see if copy from window */

  0024d	3b c1		 cmp	 eax, ecx
  0024f	0f 86 fb 00 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  00255	8b c8		 mov	 ecx, eax
  00257	2b 4d bc	 sub	 ecx, DWORD PTR _op$7$[ebp]

; 172  :                     if (op > whave) {

  0025a	3b 4d b8	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0025d	76 10		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  0025f	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  00262	83 b8 c4 1b 00
	00 00		 cmp	 DWORD PTR [eax+7108], 0
  00269	0f 85 be 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;

  0026f	8b 45 cc	 mov	 eax, DWORD PTR _window$1$[ebp]

; 200  :                     if (wnext == 0) {           /* very common case */

  00272	8b 7d e0	 mov	 edi, DWORD PTR _wnext$1$[ebp]
  00275	2b c1		 sub	 eax, ecx
  00277	85 ff		 test	 edi, edi
  00279	75 1a		 jne	 SHORT $LN38@inflate_fa

; 201  :                         from += wsize - op;

  0027b	8b 7d d0	 mov	 edi, DWORD PTR _wsize$1$[ebp]
  0027e	03 f8		 add	 edi, eax

; 202  :                         if (op < len) {         /* some from window */

  00280	3b cb		 cmp	 ecx, ebx
  00282	73 73		 jae	 SHORT $LN69@inflate_fa

; 203  :                             len -= op;

  00284	2b d9		 sub	 ebx, ecx
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00286	8a 07		 mov	 al, BYTE PTR [edi]
  00288	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0028b	88 06		 mov	 BYTE PTR [esi], al
  0028d	46		 inc	 esi

; 206  :                             } while (--op);

  0028e	83 e9 01	 sub	 ecx, 1
  00291	75 f3		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  00293	eb 5d		 jmp	 SHORT $LN104@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */

  00295	03 f8		 add	 edi, eax
  00297	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  0029a	3b c1		 cmp	 eax, ecx
  0029c	73 41		 jae	 SHORT $LN41@inflate_fa

; 211  :                         from += wsize + wnext - op;

  0029e	03 7d d0	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 212  :                         op -= wnext;

  002a1	2b c8		 sub	 ecx, eax

; 213  :                         if (op < len) {         /* some from end of window */

  002a3	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  002a6	3b cb		 cmp	 ecx, ebx
  002a8	73 4d		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  002aa	2b d9		 sub	 ebx, ecx
  002ac	2b fe		 sub	 edi, esi
  002ae	66 90		 npad	 2
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  002b0	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  002b3	88 06		 mov	 BYTE PTR [esi], al
  002b5	46		 inc	 esi

; 217  :                             } while (--op);

  002b6	83 e9 01	 sub	 ecx, 1
  002b9	75 f5		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;
; 219  :                             if (wnext < len) {  /* some from start of window */

  002bb	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002be	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]
  002c1	3b c3		 cmp	 eax, ebx
  002c3	73 32		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002c5	8b c8		 mov	 ecx, eax

; 221  :                                 len -= op;

  002c7	2b d8		 sub	 ebx, eax
  002c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  002d0	8a 07		 mov	 al, BYTE PTR [edi]
  002d2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002d5	88 06		 mov	 BYTE PTR [esi], al
  002d7	46		 inc	 esi

; 224  :                                 } while (--op);

  002d8	83 e9 01	 sub	 ecx, 1
  002db	75 f3		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  002dd	eb 13		 jmp	 SHORT $LN104@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;
; 231  :                         if (op < len) {         /* some from window */

  002df	3b cb		 cmp	 ecx, ebx
  002e1	73 14		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  002e3	2b d9		 sub	 ebx, ecx
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  002e5	8a 07		 mov	 al, BYTE PTR [edi]
  002e7	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002ea	88 06		 mov	 BYTE PTR [esi], al
  002ec	46		 inc	 esi

; 235  :                             } while (--op);

  002ed	83 e9 01	 sub	 ecx, 1
  002f0	75 f3		 jne	 SHORT $LL16@inflate_fa
$LN104@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */
; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  002f2	8b fe		 mov	 edi, esi
  002f4	2b 7d f4	 sub	 edi, DWORD PTR _dist$1$[ebp]
$LN69@inflate_fa:
  002f7	83 fb 02	 cmp	 ebx, 2
  002fa	76 38		 jbe	 SHORT $LN18@inflate_fa
  002fc	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  002ff	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00304	f7 e1		 mul	 ecx
  00306	d1 ea		 shr	 edx, 1
  00308	42		 inc	 edx
  00309	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  00310	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  00313	83 eb 03	 sub	 ebx, 3
  00316	88 06		 mov	 BYTE PTR [esi], al
  00318	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0031c	88 46 01	 mov	 BYTE PTR [esi+1], al
  0031f	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00323	83 c7 03	 add	 edi, 3
  00326	88 46 02	 mov	 BYTE PTR [esi+2], al
  00329	83 c6 03	 add	 esi, 3
  0032c	83 ea 01	 sub	 edx, 1
  0032f	75 df		 jne	 SHORT $LL17@inflate_fa
  00331	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  00334	85 db		 test	 ebx, ebx
  00336	74 56		 je	 SHORT $LN98@inflate_fa

; 246  :                         *out++ = *from++;

  00338	8a 07		 mov	 al, BYTE PTR [edi]
  0033a	88 06		 mov	 BYTE PTR [esi], al
  0033c	46		 inc	 esi

; 247  :                         if (len > 1)

  0033d	83 fb 01	 cmp	 ebx, 1
  00340	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00343	76 06		 jbe	 SHORT $LN99@inflate_fa

; 248  :                             *out++ = *from++;

  00345	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00348	88 06		 mov	 BYTE PTR [esi], al
  0034a	46		 inc	 esi
$LN99@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  0034b	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
  0034e	eb 44		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 249  :                     }
; 250  :                 }
; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  00350	8b ce		 mov	 ecx, esi
  00352	2b c8		 sub	 ecx, eax
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  00354	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  00357	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  0035a	88 06		 mov	 BYTE PTR [esi], al

; 257  :                         len -= 3;

  0035c	83 eb 03	 sub	 ebx, 3
  0035f	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  00363	88 46 01	 mov	 BYTE PTR [esi+1], al
  00366	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  0036a	88 46 02	 mov	 BYTE PTR [esi+2], al
  0036d	83 c6 03	 add	 esi, 3

; 258  :                     } while (len > 2);

  00370	83 fb 02	 cmp	 ebx, 2
  00373	77 df		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  00375	85 db		 test	 ebx, ebx
  00377	74 18		 je	 SHORT $LN101@inflate_fa

; 260  :                         *out++ = *from++;

  00379	8a 01		 mov	 al, BYTE PTR [ecx]
  0037b	88 06		 mov	 BYTE PTR [esi], al
  0037d	46		 inc	 esi

; 261  :                         if (len > 1)

  0037e	83 fb 01	 cmp	 ebx, 1
  00381	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00384	76 0e		 jbe	 SHORT $LN2@inflate_fa

; 262  :                             *out++ = *from++;

  00386	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00389	88 06		 mov	 BYTE PTR [esi], al
  0038b	46		 inc	 esi
  0038c	eb 06		 jmp	 SHORT $LN2@inflate_fa
$LN98@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  0038e	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN101@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00391	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN2@inflate_fa:
  00394	3b 5d c8	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  00397	73 09		 jae	 SHORT $LN103@inflate_fa
  00399	3b 75 c4	 cmp	 esi, DWORD PTR _end$1$[ebp]
  0039c	0f 82 ee fc ff
	ff		 jb	 $LL4@inflate_fa
$LN103@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  003a2	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
$LN3@inflate_fa:
  003a5	8b c7		 mov	 eax, edi

; 294  :     in -= len;
; 295  :     bits -= len << 3;
; 296  :     hold &= (1U << bits) - 1;
; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;
; 300  :     strm->next_out = out;

  003a7	89 71 0c	 mov	 DWORD PTR [ecx+12], esi
  003aa	c1 e8 03	 shr	 eax, 3
  003ad	2b d8		 sub	 ebx, eax
  003af	c1 e0 03	 shl	 eax, 3
  003b2	2b f8		 sub	 edi, eax
  003b4	89 19		 mov	 DWORD PTR [ecx], ebx

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  003b6	8b 45 c8	 mov	 eax, DWORD PTR _last$1$[ebp]
  003b9	2b c3		 sub	 eax, ebx
  003bb	83 c0 05	 add	 eax, 5
  003be	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 302  :     strm->avail_out = (unsigned)(out < end ?

  003c1	8b 45 c4	 mov	 eax, DWORD PTR _end$1$[ebp]
  003c4	2b c6		 sub	 eax, esi
  003c6	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003cb	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  003ce	8b cf		 mov	 ecx, edi
  003d0	b8 01 00 00 00	 mov	 eax, 1
  003d5	d3 e0		 shl	 eax, cl

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;

  003d7	8b 4d ec	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003da	48		 dec	 eax
  003db	23 c2		 and	 eax, edx

; 305  :     state->bits = bits;

  003dd	89 79 40	 mov	 DWORD PTR [ecx+64], edi
  003e0	5f		 pop	 edi
  003e1	5e		 pop	 esi
  003e2	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  003e5	5b		 pop	 ebx

; 306  :     return;
; 307  : }

  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c3		 ret	 0
$LN52@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

  003ea	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003ed	f6 c1 20	 test	 cl, 32			; 00000020H
  003f0	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  003f3	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  003f6	74 09		 je	 SHORT $LN54@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  003f8	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 283  :             break;

  003ff	eb a4		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  00401	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 287  :             state->mode = BAD;

  00408	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
  0040f	eb 94		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  00411	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]

; 272  :                 state->mode = BAD;

  00414	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]

; 273  :                 break;

  00417	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  0041a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00421	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
  00428	e9 78 ff ff ff	 jmp	 $LN3@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  0042d	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  00430	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00433	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;

  0043a	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00441	e9 5f ff ff ff	 jmp	 $LN3@inflate_fa
_inflate_fast ENDP
_TEXT	ENDS
END
