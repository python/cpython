; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN178
	DD	imagerel $LN178+303
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN178+303
	DD	imagerel $LN178+1286
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN178+1286
	DD	imagerel $LN178+1305
	DD	imagerel $chain$1$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 021H
	DD	imagerel $LN178
	DD	imagerel $LN178+303
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020521H
	DD	0f7405H
	DD	imagerel $LN178
	DD	imagerel $LN178+303
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082301H
	DD	0f019f223H
	DD	0d015e017H
	DD	06011c013H
	DD	0500f3010H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
match$1$ = 0
drop$1$ = 4
mask$1$ = 8
sym$1$ = 12
tv1918 = 16
extra$1$ = 24
base$1$ = 32
count$ = 40
offs$ = 72
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN178:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 8b ec	 mov	 rbp, rsp
  0001c	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00023	45 33 e4	 xor	 r12d, r12d
  00026	41 8b d8	 mov	 ebx, r8d
  00029	45 0f b7 d4	 movzx	 r10d, r12w
  0002d	4d 8b f9	 mov	 r15, r9
  00030	41 8b c2	 mov	 eax, r10d
  00033	4c 8b f2	 mov	 r14, rdx
  00036	41 c1 e2 10	 shl	 r10d, 16
  0003a	8b f1		 mov	 esi, ecx
  0003c	44 0b d0	 or	 r10d, eax
  0003f	66 41 0f 6e c2	 movd	 xmm0, r10d
  00044	66 0f 70 c0 00	 pshufd	 xmm0, xmm0, 0
  00049	0f 11 45 a8	 movups	 XMMWORD PTR count$[rbp-128], xmm0
  0004d	0f 11 45 b8	 movups	 XMMWORD PTR count$[rbp-112], xmm0

; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  00051	45 85 c0	 test	 r8d, r8d
  00054	74 1c		 je	 SHORT $LN6@inflate_ta
  00056	48 8b ca	 mov	 rcx, rdx
  00059	8b d3		 mov	 edx, ebx
  0005b	0f 1f 44 00 00	 npad	 5
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00060	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00063	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00067	66 ff 44 45 a8	 inc	 WORD PTR count$[rbp+rax*2-128]
  0006c	48 83 ea 01	 sub	 rdx, 1
  00070	75 ee		 jne	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00072	4c 8b 55 60	 mov	 r10, QWORD PTR bits$[rbp-128]
  00076	ba 0d 00 00 00	 mov	 edx, 13

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0007b	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00081	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  00084	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00090	41 8b c1	 mov	 eax, r9d
  00093	41 bd ff ff ff
	ff		 mov	 r13d, -1		; ffffffffH
  00099	66 44 39 64 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r12w
  0009f	75 4f		 jne	 SHORT $LN78@inflate_ta
  000a1	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000a4	66 44 39 64 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r12w
  000aa	75 41		 jne	 SHORT $LN130@inflate_ta
  000ac	8b c2		 mov	 eax, edx
  000ae	66 44 39 64 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r12w
  000b4	75 31		 jne	 SHORT $LN131@inflate_ta
  000b6	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000b9	66 44 39 64 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r12w
  000bf	75 20		 jne	 SHORT $LN132@inflate_ta
  000c1	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000c4	66 44 39 64 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r12w
  000ca	75 0f		 jne	 SHORT $LN133@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000cc	41 83 c1 fb	 add	 r9d, -5			; fffffffbH
  000d0	83 c2 fb	 add	 edx, -5			; fffffffbH
  000d3	41 83 f9 01	 cmp	 r9d, 1
  000d7	73 b7		 jae	 SHORT $LL10@inflate_ta
  000d9	eb 15		 jmp	 SHORT $LN78@inflate_ta
$LN133@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000db	41 83 c1 fc	 add	 r9d, -4			; fffffffcH
  000df	eb 0f		 jmp	 SHORT $LN78@inflate_ta
$LN132@inflate_ta:
  000e1	41 83 c1 fd	 add	 r9d, -3			; fffffffdH
  000e5	eb 09		 jmp	 SHORT $LN78@inflate_ta
$LN131@inflate_ta:
  000e7	41 83 c1 fe	 add	 r9d, -2			; fffffffeH
  000eb	eb 03		 jmp	 SHORT $LN78@inflate_ta
$LN130@inflate_ta:
  000ed	45 03 cd	 add	 r9d, r13d
$LN78@inflate_ta:

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000f0	45 3b c1	 cmp	 r8d, r9d
  000f3	41 8b c9	 mov	 ecx, r9d
  000f6	41 0f 46 c8	 cmovbe	 ecx, r8d
  000fa	45 85 c9	 test	 r9d, r9d
  000fd	75 2a		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000ff	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00102	c7 45 50 40 01
	00 00		 mov	 DWORD PTR here$[rbp-128], 320 ; 00000140H
  00109	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  0010c	89 01		 mov	 DWORD PTR [rcx], eax
  0010e	49 83 07 04	 add	 QWORD PTR [r15], 4
  00112	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00115	89 01		 mov	 DWORD PTR [rcx], eax
  00117	49 83 07 04	 add	 QWORD PTR [r15], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0011b	33 c0		 xor	 eax, eax
  0011d	41 c7 02 01 00
	00 00		 mov	 DWORD PTR [r10], 1
  00124	e9 dd 03 00 00	 jmp	 $LN1@inflate_ta
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00129	41 bb 01 00 00
	00		 mov	 r11d, 1
  0012f	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  00134	45 3b cb	 cmp	 r9d, r11d
  00137	76 19		 jbe	 SHORT $LN163@inflate_ta
  00139	48 8d 45 aa	 lea	 rax, QWORD PTR count$[rbp-126]
  0013d	0f 1f 00	 npad	 3
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  00140	66 44 39 20	 cmp	 WORD PTR [rax], r12w
  00144	75 0c		 jne	 SHORT $LN163@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00146	41 ff c3	 inc	 r11d
  00149	48 83 c0 02	 add	 rax, 2
  0014d	45 3b d9	 cmp	 r11d, r9d
  00150	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN163@inflate_ta:

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00152	41 3b cb	 cmp	 ecx, r11d
  00155	41 8b fb	 mov	 edi, r11d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00158	ba 01 00 00 00	 mov	 edx, 1
  0015d	0f 43 f9	 cmovae	 edi, ecx
  00160	44 8b c2	 mov	 r8d, edx
  00163	89 7d 90	 mov	 DWORD PTR tv1918[rbp-128], edi
  00166	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00170	8b c2		 mov	 eax, edx
  00172	45 03 c0	 add	 r8d, r8d
  00175	0f b7 4c 45 a8	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  0017a	44 2b c1	 sub	 r8d, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0017d	0f 88 79 03 00
	00		 js	 $LN42@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00183	ff c2		 inc	 edx
  00185	83 fa 0f	 cmp	 edx, 15
  00188	76 e6		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  0018a	45 85 c0	 test	 r8d, r8d
  0018d	7e 12		 jle	 SHORT $LN41@inflate_ta
  0018f	85 f6		 test	 esi, esi
  00191	0f 84 65 03 00
	00		 je	 $LN42@inflate_ta
  00197	41 83 f9 01	 cmp	 r9d, 1
  0019b	0f 85 5b 03 00
	00		 jne	 $LN42@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001a1	66 44 89 65 ca	 mov	 WORD PTR offs$[rbp-126], r12w
  001a6	49 8b cc	 mov	 rcx, r12
  001a9	ba 0e 00 00 00	 mov	 edx, 14
  001ae	66 90		 npad	 2
$LL19@inflate_ta:

; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  001b0	0f b7 44 0d aa	 movzx	 eax, WORD PTR count$[rbp+rcx-126]
  001b5	66 03 44 0d ca	 add	 ax, WORD PTR offs$[rbp+rcx-126]
  001ba	66 89 44 0d cc	 mov	 WORD PTR offs$[rbp+rcx-124], ax
  001bf	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  001c3	48 83 ea 01	 sub	 rdx, 1
  001c7	75 e7		 jne	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001c9	45 8b c4	 mov	 r8d, r12d
  001cc	85 db		 test	 ebx, ebx
  001ce	74 2d		 je	 SHORT $LN21@inflate_ta
  001d0	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]
  001d4	49 8b d6	 mov	 rdx, r14
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001d7	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001da	66 85 c0	 test	 ax, ax
  001dd	74 12		 je	 SHORT $LN20@inflate_ta
  001df	0f b7 4c 45 c8	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-128]
  001e4	66 45 89 04 4a	 mov	 WORD PTR [r10+rcx*2], r8w
  001e9	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001ec	66 ff 44 45 c8	 inc	 WORD PTR offs$[rbp+rax*2-128]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001f1	41 ff c0	 inc	 r8d
  001f4	48 83 c2 02	 add	 rdx, 2
  001f8	44 3b c3	 cmp	 r8d, ebx
  001fb	72 da		 jb	 SHORT $LL22@inflate_ta
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  001fd	4d 8b 3f	 mov	 r15, QWORD PTR [r15]
  00200	8b cf		 mov	 ecx, edi
  00202	85 f6		 test	 esi, esi
  00204	0f 84 b0 00 00
	00		 je	 $LN44@inflate_ta
  0020a	83 fe 01	 cmp	 esi, 1
  0020d	be 01 00 00 00	 mov	 esi, 1
  00212	74 6a		 je	 SHORT $LN45@inflate_ta

; 190  :         break;
; 191  :     default:    /* DISTS */
; 192  :         base = dbase;
; 193  :         extra = dext;
; 194  :         match = 0;
; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */
; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */

  00214	d3 e6		 shl	 esi, cl

; 206  :     mask = used - 1;            /* mask for comparing low */

  00216	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0021d	83 7d 40 01	 cmp	 DWORD PTR type$[rbp-128], 1
  00221	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  00228	44 8b f6	 mov	 r14d, esi
  0022b	48 89 5d a0	 mov	 QWORD PTR base$1$[rbp-128], rbx
  0022f	8b c6		 mov	 eax, esi
  00231	48 89 7d 98	 mov	 QWORD PTR extra$1$[rbp-128], rdi
  00235	44 8d 56 ff	 lea	 r10d, DWORD PTR [rsi-1]
  00239	44 89 65 80	 mov	 DWORD PTR match$1$[rbp-128], r12d
  0023d	44 89 55 88	 mov	 DWORD PTR mask$1$[rbp-128], r10d
  00241	74 66		 je	 SHORT $LN162@inflate_ta
  00243	83 7d 40 02	 cmp	 DWORD PTR type$[rbp-128], 2
  00247	48 89 5d a0	 mov	 QWORD PTR base$1$[rbp-128], rbx
  0024b	48 89 7d 98	 mov	 QWORD PTR extra$1$[rbp-128], rdi
  0024f	44 89 65 80	 mov	 DWORD PTR match$1$[rbp-128], r12d
  00253	44 89 55 88	 mov	 DWORD PTR mask$1$[rbp-128], r10d
  00257	0f 85 83 00 00
	00		 jne	 $LN166@inflate_ta
  0025d	48 89 5d a0	 mov	 QWORD PTR base$1$[rbp-128], rbx
  00261	48 89 7d 98	 mov	 QWORD PTR extra$1$[rbp-128], rdi
  00265	44 89 65 80	 mov	 DWORD PTR match$1$[rbp-128], r12d
  00269	44 89 55 88	 mov	 DWORD PTR mask$1$[rbp-128], r10d
  0026d	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  00272	76 6c		 jbe	 SHORT $LN166@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  00274	b8 01 00 00 00	 mov	 eax, 1
  00279	e9 83 02 00 00	 jmp	 $LN174@inflate_ta
$LN45@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;

  0027e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;
; 189  :         match = 257;

  00285	d3 e6		 shl	 esi, cl
  00287	48 89 45 a0	 mov	 QWORD PTR base$1$[rbp-128], rax
  0028b	41 bc 01 01 00
	00		 mov	 r12d, 257		; 00000101H
  00291	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  00298	44 89 65 80	 mov	 DWORD PTR match$1$[rbp-128], r12d
  0029c	48 89 45 98	 mov	 QWORD PTR extra$1$[rbp-128], rax
  002a0	44 8b f6	 mov	 r14d, esi
  002a3	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  002a6	89 45 88	 mov	 DWORD PTR mask$1$[rbp-128], eax
$LN162@inflate_ta:

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002a9	41 81 fe 54 03
	00 00		 cmp	 r14d, 852		; 00000354H
  002b0	77 c2		 ja	 SHORT $LN62@inflate_ta
  002b2	8b 55 80	 mov	 edx, DWORD PTR match$1$[rbp-128]
  002b5	45 33 e4	 xor	 r12d, r12d
  002b8	eb 29		 jmp	 SHORT $LN175@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  002ba	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]

; 184  :         match = 20;

  002be	be 01 00 00 00	 mov	 esi, 1
  002c3	d3 e6		 shl	 esi, cl
  002c5	ba 14 00 00 00	 mov	 edx, 20
  002ca	4c 89 55 98	 mov	 QWORD PTR extra$1$[rbp-128], r10
  002ce	44 8b f6	 mov	 r14d, esi
  002d1	4c 89 55 a0	 mov	 QWORD PTR base$1$[rbp-128], r10
  002d5	89 55 80	 mov	 DWORD PTR match$1$[rbp-128], edx
  002d8	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  002db	89 45 88	 mov	 DWORD PTR mask$1$[rbp-128], eax

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002de	eb 07		 jmp	 SHORT $LN157@inflate_ta
$LN166@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  002e0	41 8b d4	 mov	 edx, r12d
$LN175@inflate_ta:
  002e3	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]
$LN157@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  002e7	48 8b 7d 58	 mov	 rdi, QWORD PTR table$[rbp-128]
  002eb	41 8b cc	 mov	 ecx, r12d
  002ee	89 4d 8c	 mov	 DWORD PTR sym$1$[rbp-128], ecx
  002f1	41 8b dc	 mov	 ebx, r12d
  002f4	45 8b c4	 mov	 r8d, r12d
  002f7	44 89 65 84	 mov	 DWORD PTR drop$1$[rbp-128], r12d
  002fb	eb 13		 jmp	 SHORT $LL25@inflate_ta
  002fd	0f 1f 00	 npad	 3
$LL167@inflate_ta:
  00300	48 8b 7d 58	 mov	 rdi, QWORD PTR table$[rbp-128]
$LN169@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  00304	45 33 e4	 xor	 r12d, r12d
  00307	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL25@inflate_ta:
  00310	41 0f b6 c3	 movzx	 eax, r11b
  00314	41 2a c0	 sub	 al, r8b
  00317	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 217  :         if (work[sym] + 1U < match) {

  0031a	8b c1		 mov	 eax, ecx
  0031c	41 0f b7 0c 42	 movzx	 ecx, WORD PTR [r10+rax*2]
  00321	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  00324	3b c2		 cmp	 eax, edx
  00326	73 0a		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  00328	c6 45 50 00	 mov	 BYTE PTR here$[rbp-128], 0

; 219  :             here.val = work[sym];

  0032c	66 89 4d 52	 mov	 WORD PTR here$[rbp-126], cx

; 220  :         }

  00330	eb 2b		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  00332	3b ca		 cmp	 ecx, edx
  00334	72 1e		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  00336	48 8b 45 98	 mov	 rax, QWORD PTR extra$1$[rbp-128]
  0033a	2b ca		 sub	 ecx, edx
  0033c	48 03 c9	 add	 rcx, rcx
  0033f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00343	88 45 50	 mov	 BYTE PTR here$[rbp-128], al

; 223  :             here.val = base[work[sym] - match];

  00346	48 8b 45 a0	 mov	 rax, QWORD PTR base$1$[rbp-128]
  0034a	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0034e	66 89 45 52	 mov	 WORD PTR here$[rbp-126], ax

; 224  :         }

  00352	eb 09		 jmp	 SHORT $LN53@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00354	c6 45 50 60	 mov	 BYTE PTR here$[rbp-128], 96 ; 00000060H

; 227  :             here.val = 0;

  00358	66 44 89 65 52	 mov	 WORD PTR here$[rbp-126], r12w
$LN53@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  0035d	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00360	41 8b cb	 mov	 ecx, r11d
  00363	41 2b c8	 sub	 ecx, r8d
  00366	41 ba 01 00 00
	00		 mov	 r10d, 1
  0036c	41 d3 e2	 shl	 r10d, cl
  0036f	8b d3		 mov	 edx, ebx
  00371	8b 4d 84	 mov	 ecx, DWORD PTR drop$1$[rbp-128]
  00374	d3 ea		 shr	 edx, cl
  00376	03 d6		 add	 edx, esi

; 232  :         fill = 1U << curr;

  00378	44 8b c6	 mov	 r8d, esi
  0037b	0f 1f 44 00 00	 npad	 5
$LL30@inflate_ta:

; 233  :         min = fill;                 /* save offset to next table */
; 234  :         do {
; 235  :             fill -= incr;

  00380	41 2b d2	 sub	 edx, r10d

; 236  :             next[(huff >> drop) + fill] = here;

  00383	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax
  00387	45 2b c2	 sub	 r8d, r10d

; 237  :         } while (fill != 0);

  0038a	75 f4		 jne	 SHORT $LL30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  0038c	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  00390	ba 01 00 00 00	 mov	 edx, 1
  00395	d3 e2		 shl	 edx, cl

; 241  :         while (huff & incr)

  00397	85 d3		 test	 edx, ebx
  00399	74 0b		 je	 SHORT $LN32@inflate_ta
  0039b	0f 1f 44 00 00	 npad	 5
$LL31@inflate_ta:

; 242  :             incr >>= 1;

  003a0	d1 ea		 shr	 edx, 1
  003a2	85 d3		 test	 edx, ebx
  003a4	75 fa		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  003a6	85 d2		 test	 edx, edx
  003a8	74 0b		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  003aa	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  003ad	23 d8		 and	 ebx, eax

; 245  :             huff += incr;

  003af	03 da		 add	 ebx, edx

; 246  :         }

  003b1	33 d2		 xor	 edx, edx
  003b3	eb 04		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  003b5	33 d2		 xor	 edx, edx
  003b7	8b da		 mov	 ebx, edx
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  003b9	8b 4d 8c	 mov	 ecx, DWORD PTR sym$1$[rbp-128]

; 252  :         if (--(count[len]) == 0) {

  003bc	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  003c2	ff c1		 inc	 ecx
  003c4	41 8b c3	 mov	 eax, r11d
  003c7	89 4d 8c	 mov	 DWORD PTR sym$1$[rbp-128], ecx
  003ca	66 44 01 44 45
	a8		 add	 WORD PTR count$[rbp+rax*2-128], r8w
  003d0	75 20		 jne	 SHORT $LN168@inflate_ta

; 253  :             if (len == max) break;

  003d2	45 3b d9	 cmp	 r11d, r9d
  003d5	0f 84 f5 00 00
	00		 je	 $LN82@inflate_ta

; 254  :             len = lens[work[sym]];

  003db	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]
  003df	48 8b 45 48	 mov	 rax, QWORD PTR lens$[rbp-128]
  003e3	41 0f b7 0c 4a	 movzx	 ecx, WORD PTR [r10+rcx*2]
  003e8	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
  003ed	8b 4d 8c	 mov	 ecx, DWORD PTR sym$1$[rbp-128]
  003f0	eb 04		 jmp	 SHORT $LN56@inflate_ta
$LN168@inflate_ta:

; 252  :         if (--(count[len]) == 0) {

  003f2	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  003f6	8b 45 90	 mov	 eax, DWORD PTR tv1918[rbp-128]
  003f9	44 8b 45 84	 mov	 r8d, DWORD PTR drop$1$[rbp-128]
  003fd	8b 55 80	 mov	 edx, DWORD PTR match$1$[rbp-128]
  00400	44 3b d8	 cmp	 r11d, eax
  00403	0f 86 fb fe ff
	ff		 jbe	 $LN169@inflate_ta
  00409	8b 7d 88	 mov	 edi, DWORD PTR mask$1$[rbp-128]
  0040c	23 fb		 and	 edi, ebx
  0040e	41 3b fd	 cmp	 edi, r13d
  00411	0f 84 e9 fe ff
	ff		 je	 $LL167@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  00417	45 85 c0	 test	 r8d, r8d

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  0041a	4d 8d 3c b7	 lea	 r15, QWORD PTR [r15+rsi*4]

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  0041e	45 8b d3	 mov	 r10d, r11d

; 268  :             left = (int)(1 << curr);

  00421	ba 01 00 00 00	 mov	 edx, 1
  00426	44 0f 44 c0	 cmove	 r8d, eax
  0042a	45 2b d0	 sub	 r10d, r8d
  0042d	44 89 45 84	 mov	 DWORD PTR drop$1$[rbp-128], r8d
  00431	41 8b ca	 mov	 ecx, r10d
  00434	d3 e2		 shl	 edx, cl

; 269  :             while (curr + drop < max) {

  00436	45 3b d9	 cmp	 r11d, r9d
  00439	73 24		 jae	 SHORT $LN81@inflate_ta

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  0043b	45 8b c3	 mov	 r8d, r11d
  0043e	66 90		 npad	 2
$LL33@inflate_ta:

; 270  :                 left -= count[curr + drop];

  00440	41 8b c0	 mov	 eax, r8d
  00443	0f b7 4c 45 a8	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  00448	2b d1		 sub	 edx, ecx

; 271  :                 if (left <= 0) break;

  0044a	85 d2		 test	 edx, edx
  0044c	7e 0d		 jle	 SHORT $LN164@inflate_ta

; 272  :                 curr++;

  0044e	41 ff c2	 inc	 r10d
  00451	41 ff c0	 inc	 r8d

; 273  :                 left <<= 1;

  00454	03 d2		 add	 edx, edx
  00456	45 3b c1	 cmp	 r8d, r9d
  00459	72 e5		 jb	 SHORT $LL33@inflate_ta
$LN164@inflate_ta:
  0045b	44 8b 45 84	 mov	 r8d, DWORD PTR drop$1$[rbp-128]
$LN81@inflate_ta:

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;
; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  0045f	8b 45 40	 mov	 eax, DWORD PTR type$[rbp-128]
  00462	41 8b ca	 mov	 ecx, r10d
  00465	be 01 00 00 00	 mov	 esi, 1
  0046a	d3 e6		 shl	 esi, cl
  0046c	44 03 f6	 add	 r14d, esi
  0046f	83 f8 01	 cmp	 eax, 1
  00472	75 09		 jne	 SHORT $LN63@inflate_ta
  00474	41 81 fe 54 03
	00 00		 cmp	 r14d, 852		; 00000354H
  0047b	eb 0c		 jmp	 SHORT $LN176@inflate_ta
$LN63@inflate_ta:
  0047d	83 f8 02	 cmp	 eax, 2
  00480	75 0d		 jne	 SHORT $LN61@inflate_ta
  00482	41 81 fe 50 02
	00 00		 cmp	 r14d, 592		; 00000250H
$LN176@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00489	0f 87 e5 fd ff
	ff		 ja	 $LN62@inflate_ta
$LN61@inflate_ta:

; 284  :             (*table)[low].op = (unsigned char)curr;
; 285  :             (*table)[low].bits = (unsigned char)root;

  0048f	8b 4d 90	 mov	 ecx, DWORD PTR tv1918[rbp-128]
  00492	48 8d 14 bd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*4]
  0049a	44 8b ef	 mov	 r13d, edi
  0049d	48 8b 7d 58	 mov	 rdi, QWORD PTR table$[rbp-128]
  004a1	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  004a4	44 88 14 02	 mov	 BYTE PTR [rdx+rax], r10b
  004a8	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 286  :             (*table)[low].val = (unsigned short)(next - *table);
; 287  :         }
; 288  :     }

  004ab	4c 8b 55 68	 mov	 r10, QWORD PTR work$[rbp-128]
  004af	88 4c 02 01	 mov	 BYTE PTR [rdx+rax+1], cl
  004b3	49 8b c7	 mov	 rax, r15
  004b6	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  004b9	48 2b c1	 sub	 rax, rcx
  004bc	48 c1 f8 02	 sar	 rax, 2
  004c0	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax
  004c5	8b 4d 8c	 mov	 ecx, DWORD PTR sym$1$[rbp-128]
  004c8	8b 55 80	 mov	 edx, DWORD PTR match$1$[rbp-128]
  004cb	e9 34 fe ff ff	 jmp	 $LN169@inflate_ta
$LN82@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  004d0	85 db		 test	 ebx, ebx
  004d2	74 11		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */
; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;
; 297  :         next[huff] = here;

  004d4	8b cb		 mov	 ecx, ebx
  004d6	c6 45 50 40	 mov	 BYTE PTR here$[rbp-128], 64 ; 00000040H
  004da	66 89 55 52	 mov	 WORD PTR here$[rbp-126], dx
  004de	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  004e1	41 89 04 8f	 mov	 DWORD PTR [r15+rcx*4], eax
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;
; 302  :     *bits = root;

  004e5	48 8b 4d 60	 mov	 rcx, QWORD PTR bits$[rbp-128]
  004e9	41 8b c6	 mov	 eax, r14d
  004ec	48 c1 e0 02	 shl	 rax, 2
  004f0	48 01 07	 add	 QWORD PTR [rdi], rax
  004f3	8b 45 90	 mov	 eax, DWORD PTR tv1918[rbp-128]
  004f6	89 01		 mov	 DWORD PTR [rcx], eax

; 303  :     return 0;

  004f8	33 c0		 xor	 eax, eax
  004fa	eb 05		 jmp	 SHORT $LN174@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  004fc	b8 ff ff ff ff	 mov	 eax, -1
$LN174@inflate_ta:
  00501	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
$LN1@inflate_ta:

; 304  : }

  00506	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0050d	41 5f		 pop	 r15
  0050f	41 5e		 pop	 r14
  00511	41 5d		 pop	 r13
  00513	41 5c		 pop	 r12
  00515	5e		 pop	 rsi
  00516	5b		 pop	 rbx
  00517	5d		 pop	 rbp
  00518	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
