; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN7
	DD	imagerel $LN7+57
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN17+91
	DD	imagerel $LN17+149
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN17+149
	DD	imagerel $LN17+172
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN17+172
	DD	imagerel $LN17+410
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN17+410
	DD	imagerel $LN17+423
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN20+33
	DD	imagerel $LN20+68
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN20+68
	DD	imagerel $LN20+287
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+101
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+172
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+272
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN8
	DD	imagerel $LN8+96
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN12
	DD	imagerel $LN12+147
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN999
	DD	imagerel $LN999+6008
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN14+67
	DD	imagerel $LN14+173
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN14+173
	DD	imagerel $LN14+225
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN14+225
	DD	imagerel $LN14+241
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 091c01H
	DD	0f015a21cH
	DD	0d011e013H
	DD	0700dc00fH
	DD	0300b600cH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 0a6801H
	DD	07e468H
	DD	067460H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 061121H
	DD	085411H
	DD	06340cH
	DD	097400H
	DD	imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	097405H
	DD	imagerel $LN20
	DD	imagerel $LN20+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 080021H
	DD	04f400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 021H
	DD	imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 020521H
	DD	04f405H
	DD	imagerel $LN17+49
	DD	imagerel $LN17+91
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061421H
	DD	0a6414H
	DD	09540aH
	DD	083405H
	DD	imagerel $LN17
	DD	imagerel $LN17+49
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 146  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 155  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 151  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 155  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 154  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 200  : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 c9 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 bf 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 b5 00 00
	00		 jne	 $LN3@inflateIni

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;
; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN4@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 237  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  0003f	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00043	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00048	33 ed		 xor	 ebp, ebp
  0004a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004f	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00053	48 85 c0	 test	 rax, rax
  00056	75 13		 jne	 SHORT $LN10@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 214  :         strm->opaque = (voidpf)0;

  0005f	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00063	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00067	8b cd		 mov	 ecx, ebp
  00069	eb 04		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  0006b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0006f	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00073	75 0b		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0007c	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0008b	ff d0		 call	 rax
  0008d	48 8b f8	 mov	 rdi, rax

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00090	48 85 c0	 test	 rax, rax
  00093	75 18		 jne	 SHORT $LN7@inflateIni
  00095	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN12@inflateIni:
  00098	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 237  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5e		 pop	 rsi
  000ac	c3		 ret	 0
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  000ad	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  000b1	8b d6		 mov	 edx, esi
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	48 89 18	 mov	 QWORD PTR [rax], rbx
  000b9	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000bd	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000c4	e8 00 00 00 00	 call	 inflateReset2
  000c9	8b f0		 mov	 esi, eax

; 232  :     if (ret != Z_OK) {

  000cb	85 c0		 test	 eax, eax
  000cd	74 0e		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  000cf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 234  :         strm->state = Z_NULL;

  000d9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000dd	8b c6		 mov	 eax, esi
  000df	eb b7		 jmp	 SHORT $LN12@inflateIni
$LN3@inflateIni:

; 237  : }

  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	b8 fa ff ff ff	 mov	 eax, -6
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5e		 pop	 rsi
  000f0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
out$1$ = 52
last$ = 56
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 625  : {

$LN999:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8b ec	 mov	 rbp, rsp
  00018	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0001c	44 8b da	 mov	 r11d, edx
  0001f	4c 8b e1	 mov	 r12, rcx

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00022	e8 00 00 00 00	 call	 inflateStateCheck
  00027	85 c0		 test	 eax, eax
  00029	0f 85 b4 16 00
	00		 jne	 $LN333@inflate
  0002f	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00033	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9
  00037	4d 85 c9	 test	 r9, r9
  0003a	0f 84 a3 16 00
	00		 je	 $LN333@inflate
  00040	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00043	48 85 f6	 test	 rsi, rsi
  00046	75 09		 jne	 SHORT $LN749@inflate
  00048	39 71 08	 cmp	 DWORD PTR [rcx+8], esi
  0004b	0f 85 92 16 00
	00		 jne	 $LN333@inflate
$LN749@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  00051	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00055	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  00059	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  0005f	75 18		 jne	 SHORT $LN4@inflate
  00061	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
  00069	ba 40 3f 00 00	 mov	 edx, 16192		; 00003f40H
  0006e	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00072	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00075	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9
$LN4@inflate:

; 651  :     LOAD();

  00079	44 8b 51 18	 mov	 r10d, DWORD PTR [rcx+24]

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0007d	8d 82 cc c0 ff
	ff		 lea	 eax, DWORD PTR [rdx-16180]
  00083	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00086	45 33 ff	 xor	 r15d, r15d
  00089	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  0008d	45 8b c2	 mov	 r8d, r10d
  00090	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  00094	44 89 55 60	 mov	 DWORD PTR left$1$[rbp-88], r10d
  00098	89 7d e4	 mov	 DWORD PTR in$1$[rbp-88], edi
  0009b	44 89 55 dc	 mov	 DWORD PTR out$1$[rbp-88], r10d
  0009f	44 89 7d 58	 mov	 DWORD PTR ret$1$[rbp-88], r15d
  000a3	83 f8 1e	 cmp	 eax, 30
  000a6	0f 87 37 16 00
	00		 ja	 $LN333@inflate
$LN996@inflate:
  000ac	48 98		 cdqe
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000b5	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN844@inflate[rcx+rax*4]
  000bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000c3	48 03 c8	 add	 rcx, rax
  000c6	ff e1		 jmp	 rcx
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000c8	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  000cc	85 d2		 test	 edx, edx
  000ce	75 0d		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000d0	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 660  :                 break;

  000d8	e9 91 06 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000dd	83 fb 10	 cmp	 ebx, 16
  000e0	73 1f		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000e2	85 ff		 test	 edi, edi
  000e4	0f 84 0a 08 00
	00		 je	 $LN963@inflate
  000ea	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000ed	8b cb		 mov	 ecx, ebx
  000ef	d3 e0		 shl	 eax, cl
  000f1	ff cf		 dec	 edi
  000f3	44 03 f0	 add	 r14d, eax
  000f6	48 ff c6	 inc	 rsi
  000f9	83 c3 08	 add	 ebx, 8
  000fc	83 fb 10	 cmp	 ebx, 16
  000ff	72 e1		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00101	f6 c2 02	 test	 dl, 2
  00104	74 56		 je	 SHORT $LN338@inflate
  00106	41 81 fe 1f 8b
	00 00		 cmp	 r14d, 35615		; 00008b1fH
  0010d	75 4d		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  0010f	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  00114	75 08		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00116	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  0011e	45 33 c0	 xor	 r8d, r8d
  00121	33 d2		 xor	 edx, edx
  00123	33 c9		 xor	 ecx, ecx
  00125	e8 00 00 00 00	 call	 crc32

; 668  :                 CRC2(state->check, hold);

  0012a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00130	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00134	48 8d 55 d8	 lea	 rdx, QWORD PTR hbuf$[rbp-88]
  00138	66 c7 45 d8 1f
	8b		 mov	 WORD PTR hbuf$[rbp-88], 35615 ; 00008b1fH
  0013e	8b c8		 mov	 ecx, eax
  00140	e8 00 00 00 00	 call	 crc32
  00145	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 669  :                 INITBITS();

  00149	45 8b f7	 mov	 r14d, r15d
  0014c	41 8b df	 mov	 ebx, r15d

; 670  :                 state->mode = FLAGS;

  0014f	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 671  :                 break;

  00157	e9 0a 06 00 00	 jmp	 $LN929@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  0015c	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00160	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  00164	48 85 c0	 test	 rax, rax
  00167	74 0b		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  00169	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  00170	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00174	f6 c2 01	 test	 dl, 1
  00177	0f 84 cf 00 00
	00		 je	 $LN342@inflate
  0017d	41 0f b6 ce	 movzx	 ecx, r14b
  00181	41 8b c6	 mov	 eax, r14d
  00184	c1 e8 08	 shr	 eax, 8
  00187	c1 e1 08	 shl	 ecx, 8
  0018a	03 c8		 add	 ecx, eax
  0018c	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00191	f7 e1		 mul	 ecx
  00193	8b c1		 mov	 eax, ecx
  00195	2b c2		 sub	 eax, edx
  00197	d1 e8		 shr	 eax, 1
  00199	03 c2		 add	 eax, edx
  0019b	c1 e8 04	 shr	 eax, 4
  0019e	6b c0 1f	 imul	 eax, eax, 31
  001a1	3b c8		 cmp	 ecx, eax
  001a3	0f 85 a3 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  001a9	41 8b c6	 mov	 eax, r14d
  001ac	24 0f		 and	 al, 15
  001ae	3c 08		 cmp	 al, 8
  001b0	74 19		 je	 SHORT $LN26@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  001b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  001b9	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 687  :                 state->mode = BAD;

  001be	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 688  :                 break;

  001c6	e9 a3 05 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);
; 691  :             len = BITS(4) + 8;
; 692  :             if (state->wbits == 0)

  001cb	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  001cf	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001d2	41 c1 ee 04	 shr	 r14d, 4
  001d6	41 8b ce	 mov	 ecx, r14d
  001d9	83 e1 0f	 and	 ecx, 15
  001dc	83 c1 08	 add	 ecx, 8
  001df	85 c0		 test	 eax, eax
  001e1	75 06		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001e3	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
  001e7	8b c1		 mov	 eax, ecx
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001e9	83 f9 0f	 cmp	 ecx, 15
  001ec	77 45		 ja	 SHORT $LN346@inflate
  001ee	3b c8		 cmp	 ecx, eax
  001f0	77 41		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001f2	b8 01 00 00 00	 mov	 eax, 1

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001f7	45 33 c0	 xor	 r8d, r8d
  001fa	d3 e0		 shl	 eax, cl
  001fc	33 d2		 xor	 edx, edx
  001fe	33 c9		 xor	 ecx, ecx
  00200	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  00204	e8 00 00 00 00	 call	 adler32

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00209	41 c1 ee 08	 shr	 r14d, 8

; 703  :             INITBITS();

  0020d	41 8b df	 mov	 ebx, r15d
  00210	41 f7 d6	 not	 r14d
  00213	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00217	41 83 e6 02	 and	 r14d, 2
  0021b	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  00220	41 81 ce 3d 3f
	00 00		 or	 r14d, 16189		; 00003f3dH
  00227	45 89 75 08	 mov	 DWORD PTR [r13+8], r14d
  0022b	45 8b f7	 mov	 r14d, r15d

; 704  :             break;

  0022e	e9 33 05 00 00	 jmp	 $LN929@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00233	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  0023a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 696  :                 state->mode = BAD;

  0023f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 697  :                 break;

  00247	e9 22 05 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  0024c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  00253	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 682  :                 state->mode = BAD;

  00258	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 683  :                 break;

  00260	e9 09 05 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  00265	83 fb 10	 cmp	 ebx, 16
  00268	73 25		 jae	 SHORT $LN30@inflate
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL33@inflate:
  00270	85 ff		 test	 edi, edi
  00272	0f 84 7c 06 00
	00		 je	 $LN963@inflate
  00278	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0027b	8b cb		 mov	 ecx, ebx
  0027d	d3 e0		 shl	 eax, cl
  0027f	ff cf		 dec	 edi
  00281	44 03 f0	 add	 r14d, eax
  00284	48 ff c6	 inc	 rsi
  00287	83 c3 08	 add	 ebx, 8
  0028a	83 fb 10	 cmp	 ebx, 16
  0028d	72 e1		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  0028f	45 89 75 18	 mov	 DWORD PTR [r13+24], r14d

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00293	41 80 fe 08	 cmp	 r14b, 8
  00297	74 19		 je	 SHORT $LN349@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  00299	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  002a0	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 711  :                 state->mode = BAD;

  002a5	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 712  :                 break;

  002ad	e9 bc 04 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  002b2	41 f7 c6 00 e0
	00 00		 test	 r14d, 57344		; 0000e000H
  002b9	74 19		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  002bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002c2	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 716  :                 state->mode = BAD;

  002c7	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 717  :                 break;

  002cf	e9 9a 04 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  002d4	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  002d8	41 8b ce	 mov	 ecx, r14d
  002db	c1 e9 08	 shr	 ecx, 8
  002de	41 8b c6	 mov	 eax, r14d
  002e1	48 85 d2	 test	 rdx, rdx
  002e4	74 0b		 je	 SHORT $LN653@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  002e6	8b c1		 mov	 eax, ecx
  002e8	83 e0 01	 and	 eax, 1
  002eb	89 02		 mov	 DWORD PTR [rdx], eax
  002ed	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
$LN653@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002f1	0f ba e0 09	 bt	 eax, 9
  002f5	73 25		 jae	 SHORT $LN39@inflate
  002f7	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  002fc	74 1e		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002fe	88 4d d9	 mov	 BYTE PTR hbuf$[rbp-87], cl
  00301	48 8d 55 d8	 lea	 rdx, QWORD PTR hbuf$[rbp-88]
  00305	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00309	41 b8 02 00 00
	00		 mov	 r8d, 2
  0030f	44 88 75 d8	 mov	 BYTE PTR hbuf$[rbp-88], r14b
  00313	e8 00 00 00 00	 call	 crc32
  00318	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 723  :             INITBITS();

  0031c	45 8b f7	 mov	 r14d, r15d

; 724  :             state->mode = TIME;

  0031f	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  00327	41 8b df	 mov	 ebx, r15d

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0032a	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  0032c	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0032f	73 1f		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00331	85 ff		 test	 edi, edi
  00333	0f 84 bb 05 00
	00		 je	 $LN963@inflate
  00339	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0033c	8b cb		 mov	 ecx, ebx
  0033e	d3 e0		 shl	 eax, cl
  00340	ff cf		 dec	 edi
  00342	44 03 f0	 add	 r14d, eax
  00345	48 ff c6	 inc	 rsi
  00348	83 c3 08	 add	 ebx, 8
  0034b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0034e	72 e1		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00350	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00354	48 85 c0	 test	 rax, rax
  00357	74 04		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  00359	44 89 70 04	 mov	 DWORD PTR [rax+4], r14d
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0035d	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00365	74 3c		 je	 SHORT $LN53@inflate
  00367	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0036c	74 35		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  0036e	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00372	48 8d 55 d8	 lea	 rdx, QWORD PTR hbuf$[rbp-88]
  00376	41 8b c6	 mov	 eax, r14d
  00379	44 88 75 d8	 mov	 BYTE PTR hbuf$[rbp-88], r14b
  0037d	c1 e8 08	 shr	 eax, 8
  00380	41 b8 04 00 00
	00		 mov	 r8d, 4
  00386	88 45 d9	 mov	 BYTE PTR hbuf$[rbp-87], al
  00389	41 8b c6	 mov	 eax, r14d
  0038c	c1 e8 10	 shr	 eax, 16
  0038f	41 c1 ee 18	 shr	 r14d, 24
  00393	88 45 da	 mov	 BYTE PTR hbuf$[rbp-86], al
  00396	44 88 75 db	 mov	 BYTE PTR hbuf$[rbp-85], r14b
  0039a	e8 00 00 00 00	 call	 crc32
  0039f	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 731  :             INITBITS();

  003a3	45 8b f7	 mov	 r14d, r15d

; 732  :             state->mode = OS;

  003a6	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003ae	41 8b df	 mov	 ebx, r15d

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  003b1	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003b3	83 fb 10	 cmp	 ebx, 16
  003b6	73 1f		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  003b8	85 ff		 test	 edi, edi
  003ba	0f 84 34 05 00
	00		 je	 $LN963@inflate
  003c0	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  003c3	8b cb		 mov	 ecx, ebx
  003c5	d3 e0		 shl	 eax, cl
  003c7	ff cf		 dec	 edi
  003c9	44 03 f0	 add	 r14d, eax
  003cc	48 ff c6	 inc	 rsi
  003cf	83 c3 08	 add	 ebx, 8
  003d2	83 fb 10	 cmp	 ebx, 16
  003d5	72 e1		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  003d7	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  003db	48 85 c9	 test	 rcx, rcx
  003de	74 16		 je	 SHORT $LN751@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  003e0	41 0f b6 c6	 movzx	 eax, r14b
  003e4	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  003e7	41 8b ce	 mov	 ecx, r14d
  003ea	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  003ee	c1 e9 08	 shr	 ecx, 8
  003f1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  003f4	eb 06		 jmp	 SHORT $LN654@inflate
$LN751@inflate:
  003f6	41 8b ce	 mov	 ecx, r14d
  003f9	c1 e9 08	 shr	 ecx, 8
$LN654@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003fc	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00404	74 25		 je	 SHORT $LN67@inflate
  00406	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0040b	74 1e		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  0040d	88 4d d9	 mov	 BYTE PTR hbuf$[rbp-87], cl
  00410	48 8d 55 d8	 lea	 rdx, QWORD PTR hbuf$[rbp-88]
  00414	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00418	41 b8 02 00 00
	00		 mov	 r8d, 2
  0041e	44 88 75 d8	 mov	 BYTE PTR hbuf$[rbp-88], r14b
  00422	e8 00 00 00 00	 call	 crc32
  00427	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 741  :             INITBITS();

  0042b	45 8b f7	 mov	 r14d, r15d

; 742  :             state->mode = EXLEN;

  0042e	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  00436	41 8b df	 mov	 ebx, r15d
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00439	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00441	74 71		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  00443	83 fb 10	 cmp	 ebx, 16
  00446	73 1f		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00448	85 ff		 test	 edi, edi
  0044a	0f 84 a4 04 00
	00		 je	 $LN963@inflate
  00450	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00453	8b cb		 mov	 ecx, ebx
  00455	d3 e0		 shl	 eax, cl
  00457	ff cf		 dec	 edi
  00459	44 03 f0	 add	 r14d, eax
  0045c	48 ff c6	 inc	 rsi
  0045f	83 c3 08	 add	 ebx, 8
  00462	83 fb 10	 cmp	 ebx, 16
  00465	72 e1		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00467	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0046b	45 89 75 50	 mov	 DWORD PTR [r13+80], r14d
  0046f	48 85 c0	 test	 rax, rax
  00472	74 04		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00474	44 89 70 18	 mov	 DWORD PTR [rax+24], r14d
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00478	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00480	74 2a		 je	 SHORT $LN81@inflate
  00482	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00487	74 23		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00489	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0048d	48 8d 55 d8	 lea	 rdx, QWORD PTR hbuf$[rbp-88]
  00491	44 88 75 d8	 mov	 BYTE PTR hbuf$[rbp-88], r14b
  00495	41 b8 02 00 00
	00		 mov	 r8d, 2
  0049b	41 c1 ee 08	 shr	 r14d, 8
  0049f	44 88 75 d9	 mov	 BYTE PTR hbuf$[rbp-87], r14b
  004a3	e8 00 00 00 00	 call	 crc32
  004a8	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 751  :                 INITBITS();

  004ac	45 8b f7	 mov	 r14d, r15d
  004af	41 8b df	 mov	 ebx, r15d

; 752  :             }

  004b2	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  004b4	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004b8	48 85 c0	 test	 rax, rax
  004bb	74 04		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  004bd	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  004c1	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  004c9	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  004cd	0f ba e1 0a	 bt	 ecx, 10
  004d1	0f 83 a0 00 00
	00		 jae	 $LN374@inflate

; 758  :                 copy = state->length;

  004d7	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 759  :                 if (copy > have) copy = have;
; 760  :                 if (copy) {

  004db	44 8b ff	 mov	 r15d, edi
  004de	3b c7		 cmp	 eax, edi
  004e0	44 0f 46 f8	 cmovbe	 r15d, eax
  004e4	45 85 ff	 test	 r15d, r15d
  004e7	0f 84 7f 00 00
	00		 je	 $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  004ed	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  004f1	44 8b e0	 mov	 r12d, eax
  004f4	48 85 d2	 test	 rdx, rdx
  004f7	74 40		 je	 SHORT $LN372@inflate
  004f9	4c 8b 52 10	 mov	 r10, QWORD PTR [rdx+16]
  004fd	4d 85 d2	 test	 r10, r10
  00500	74 37		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;
; 764  :                         zmemcpy(state->head->extra + len, next,

  00502	44 8b 42 1c	 mov	 r8d, DWORD PTR [rdx+28]
  00506	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]
  0050a	41 8b d0	 mov	 edx, r8d
  0050d	44 2b c8	 sub	 r9d, eax
  00510	41 8b c7	 mov	 eax, r15d
  00513	41 2b d1	 sub	 edx, r9d
  00516	43 8d 0c 0f	 lea	 ecx, DWORD PTR [r15+r9]
  0051a	41 3b c8	 cmp	 ecx, r8d
  0051d	41 8b c9	 mov	 ecx, r9d
  00520	0f 47 c2	 cmova	 eax, edx
  00523	49 03 ca	 add	 rcx, r10
  00526	44 8b c0	 mov	 r8d, eax
  00529	48 8b d6	 mov	 rdx, rsi
  0052c	e8 00 00 00 00	 call	 memcpy
  00531	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00535	45 8b 65 50	 mov	 r12d, DWORD PTR [r13+80]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00539	0f ba e1 09	 bt	 ecx, 9
  0053d	73 1a		 jae	 SHORT $LN373@inflate
  0053f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00544	74 13		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00546	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0054a	45 8b c7	 mov	 r8d, r15d
  0054d	48 8b d6	 mov	 rdx, rsi
  00550	e8 00 00 00 00	 call	 crc32
  00555	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 770  :                     have -= copy;
; 771  :                     next += copy;

  00559	41 8b c7	 mov	 eax, r15d
  0055c	41 2b ff	 sub	 edi, r15d
  0055f	48 03 f0	 add	 rsi, rax

; 772  :                     state->length -= copy;

  00562	41 8b c4	 mov	 eax, r12d
  00565	41 2b c7	 sub	 eax, r15d
  00568	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  0056c	85 c0		 test	 eax, eax
  0056e	0f 85 80 03 00
	00		 jne	 $LN963@inflate
  00574	45 33 ff	 xor	 r15d, r15d
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00577	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 777  :             state->mode = NAME;

  0057b	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00583	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  0058b	0f 84 82 00 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  00591	85 ff		 test	 edi, edi
  00593	0f 84 5b 03 00
	00		 je	 $LN963@inflate
  00599	0f 1f 80 00 00
	00 00		 npad	 7
$LL88@inflate:

; 781  :                 copy = 0;
; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  005a0	41 8b c7	 mov	 eax, r15d
  005a3	41 ff c7	 inc	 r15d
  005a6	44 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+rsi]

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  005ab	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  005af	48 85 c0	 test	 rax, rax
  005b2	74 1a		 je	 SHORT $LN86@inflate
  005b4	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005b8	48 85 d2	 test	 rdx, rdx
  005bb	74 11		 je	 SHORT $LN86@inflate
  005bd	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  005c1	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005c4	73 08		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  005c6	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  005ca	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  005ce	45 84 e4	 test	 r12b, r12b
  005d1	74 05		 je	 SHORT $LN380@inflate
  005d3	44 3b ff	 cmp	 r15d, edi
  005d6	72 c8		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005d8	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005e0	74 1a		 je	 SHORT $LN381@inflate
  005e2	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005e7	74 13		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  005e9	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005ed	45 8b c7	 mov	 r8d, r15d
  005f0	48 8b d6	 mov	 rdx, rsi
  005f3	e8 00 00 00 00	 call	 crc32
  005f8	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 791  :                 have -= copy;
; 792  :                 next += copy;

  005fc	41 8b c7	 mov	 eax, r15d
  005ff	41 2b ff	 sub	 edi, r15d
  00602	48 03 f0	 add	 rsi, rax

; 793  :                 if (len) goto inf_leave;

  00605	45 84 e4	 test	 r12b, r12b
  00608	0f 85 e6 02 00
	00		 jne	 $LN963@inflate

; 794  :             }

  0060e	45 33 ff	 xor	 r15d, r15d
  00611	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  00613	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00617	48 85 c0	 test	 rax, rax
  0061a	74 04		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  0061c	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN383@inflate:

; 797  :             state->length = 0;

  00620	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 798  :             state->mode = COMMENT;

  00624	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  0062c	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  00634	74 7d		 je	 SHORT $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00636	85 ff		 test	 edi, edi
  00638	0f 84 b6 02 00
	00		 je	 $LN963@inflate
  0063e	66 90		 npad	 2
$LL91@inflate:

; 802  :                 copy = 0;
; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00640	41 8b c7	 mov	 eax, r15d
  00643	41 ff c7	 inc	 r15d
  00646	44 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+rsi]

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  0064b	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0064f	48 85 c0	 test	 rax, rax
  00652	74 1a		 je	 SHORT $LN89@inflate
  00654	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00658	48 85 d2	 test	 rdx, rdx
  0065b	74 11		 je	 SHORT $LN89@inflate
  0065d	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  00661	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00664	73 08		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00666	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  0066a	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  0066e	45 84 e4	 test	 r12b, r12b
  00671	74 05		 je	 SHORT $LN389@inflate
  00673	44 3b ff	 cmp	 r15d, edi
  00676	72 c8		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00678	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00680	74 1a		 je	 SHORT $LN390@inflate
  00682	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00687	74 13		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00689	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0068d	45 8b c7	 mov	 r8d, r15d
  00690	48 8b d6	 mov	 rdx, rsi
  00693	e8 00 00 00 00	 call	 crc32
  00698	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 812  :                 have -= copy;
; 813  :                 next += copy;

  0069c	41 8b c7	 mov	 eax, r15d
  0069f	41 2b ff	 sub	 edi, r15d
  006a2	48 03 f0	 add	 rsi, rax

; 814  :                 if (len) goto inf_leave;

  006a5	45 84 e4	 test	 r12b, r12b
  006a8	0f 85 46 02 00
	00		 jne	 $LN963@inflate

; 815  :             }

  006ae	45 33 ff	 xor	 r15d, r15d
  006b1	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  006b3	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  006b7	48 85 c0	 test	 rax, rax
  006ba	74 04		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  006bc	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN392@inflate:
  006c0	4c 8b 65 48	 mov	 r12, QWORD PTR strm$[rbp-88]
  006c4	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]

; 818  :             state->mode = HCRC;

  006c8	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  006d0	41 8b 55 18	 mov	 edx, DWORD PTR [r13+24]
  006d4	0f ba e2 09	 bt	 edx, 9
  006d8	73 52		 jae	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  006da	83 fb 10	 cmp	 ebx, 16
  006dd	73 20		 jae	 SHORT $LN92@inflate
  006df	90		 npad	 1
$LL95@inflate:
  006e0	85 ff		 test	 edi, edi
  006e2	0f 84 0c 02 00
	00		 je	 $LN963@inflate
  006e8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  006eb	8b cb		 mov	 ecx, ebx
  006ed	d3 e0		 shl	 eax, cl
  006ef	ff cf		 dec	 edi
  006f1	44 03 f0	 add	 r14d, eax
  006f4	48 ff c6	 inc	 rsi
  006f7	83 c3 08	 add	 ebx, 8
  006fa	83 fb 10	 cmp	 ebx, 16
  006fd	72 e1		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  006ff	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00704	74 20		 je	 SHORT $LN102@inflate
  00706	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  0070b	44 3b f0	 cmp	 r14d, eax
  0070e	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00710	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00717	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 824  :                     state->mode = BAD;

  0071c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 825  :                     break;

  00724	eb 44		 jmp	 SHORT $LN993@inflate
$LN102@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  00726	45 8b f7	 mov	 r14d, r15d
  00729	41 8b df	 mov	 ebx, r15d
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  0072c	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00730	48 85 c0	 test	 rax, rax
  00733	74 14		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00735	c1 fa 09	 sar	 edx, 9
  00738	83 e2 01	 and	 edx, 1
  0073b	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 831  :                 state->head->done = 1;

  0073e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00742	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00749	45 33 c0	 xor	 r8d, r8d
  0074c	33 d2		 xor	 edx, edx
  0074e	33 c9		 xor	 ecx, ecx
  00750	e8 00 00 00 00	 call	 crc32
  00755	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00759	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN995@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0075e	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN929@inflate:
  00766	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
$LN993@inflate:
  0076a	4c 8b 4d e8	 mov	 r9, QWORD PTR put$1$[rbp-88]
$LN8@inflate:
  0076e	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  00772	8d 82 cc c0 ff
	ff		 lea	 eax, DWORD PTR [rdx-16180]
  00778	83 f8 1e	 cmp	 eax, 30
  0077b	0f 87 62 0f 00
	00		 ja	 $LN333@inflate
  00781	44 8b 45 dc	 mov	 r8d, DWORD PTR out$1$[rbp-88]
  00785	45 33 ff	 xor	 r15d, r15d
  00788	44 8b 5d 50	 mov	 r11d, DWORD PTR flush$[rbp-88]
  0078c	e9 1b f9 ff ff	 jmp	 $LN996@inflate
$LN105@inflate:

; 834  :             state->mode = TYPE;
; 835  :             break;
; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00791	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00794	73 1f		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  00796	85 ff		 test	 edi, edi
  00798	0f 84 56 01 00
	00		 je	 $LN963@inflate
  0079e	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  007a1	8b cb		 mov	 ecx, ebx
  007a3	d3 e0		 shl	 eax, cl
  007a5	ff cf		 dec	 edi
  007a7	44 03 f0	 add	 r14d, eax
  007aa	48 ff c6	 inc	 rsi
  007ad	83 c3 08	 add	 ebx, 8
  007b0	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007b3	72 e1		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  007b5	41 8b ce	 mov	 ecx, r14d
  007b8	41 8b c6	 mov	 eax, r14d
  007bb	c1 e0 10	 shl	 eax, 16
  007be	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007c4	03 c8		 add	 ecx, eax

; 840  :             INITBITS();

  007c6	41 8b df	 mov	 ebx, r15d
  007c9	41 8b c6	 mov	 eax, r14d
  007cc	c1 e1 08	 shl	 ecx, 8
  007cf	c1 e8 08	 shr	 eax, 8
  007d2	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007d7	41 c1 ee 18	 shr	 r14d, 24
  007db	03 c1		 add	 eax, ecx
  007dd	41 03 c6	 add	 eax, r14d
  007e0	45 8b f7	 mov	 r14d, r15d
  007e3	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  007e7	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 841  :             state->mode = DICT;

  007ec	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  007f4	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  007f9	0f 84 d7 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007ff	45 33 c0	 xor	 r8d, r8d
  00802	33 d2		 xor	 edx, edx
  00804	33 c9		 xor	 ecx, ecx
  00806	e8 00 00 00 00	 call	 adler32
  0080b	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
  0080f	44 8b 5d 50	 mov	 r11d, DWORD PTR flush$[rbp-88]
  00813	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00817	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 848  :             state->mode = TYPE;

  0081c	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00824	41 8d 43 fb	 lea	 eax, DWORD PTR [r11-5]
  00828	83 f8 01	 cmp	 eax, 1
  0082b	0f 86 c3 00 00
	00		 jbe	 $LN963@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00831	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00836	74 17		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  00838	8b cb		 mov	 ecx, ebx

; 854  :                 state->mode = CHECK;

  0083a	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  00842	83 e1 07	 and	 ecx, 7
  00845	41 d3 ee	 shr	 r14d, cl
  00848	2b d9		 sub	 ebx, ecx

; 855  :                 break;

  0084a	e9 1b ff ff ff	 jmp	 $LN993@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  0084f	83 fb 03	 cmp	 ebx, 3
  00852	73 1f		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00854	85 ff		 test	 edi, edi
  00856	0f 84 98 00 00
	00		 je	 $LN963@inflate
  0085c	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0085f	8b cb		 mov	 ecx, ebx
  00861	d3 e0		 shl	 eax, cl
  00863	ff cf		 dec	 edi
  00865	44 03 f0	 add	 r14d, eax
  00868	48 ff c6	 inc	 rsi
  0086b	83 c3 08	 add	 ebx, 8
  0086e	83 fb 03	 cmp	 ebx, 3
  00871	72 e1		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 858  :             state->last = BITS(1);

  00873	41 8b c6	 mov	 eax, r14d

; 859  :             DROPBITS(1);

  00876	41 d1 ee	 shr	 r14d, 1
  00879	83 e0 01	 and	 eax, 1
  0087c	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 860  :             switch (BITS(2)) {

  00880	41 8b c6	 mov	 eax, r14d
  00883	83 e0 03	 and	 eax, 3
  00886	0f 84 f1 00 00
	00		 je	 $LN408@inflate
  0088c	83 e8 01	 sub	 eax, 1
  0088f	74 42		 je	 SHORT $LN409@inflate
  00891	83 e8 01	 sub	 eax, 1
  00894	74 29		 je	 SHORT $LN411@inflate
  00896	83 f8 01	 cmp	 eax, 1
  00899	0f 85 e6 00 00
	00		 jne	 $LN138@inflate

; 873  :                     goto inf_leave;
; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  0089f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  008a6	41 c1 ee 02	 shr	 r14d, 2
  008aa	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  008af	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008b2	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 886  :             break;

  008ba	e9 ab fe ff ff	 jmp	 $LN993@inflate
$LN411@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  008bf	41 c1 ee 02	 shr	 r14d, 2
  008c3	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008c6	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 886  :             break;

  008ce	e9 97 fe ff ff	 jmp	 $LN993@inflate
$LN409@inflate:

; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008d3	49 8b cd	 mov	 rcx, r13
  008d6	e8 00 00 00 00	 call	 fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  008db	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H

; 871  :                 if (flush == Z_TREES) {

  008e3	41 83 fb 06	 cmp	 r11d, 6
  008e7	0f 85 98 00 00
	00		 jne	 $LN138@inflate

; 872  :                     DROPBITS(2);

  008ed	41 c1 ee 02	 shr	 r14d, 2
  008f1	83 c3 fd	 add	 ebx, -3			; fffffffdH
$LN963@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  008f4	44 8b 65 58	 mov	 r12d, DWORD PTR ret$1$[rbp-88]
$LN997@inflate:
  008f8	8b 55 50	 mov	 edx, DWORD PTR flush$[rbp-88]
$inf_leave$1000:
  008fb	4c 8b 7d 48	 mov	 r15, QWORD PTR strm$[rbp-88]
  008ff	48 8b 4d e8	 mov	 rcx, QWORD PTR put$1$[rbp-88]
  00903	8b 45 60	 mov	 eax, DWORD PTR left$1$[rbp-88]
  00906	49 89 4f 10	 mov	 QWORD PTR [r15+16], rcx
  0090a	41 89 47 18	 mov	 DWORD PTR [r15+24], eax
  0090e	49 89 37	 mov	 QWORD PTR [r15], rsi
  00911	41 89 7f 08	 mov	 DWORD PTR [r15+8], edi

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00915	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  0091a	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  0091e	8b 5d dc	 mov	 ebx, DWORD PTR out$1$[rbp-88]
  00921	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  00925	75 29		 jne	 SHORT $LN502@inflate
  00927	41 3b 5f 18	 cmp	 ebx, DWORD PTR [r15+24]
  0092b	0f 84 ee 0c 00
	00		 je	 $LN503@inflate
  00931	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00935	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  0093a	0f 8d df 0c 00
	00		 jge	 $LN503@inflate
  00940	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  00945	7c 09		 jl	 SHORT $LN502@inflate
  00947	83 fa 04	 cmp	 edx, 4
  0094a	0f 84 cf 0c 00
	00		 je	 $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00950	49 8b 57 10	 mov	 rdx, QWORD PTR [r15+16]
  00954	44 8b c3	 mov	 r8d, ebx
  00957	45 2b 47 18	 sub	 r8d, DWORD PTR [r15+24]
  0095b	49 8b cf	 mov	 rcx, r15
  0095e	e8 00 00 00 00	 call	 updatewindow
  00963	85 c0		 test	 eax, eax
  00965	0f 84 b4 0c 00
	00		 je	 $LN503@inflate

; 1258 :             state->mode = MEM;

  0096b	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1275 : }

  00973	b8 fc ff ff ff	 mov	 eax, -4
  00978	e9 6b 0d 00 00	 jmp	 $LN1@inflate
$LN408@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  0097d	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 883  :                 state->mode = BAD;
; 884  :             }
; 885  :             DROPBITS(2);

  00985	41 c1 ee 02	 shr	 r14d, 2
  00989	83 c3 fd	 add	 ebx, -3			; fffffffdH

; 886  :             break;

  0098c	e9 d9 fd ff ff	 jmp	 $LN993@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00991	8b cb		 mov	 ecx, ebx
  00993	83 e1 07	 and	 ecx, 7
  00996	41 d3 ee	 shr	 r14d, cl
  00999	2b d9		 sub	 ebx, ecx

; 889  :             NEEDBITS(32);

  0099b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0099e	73 1f		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  009a0	85 ff		 test	 edi, edi
  009a2	0f 84 4c ff ff
	ff		 je	 $LN963@inflate
  009a8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  009ab	8b cb		 mov	 ecx, ebx
  009ad	d3 e0		 shl	 eax, cl
  009af	ff cf		 dec	 edi
  009b1	44 03 f0	 add	 r14d, eax
  009b4	48 ff c6	 inc	 rsi
  009b7	83 c3 08	 add	 ebx, 8
  009ba	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009bd	72 e1		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009bf	41 8b c6	 mov	 eax, r14d
  009c2	41 0f b7 ce	 movzx	 ecx, r14w
  009c6	f7 d0		 not	 eax
  009c8	c1 e8 10	 shr	 eax, 16
  009cb	3b c8		 cmp	 ecx, eax
  009cd	74 19		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  009cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  009d6	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 892  :                 state->mode = BAD;

  009db	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 893  :                 break;

  009e3	e9 86 fd ff ff	 jmp	 $LN8@inflate
$LN415@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  009e8	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  009ec	45 8b f7	 mov	 r14d, r15d

; 899  :             state->mode = COPY_;

  009ef	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  009f7	41 8b df	 mov	 ebx, r15d

; 900  :             if (flush == Z_TREES) goto inf_leave;

  009fa	41 83 fb 06	 cmp	 r11d, 6
  009fe	0f 84 f0 fe ff
	ff		 je	 $LN963@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00a04	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  00a0c	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]

; 905  :             if (copy) {

  00a10	85 c9		 test	 ecx, ecx
  00a12	74 50		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;
; 907  :                 if (copy > left) copy = left;

  00a14	3b cf		 cmp	 ecx, edi
  00a16	8b c7		 mov	 eax, edi

; 908  :                 if (copy == 0) goto inf_leave;

  00a18	45 8b fa	 mov	 r15d, r10d
  00a1b	0f 46 c1	 cmovbe	 eax, ecx
  00a1e	41 3b c2	 cmp	 eax, r10d
  00a21	44 0f 46 f8	 cmovbe	 r15d, eax
  00a25	45 85 ff	 test	 r15d, r15d
  00a28	0f 84 c6 fe ff
	ff		 je	 $LN963@inflate

; 909  :                 zmemcpy(put, next, copy);

  00a2e	45 8b c7	 mov	 r8d, r15d
  00a31	48 8b d6	 mov	 rdx, rsi
  00a34	49 8b c9	 mov	 rcx, r9
  00a37	e8 00 00 00 00	 call	 memcpy

; 910  :                 have -= copy;
; 911  :                 next += copy;
; 912  :                 left -= copy;

  00a3c	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
  00a40	41 2b ff	 sub	 edi, r15d

; 913  :                 put += copy;

  00a43	4c 8b 4d e8	 mov	 r9, QWORD PTR put$1$[rbp-88]
  00a47	45 2b d7	 sub	 r10d, r15d
  00a4a	41 8b c7	 mov	 eax, r15d
  00a4d	4c 03 c8	 add	 r9, rax
  00a50	44 89 55 60	 mov	 DWORD PTR left$1$[rbp-88], r10d
  00a54	48 03 f0	 add	 rsi, rax
  00a57	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9

; 914  :                 state->length -= copy;

  00a5b	45 29 7d 50	 sub	 DWORD PTR [r13+80], r15d

; 915  :                 break;

  00a5f	e9 0a fd ff ff	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  00a64	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 919  :             break;

  00a6c	e9 fd fc ff ff	 jmp	 $LN8@inflate
$LN155@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a71	83 fb 0e	 cmp	 ebx, 14
  00a74	73 1f		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a76	85 ff		 test	 edi, edi
  00a78	0f 84 76 fe ff
	ff		 je	 $LN963@inflate
  00a7e	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00a81	8b cb		 mov	 ecx, ebx
  00a83	d3 e0		 shl	 eax, cl
  00a85	ff cf		 dec	 edi
  00a87	44 03 f0	 add	 r14d, eax
  00a8a	48 ff c6	 inc	 rsi
  00a8d	83 c3 08	 add	 ebx, 8
  00a90	83 fb 0e	 cmp	 ebx, 14
  00a93	72 e1		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00a95	41 8b ce	 mov	 ecx, r14d

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00a98	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00a9b	41 c1 ee 05	 shr	 r14d, 5
  00a9f	83 e1 1f	 and	 ecx, 31
  00aa2	41 8b d6	 mov	 edx, r14d
  00aa5	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00aab	41 c1 ee 05	 shr	 r14d, 5
  00aaf	83 e2 1f	 and	 edx, 31
  00ab2	41 8b c6	 mov	 eax, r14d
  00ab5	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00ab9	83 e0 0f	 and	 eax, 15
  00abc	41 c1 ee 04	 shr	 r14d, 4
  00ac0	83 c0 04	 add	 eax, 4
  00ac3	ff c2		 inc	 edx
  00ac5	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00acc	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00ad0	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00ad6	0f 87 1f 01 00
	00		 ja	 $LN426@inflate
  00adc	83 fa 1e	 cmp	 edx, 30
  00adf	0f 87 16 01 00
	00		 ja	 $LN426@inflate

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00ae5	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 937  :             state->mode = LENLENS;

  00aec	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00af4	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00afb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00b02	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b06	73 62		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00b08	83 fb 03	 cmp	 ebx, 3
  00b0b	73 22		 jae	 SHORT $LN172@inflate
  00b0d	0f 1f 00	 npad	 3
$LL175@inflate:
  00b10	85 ff		 test	 edi, edi
  00b12	0f 84 dc fd ff
	ff		 je	 $LN963@inflate
  00b18	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00b1b	8b cb		 mov	 ecx, ebx
  00b1d	d3 e0		 shl	 eax, cl
  00b1f	ff cf		 dec	 edi
  00b21	44 03 f0	 add	 r14d, eax
  00b24	48 ff c6	 inc	 rsi
  00b27	83 c3 08	 add	 ebx, 8
  00b2a	83 fb 03	 cmp	 ebx, 3
  00b2d	72 e1		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b2f	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b36	41 0f b7 ce	 movzx	 ecx, r14w
  00b3a	66 83 e1 07	 and	 cx, 7

; 942  :                 DROPBITS(3);

  00b3e	41 c1 ee 03	 shr	 r14d, 3
  00b42	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00b45	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b4d	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00b56	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b5d	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b64	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b68	72 9e		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00b6a	83 f8 13	 cmp	 eax, 19
  00b6d	73 2a		 jae	 SHORT $LN184@inflate
  00b6f	90		 npad	 1
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b70	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b77	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b7f	66 45 89 bc 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r15w
  00b88	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b8f	41 83 bd 84 00
	00 00 13	 cmp	 DWORD PTR [r13+132], 19
  00b97	72 d7		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;
; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00b99	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  00b9d	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  00ba4	c7 01 07 00 00
	00		 mov	 DWORD PTR [rcx], 7
  00baa	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00bb1	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00bb5	49 89 01	 mov	 QWORD PTR [r9], rax

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00bb8	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00bbf	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00bc6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00bcb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00bd0	33 c9		 xor	 ecx, ecx
  00bd2	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00bd6	e8 00 00 00 00	 call	 inflate_table
  00bdb	89 45 58	 mov	 DWORD PTR ret$1$[rbp-88], eax

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  00bde	85 c0		 test	 eax, eax
  00be0	74 32		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00be2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00be9	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 953  :                 state->mode = BAD;

  00bee	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 954  :                 break;

  00bf6	e9 6b fb ff ff	 jmp	 $LN929@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00bfb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c02	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 931  :                 state->mode = BAD;

  00c07	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 932  :                 break;

  00c0f	e9 5a fb ff ff	 jmp	 $LN8@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00c14	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 958  :             state->mode = CODELENS;

  00c1b	ba 46 3f 00 00	 mov	 edx, 16198		; 00003f46H
  00c20	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00c28	41 8b 8d 80 00
	00 00		 mov	 ecx, DWORD PTR [r13+128]
  00c2f	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00c33	41 03 c8	 add	 ecx, r8d
  00c36	41 39 8d 84 00
	00 00		 cmp	 DWORD PTR [r13+132], ecx
  00c3d	0f 83 0e 02 00
	00		 jae	 $LN186@inflate
  00c43	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00c50	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  00c54	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c5a	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  00c5e	41 d3 e1	 shl	 r9d, cl
  00c61	41 ff c9	 dec	 r9d
  00c64	41 8b c6	 mov	 eax, r14d
  00c67	41 8b c9	 mov	 ecx, r9d
  00c6a	48 23 c8	 and	 rcx, rax
  00c6d	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00c71	8b d0		 mov	 edx, eax
  00c73	c1 ea 08	 shr	 edx, 8
  00c76	44 8b c0	 mov	 r8d, eax
  00c79	0f b6 ca	 movzx	 ecx, dl
  00c7c	41 c1 e8 10	 shr	 r8d, 16
  00c80	89 45 e0	 mov	 DWORD PTR here$[rbp-88], eax

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00c83	3b cb		 cmp	 ecx, ebx
  00c85	76 3d		 jbe	 SHORT $LN655@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00c87	85 ff		 test	 edi, edi
  00c89	0f 84 65 fc ff
	ff		 je	 $LN963@inflate
  00c8f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00c92	8b cb		 mov	 ecx, ebx
  00c94	d3 e0		 shl	 eax, cl
  00c96	ff cf		 dec	 edi
  00c98	44 03 f0	 add	 r14d, eax
  00c9b	48 ff c6	 inc	 rsi
  00c9e	41 8b ce	 mov	 ecx, r14d
  00ca1	83 c3 08	 add	 ebx, 8
  00ca4	41 8b c1	 mov	 eax, r9d
  00ca7	48 23 c1	 and	 rax, rcx
  00caa	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00cae	8b d0		 mov	 edx, eax
  00cb0	c1 ea 08	 shr	 edx, 8
  00cb3	44 8b c0	 mov	 r8d, eax
  00cb6	0f b6 ca	 movzx	 ecx, dl
  00cb9	41 c1 e8 10	 shr	 r8d, 16
  00cbd	89 45 e0	 mov	 DWORD PTR here$[rbp-88], eax
  00cc0	3b cb		 cmp	 ecx, ebx
  00cc2	77 c3		 ja	 SHORT $LL187@inflate
$LN655@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00cc4	66 41 83 f8 10	 cmp	 r8w, 16
  00cc9	73 31		 jae	 SHORT $LN433@inflate

; 967  :                     DROPBITS(here.bits);

  00ccb	0f b6 ca	 movzx	 ecx, dl

; 968  :                     state->lens[state->have++] = here.val;

  00cce	c1 e8 10	 shr	 eax, 16
  00cd1	41 d3 ee	 shr	 r14d, cl
  00cd4	0f b6 ca	 movzx	 ecx, dl
  00cd7	2b d9		 sub	 ebx, ecx
  00cd9	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00ce0	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00ce9	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00cf0	41 8b 95 84 00
	00 00		 mov	 edx, DWORD PTR [r13+132]

; 969  :                 }

  00cf7	e9 3b 01 00 00	 jmp	 $LN610@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00cfc	0f b6 d2	 movzx	 edx, dl
  00cff	75 5f		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00d01	83 c2 02	 add	 edx, 2
  00d04	3b da		 cmp	 ebx, edx
  00d06	73 1e		 jae	 SHORT $LN196@inflate
$LL199@inflate:
  00d08	85 ff		 test	 edi, edi
  00d0a	0f 84 e4 fb ff
	ff		 je	 $LN963@inflate
  00d10	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00d13	8b cb		 mov	 ecx, ebx
  00d15	d3 e0		 shl	 eax, cl
  00d17	ff cf		 dec	 edi
  00d19	44 03 f0	 add	 r14d, eax
  00d1c	48 ff c6	 inc	 rsi
  00d1f	83 c3 08	 add	 ebx, 8
  00d22	3b da		 cmp	 ebx, edx
  00d24	72 e2		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00d26	0f b6 4d e1	 movzx	 ecx, BYTE PTR here$[rbp-87]

; 974  :                         if (state->have == 0) {

  00d2a	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d31	2b d9		 sub	 ebx, ecx
  00d33	41 d3 ee	 shr	 r14d, cl
  00d36	85 c0		 test	 eax, eax
  00d38	0f 84 43 01 00
	00		 je	 $LN567@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";
; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];
; 980  :                         copy = 3 + BITS(2);

  00d3e	45 8b c6	 mov	 r8d, r14d

; 981  :                         DROPBITS(2);

  00d41	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00d44	41 83 e0 03	 and	 r8d, 3
  00d48	41 c1 ee 02	 shr	 r14d, 2
  00d4c	41 83 c0 03	 add	 r8d, 3
  00d50	ff c8		 dec	 eax
  00d52	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 982  :                     }

  00d5b	e9 96 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00d60	66 41 83 f8 11	 cmp	 r8w, 17
  00d65	75 47		 jne	 SHORT $LN226@inflate

; 984  :                         NEEDBITS(here.bits + 3);

  00d67	83 c2 03	 add	 edx, 3
  00d6a	3b da		 cmp	 ebx, edx
  00d6c	73 20		 jae	 SHORT $LN210@inflate
  00d6e	66 90		 npad	 2
$LL213@inflate:
  00d70	85 ff		 test	 edi, edi
  00d72	0f 84 7c fb ff
	ff		 je	 $LN963@inflate
  00d78	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00d7b	8b cb		 mov	 ecx, ebx
  00d7d	d3 e0		 shl	 eax, cl
  00d7f	ff cf		 dec	 edi
  00d81	44 03 f0	 add	 r14d, eax
  00d84	48 ff c6	 inc	 rsi
  00d87	83 c3 08	 add	 ebx, 8
  00d8a	3b da		 cmp	 ebx, edx
  00d8c	72 e2		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00d8e	0f b6 4d e1	 movzx	 ecx, BYTE PTR here$[rbp-87]

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);
; 988  :                         DROPBITS(3);

  00d92	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00d97	41 d3 ee	 shr	 r14d, cl
  00d9a	45 8b cf	 mov	 r9d, r15d
  00d9d	45 8b c6	 mov	 r8d, r14d
  00da0	41 83 e0 07	 and	 r8d, 7
  00da4	41 83 c0 03	 add	 r8d, 3
  00da8	41 c1 ee 03	 shr	 r14d, 3

; 989  :                     }

  00dac	eb 44		 jmp	 SHORT $LN994@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00dae	83 c2 07	 add	 edx, 7
  00db1	3b da		 cmp	 ebx, edx
  00db3	73 1e		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00db5	85 ff		 test	 edi, edi
  00db7	0f 84 37 fb ff
	ff		 je	 $LN963@inflate
  00dbd	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00dc0	8b cb		 mov	 ecx, ebx
  00dc2	d3 e0		 shl	 eax, cl
  00dc4	ff cf		 dec	 edi
  00dc6	44 03 f0	 add	 r14d, eax
  00dc9	48 ff c6	 inc	 rsi
  00dcc	83 c3 08	 add	 ebx, 8
  00dcf	3b da		 cmp	 ebx, edx
  00dd1	72 e2		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00dd3	0f b6 4d e1	 movzx	 ecx, BYTE PTR here$[rbp-87]

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);
; 995  :                         DROPBITS(7);

  00dd7	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00ddc	41 d3 ee	 shr	 r14d, cl
  00ddf	45 0f b7 cf	 movzx	 r9d, r15w
  00de3	45 8b c6	 mov	 r8d, r14d
  00de6	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  00dea	41 83 c0 0b	 add	 r8d, 11
  00dee	41 c1 ee 07	 shr	 r14d, 7
$LN994@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00df2	2b c1		 sub	 eax, ecx
  00df4	03 d8		 add	 ebx, eax
$LN236@inflate:
  00df6	41 8b 95 80 00
	00 00		 mov	 edx, DWORD PTR [r13+128]
  00dfd	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00e04	41 03 55 7c	 add	 edx, DWORD PTR [r13+124]
  00e08	41 03 c8	 add	 ecx, r8d
  00e0b	3b ca		 cmp	 ecx, edx
  00e0d	77 72		 ja	 SHORT $LN567@inflate
  00e0f	90		 npad	 1
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00e10	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00e17	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  00e20	41 8b 95 84 00
	00 00		 mov	 edx, DWORD PTR [r13+132]
  00e27	8d 52 01	 lea	 edx, DWORD PTR [rdx+1]
  00e2a	41 89 95 84 00
	00 00		 mov	 DWORD PTR [r13+132], edx
  00e31	41 83 c0 ff	 add	 r8d, -1			; ffffffffH
  00e35	75 d9		 jne	 SHORT $LL238@inflate
$LN610@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00e37	41 8b 8d 80 00
	00 00		 mov	 ecx, DWORD PTR [r13+128]
  00e3e	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00e42	41 03 c8	 add	 ecx, r8d
  00e45	3b d1		 cmp	 edx, ecx
  00e47	0f 82 03 fe ff
	ff		 jb	 $LL185@inflate

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  00e4d	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00e51	81 fa 51 3f 00
	00		 cmp	 edx, 16209		; 00003f51H
  00e57	0f 84 09 f9 ff
	ff		 je	 $LN929@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00e5d	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00e66	75 32		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e68	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00e6f	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1013 :                 state->mode = BAD;

  00e74	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1014 :                 break;

  00e7c	e9 e5 f8 ff ff	 jmp	 $LN929@inflate
$LN567@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00e81	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e88	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00e8d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00e95	e9 cc f8 ff ff	 jmp	 $LN929@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00e9a	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00ea1	41 c7 45 70 09
	00 00 00	 mov	 DWORD PTR [r13+112], 9
  00ea9	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00eb0	4d 8d a5 10 03
	00 00		 lea	 r12, QWORD PTR [r13+784]
  00eb7	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00ebb	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00ec2	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00ec6	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00ecb	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00ed2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ed7	b9 01 00 00 00	 mov	 ecx, 1
  00edc	e8 00 00 00 00	 call	 inflate_table
  00ee1	89 45 58	 mov	 DWORD PTR ret$1$[rbp-88], eax

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00ee4	85 c0		 test	 eax, eax
  00ee6	74 1d		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00ee8	4c 8b 65 48	 mov	 r12, QWORD PTR strm$[rbp-88]
  00eec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00ef3	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1027 :                 state->mode = BAD;

  00ef8	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1028 :                 break;

  00f00	e9 61 f8 ff ff	 jmp	 $LN929@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00f05	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1031 :             state->distbits = 6;

  00f0c	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f10	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00f17	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f1e	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00f22	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00f26	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00f2c	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00f31	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f36	b9 02 00 00 00	 mov	 ecx, 2
  00f3b	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00f43	49 03 d5	 add	 rdx, r13
  00f46	e8 00 00 00 00	 call	 inflate_table
  00f4b	89 45 58	 mov	 DWORD PTR ret$1$[rbp-88], eax
  00f4e	44 8b e0	 mov	 r12d, eax

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  00f51	85 c0		 test	 eax, eax
  00f53	74 1d		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  00f55	4c 8b 65 48	 mov	 r12, QWORD PTR strm$[rbp-88]
  00f59	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00f60	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1036 :                 state->mode = BAD;

  00f65	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1037 :                 break;

  00f6d	e9 f4 f7 ff ff	 jmp	 $LN929@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00f72	8b 55 50	 mov	 edx, DWORD PTR flush$[rbp-88]
  00f75	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00f7d	83 fa 06	 cmp	 edx, 6
  00f80	0f 84 75 f9 ff
	ff		 je	 $inf_leave$1000
  00f86	4c 8b 65 48	 mov	 r12, QWORD PTR strm$[rbp-88]
  00f8a	45 33 ff	 xor	 r15d, r15d
  00f8d	44 8b 45 dc	 mov	 r8d, DWORD PTR out$1$[rbp-88]
  00f91	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00f95	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00f9d	83 ff 06	 cmp	 edi, 6
  00fa0	72 74		 jb	 SHORT $LN451@inflate
  00fa2	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00fa9	72 6b		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00fab	48 8b 4d e8	 mov	 rcx, QWORD PTR put$1$[rbp-88]

; 1047 :                 inflate_fast(strm, out);

  00faf	41 8b d0	 mov	 edx, r8d
  00fb2	49 89 4c 24 10	 mov	 QWORD PTR [r12+16], rcx
  00fb7	49 8b cc	 mov	 rcx, r12
  00fba	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  00fbf	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  00fc3	41 89 7c 24 08	 mov	 DWORD PTR [r12+8], edi
  00fc8	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  00fcc	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00fd0	e8 00 00 00 00	 call	 inflate_fast

; 1048 :                 LOAD();
; 1049 :                 if (state->mode == TYPE)

  00fd5	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  00fdd	4d 8b 4c 24 10	 mov	 r9, QWORD PTR [r12+16]
  00fe2	45 8b 54 24 18	 mov	 r10d, DWORD PTR [r12+24]
  00fe7	49 8b 34 24	 mov	 rsi, QWORD PTR [r12]
  00feb	41 8b 7c 24 08	 mov	 edi, DWORD PTR [r12+8]
  00ff0	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  00ff4	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  00ff8	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9
  00ffc	44 89 55 60	 mov	 DWORD PTR left$1$[rbp-88], r10d
  01000	0f 85 68 f7 ff
	ff		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  01006	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1051 :                 break;

  01011	e9 58 f7 ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  01016	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  0101a	ba 01 00 00 00	 mov	 edx, 1
  0101f	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  01023	d3 e2		 shl	 edx, cl
  01025	ff ca		 dec	 edx
  01027	41 8b c6	 mov	 eax, r14d
  0102a	8b ca		 mov	 ecx, edx
  0102c	48 23 c8	 and	 rcx, rax
  0102f	45 89 bd e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r15d
  01036	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  0103a	8b c8		 mov	 ecx, eax
  0103c	c1 e9 08	 shr	 ecx, 8
  0103f	0f b6 c9	 movzx	 ecx, cl

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  01042	3b cb		 cmp	 ecx, ebx
  01044	76 32		 jbe	 SHORT $LN569@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  01046	85 ff		 test	 edi, edi
  01048	0f 84 a6 f8 ff
	ff		 je	 $LN963@inflate
  0104e	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  01051	8b cb		 mov	 ecx, ebx
  01053	d3 e0		 shl	 eax, cl
  01055	ff cf		 dec	 edi
  01057	44 03 f0	 add	 r14d, eax
  0105a	48 ff c6	 inc	 rsi
  0105d	41 8b ce	 mov	 ecx, r14d
  01060	83 c3 08	 add	 ebx, 8
  01063	8b c2		 mov	 eax, edx
  01065	48 23 c1	 and	 rax, rcx
  01068	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  0106c	8b c8		 mov	 ecx, eax
  0106e	c1 e9 08	 shr	 ecx, 8
  01071	0f b6 c9	 movzx	 ecx, cl
  01074	3b cb		 cmp	 ecx, ebx
  01076	77 ce		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  01078	84 c0		 test	 al, al
  0107a	0f 84 b3 00 00
	00		 je	 $LN263@inflate
  01080	a8 f0		 test	 al, 240			; 000000f0H
  01082	0f 85 ab 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;

  01088	8b c8		 mov	 ecx, eax
  0108a	89 45 e0	 mov	 DWORD PTR last$[rbp-88], eax

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +
; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0108d	44 0f b6 7d e1	 movzx	 r15d, BYTE PTR last$[rbp-87]
  01092	41 b8 01 00 00
	00		 mov	 r8d, 1
  01098	c1 e9 08	 shr	 ecx, 8
  0109b	8b d0		 mov	 edx, eax
  0109d	44 0f b6 c9	 movzx	 r9d, cl
  010a1	0f b6 c8	 movzx	 ecx, al
  010a4	41 03 c9	 add	 ecx, r9d
  010a7	c1 e8 10	 shr	 eax, 16
  010aa	41 d3 e0	 shl	 r8d, cl
  010ad	41 8b c9	 mov	 ecx, r9d
  010b0	41 ff c8	 dec	 r8d
  010b3	45 23 c6	 and	 r8d, r14d
  010b6	41 d3 e8	 shr	 r8d, cl
  010b9	44 03 c0	 add	 r8d, eax
  010bc	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  010c0	8b c8		 mov	 ecx, eax
  010c2	c1 e9 08	 shr	 ecx, 8
  010c5	44 0f b6 c1	 movzx	 r8d, cl
  010c9	45 03 c1	 add	 r8d, r9d
  010cc	44 3b c3	 cmp	 r8d, ebx
  010cf	76 52		 jbe	 SHORT $LN260@inflate
  010d1	44 0f b7 5d e2	 movzx	 r11d, WORD PTR last$[rbp-86]
$LL252@inflate:

; 1065 :                     PULLBYTE();

  010d6	85 ff		 test	 edi, edi
  010d8	0f 84 16 f8 ff
	ff		 je	 $LN963@inflate
  010de	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  010e1	8b cb		 mov	 ecx, ebx
  010e3	d3 e0		 shl	 eax, cl
  010e5	41 b8 01 00 00
	00		 mov	 r8d, 1
  010eb	44 03 f0	 add	 r14d, eax
  010ee	0f b6 ca	 movzx	 ecx, dl
  010f1	41 03 cf	 add	 ecx, r15d
  010f4	ff cf		 dec	 edi
  010f6	41 d3 e0	 shl	 r8d, cl
  010f9	48 ff c6	 inc	 rsi
  010fc	41 ff c8	 dec	 r8d
  010ff	41 8b cf	 mov	 ecx, r15d
  01102	45 23 c6	 and	 r8d, r14d
  01105	83 c3 08	 add	 ebx, 8
  01108	41 d3 e8	 shr	 r8d, cl
  0110b	45 03 c3	 add	 r8d, r11d
  0110e	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  01112	8b c8		 mov	 ecx, eax
  01114	c1 e9 08	 shr	 ecx, 8
  01117	44 0f b6 c1	 movzx	 r8d, cl
  0111b	45 03 c7	 add	 r8d, r15d
  0111e	44 3b c3	 cmp	 r8d, ebx
  01121	77 b3		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);

  01123	41 8b cf	 mov	 ecx, r15d
  01126	41 d3 ee	 shr	 r14d, cl
  01129	41 2b df	 sub	 ebx, r15d

; 1068 :                 state->back += last.bits;

  0112c	41 89 8d e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], ecx
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  01133	8b c8		 mov	 ecx, eax
  01135	c1 e9 08	 shr	 ecx, 8
  01138	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  0113b	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  01142	2b d9		 sub	 ebx, ecx
  01144	41 d3 ee	 shr	 r14d, cl

; 1072 :             state->length = (unsigned)here.val;

  01147	8b c8		 mov	 ecx, eax
  01149	c1 e9 10	 shr	 ecx, 16
  0114c	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1073 :             if ((int)(here.op) == 0) {

  01150	84 c0		 test	 al, al
  01152	75 0d		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  01154	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1078 :                 break;

  0115c	e9 05 f6 ff ff	 jmp	 $LN929@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  01161	a8 20		 test	 al, 32			; 00000020H
  01163	74 10		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  01165	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1083 :                 state->mode = TYPE;
; 1084 :                 break;

  01170	e9 e9 f5 ff ff	 jmp	 $LN995@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  01175	a8 40		 test	 al, 64			; 00000040H
  01177	74 19		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  01179	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  01180	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1088 :                 state->mode = BAD;

  01185	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1089 :                 break;

  0118d	e9 d4 f5 ff ff	 jmp	 $LN929@inflate
$LN460@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  01192	0f b6 c8	 movzx	 ecx, al
  01195	83 e1 0f	 and	 ecx, 15

; 1092 :             state->mode = LENEXT;

  01198	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  011a0	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  011a4	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  011a8	85 d2		 test	 edx, edx
  011aa	74 40		 je	 SHORT $LN753@inflate

; 1095 :                 NEEDBITS(state->extra);

  011ac	3b da		 cmp	 ebx, edx
  011ae	73 1e		 jae	 SHORT $LN264@inflate
$LL267@inflate:
  011b0	85 ff		 test	 edi, edi
  011b2	0f 84 3c f7 ff
	ff		 je	 $LN963@inflate
  011b8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  011bb	8b cb		 mov	 ecx, ebx
  011bd	d3 e0		 shl	 eax, cl
  011bf	ff cf		 dec	 edi
  011c1	44 03 f0	 add	 r14d, eax
  011c4	48 ff c6	 inc	 rsi
  011c7	83 c3 08	 add	 ebx, 8
  011ca	3b da		 cmp	 ebx, edx
  011cc	72 e2		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  011ce	8b ca		 mov	 ecx, edx
  011d0	b8 01 00 00 00	 mov	 eax, 1
  011d5	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  011d7	2b da		 sub	 ebx, edx
  011d9	ff c8		 dec	 eax
  011db	41 23 c6	 and	 eax, r14d
  011de	41 d3 ee	 shr	 r14d, cl
  011e1	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1098 :                 state->back += state->extra;

  011e5	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN753@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  011ec	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  011f0	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1102 :             state->mode = DIST;

  011f7	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  011ff	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  01203	ba 01 00 00 00	 mov	 edx, 1
  01208	4d 8b 55 68	 mov	 r10, QWORD PTR [r13+104]
  0120c	d3 e2		 shl	 edx, cl
  0120e	ff ca		 dec	 edx
  01210	41 8b c6	 mov	 eax, r14d
  01213	8b ca		 mov	 ecx, edx
  01215	48 23 c8	 and	 rcx, rax
  01218	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  0121c	8b c8		 mov	 ecx, eax
  0121e	c1 e9 08	 shr	 ecx, 8
  01221	0f b6 c9	 movzx	 ecx, cl

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  01224	3b cb		 cmp	 ecx, ebx
  01226	76 32		 jbe	 SHORT $LN574@inflate
$LL275@inflate:

; 1107 :                 PULLBYTE();

  01228	85 ff		 test	 edi, edi
  0122a	0f 84 c4 f6 ff
	ff		 je	 $LN963@inflate
  01230	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  01233	8b cb		 mov	 ecx, ebx
  01235	d3 e0		 shl	 eax, cl
  01237	ff cf		 dec	 edi
  01239	44 03 f0	 add	 r14d, eax
  0123c	48 ff c6	 inc	 rsi
  0123f	41 8b ce	 mov	 ecx, r14d
  01242	83 c3 08	 add	 ebx, 8
  01245	8b c2		 mov	 eax, edx
  01247	48 23 c1	 and	 rax, rcx
  0124a	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  0124e	8b c8		 mov	 ecx, eax
  01250	c1 e9 08	 shr	 ecx, 8
  01253	0f b6 c9	 movzx	 ecx, cl
  01256	3b cb		 cmp	 ecx, ebx
  01258	77 ce		 ja	 SHORT $LL275@inflate
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  0125a	a8 f0		 test	 al, 240			; 000000f0H
  0125c	0f 85 ab 00 00
	00		 jne	 $LN292@inflate

; 1110 :                 last = here;

  01262	8b c8		 mov	 ecx, eax
  01264	89 45 e0	 mov	 DWORD PTR last$[rbp-88], eax

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +
; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01267	44 0f b6 7d e1	 movzx	 r15d, BYTE PTR last$[rbp-87]
  0126c	41 b8 01 00 00
	00		 mov	 r8d, 1
  01272	c1 e9 08	 shr	 ecx, 8
  01275	8b d0		 mov	 edx, eax
  01277	44 0f b6 c9	 movzx	 r9d, cl
  0127b	0f b6 c8	 movzx	 ecx, al
  0127e	41 03 c9	 add	 ecx, r9d
  01281	c1 e8 10	 shr	 eax, 16
  01284	41 d3 e0	 shl	 r8d, cl
  01287	41 8b c9	 mov	 ecx, r9d
  0128a	41 ff c8	 dec	 r8d
  0128d	45 23 c6	 and	 r8d, r14d
  01290	41 d3 e8	 shr	 r8d, cl
  01293	44 03 c0	 add	 r8d, eax
  01296	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  0129a	8b c8		 mov	 ecx, eax
  0129c	c1 e9 08	 shr	 ecx, 8
  0129f	44 0f b6 c1	 movzx	 r8d, cl
  012a3	45 03 c1	 add	 r8d, r9d
  012a6	44 3b c3	 cmp	 r8d, ebx
  012a9	76 52		 jbe	 SHORT $LN289@inflate
  012ab	44 0f b7 5d e2	 movzx	 r11d, WORD PTR last$[rbp-86]
$LL281@inflate:

; 1115 :                     PULLBYTE();

  012b0	85 ff		 test	 edi, edi
  012b2	0f 84 3c f6 ff
	ff		 je	 $LN963@inflate
  012b8	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  012bb	8b cb		 mov	 ecx, ebx
  012bd	d3 e0		 shl	 eax, cl
  012bf	41 b8 01 00 00
	00		 mov	 r8d, 1
  012c5	44 03 f0	 add	 r14d, eax
  012c8	0f b6 ca	 movzx	 ecx, dl
  012cb	41 03 cf	 add	 ecx, r15d
  012ce	ff cf		 dec	 edi
  012d0	41 d3 e0	 shl	 r8d, cl
  012d3	48 ff c6	 inc	 rsi
  012d6	41 ff c8	 dec	 r8d
  012d9	41 8b cf	 mov	 ecx, r15d
  012dc	45 23 c6	 and	 r8d, r14d
  012df	83 c3 08	 add	 ebx, 8
  012e2	41 d3 e8	 shr	 r8d, cl
  012e5	45 03 c3	 add	 r8d, r11d
  012e8	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  012ec	8b c8		 mov	 ecx, eax
  012ee	c1 e9 08	 shr	 ecx, 8
  012f1	44 0f b6 c1	 movzx	 r8d, cl
  012f5	45 03 c7	 add	 r8d, r15d
  012f8	44 3b c3	 cmp	 r8d, ebx
  012fb	77 b3		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);

  012fd	41 8b cf	 mov	 ecx, r15d
  01300	41 2b df	 sub	 ebx, r15d
  01303	41 d3 ee	 shr	 r14d, cl

; 1118 :                 state->back += last.bits;

  01306	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {

  0130d	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
  01311	8b c8		 mov	 ecx, eax
  01313	c1 e9 08	 shr	 ecx, 8
  01316	0f b6 c9	 movzx	 ecx, cl
  01319	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  01320	2b d9		 sub	 ebx, ecx
  01322	41 d3 ee	 shr	 r14d, cl
  01325	a8 40		 test	 al, 64			; 00000040H
  01327	74 19		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01329	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  01330	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1124 :                 state->mode = BAD;

  01335	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1125 :                 break;

  0133d	e9 28 f4 ff ff	 jmp	 $LN993@inflate
$LN470@inflate:
  01342	44 8b 45 dc	 mov	 r8d, DWORD PTR out$1$[rbp-88]

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  01346	8b c8		 mov	 ecx, eax
  01348	c1 e9 10	 shr	 ecx, 16
  0134b	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  0134f	0f b6 c8	 movzx	 ecx, al
  01352	83 e1 0f	 and	 ecx, 15

; 1129 :             state->mode = DISTEXT;

  01355	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  0135d	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  01361	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  01365	85 d2		 test	 edx, edx
  01367	74 43		 je	 SHORT $LN755@inflate

; 1132 :                 NEEDBITS(state->extra);

  01369	3b da		 cmp	 ebx, edx
  0136b	73 21		 jae	 SHORT $LN293@inflate
  0136d	0f 1f 00	 npad	 3
$LL296@inflate:
  01370	85 ff		 test	 edi, edi
  01372	0f 84 7c f5 ff
	ff		 je	 $LN963@inflate
  01378	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0137b	8b cb		 mov	 ecx, ebx
  0137d	d3 e0		 shl	 eax, cl
  0137f	ff cf		 dec	 edi
  01381	44 03 f0	 add	 r14d, eax
  01384	48 ff c6	 inc	 rsi
  01387	83 c3 08	 add	 ebx, 8
  0138a	3b da		 cmp	 ebx, edx
  0138c	72 e2		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  0138e	8b ca		 mov	 ecx, edx
  01390	b8 01 00 00 00	 mov	 eax, 1
  01395	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  01397	2b da		 sub	 ebx, edx
  01399	ff c8		 dec	 eax
  0139b	41 23 c6	 and	 eax, r14d
  0139e	41 d3 ee	 shr	 r14d, cl
  013a1	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1135 :                 state->back += state->extra;

  013a5	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN755@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  013ac	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  013b4	45 85 d2	 test	 r10d, r10d
  013b7	0f 84 37 f5 ff
	ff		 je	 $LN963@inflate

; 1148 :             copy = out - left;
; 1149 :             if (state->offset > copy) {         /* copy from window */

  013bd	41 8b 45 54	 mov	 eax, DWORD PTR [r13+84]
  013c1	41 8b c8	 mov	 ecx, r8d
  013c4	41 2b ca	 sub	 ecx, r10d
  013c7	3b c1		 cmp	 eax, ecx
  013c9	76 51		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  013cb	2b c1		 sub	 eax, ecx

; 1151 :                 if (copy > state->whave) {

  013cd	41 3b 45 38	 cmp	 eax, DWORD PTR [r13+56]
  013d1	76 23		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  013d3	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  013db	74 19		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  013dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  013e4	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1154 :                         state->mode = BAD;

  013e9	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1155 :                         break;

  013f1	e9 74 f3 ff ff	 jmp	 $LN993@inflate
$LN479@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  013f6	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  013fa	3b c1		 cmp	 eax, ecx
  013fc	76 06		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;

  013fe	2b c1		 sub	 eax, ecx

; 1173 :                     from = state->window + (state->wsize - copy);

  01400	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
$LN480@inflate:

; 1174 :                 }
; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);
; 1177 :                 if (copy > state->length) copy = state->length;

  01404	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01408	2b c8		 sub	 ecx, eax
  0140a	8b d1		 mov	 edx, ecx

; 1178 :             }

  0140c	45 8b c8	 mov	 r9d, r8d
  0140f	49 03 55 40	 add	 rdx, QWORD PTR [r13+64]
  01413	41 3b c0	 cmp	 eax, r8d
  01416	44 0f 46 c8	 cmovbe	 r9d, eax
  0141a	eb 0e		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  0141c	48 8b 55 e8	 mov	 rdx, QWORD PTR put$1$[rbp-88]

; 1181 :                 copy = state->length;

  01420	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01424	48 2b d0	 sub	 rdx, rax
  01427	45 8b c8	 mov	 r9d, r8d
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;
; 1184 :             left -= copy;

  0142a	45 3b ca	 cmp	 r9d, r10d
  0142d	41 8b ca	 mov	 ecx, r10d
  01430	41 0f 46 c9	 cmovbe	 ecx, r9d

; 1185 :             state->length -= copy;

  01434	4c 8b 4d e8	 mov	 r9, QWORD PTR put$1$[rbp-88]
  01438	44 2b d1	 sub	 r10d, ecx
  0143b	44 2b c1	 sub	 r8d, ecx
  0143e	44 89 55 60	 mov	 DWORD PTR left$1$[rbp-88], r10d
  01442	49 2b d1	 sub	 rdx, r9
  01445	45 89 45 50	 mov	 DWORD PTR [r13+80], r8d
  01449	0f 1f 80 00 00
	00 00		 npad	 7
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01450	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  01455	41 88 01	 mov	 BYTE PTR [r9], al
  01458	49 ff c1	 inc	 r9

; 1188 :             } while (--copy);

  0145b	83 c1 ff	 add	 ecx, -1			; ffffffffH
  0145e	75 f0		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01460	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9
  01464	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  01468	0f 85 00 f3 ff
	ff		 jne	 $LN8@inflate
  0146e	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1190 :             break;

  01476	e9 f3 f2 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  0147b	45 85 d2	 test	 r10d, r10d
  0147e	0f 84 70 f4 ff
	ff		 je	 $LN963@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  01484	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  01489	41 88 01	 mov	 BYTE PTR [r9], al
  0148c	49 ff c1	 inc	 r9

; 1194 :             left--;

  0148f	41 ff ca	 dec	 r10d
  01492	4c 89 4d e8	 mov	 QWORD PTR put$1$[rbp-88], r9
  01496	44 89 55 60	 mov	 DWORD PTR left$1$[rbp-88], r10d

; 1195 :             state->mode = LEN;

  0149a	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1196 :             break;

  014a2	e9 c7 f2 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  014a7	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  014ac	0f 84 cb 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  014b2	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014b5	73 1f		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  014b7	85 ff		 test	 edi, edi
  014b9	0f 84 35 f4 ff
	ff		 je	 $LN963@inflate
  014bf	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  014c2	8b cb		 mov	 ecx, ebx
  014c4	d3 e0		 shl	 eax, cl
  014c6	ff cf		 dec	 edi
  014c8	44 03 f0	 add	 r14d, eax
  014cb	48 ff c6	 inc	 rsi
  014ce	83 c3 08	 add	 ebx, 8
  014d1	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014d4	72 e1		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1200 :                 out -= left;

  014d6	45 2b c2	 sub	 r8d, r10d

; 1201 :                 strm->total_out += out;

  014d9	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1202 :                 state->total += out;

  014de	45 01 45 24	 add	 DWORD PTR [r13+36], r8d

; 1203 :                 if ((state->wrap & 4) && out)

  014e2	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  014e6	a8 04		 test	 al, 4
  014e8	74 36		 je	 SHORT $LN490@inflate
  014ea	45 85 c0	 test	 r8d, r8d
  014ed	74 31		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  014ef	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  014f3	49 8b d1	 mov	 rdx, r9
  014f6	41 8b c0	 mov	 eax, r8d
  014f9	48 2b d0	 sub	 rdx, rax
  014fc	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01501	74 07		 je	 SHORT $LN511@inflate
  01503	e8 00 00 00 00	 call	 crc32
  01508	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  0150a	e8 00 00 00 00	 call	 adler32
$LN512@inflate:
  0150f	44 8b 55 60	 mov	 r10d, DWORD PTR left$1$[rbp-88]
  01513	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01517	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  0151c	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;

  01520	44 89 55 dc	 mov	 DWORD PTR out$1$[rbp-88], r10d

; 1207 :                 if ((state->wrap & 4) && (

  01524	a8 04		 test	 al, 4
  01526	74 4f		 je	 SHORT $LN317@inflate
  01528	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0152d	41 8b ce	 mov	 ecx, r14d
  01530	75 26		 jne	 SHORT $LN514@inflate
  01532	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01538	41 8b c6	 mov	 eax, r14d
  0153b	c1 e0 10	 shl	 eax, 16
  0153e	03 c8		 add	 ecx, eax
  01540	41 8b c6	 mov	 eax, r14d
  01543	c1 e8 08	 shr	 eax, 8
  01546	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0154b	c1 e1 08	 shl	 ecx, 8
  0154e	03 c8		 add	 ecx, eax
  01550	41 8b c6	 mov	 eax, r14d
  01553	c1 e8 18	 shr	 eax, 24
  01556	03 c8		 add	 ecx, eax
$LN514@inflate:
  01558	41 3b 4d 20	 cmp	 ecx, DWORD PTR [r13+32]
  0155c	74 19		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  0155e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  01565	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1213 :                     state->mode = BAD;

  0156a	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1214 :                     break;

  01572	e9 f3 f1 ff ff	 jmp	 $LN993@inflate
$LN317@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  01577	45 8b f7	 mov	 r14d, r15d
  0157a	41 8b df	 mov	 ebx, r15d
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  0157d	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01585	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  0158a	74 75		 je	 SHORT $LN327@inflate
  0158c	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01591	74 6e		 je	 SHORT $LN327@inflate

; 1223 :                 NEEDBITS(32);

  01593	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01596	73 1f		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01598	85 ff		 test	 edi, edi
  0159a	0f 84 54 f3 ff
	ff		 je	 $LN963@inflate
  015a0	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  015a3	8b cb		 mov	 ecx, ebx
  015a5	d3 e0		 shl	 eax, cl
  015a7	ff cf		 dec	 edi
  015a9	44 03 f0	 add	 r14d, eax
  015ac	48 ff c6	 inc	 rsi
  015af	83 c3 08	 add	 ebx, 8
  015b2	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015b5	72 e1		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  015b7	45 3b 75 24	 cmp	 r14d, DWORD PTR [r13+36]
  015bb	74 3e		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  015bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  015c4	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1226 :                     state->mode = BAD;

  015c9	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  015d1	e9 94 f1 ff ff	 jmp	 $LN993@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  015d6	4d 89 4c 24 10	 mov	 QWORD PTR [r12+16], r9

; 845  :                 return Z_NEED_DICT;

  015db	b8 02 00 00 00	 mov	 eax, 2
  015e0	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  015e5	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  015e9	41 89 7c 24 08	 mov	 DWORD PTR [r12+8], edi
  015ee	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  015f2	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  015f6	e9 ed 00 00 00	 jmp	 $LN1@inflate
$LN328@inflate:

; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015fb	45 8b f7	 mov	 r14d, r15d
  015fe	41 8b df	 mov	 ebx, r15d
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  01601	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  01609	41 bc 01 00 00
	00		 mov	 r12d, 1

; 1236 :             goto inf_leave;

  0160f	e9 e4 f2 ff ff	 jmp	 $LN997@inflate
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  01614	41 bc fd ff ff
	ff		 mov	 r12d, -3
  0161a	e9 d9 f2 ff ff	 jmp	 $LN997@inflate
$LN503@inflate:

; 1259 :             return Z_MEM_ERROR;
; 1260 :         }
; 1261 :     in -= strm->avail_in;
; 1262 :     out -= strm->avail_out;

  0161f	41 2b 5f 18	 sub	 ebx, DWORD PTR [r15+24]
  01623	44 8b 55 e4	 mov	 r10d, DWORD PTR in$1$[rbp-88]
  01627	45 2b 57 08	 sub	 r10d, DWORD PTR [r15+8]

; 1263 :     strm->total_in += in;

  0162b	45 01 57 0c	 add	 DWORD PTR [r15+12], r10d

; 1264 :     strm->total_out += out;

  0162f	41 01 5f 1c	 add	 DWORD PTR [r15+28], ebx

; 1265 :     state->total += out;

  01633	41 01 5d 24	 add	 DWORD PTR [r13+36], ebx

; 1266 :     if ((state->wrap & 4) && out)

  01637	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0163c	44 89 55 e4	 mov	 DWORD PTR in$1$[rbp-88], r10d
  01640	74 33		 je	 SHORT $LN504@inflate
  01642	85 db		 test	 ebx, ebx
  01644	74 2f		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  01646	49 8b 57 10	 mov	 rdx, QWORD PTR [r15+16]
  0164a	44 8b c3	 mov	 r8d, ebx
  0164d	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  01651	8b c3		 mov	 eax, ebx
  01653	48 2b d0	 sub	 rdx, rax
  01656	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0165b	74 07		 je	 SHORT $LN515@inflate
  0165d	e8 00 00 00 00	 call	 crc32
  01662	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  01664	e8 00 00 00 00	 call	 adler32
$LN516@inflate:
  01669	44 8b 55 e4	 mov	 r10d, DWORD PTR in$1$[rbp-88]
  0166d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01671	41 89 47 4c	 mov	 DWORD PTR [r15+76], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01675	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  01679	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  0167f	74 10		 je	 SHORT $LN517@inflate
  01681	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01687	74 08		 je	 SHORT $LN517@inflate
  01689	45 33 c9	 xor	 r9d, r9d
  0168c	45 8b c1	 mov	 r8d, r9d
  0168f	eb 09		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  01691	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01697	45 33 c9	 xor	 r9d, r9d
$LN518@inflate:
  0169a	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  0169e	f7 d8		 neg	 eax
  016a0	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  016a5	1b c9		 sbb	 ecx, ecx
  016a7	83 e1 40	 and	 ecx, 64			; 00000040H
  016aa	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  016b0	44 0f 44 c8	 cmove	 r9d, eax
  016b4	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  016b8	44 03 c8	 add	 r9d, eax
  016bb	45 03 4d 4c	 add	 r9d, DWORD PTR [r13+76]
  016bf	45 89 4f 48	 mov	 DWORD PTR [r15+72], r9d

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  016c3	45 85 d2	 test	 r10d, r10d
  016c6	75 04		 jne	 SHORT $LN507@inflate
  016c8	85 db		 test	 ebx, ebx
  016ca	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  016cc	83 7d 50 04	 cmp	 DWORD PTR flush$[rbp-88], 4
  016d0	75 0c		 jne	 SHORT $LN505@inflate
$LN506@inflate:
  016d2	45 85 e4	 test	 r12d, r12d
  016d5	b8 fb ff ff ff	 mov	 eax, -5
  016da	44 0f 44 e0	 cmove	 r12d, eax
$LN505@inflate:

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;

  016de	41 8b c4	 mov	 eax, r12d
  016e1	eb 05		 jmp	 SHORT $LN1@inflate
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  016e3	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflate:

; 1275 : }

  016e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  016ec	41 5f		 pop	 r15
  016ee	41 5e		 pop	 r14
  016f0	41 5d		 pop	 r13
  016f2	41 5c		 pop	 r12
  016f4	5f		 pop	 rdi
  016f5	5e		 pop	 rsi
  016f6	5b		 pop	 rbx
  016f7	5d		 pop	 rbp
  016f8	c3		 ret	 0
  016f9	0f 1f 00	 npad	 3
$LN844@inflate:
  016fc	00 00 00 00	 DD	 $LN335@inflate
  01700	00 00 00 00	 DD	 $LN32@inflate
  01704	00 00 00 00	 DD	 $LN46@inflate
  01708	00 00 00 00	 DD	 $LN60@inflate
  0170c	00 00 00 00	 DD	 $LN361@inflate
  01710	00 00 00 00	 DD	 $LN368@inflate
  01714	00 00 00 00	 DD	 $LN375@inflate
  01718	00 00 00 00	 DD	 $LN384@inflate
  0171c	00 00 00 00	 DD	 $LN393@inflate
  01720	00 00 00 00	 DD	 $LN105@inflate
  01724	00 00 00 00	 DD	 $LN400@inflate
  01728	00 00 00 00	 DD	 $LN402@inflate
  0172c	00 00 00 00	 DD	 $LN403@inflate
  01730	00 00 00 00	 DD	 $LN141@inflate
  01734	00 00 00 00	 DD	 $LN416@inflate
  01738	00 00 00 00	 DD	 $LN418@inflate
  0173c	00 00 00 00	 DD	 $LN155@inflate
  01740	00 00 00 00	 DD	 $LN532@inflate
  01744	00 00 00 00	 DD	 $LN535@inflate
  01748	00 00 00 00	 DD	 $LN448@inflate
  0174c	00 00 00 00	 DD	 $LN450@inflate
  01750	00 00 00 00	 DD	 $LN461@inflate
  01754	00 00 00 00	 DD	 $LN464@inflate
  01758	00 00 00 00	 DD	 $LN471@inflate
  0175c	00 00 00 00	 DD	 $LN474@inflate
  01760	00 00 00 00	 DD	 $LN485@inflate
  01764	00 00 00 00	 DD	 $LN487@inflate
  01768	00 00 00 00	 DD	 $LN492@inflate
  0176c	00 00 00 00	 DD	 $LN496@inflate
  01770	00 00 00 00	 DD	 $LN497@inflate
  01774	00 00 00 00	 DD	 $LN498@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1279 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1289 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001d	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00021	48 8b 42 40	 mov	 rax, QWORD PTR [rdx+64]
  00025	48 85 c0	 test	 rax, rax
  00028	74 0e		 je	 SHORT $LN3@inflateEnd
  0002a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	ff 53 38	 call	 QWORD PTR [rbx+56]
  00034	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00038	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0003c	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1286 :     strm->state = Z_NULL;
; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  0003f	33 c0		 xor	 eax, eax
  00041	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1289 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 117  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 121  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 142  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 127  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00069	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  0006d	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00071	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  0007b	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 142  : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 160  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b e9	 mov	 rbp, rcx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00019	e8 00 00 00 00	 call	 inflateStateCheck
  0001e	85 c0		 test	 eax, eax
  00020	75 57		 jne	 SHORT $LN7@inflateRes

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00022	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00026	85 d2		 test	 edx, edx
  00028	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0002a	33 f6		 xor	 esi, esi

; 171  :         windowBits = -windowBits;

  0002c	f7 db		 neg	 ebx

; 172  :     }

  0002e	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00030	8b f3		 mov	 esi, ebx
  00032	c1 ee 04	 shr	 esi, 4
  00035	83 c6 05	 add	 esi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00038	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00040	85 db		 test	 ebx, ebx
  00042	74 08		 je	 SHORT $LN6@inflateRes
  00044	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00047	83 f8 07	 cmp	 eax, 7
  0004a	77 2d		 ja	 SHORT $LN7@inflateRes
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0004c	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  00050	48 85 d2	 test	 rdx, rdx
  00053	74 14		 je	 SHORT $LN8@inflateRes
  00055	39 5f 30	 cmp	 DWORD PTR [rdi+48], ebx
  00058	74 0f		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  0005a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005e	ff 55 38	 call	 QWORD PTR [rbp+56]

; 186  :         state->window = Z_NULL;

  00061	48 c7 47 40 00
	00 00 00	 mov	 QWORD PTR [rdi+64], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00069	48 8b cd	 mov	 rcx, rbp
  0006c	89 77 10	 mov	 DWORD PTR [rdi+16], esi
  0006f	89 5f 30	 mov	 DWORD PTR [rdi+48], ebx
  00072	e8 00 00 00 00	 call	 inflateReset
  00077	eb 05		 jmp	 SHORT $LN1@inflateRes
$LN7@inflateRes:

; 183  :         return Z_STREAM_ERROR;

  00079	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateRes:

; 193  : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00088	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 251  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	75 46		 jne	 SHORT $LN5@inflatePri

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00010	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]

; 256  :     if (bits < 0) {

  00014	85 d2		 test	 edx, edx
  00016	79 09		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00018	49 89 41 48	 mov	 QWORD PTR [r9+72], rax

; 266  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
$LN3@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00021	83 fa 10	 cmp	 edx, 16
  00024	7f 30		 jg	 SHORT $LN5@inflatePri
  00026	45 8b 41 4c	 mov	 r8d, DWORD PTR [r9+76]
  0002a	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  0002e	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00032	77 22		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00034	8b ca		 mov	 ecx, edx

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  00036	45 89 51 4c	 mov	 DWORD PTR [r9+76], r10d
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	d3 e0		 shl	 eax, cl
  00041	41 8b c8	 mov	 ecx, r8d
  00044	ff c8		 dec	 eax
  00046	41 23 c3	 and	 eax, r11d
  00049	d3 e0		 shl	 eax, cl
  0004b	41 01 41 48	 add	 DWORD PTR [r9+72], eax

; 265  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax

; 266  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN5@inflatePri:

; 258  :         state->bits = 0;
; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00056	b8 fe ff ff ff	 mov	 eax, -2

; 266  : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 317  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 318  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 319  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
end$ = 56
copy$ = 64
updatewindow PROC					; COMDAT

; 400  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  0000f	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	41 8b e8	 mov	 ebp, r8d
  00019	4c 8b d1	 mov	 r10, rcx

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0001c	4c 8b 4b 40	 mov	 r9, QWORD PTR [rbx+64]
  00020	4d 85 c9	 test	 r9, r9
  00023	75 36		 jne	 SHORT $LN15@updatewind

; 408  :         state->window = (unsigned char FAR *)

  00025	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00028	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0002c	ba 01 00 00 00	 mov	 edx, 1
  00031	d3 e2		 shl	 edx, cl
  00033	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  00037	41 ff 52 30	 call	 QWORD PTR [r10+48]
  0003b	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  0003f	4c 8b c8	 mov	 r9, rax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00042	48 85 c0	 test	 rax, rax
  00045	75 14		 jne	 SHORT $LN15@updatewind
  00047	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 444  : }

  0004b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00050	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5e		 pop	 rsi
  0005a	c3		 ret	 0
$LN15@updatewind:
  0005b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00060	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  00063	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00068	45 33 f6	 xor	 r14d, r14d
  0006b	85 ff		 test	 edi, edi
  0006d	75 11		 jne	 SHORT $LN14@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0006f	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00072	bf 01 00 00 00	 mov	 edi, 1
  00077	d3 e7		 shl	 edi, cl
  00079	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 417  :         state->wnext = 0;
; 418  :         state->whave = 0;

  0007c	4c 89 73 38	 mov	 QWORD PTR [rbx+56], r14
$LN14@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00080	3b ef		 cmp	 ebp, edi
  00082	72 1a		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00084	44 8b c7	 mov	 r8d, edi
  00087	49 8b c9	 mov	 rcx, r9
  0008a	49 2b f0	 sub	 rsi, r8
  0008d	48 8b d6	 mov	 rdx, rsi
  00090	e8 00 00 00 00	 call	 memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00095	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00098	44 89 73 3c	 mov	 DWORD PTR [rbx+60], r14d

; 426  :     }

  0009c	eb 53		 jmp	 SHORT $LN16@updatewind
$LN5@updatewind:

; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0009e	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 429  :         if (dist > copy) dist = copy;
; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  000a1	48 8b d6	 mov	 rdx, rsi
  000a4	2b f9		 sub	 edi, ecx
  000a6	3b fd		 cmp	 edi, ebp
  000a8	0f 47 fd	 cmova	 edi, ebp
  000ab	48 2b d5	 sub	 rdx, rbp
  000ae	44 8b c7	 mov	 r8d, edi
  000b1	49 03 c9	 add	 rcx, r9
  000b4	e8 00 00 00 00	 call	 memcpy

; 431  :         copy -= dist;

  000b9	2b ef		 sub	 ebp, edi

; 432  :         if (copy) {

  000bb	74 1a		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000bd	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c1	44 8b c5	 mov	 r8d, ebp
  000c4	49 2b f0	 sub	 rsi, r8
  000c7	48 8b d6	 mov	 rdx, rsi
  000ca	e8 00 00 00 00	 call	 memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000cf	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000d2	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 436  :         }

  000d5	eb 1a		 jmp	 SHORT $LN16@updatewind
$LN8@updatewind:

; 437  :         else {
; 438  :             state->wnext += dist;

  000d7	01 7b 3c	 add	 DWORD PTR [rbx+60], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000da	8b 43 3c	 mov	 eax, DWORD PTR [rbx+60]
  000dd	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000e0	41 0f 44 c6	 cmove	 eax, r14d
  000e4	89 43 3c	 mov	 DWORD PTR [rbx+60], eax

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000e7	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  000ea	3b 43 34	 cmp	 eax, DWORD PTR [rbx+52]
  000ed	73 05		 jae	 SHORT $LN11@updatewind
  000ef	03 c7		 add	 eax, edi
$LN16@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000f1	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000f4	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  000f9	33 c0		 xor	 eax, eax
  000fb	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 444  : }

  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5e		 pop	 rsi
  0010f	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1295 : {

$LN7:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1312 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1312 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1318 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0001d	e8 00 00 00 00	 call	 inflateStateCheck
  00022	85 c0		 test	 eax, eax
  00024	75 6c		 jne	 SHORT $LN10@inflateSet

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  00026	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  0002a	39 43 10	 cmp	 DWORD PTR [rbx+16], eax
  0002d	74 09		 je	 SHORT $LN9@inflateSet
  0002f	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  00036	75 5a		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00038	81 7b 08 3e 3f
	00 00		 cmp	 DWORD PTR [rbx+8], 16190 ; 00003f3eH
  0003f	75 25		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	33 d2		 xor	 edx, edx
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 adler32

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0004d	44 8b c6	 mov	 r8d, esi
  00050	48 8b d5	 mov	 rdx, rbp
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 adler32

; 1333 :         if (dictid != state->check)

  0005a	3b 43 20	 cmp	 eax, DWORD PTR [rbx+32]
  0005d	74 07		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0005f	b8 fd ff ff ff	 mov	 eax, -3
  00064	eb 31		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00066	48 8d 14 2e	 lea	 rdx, QWORD PTR [rsi+rbp]
  0006a	44 8b c6	 mov	 r8d, esi
  0006d	48 8b cf	 mov	 rcx, rdi
  00070	e8 00 00 00 00	 call	 updatewindow

; 1340 :     if (ret) {

  00075	85 c0		 test	 eax, eax
  00077	74 0e		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  00079	c7 43 08 52 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00080	b8 fc ff ff ff	 mov	 eax, -4
  00085	eb 10		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  00087	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [rbx+20], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 05		 jmp	 SHORT $LN1@inflateSet
$LN10@inflateSet:

; 1327 :         return Z_STREAM_ERROR;

  00092	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateSet:

; 1347 : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1352 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	75 1c		 jne	 SHORT $LN5@inflateGet

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  00015	74 12		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00017	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1362 :     head->done = 0;
; 1363 :     return Z_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1364 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@inflateGet:

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2

; 1364 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1381 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1386 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d0	 mov	 r10d, r8d
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1387 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 43		 je	 SHORT $LN13@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 32		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 0f		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	2b c8		 sub	 ecx, eax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	8b c1		 mov	 eax, ecx
  00040	0f 45 c3	 cmovne	 eax, ebx
$LN7@syncsearch:

; 1394 :         next++;

  00043	41 ff c1	 inc	 r9d
  00046	48 ff c2	 inc	 rdx
  00049	45 3b ca	 cmp	 r9d, r10d
  0004c	72 c9		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;
; 1397 :     return next;
; 1398 : }

  0004e	41 89 03	 mov	 DWORD PTR [r11], eax
  00051	41 8b c1	 mov	 eax, r9d
  00054	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00059	c3		 ret	 0
$LN13@syncsearch:
  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	89 01		 mov	 DWORD PTR [rcx], eax
  00061	41 8b c1	 mov	 eax, r9d
  00064	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
inflateSync PROC					; COMDAT

; 1402 : {

$LN20:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1441 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5e		 pop	 rsi
  0001c	c3		 ret	 0
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00021	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00026	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0002a	45 85 c0	 test	 r8d, r8d
  0002d	75 15		 jne	 SHORT $LN15@inflateSyn
  0002f	83 7f 4c 08	 cmp	 DWORD PTR [rdi+76], 8
  00033	73 0f		 jae	 SHORT $LN15@inflateSyn
  00035	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0003a	41 8d 40 fb	 lea	 eax, QWORD PTR [r8-5]

; 1441 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN15@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00044	81 7f 08 53 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16211 ; 00003f53H
  0004b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00050	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00055	74 6b		 je	 SHORT $LN13@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00057	8b 57 4c	 mov	 edx, DWORD PTR [rdi+76]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  0005a	45 33 c9	 xor	 r9d, r9d
  0005d	44 8b 47 48	 mov	 r8d, DWORD PTR [rdi+72]
  00061	8b ca		 mov	 ecx, edx
  00063	83 e1 07	 and	 ecx, 7
  00066	c7 47 08 53 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16211 ; 00003f53H
  0006d	41 d3 e0	 shl	 r8d, cl
  00070	2b d1		 sub	 edx, ecx
  00072	44 89 47 48	 mov	 DWORD PTR [rdi+72], r8d
  00076	89 57 4c	 mov	 DWORD PTR [rdi+76], edx

; 1419 :         while (state->bits >= 8) {

  00079	83 fa 08	 cmp	 edx, 8
  0007c	72 21		 jb	 SHORT $LN3@inflateSyn
  0007e	66 90		 npad	 2
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00080	0f b6 47 48	 movzx	 eax, BYTE PTR [rdi+72]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00084	83 c2 f8	 add	 edx, -8			; fffffff8H
  00087	41 c1 e8 08	 shr	 r8d, 8
  0008b	42 88 44 0c 38	 mov	 BYTE PTR buf$[rsp+r9], al
  00090	41 ff c1	 inc	 r9d
  00093	44 89 47 48	 mov	 DWORD PTR [rdi+72], r8d
  00097	83 fa 08	 cmp	 edx, 8
  0009a	73 e4		 jae	 SHORT $LL2@inflateSyn
  0009c	89 57 4c	 mov	 DWORD PTR [rdi+76], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0009f	48 8d 9f 84 00
	00 00		 lea	 rbx, QWORD PTR [rdi+132]

; 1425 :         syncsearch(&(state->have), buf, len);

  000a6	45 8b c1	 mov	 r8d, r9d
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  000b2	48 8d 54 24 38	 lea	 rdx, QWORD PTR buf$[rsp]
  000b7	e8 00 00 00 00	 call	 syncsearch
  000bc	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000c0	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN13@inflateSyn:
  000c2	48 8d 9f 84 00
	00 00		 lea	 rbx, QWORD PTR [rdi+132]
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000c9	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 syncsearch

; 1430 :     strm->avail_in -= len;
; 1431 :     strm->next_in += len;
; 1432 :     strm->total_in += len;

  000d4	8b 6e 0c	 mov	 ebp, DWORD PTR [rsi+12]
  000d7	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000da	03 e8		 add	 ebp, eax
  000dc	8b c8		 mov	 ecx, eax
  000de	48 01 0e	 add	 QWORD PTR [rsi], rcx
  000e1	89 6e 0c	 mov	 DWORD PTR [rsi+12], ebp

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000e4	83 3b 04	 cmp	 DWORD PTR [rbx], 4
  000e7	74 07		 je	 SHORT $LN7@inflateSyn
  000e9	b8 fd ff ff ff	 mov	 eax, -3
  000ee	eb 1a		 jmp	 SHORT $LN18@inflateSyn
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000f0	8b 5e 1c	 mov	 ebx, DWORD PTR [rsi+28]

; 1437 :     inflateReset(strm);

  000f3	48 8b ce	 mov	 rcx, rsi
  000f6	e8 00 00 00 00	 call	 inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000fb	89 6e 0c	 mov	 DWORD PTR [rsi+12], ebp

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000fe	33 c0		 xor	 eax, eax
  00100	89 5e 1c	 mov	 DWORD PTR [rsi+28], ebx
  00103	c7 47 08 3f 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16191 ; 00003f3fH
$LN18@inflateSyn:
  0010a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0010f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00114	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1441 : }

  00119	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011d	5e		 pop	 rsi
  0011e	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1453 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1459 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1459 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1464 : {

$LN17:
  00000	40 57		 push	 rdi
  00002	41 56		 push	 r14
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	4c 8b f1	 mov	 r14, rcx
  0000b	48 8b fa	 mov	 rdi, rdx

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000e	48 8b ca	 mov	 rcx, rdx
  00011	e8 00 00 00 00	 call	 inflateStateCheck
  00016	85 c0		 test	 eax, eax
  00018	0f 85 7c 01 00
	00		 jne	 $LN3@inflateCop
  0001e	4d 85 f6	 test	 r14, r14
  00021	0f 84 73 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  00027	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00031	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00036	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0003b	bd 01 00 00 00	 mov	 ebp, 1
  00040	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00045	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00049	8b d5		 mov	 edx, ebp
  0004b	ff 57 30	 call	 QWORD PTR [rdi+48]
  0004e	48 8b d8	 mov	 rbx, rax

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00051	48 85 c0	 test	 rax, rax
  00054	75 05		 jne	 SHORT $LN4@inflateCop
  00056	8d 45 fb	 lea	 eax, QWORD PTR [rbp-5]
  00059	eb 3a		 jmp	 SHORT $LN14@inflateCop
$LN4@inflateCop:
  0005b	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 1479 :     window = Z_NULL;

  00060	45 33 ff	 xor	 r15d, r15d

; 1480 :     if (state->window != Z_NULL) {

  00063	4c 39 7e 40	 cmp	 QWORD PTR [rsi+64], r15
  00067	74 43		 je	 SHORT $LN11@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00069	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  0006c	8b d5		 mov	 edx, ebp
  0006e	d3 e2		 shl	 edx, cl
  00070	44 8b c5	 mov	 r8d, ebp
  00073	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00077	ff 57 30	 call	 QWORD PTR [rdi+48]
  0007a	4c 8b f8	 mov	 r15, rax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  0007d	48 85 c0	 test	 rax, rax
  00080	75 2a		 jne	 SHORT $LN11@inflateCop

; 1484 :             ZFREE(source, copy);

  00082	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00086	48 8b d3	 mov	 rdx, rbx
  00089	ff 57 38	 call	 QWORD PTR [rdi+56]

; 1485 :             return Z_MEM_ERROR;

  0008c	41 8d 47 fc	 lea	 eax, QWORD PTR [r15-4]
$LN15@inflateCop:
  00090	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN14@inflateCop:
  00095	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1506 : }

  000a4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a8	41 5e		 pop	 r14
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN11@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000ac	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000af	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	41 0f 11 06	 movups	 XMMWORD PTR [r14], xmm0
  000bf	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000c3	41 0f 11 4e 10	 movups	 XMMWORD PTR [r14+16], xmm1
  000c8	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000cc	41 0f 11 46 20	 movups	 XMMWORD PTR [r14+32], xmm0
  000d1	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000d5	41 0f 11 4e 30	 movups	 XMMWORD PTR [r14+48], xmm1
  000da	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [rdi+64]
  000de	41 0f 11 46 40	 movups	 XMMWORD PTR [r14+64], xmm0
  000e3	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [rdi+80]
  000e8	f2 41 0f 11 4e
	50		 movsd	 QWORD PTR [r14+80], xmm1
  000ee	e8 00 00 00 00	 call	 memcpy

; 1492 :     copy->strm = dest;

  000f3	4c 89 33	 mov	 QWORD PTR [rbx], r14

; 1493 :     if (state->lencode >= state->codes &&

  000f6	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  000fd	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00101	48 3b c8	 cmp	 rcx, rax
  00104	72 47		 jb	 SHORT $LN7@inflateCop
  00106	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  0010d	48 3b c8	 cmp	 rcx, rax
  00110	77 3b		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00112	48 2b ce	 sub	 rcx, rsi
  00115	48 8d 81 b0 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1360]
  0011c	48 c1 f8 02	 sar	 rax, 2
  00120	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00126	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0012a	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  0012e	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  00132	48 2b c6	 sub	 rax, rsi
  00135	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0013b	48 c1 f8 02	 sar	 rax, 2
  0013f	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00145	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00149	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  0014d	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  00154	48 2b c6	 sub	 rax, rsi
  00157	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0015d	48 c1 f8 02	 sar	 rax, 2
  00161	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00167	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0016b	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1499 :     if (window != Z_NULL) {

  00172	4d 85 ff	 test	 r15, r15
  00175	74 14		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  00177	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1501 :         zmemcpy(window, state->window, wsize);

  0017a	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  0017e	d3 e5		 shl	 ebp, cl
  00180	49 8b cf	 mov	 rcx, r15
  00183	44 8b c5	 mov	 r8d, ebp
  00186	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  0018b	4c 89 7b 40	 mov	 QWORD PTR [rbx+64], r15

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  0018f	33 c0		 xor	 eax, eax
  00191	49 89 5e 28	 mov	 QWORD PTR [r14+40], rbx
  00195	e9 f6 fe ff ff	 jmp	 $LN15@inflateCop
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  0019a	b8 fe ff ff ff	 mov	 eax, -2

; 1506 : }

  0019f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001a3	41 5e		 pop	 r14
  001a5	5f		 pop	 rdi
  001a6	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1511 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1523 : #endif
; 1524 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1523 : #endif
; 1524 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1529 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 8b c2	 mov	 r8d, edx

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateVal
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 1539 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  0001e	8b 4a 10	 mov	 ecx, DWORD PTR [rdx+16]

; 1534 :     if (check)
; 1535 :         state->wrap |= 4;
; 1536 :     else
; 1537 :         state->wrap &= ~4;
; 1538 :     return Z_OK;

  00021	8b c1		 mov	 eax, ecx
  00023	83 e0 fb	 and	 eax, -5
  00026	83 c9 04	 or	 ecx, 4
  00029	45 85 c0	 test	 r8d, r8d
  0002c	0f 44 c8	 cmove	 ecx, eax
  0002f	33 c0		 xor	 eax, eax
  00031	89 4a 10	 mov	 DWORD PTR [rdx+16], ecx

; 1539 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1543 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1556 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateCod
  0000d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1561 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1560 :     return (unsigned long)(state->next - state->codes);

  0001b	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00022	48 2b c1	 sub	 rax, rcx
  00025	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0002b	48 c1 f8 02	 sar	 rax, 2

; 1561 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
