; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	inffas8664fnc:PROC
PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN21
	DD	imagerel $LN21+456
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091c01H
	DD	018741cH
	DD	017641cH
	DD	016341cH
	DD	014011cH
	DD	05010H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\contrib\masmx64\inffas8664.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
ar$ = 32
strm$ = 176
start$ = 184
inflate_fast PROC					; COMDAT

; 109  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 110  :     struct inflate_state FAR *state;
; 111  :     type_ar ar;
; 112  :     void inffas8664fnc(struct inffast_ar * par);
; 113  : 
; 114  : 
; 115  : 
; 116  : #if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
; 117  : #define PAD_AVAIL_IN 6
; 118  : #define PAD_AVAIL_OUT 258
; 119  : #else
; 120  : #define PAD_AVAIL_IN 5
; 121  : #define PAD_AVAIL_OUT 257
; 122  : #endif
; 123  : 
; 124  :     /* copy state to local variables */
; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001c	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00020	48 8b f9	 mov	 rdi, rcx

; 126  : 
; 127  :     ar.in = strm->next_in;

  00023	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00026	8b c2		 mov	 eax, edx

; 128  :     ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);

  00028	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]

; 129  :     ar.out = strm->next_out;
; 130  :     ar.beg = ar.out - (start - strm->avail_out);
; 131  :     ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
; 132  :     ar.wsize = state->wsize;
; 133  :     ar.write = state->wnext;
; 134  :     ar.window = state->window;
; 135  :     ar.hold = state->hold;
; 136  :     ar.bits = state->bits;
; 137  :     ar.lcode = state->lencode;
; 138  :     ar.dcode = state->distcode;
; 139  :     ar.lmask = (1U << state->lenbits) - 1;

  0002c	be 01 00 00 00	 mov	 esi, 1
  00031	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00034	41 83 e8 06	 sub	 r8d, 6
  00038	2b c2		 sub	 eax, edx
  0003a	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10
  0003e	4d 03 c2	 add	 r8, r10
  00041	4c 89 45 ef	 mov	 QWORD PTR ar$[rbp-49], r8
  00045	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00049	4c 89 45 f7	 mov	 QWORD PTR ar$[rbp-41], r8
  0004d	49 8b c8	 mov	 rcx, r8
  00050	48 2b c8	 sub	 rcx, rax
  00053	48 89 4d ff	 mov	 QWORD PTR ar$[rbp-33], rcx
  00057	8d 8a fe fe ff
	ff		 lea	 ecx, DWORD PTR [rdx-258]
  0005d	49 03 c8	 add	 rcx, r8
  00060	48 89 4d 07	 mov	 QWORD PTR ar$[rbp-25], rcx
  00064	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00067	89 45 33	 mov	 DWORD PTR ar$[rbp+19], eax
  0006a	8b 43 3c	 mov	 eax, DWORD PTR [rbx+60]
  0006d	89 45 37	 mov	 DWORD PTR ar$[rbp+23], eax
  00070	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00074	48 89 45 0f	 mov	 QWORD PTR ar$[rbp-17], rax
  00078	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  0007c	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  00080	8b 53 4c	 mov	 edx, DWORD PTR [rbx+76]
  00083	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  00086	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0008a	48 89 45 17	 mov	 QWORD PTR ar$[rbp-9], rax
  0008e	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00092	48 89 45 1f	 mov	 QWORD PTR ar$[rbp-1], rax
  00096	8b c6		 mov	 eax, esi
  00098	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  0009b	d3 e0		 shl	 eax, cl
  0009d	ff c8		 dec	 eax
  0009f	89 45 3b	 mov	 DWORD PTR ar$[rbp+27], eax

; 140  :     ar.dmask = (1U << state->distbits) - 1;

  000a2	8b c6		 mov	 eax, esi
  000a4	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  000a7	d3 e0		 shl	 eax, cl
  000a9	ff c8		 dec	 eax
  000ab	89 45 3f	 mov	 DWORD PTR ar$[rbp+31], eax
  000ae	41 f6 c2 03	 test	 r10b, 3

; 141  : 
; 142  :     /* decode literals and length/distances until end-of-block or not enough
; 143  :        input data or output space */
; 144  : 
; 145  :     /* align in on 1/2 hold size boundary */
; 146  :     while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {

  000b2	74 2e		 je	 SHORT $LN3@inflate_fa
  000b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@inflate_fa:

; 147  :         ar.hold += (unsigned long)*ar.in++ << ar.bits;

  000c0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000c4	8b ca		 mov	 ecx, edx
  000c6	d3 e0		 shl	 eax, cl
  000c8	49 ff c2	 inc	 r10
  000cb	4c 03 c0	 add	 r8, rax
  000ce	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10

; 148  :         ar.bits += 8;

  000d2	83 c2 08	 add	 edx, 8
  000d5	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  000d9	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  000dc	41 f6 c2 03	 test	 r10b, 3
  000e0	75 de		 jne	 SHORT $LL2@inflate_fa
$LN3@inflate_fa:

; 149  :     }
; 150  : 
; 151  :     inffas8664fnc(&ar);

  000e2	48 8d 4d d7	 lea	 rcx, QWORD PTR ar$[rbp-73]
  000e6	e8 00 00 00 00	 call	 inffas8664fnc

; 152  : 
; 153  :     if (ar.status > 1) {

  000eb	8b 45 4b	 mov	 eax, DWORD PTR ar$[rbp+43]
  000ee	3b c6		 cmp	 eax, esi
  000f0	76 3b		 jbe	 SHORT $LN4@inflate_fa

; 154  :         if (ar.status == 2)

  000f2	83 f8 02	 cmp	 eax, 2
  000f5	75 14		 jne	 SHORT $LN6@inflate_fa

; 155  :             strm->msg = "invalid literal/length code";

  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  000fe	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx
  00102	c7 43 08 51 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16209 ; 00003f51H

; 161  :     }

  00109	eb 2b		 jmp	 SHORT $LN10@inflate_fa
$LN6@inflate_fa:

; 156  :         else if (ar.status == 3)

  0010b	83 f8 03	 cmp	 eax, 3
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  0011c	48 0f 45 ca	 cmovne	 rcx, rdx

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  00120	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx
  00124	c7 43 08 51 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16209 ; 00003f51H

; 161  :     }

  0012b	eb 09		 jmp	 SHORT $LN10@inflate_fa
$LN4@inflate_fa:

; 162  :     else if ( ar.status == 1 ) {

  0012d	75 07		 jne	 SHORT $LN10@inflate_fa

; 163  :         state->mode = TYPE;

  0012f	c7 43 08 3f 3f
	00 00		 mov	 DWORD PTR [rbx+8], 16191 ; 00003f3fH
$LN10@inflate_fa:

; 164  :     }
; 165  : 
; 166  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 167  :     ar.len = ar.bits >> 3;

  00136	8b 4d 2f	 mov	 ecx, DWORD PTR ar$[rbp+15]

; 168  :     ar.in -= ar.len;
; 169  :     ar.bits -= ar.len << 3;
; 170  :     ar.hold &= (1U << ar.bits) - 1;
; 171  : 
; 172  :     /* update state and return */
; 173  :     strm->next_in = ar.in;
; 174  :     strm->next_out = ar.out;
; 175  :     strm->avail_in = (unsigned)(ar.in < ar.last ?
; 176  :                                 PAD_AVAIL_IN + (ar.last - ar.in) :
; 177  :                                 PAD_AVAIL_IN - (ar.in - ar.last));
; 178  :     strm->avail_out = (unsigned)(ar.out < ar.end ?
; 179  :                                  PAD_AVAIL_OUT + (ar.end - ar.out) :
; 180  :                                  PAD_AVAIL_OUT - (ar.out - ar.end));
; 181  :     state->hold = (unsigned long)ar.hold;
; 182  :     state->bits = ar.bits;
; 183  :     return;
; 184  : }

  00139	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00141	4c 8b 45 f7	 mov	 r8, QWORD PTR ar$[rbp-41]
  00145	8b c1		 mov	 eax, ecx
  00147	4c 8b 4d e7	 mov	 r9, QWORD PTR ar$[rbp-57]
  0014b	c1 e8 03	 shr	 eax, 3
  0014e	8b d0		 mov	 edx, eax
  00150	4c 2b ca	 sub	 r9, rdx
  00153	4c 89 47 10	 mov	 QWORD PTR [rdi+16], r8
  00157	4c 89 0f	 mov	 QWORD PTR [rdi], r9
  0015a	8d 04 c5 00 00
	00 00		 lea	 eax, DWORD PTR [rax*8]
  00161	2b c8		 sub	 ecx, eax
  00163	d3 e6		 shl	 esi, cl
  00165	89 4d 2f	 mov	 DWORD PTR ar$[rbp+15], ecx
  00168	48 8b 4d ef	 mov	 rcx, QWORD PTR ar$[rbp-49]
  0016c	48 8b d1	 mov	 rdx, rcx
  0016f	49 2b d1	 sub	 rdx, r9
  00172	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00175	48 21 45 27	 and	 QWORD PTR ar$[rbp+7], rax
  00179	48 8b c1	 mov	 rax, rcx
  0017c	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00180	49 2b c1	 sub	 rax, r9
  00183	4c 3b c9	 cmp	 r9, rcx
  00186	48 8b 4d 07	 mov	 rcx, QWORD PTR ar$[rbp-25]
  0018a	48 0f 42 c2	 cmovb	 rax, rdx
  0018e	48 8b d1	 mov	 rdx, rcx
  00191	83 c0 06	 add	 eax, 6
  00194	49 2b d0	 sub	 rdx, r8
  00197	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  0019a	48 8b c1	 mov	 rax, rcx
  0019d	49 2b c0	 sub	 rax, r8
  001a0	4c 3b c1	 cmp	 r8, rcx
  001a3	48 0f 42 c2	 cmovb	 rax, rdx
  001a7	05 02 01 00 00	 add	 eax, 258		; 00000102H
  001ac	89 47 18	 mov	 DWORD PTR [rdi+24], eax
  001af	8b 45 27	 mov	 eax, DWORD PTR ar$[rbp+7]
  001b2	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  001b6	89 43 48	 mov	 DWORD PTR [rbx+72], eax
  001b9	8b 45 2f	 mov	 eax, DWORD PTR ar$[rbp+15]
  001bc	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
  001bf	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001c3	49 8b e3	 mov	 rsp, r11
  001c6	5d		 pop	 rbp
  001c7	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
