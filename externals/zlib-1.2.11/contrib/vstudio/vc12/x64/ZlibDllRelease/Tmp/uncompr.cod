; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	uncompress
PUBLIC	uncompress2
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress2 DD imagerel $LN29
	DD	imagerel $LN29+119
	DD	imagerel $unwind$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$uncompress2 DD imagerel $LN29+119
	DD	imagerel $LN29+320
	DD	imagerel $chain$0$uncompress2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$uncompress2 DD imagerel $LN29+320
	DD	imagerel $LN29+349
	DD	imagerel $chain$1$uncompress2
;	COMDAT xdata
xdata	SEGMENT
$chain$1$uncompress2 DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+119
	DD	imagerel $unwind$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$uncompress2 DD 020821H
	DD	0183408H
	DD	imagerel $LN29
	DD	imagerel $LN29+119
	DD	imagerel $unwind$uncompress2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress2 DD 0b1a01H
	DD	01a641aH
	DD	019541aH
	DD	012011aH
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress DD 010901H
	DD	04209H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress2
_TEXT	SEGMENT
buf$ = 32
stream$ = 48
dest$ = 192
destLen$ = 200
source$ = 208
sourceLen$ = 216
uncompress2 PROC					; COMDAT

; 32   : {

$LN29:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;
; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;
; 40   :     if (*destLen) {

  0001a	8b 3a		 mov	 edi, DWORD PTR [rdx]
  0001c	33 ed		 xor	 ebp, ebp
  0001e	41 8b 31	 mov	 esi, DWORD PTR [r9]
  00021	4d 8b e9	 mov	 r13, r9
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b f9	 mov	 r15, rcx
  0002a	44 8d 75 01	 lea	 r14d, QWORD PTR [rbp+1]
  0002e	85 ff		 test	 edi, edi
  00030	74 04		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;
; 42   :         *destLen = 0;

  00032	89 2a		 mov	 DWORD PTR [rdx], ebp

; 43   :     }

  00034	eb 08		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;

  00036	41 8b fe	 mov	 edi, r14d

; 46   :         dest = buf;

  00039	4c 8d 7c 24 20	 lea	 r15, QWORD PTR buf$[rsp]
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  0003e	4c 89 44 24 30	 mov	 QWORD PTR stream$[rsp], r8

; 50   :     stream.avail_in = 0;
; 51   :     stream.zalloc = (alloc_func)0;
; 52   :     stream.zfree = (free_func)0;
; 53   :     stream.opaque = (voidpf)0;
; 54   : 
; 55   :     err = inflateInit(&stream);

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  0004a	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00050	89 6c 24 38	 mov	 DWORD PTR stream$[rsp+8], ebp
  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  00059	48 89 6c 24 60	 mov	 QWORD PTR stream$[rsp+48], rbp
  0005e	48 89 6c 24 68	 mov	 QWORD PTR stream$[rsp+56], rbp
  00063	48 89 6c 24 70	 mov	 QWORD PTR stream$[rsp+64], rbp
  00068	e8 00 00 00 00	 call	 inflateInit_

; 56   :     if (err != Z_OK) return err;

  0006d	85 c0		 test	 eax, eax
  0006f	0f 85 cb 00 00
	00		 jne	 $LN1@uncompress

; 57   : 
; 58   :     stream.next_out = dest;
; 59   :     stream.avail_out = 0;

  00075	8b c5		 mov	 eax, ebp
  00077	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  0007f	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax
  00083	bd ff ff ff ff	 mov	 ebp, -1			; ffffffffH
  00088	4c 89 7c 24 40	 mov	 QWORD PTR stream$[rsp+16], r15
  0008d	0f 1f 00	 npad	 3
$LL4@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  00090	85 c0		 test	 eax, eax
  00092	75 0d		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00094	3b fd		 cmp	 edi, ebp
  00096	8b c7		 mov	 eax, edi
  00098	0f 47 c5	 cmova	 eax, ebp
  0009b	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax

; 64   :             left -= stream.avail_out;

  0009f	2b f8		 sub	 edi, eax
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  000a1	83 7c 24 38 00	 cmp	 DWORD PTR stream$[rsp+8], 0
  000a6	75 0d		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  000a8	3b f5		 cmp	 esi, ebp
  000aa	8b c6		 mov	 eax, esi
  000ac	0f 47 c5	 cmova	 eax, ebp
  000af	89 44 24 38	 mov	 DWORD PTR stream$[rsp+8], eax

; 68   :             len -= stream.avail_in;

  000b3	2b f0		 sub	 esi, eax
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000b5	33 d2		 xor	 edx, edx
  000b7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000bc	e8 00 00 00 00	 call	 inflate
  000c1	8b d8		 mov	 ebx, eax

; 71   :     } while (err == Z_OK);

  000c3	85 c0		 test	 eax, eax
  000c5	75 06		 jne	 SHORT $LN27@uncompress
  000c7	8b 44 24 48	 mov	 eax, DWORD PTR stream$[rsp+24]
  000cb	eb c3		 jmp	 SHORT $LL4@uncompress
$LN27@uncompress:

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000cd	8b 4c 24 38	 mov	 ecx, DWORD PTR stream$[rsp+8]

; 74   :     if (dest != buf)

  000d1	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  000d6	03 ce		 add	 ecx, esi
  000d8	bd 00 00 00 00	 mov	 ebp, 0
  000dd	41 29 4d 00	 sub	 DWORD PTR [r13], ecx
  000e1	4c 3b f8	 cmp	 r15, rax
  000e4	74 24		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  000e6	8b 44 24 4c	 mov	 eax, DWORD PTR stream$[rsp+28]
  000ea	41 89 04 24	 mov	 DWORD PTR [r12], eax
$LN12@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  000ee	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000f3	44 8b f7	 mov	 r14d, edi
  000f6	e8 00 00 00 00	 call	 inflateEnd

; 80   :     return err == Z_STREAM_END ? Z_OK :

  000fb	83 fb 01	 cmp	 ebx, 1
  000fe	74 36		 je	 SHORT $LN15@uncompress
  00100	83 fb 02	 cmp	 ebx, 2
  00103	75 1c		 jne	 SHORT $LN16@uncompress
  00105	8d 6b fb	 lea	 ebp, QWORD PTR [rbx-5]
  00108	eb 2c		 jmp	 SHORT $LN15@uncompress
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  0010a	39 6c 24 4c	 cmp	 DWORD PTR stream$[rsp+28], ebp
  0010e	74 de		 je	 SHORT $LN12@uncompress
  00110	83 fb fb	 cmp	 ebx, -5
  00113	75 d9		 jne	 SHORT $LN12@uncompress

; 77   :         left = 1;

  00115	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  0011a	e8 00 00 00 00	 call	 inflateEnd
  0011f	eb 05		 jmp	 SHORT $LN23@uncompress
$LN16@uncompress:

; 80   :     return err == Z_STREAM_END ? Z_OK :

  00121	83 fb fb	 cmp	 ebx, -5
  00124	75 0e		 jne	 SHORT $LN14@uncompress
$LN23@uncompress:
  00126	8b 4c 24 48	 mov	 ecx, DWORD PTR stream$[rsp+24]
  0012a	bd fd ff ff ff	 mov	 ebp, -3
  0012f	41 03 ce	 add	 ecx, r14d
  00132	75 02		 jne	 SHORT $LN15@uncompress
$LN14@uncompress:
  00134	8b eb		 mov	 ebp, ebx
$LN15@uncompress:
  00136	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  0013e	8b c5		 mov	 eax, ebp
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  00140	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00148	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  0014c	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00150	49 8b e3	 mov	 rsp, r11
  00153	41 5f		 pop	 r15
  00155	41 5e		 pop	 r14
  00157	41 5d		 pop	 r13
  00159	41 5c		 pop	 r12
  0015b	5f		 pop	 rdi
  0015c	c3		 ret	 0
uncompress2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress
_TEXT	SEGMENT
dest$ = 48
destLen$ = 56
source$ = 64
sourceLen$ = 72
uncompress PROC						; COMDAT

; 91   : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00009	4c 8d 4c 24 48	 lea	 r9, QWORD PTR sourceLen$[rsp]
  0000e	e8 00 00 00 00	 call	 uncompress2

; 93   : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
uncompress ENDP
_TEXT	ENDS
END
