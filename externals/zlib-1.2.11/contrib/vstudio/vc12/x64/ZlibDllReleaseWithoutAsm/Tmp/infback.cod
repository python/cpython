; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN591
	DD	imagerel $LN591+64
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN591+64
	DD	imagerel $LN591+3710
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN591+3710
	DD	imagerel $LN591+3804
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN14+87
	DD	imagerel $LN14+199
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN14+199
	DD	imagerel $LN14+232
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN14+232
	DD	imagerel $LN14+274
	DD	imagerel $chain$4$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN591
	DD	imagerel $LN591+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0be422H
	DD	0c740eH
	DD	0d640aH
	DD	0e3404H
	DD	imagerel $LN591
	DD	imagerel $LN591+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 dd 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d3 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c8 00 00
	00		 jne	 $LN3@inflateBac

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 aa 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 a1 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 95 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00053	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00057	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005c	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00061	45 33 f6	 xor	 r14d, r14d
  00064	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14
  00068	48 85 c0	 test	 rax, rax
  0006b	75 14		 jne	 SHORT $LN10@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00074	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00078	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0007c	41 8b ce	 mov	 ecx, r14d
  0007f	eb 04		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  00081	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00085	4c 39 73 38	 cmp	 QWORD PTR [rbx+56], r14
  00089	75 0b		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  00092	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  00096	bf 01 00 00 00	 mov	 edi, 1
  0009b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000a1	8b d7		 mov	 edx, edi
  000a3	ff d0		 call	 rax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a5	48 85 c0	 test	 rax, rax
  000a8	75 1d		 jne	 SHORT $LN8@inflateBac
  000aa	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN12@inflateBac:
  000ad	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000b2	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 70   : }

  000b7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5e		 pop	 rsi
  000c6	c3		 ret	 0
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c7	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000cb	8b ce		 mov	 ecx, esi
  000cd	d3 e7		 shl	 edi, cl
  000cf	89 78 34	 mov	 DWORD PTR [rax+52], edi
  000d2	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000d9	89 70 30	 mov	 DWORD PTR [rax+48], esi

; 66   :     state->window = window;

  000dc	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp

; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;

  000e0	4c 89 70 38	 mov	 QWORD PTR [rax+56], r14

; 69   :     return Z_OK;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb c5		 jmp	 SHORT $LN12@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e8	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fb	5e		 pop	 rsi
  000fc	c3		 ret	 0
$LN3@inflateBac:
  000fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00102	b8 fa ff ff ff	 mov	 eax, -6
  00107	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5e		 pop	 rsi
  00111	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 121  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 122  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN591:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e8	 mov	 r13, r8
  00024	4c 8b c1	 mov	 r8, rcx
  00027	4c 8b e2	 mov	 r12, rdx

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 4b 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 3e 0e 00
	00		 je	 $LN254@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00044	33 d2		 xor	 edx, edx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  0004e	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  00052	49 c7 47 08 3f
	3f 00 00	 mov	 QWORD PTR [r15+8], 16191 ; 00003f3fH

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  0005a	41 89 57 38	 mov	 DWORD PTR [r15+56], edx
  0005e	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14

; 282  :     next = strm->next_in;

  00062	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00065	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  00069	48 85 c0	 test	 rax, rax

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006c	74 05		 je	 SHORT $LN343@inflateBac
  0006e	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00071	eb 02		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00073	8b fa		 mov	 edi, edx
$LN344@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00075	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00079	44 8b f2	 mov	 r14d, edx
  0007c	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00080	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00085	45 8b 4f 34	 mov	 r9d, DWORD PTR [r15+52]
  00089	8b f2		 mov	 esi, edx
  0008b	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008f	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00093	83 f8 12	 cmp	 eax, 18
  00096	0f 87 ab 0d 00
	00		 ja	 $LN341@inflateBac
$LN586@inflateBac:
  0009c	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  000a3	48 98		 cdqe
  000a5	41 bb 01 00 00
	00		 mov	 r11d, 1
  000ab	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN511@inflateBac[r10+rax*4]
  000b3	49 03 ca	 add	 rcx, r10
  000b6	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000b8	41 83 7f 0c 00	 cmp	 DWORD PTR [r15+12], 0
  000bd	74 17		 je	 SHORT $LN12@inflateBac

; 295  :                 BYTEBITS();

  000bf	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c1	41 c7 47 08 50
	3f 00 00	 mov	 DWORD PTR [r15+8], 16208 ; 00003f50H
  000c9	83 e1 07	 and	 ecx, 7
  000cc	41 d3 ee	 shr	 r14d, cl
  000cf	2b f1		 sub	 esi, ecx

; 297  :                 break;

  000d1	e9 1d 0d 00 00	 jmp	 $LN545@inflateBac
$LN12@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000d6	83 fe 03	 cmp	 esi, 3
  000d9	73 41		 jae	 SHORT $LN10@inflateBac
  000db	0f 1f 44 00 00	 npad	 5
$LL13@inflateBac:
  000e0	85 ff		 test	 edi, edi
  000e2	75 14		 jne	 SHORT $LN18@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cd	 mov	 rcx, r13
  000eb	41 ff d4	 call	 r12
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 18 0d 00
	00		 je	 $LN369@inflateBac
$LN18@inflateBac:
  000f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  000fc	8b ce		 mov	 ecx, esi
  000fe	ff cf		 dec	 edi
  00100	83 c6 08	 add	 esi, 8
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0010a	d3 e0		 shl	 eax, cl
  0010c	44 03 f0	 add	 r14d, eax
  0010f	83 fe 03	 cmp	 esi, 3
  00112	72 cc		 jb	 SHORT $LL13@inflateBac
  00114	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00118	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN10@inflateBac:

; 300  :             state->last = BITS(1);

  0011c	41 8b c6	 mov	 eax, r14d

; 301  :             DROPBITS(1);

  0011f	41 d1 ee	 shr	 r14d, 1
  00122	83 e0 01	 and	 eax, 1
  00125	41 89 47 0c	 mov	 DWORD PTR [r15+12], eax

; 302  :             switch (BITS(2)) {

  00129	41 8b c6	 mov	 eax, r14d
  0012c	83 e0 03	 and	 eax, 3
  0012f	74 5e		 je	 SHORT $LN259@inflateBac
  00131	83 e8 01	 sub	 eax, 1
  00134	74 3d		 je	 SHORT $LN260@inflateBac
  00136	83 e8 01	 sub	 eax, 1
  00139	74 24		 je	 SHORT $LN261@inflateBac
  0013b	83 f8 01	 cmp	 eax, 1
  0013e	75 57		 jne	 SHORT $LN28@inflateBac

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00147	41 c1 ee 02	 shr	 r14d, 2
  0014b	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  0014f	83 c6 fd	 add	 esi, -3			; fffffffdH
  00152	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 324  :             break;

  0015a	e9 94 0c 00 00	 jmp	 $LN545@inflateBac
$LN261@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0015f	41 c1 ee 02	 shr	 r14d, 2
  00163	83 c6 fd	 add	 esi, -3			; fffffffdH
  00166	41 c7 47 08 44
	3f 00 00	 mov	 DWORD PTR [r15+8], 16196 ; 00003f44H

; 324  :             break;

  0016e	e9 80 0c 00 00	 jmp	 $LN545@inflateBac
$LN260@inflateBac:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00173	49 8b cf	 mov	 rcx, r15
  00176	e8 00 00 00 00	 call	 fixedtables

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0017b	41 c1 ee 02	 shr	 r14d, 2
  0017f	83 c6 fd	 add	 esi, -3			; fffffffdH
  00182	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 324  :             break;

  0018a	e9 64 0c 00 00	 jmp	 $LN545@inflateBac
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  0018f	41 c7 47 08 41
	3f 00 00	 mov	 DWORD PTR [r15+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00197	41 c1 ee 02	 shr	 r14d, 2
  0019b	83 c6 fd	 add	 esi, -3			; fffffffdH

; 324  :             break;

  0019e	e9 50 0c 00 00	 jmp	 $LN545@inflateBac
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001a3	8b ce		 mov	 ecx, esi
  001a5	83 e1 07	 and	 ecx, 7
  001a8	41 d3 ee	 shr	 r14d, cl
  001ab	2b f1		 sub	 esi, ecx

; 329  :             NEEDBITS(32);

  001ad	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b0	73 3e		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b2	85 ff		 test	 edi, edi
  001b4	75 14		 jne	 SHORT $LN40@inflateBac
  001b6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001ba	49 8b cd	 mov	 rcx, r13
  001bd	41 ff d4	 call	 r12
  001c0	8b f8		 mov	 edi, eax
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 46 0c 00
	00		 je	 $LN369@inflateBac
$LN40@inflateBac:
  001ca	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  001ce	8b ce		 mov	 ecx, esi
  001d0	ff cf		 dec	 edi
  001d2	83 c6 08	 add	 esi, 8
  001d5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d8	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  001dc	d3 e0		 shl	 eax, cl
  001de	44 03 f0	 add	 r14d, eax
  001e1	83 fe 20	 cmp	 esi, 32			; 00000020H
  001e4	72 cc		 jb	 SHORT $LL35@inflateBac
  001e6	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ea	33 d2		 xor	 edx, edx
  001ec	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f0	41 8b c6	 mov	 eax, r14d
  001f3	45 0f b7 e6	 movzx	 r12d, r14w
  001f7	f7 d0		 not	 eax
  001f9	c1 e8 10	 shr	 eax, 16
  001fc	44 3b e0	 cmp	 r12d, eax
  001ff	74 18		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00201	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  00208	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 332  :                 state->mode = BAD;

  0020c	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 333  :                 break;

  00214	e9 da 0b 00 00	 jmp	 $LN545@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00219	45 89 67 50	 mov	 DWORD PTR [r15+80], r12d

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  0021d	44 8b f2	 mov	 r14d, edx
  00220	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00222	45 85 e4	 test	 r12d, r12d
  00225	0f 84 9e 00 00
	00		 je	 $LN47@inflateBac
  0022b	0f 1f 44 00 00	 npad	 5
$LL46@inflateBac:

; 342  :                 copy = state->length;
; 343  :                 PULL();

  00230	85 ff		 test	 edi, edi
  00232	75 14		 jne	 SHORT $LN48@inflateBac
  00234	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00238	49 8b cd	 mov	 rcx, r13
  0023b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0023e	8b f8		 mov	 edi, eax
  00240	85 c0		 test	 eax, eax
  00242	0f 84 c8 0b 00
	00		 je	 $LN369@inflateBac
$LN48@inflateBac:

; 344  :                 ROOM();

  00248	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  0024b	85 db		 test	 ebx, ebx
  0024d	75 28		 jne	 SHORT $LN51@inflateBac
  0024f	41 8b 5f 34	 mov	 ebx, DWORD PTR [r15+52]
  00253	44 8b c3	 mov	 r8d, ebx
  00256	49 8b 47 40	 mov	 rax, QWORD PTR [r15+64]
  0025a	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  0025e	48 8b d0	 mov	 rdx, rax
  00261	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  00265	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  00268	41 89 5f 38	 mov	 DWORD PTR [r15+56], ebx
  0026c	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  0026f	85 c0		 test	 eax, eax
  00271	0f 85 9f 0b 00
	00		 jne	 $LN372@inflateBac
$LN51@inflateBac:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  00277	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0027b	44 3b e7	 cmp	 r12d, edi
  0027e	8b c3		 mov	 eax, ebx
  00280	8b cf		 mov	 ecx, edi
  00282	41 0f 46 cc	 cmovbe	 ecx, r12d
  00286	4c 8b 65 c8	 mov	 r12, QWORD PTR put$1$[rbp-120]
  0028a	3b cb		 cmp	 ecx, ebx
  0028c	0f 46 c1	 cmovbe	 eax, ecx
  0028f	49 8b cc	 mov	 rcx, r12
  00292	44 8b c0	 mov	 r8d, eax
  00295	8b d8		 mov	 ebx, eax
  00297	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;

  0029c	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 350  :                 left -= copy;
; 351  :                 put += copy;

  002a0	4c 03 e3	 add	 r12, rbx
  002a3	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002a7	2b fb		 sub	 edi, ebx
  002a9	4c 89 65 c8	 mov	 QWORD PTR put$1$[rbp-120], r12
  002ad	44 2b cb	 sub	 r9d, ebx

; 352  :                 state->length -= copy;

  002b0	45 8b 67 50	 mov	 r12d, DWORD PTR [r15+80]
  002b4	44 2b e3	 sub	 r12d, ebx
  002b7	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002bb	45 89 67 50	 mov	 DWORD PTR [r15+80], r12d
  002bf	0f 85 6b ff ff
	ff		 jne	 $LL46@inflateBac
  002c5	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN47@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  002c9	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH

; 356  :             break;

  002d1	e9 19 0b 00 00	 jmp	 $LN583@inflateBac
$LN56@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002d6	83 fe 0e	 cmp	 esi, 14
  002d9	73 48		 jae	 SHORT $LN54@inflateBac
  002db	0f 1f 44 00 00	 npad	 5
$LL57@inflateBac:
  002e0	85 ff		 test	 edi, edi
  002e2	75 14		 jne	 SHORT $LN62@inflateBac
  002e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002e8	49 8b cd	 mov	 rcx, r13
  002eb	41 ff d4	 call	 r12
  002ee	8b f8		 mov	 edi, eax
  002f0	85 c0		 test	 eax, eax
  002f2	0f 84 18 0b 00
	00		 je	 $LN369@inflateBac
$LN62@inflateBac:
  002f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  002fc	8b ce		 mov	 ecx, esi
  002fe	ff cf		 dec	 edi
  00300	83 c6 08	 add	 esi, 8
  00303	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00306	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0030a	d3 e0		 shl	 eax, cl
  0030c	44 03 f0	 add	 r14d, eax
  0030f	83 fe 0e	 cmp	 esi, 14
  00312	72 cc		 jb	 SHORT $LL57@inflateBac
  00314	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00318	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  0031f	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN54@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  00323	41 8b ce	 mov	 ecx, r14d

; 362  :             DROPBITS(5);
; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  00326	83 c6 f2	 add	 esi, -14		; fffffff2H
  00329	41 c1 ee 05	 shr	 r14d, 5
  0032d	83 e1 1f	 and	 ecx, 31
  00330	41 8b d6	 mov	 edx, r14d
  00333	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00339	41 c1 ee 05	 shr	 r14d, 5
  0033d	83 e2 1f	 and	 edx, 31
  00340	41 8b c6	 mov	 eax, r14d
  00343	41 89 4f 7c	 mov	 DWORD PTR [r15+124], ecx
  00347	83 e0 0f	 and	 eax, 15
  0034a	41 c1 ee 04	 shr	 r14d, 4
  0034e	83 c0 04	 add	 eax, 4
  00351	ff c2		 inc	 edx
  00353	41 89 97 80 00
	00 00		 mov	 DWORD PTR [r15+128], edx
  0035a	41 89 47 78	 mov	 DWORD PTR [r15+120], eax

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  0035e	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00364	0f 87 76 05 00
	00		 ja	 $LN277@inflateBac
  0036a	83 fa 1e	 cmp	 edx, 30
  0036d	0f 87 6d 05 00
	00		 ja	 $LN277@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  00373	33 c9		 xor	 ecx, ecx
  00375	41 89 8f 84 00
	00 00		 mov	 DWORD PTR [r15+132], ecx

; 378  :             while (state->have < state->ncode) {

  0037c	85 c0		 test	 eax, eax
  0037e	0f 84 9c 00 00
	00		 je	 $LL90@inflateBac
$LL74@inflateBac:

; 379  :                 NEEDBITS(3);

  00384	83 fe 03	 cmp	 esi, 3
  00387	73 45		 jae	 SHORT $LN76@inflateBac
  00389	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0038d	0f 1f 00	 npad	 3
$LL79@inflateBac:
  00390	85 ff		 test	 edi, edi
  00392	75 18		 jne	 SHORT $LN84@inflateBac
  00394	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00398	49 8b cd	 mov	 rcx, r13
  0039b	41 ff d4	 call	 r12
  0039e	8b f8		 mov	 edi, eax
  003a0	85 c0		 test	 eax, eax
  003a2	0f 84 68 0a 00
	00		 je	 $LN369@inflateBac
  003a8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  003ac	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003af	8b ce		 mov	 ecx, esi
  003b1	d3 e0		 shl	 eax, cl
  003b3	48 ff c2	 inc	 rdx
  003b6	44 03 f0	 add	 r14d, eax
  003b9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003bd	ff cf		 dec	 edi
  003bf	83 c6 08	 add	 esi, 8
  003c2	83 fe 03	 cmp	 esi, 3
  003c5	72 c9		 jb	 SHORT $LL79@inflateBac
  003c7	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003ce	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003d5	41 0f b7 ce	 movzx	 ecx, r14w
  003d9	66 83 e1 07	 and	 cx, 7

; 381  :                 DROPBITS(3);

  003dd	41 c1 ee 03	 shr	 r14d, 3
  003e1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e4	41 0f b7 84 42
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r10+rax*2]
  003ed	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  003f6	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  003fd	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00404	41 3b 47 78	 cmp	 eax, DWORD PTR [r15+120]
  00408	0f 82 76 ff ff
	ff		 jb	 $LL74@inflateBac

; 382  :             }
; 383  :             while (state->have < 19)

  0040e	83 f8 13	 cmp	 eax, 19
  00411	73 37		 jae	 SHORT $LN91@inflateBac
  00413	33 c9		 xor	 ecx, ecx
  00415	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL90@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  00420	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00427	41 0f b7 84 42
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r10+rax*2]
  00430	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00439	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  00440	41 83 bf 84 00
	00 00 13	 cmp	 DWORD PTR [r15+132], 19
  00448	72 d6		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  0044a	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  00451	41 c7 47 70 07
	00 00 00	 mov	 DWORD PTR [r15+112], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00459	49 8d 97 10 03
	00 00		 lea	 rdx, QWORD PTR [r15+784]
  00460	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  00467	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0046c	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00473	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  00477	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  0047e	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  00482	41 b8 13 00 00
	00		 mov	 r8d, 19
  00488	33 c9		 xor	 ecx, ecx
  0048a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048f	e8 00 00 00 00	 call	 inflate_table

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  00494	85 c0		 test	 eax, eax
  00496	74 20		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  00498	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
$LN589@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  0049f	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  004a3	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  004a7	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  004ab	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  004b3	e9 3b 09 00 00	 jmp	 $LN545@inflateBac
$LN280@inflateBac:

; 392  :                 state->mode = BAD;
; 393  :                 break;
; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004b8	41 8b 8f 80 00
	00 00		 mov	 ecx, DWORD PTR [r15+128]
  004bf	41 8b 57 7c	 mov	 edx, DWORD PTR [r15+124]
  004c3	41 c7 87 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r15+132], 0
  004ce	03 ca		 add	 ecx, edx
  004d0	0f 84 8f 02 00
	00		 je	 $LN93@inflateBac
  004d6	49 8d 5f 70	 lea	 rbx, QWORD PTR [r15+112]
  004da	66 0f 1f 44 00
	00		 npad	 6
$LL92@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004e0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004e2	b8 01 00 00 00	 mov	 eax, 1

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004e7	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  004eb	d3 e0		 shl	 eax, cl
  004ed	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004f0	41 8b c6	 mov	 eax, r14d
  004f3	48 23 c8	 and	 rcx, rax
  004f6	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  004fa	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004fd	8b d0		 mov	 edx, eax
  004ff	c1 ea 08	 shr	 edx, 8
  00502	44 8b c8	 mov	 r9d, eax
  00505	0f b6 ca	 movzx	 ecx, dl
  00508	41 c1 e9 10	 shr	 r9d, 16
  0050c	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  0050f	3b ce		 cmp	 ecx, esi
  00511	76 62		 jbe	 SHORT $LN375@inflateBac
$LL94@inflateBac:

; 403  :                     PULLBYTE();

  00513	85 ff		 test	 edi, edi
  00515	75 18		 jne	 SHORT $LN100@inflateBac
  00517	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0051b	49 8b cd	 mov	 rcx, r13
  0051e	41 ff d4	 call	 r12
  00521	8b f8		 mov	 edi, eax
  00523	85 c0		 test	 eax, eax
  00525	0f 84 e5 08 00
	00		 je	 $LN369@inflateBac
  0052b	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  0052f	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00533	8b ce		 mov	 ecx, esi
  00535	d3 e0		 shl	 eax, cl
  00537	49 ff c0	 inc	 r8
  0053a	44 03 f0	 add	 r14d, eax
  0053d	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00541	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00543	b8 01 00 00 00	 mov	 eax, 1
  00548	d3 e0		 shl	 eax, cl
  0054a	ff cf		 dec	 edi
  0054c	41 8b d6	 mov	 edx, r14d
  0054f	83 c6 08	 add	 esi, 8
  00552	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00555	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00559	48 23 ca	 and	 rcx, rdx
  0055c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0055f	8b d0		 mov	 edx, eax
  00561	c1 ea 08	 shr	 edx, 8
  00564	44 8b c8	 mov	 r9d, eax
  00567	0f b6 ca	 movzx	 ecx, dl
  0056a	41 c1 e9 10	 shr	 r9d, 16
  0056e	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00571	3b ce		 cmp	 ecx, esi
  00573	77 9e		 ja	 SHORT $LL94@inflateBac
$LN375@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  00575	66 41 83 f9 10	 cmp	 r9w, 16
  0057a	73 31		 jae	 SHORT $LN284@inflateBac

; 406  :                     DROPBITS(here.bits);

  0057c	0f b6 ca	 movzx	 ecx, dl

; 407  :                     state->lens[state->have++] = here.val;

  0057f	c1 e8 10	 shr	 eax, 16
  00582	41 d3 ee	 shr	 r14d, cl
  00585	0f b6 ca	 movzx	 ecx, dl
  00588	2b f1		 sub	 esi, ecx
  0058a	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00591	66 41 89 84 4f
	90 00 00 00	 mov	 WORD PTR [r15+rcx*2+144], ax
  0059a	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  005a1	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]

; 408  :                 }

  005a8	e9 9e 01 00 00	 jmp	 $LN406@inflateBac
$LN284@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  005ad	0f b6 da	 movzx	 ebx, dl
  005b0	75 7d		 jne	 SHORT $LN286@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  005b2	83 c3 02	 add	 ebx, 2
  005b5	3b f3		 cmp	 esi, ebx
  005b7	73 3e		 jae	 SHORT $LN106@inflateBac
  005b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL109@inflateBac:
  005c0	85 ff		 test	 edi, edi
  005c2	75 18		 jne	 SHORT $LN114@inflateBac
  005c4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005c8	49 8b cd	 mov	 rcx, r13
  005cb	41 ff d4	 call	 r12
  005ce	8b f8		 mov	 edi, eax
  005d0	85 c0		 test	 eax, eax
  005d2	0f 84 38 08 00
	00		 je	 $LN369@inflateBac
  005d8	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005dc	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  005e0	8b ce		 mov	 ecx, esi
  005e2	d3 e0		 shl	 eax, cl
  005e4	49 ff c0	 inc	 r8
  005e7	44 03 f0	 add	 r14d, eax
  005ea	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  005ee	ff cf		 dec	 edi
  005f0	83 c6 08	 add	 esi, 8
  005f3	3b f3		 cmp	 esi, ebx
  005f5	72 c9		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 412  :                         DROPBITS(here.bits);

  005f7	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 413  :                         if (state->have == 0) {

  005fb	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00602	2b f1		 sub	 esi, ecx
  00604	41 d3 ee	 shr	 r14d, cl
  00607	85 c0		 test	 eax, eax
  00609	0f 84 7b 01 00
	00		 je	 $LN380@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";
; 415  :                             state->mode = BAD;
; 416  :                             break;
; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  0060f	41 8b d6	 mov	 edx, r14d

; 420  :                         DROPBITS(2);

  00612	83 c6 fe	 add	 esi, -2			; fffffffeH
  00615	83 e2 03	 and	 edx, 3
  00618	41 c1 ee 02	 shr	 r14d, 2
  0061c	83 c2 03	 add	 edx, 3
  0061f	ff c8		 dec	 eax
  00621	45 0f b7 8c 47
	90 00 00 00	 movzx	 r9d, WORD PTR [r15+rax*2+144]

; 421  :                     }

  0062a	e9 cd 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  0062f	66 41 83 f9 11	 cmp	 r9w, 17
  00634	75 65		 jne	 SHORT $LN142@inflateBac

; 423  :                         NEEDBITS(here.bits + 3);

  00636	83 c3 03	 add	 ebx, 3
  00639	3b f3		 cmp	 esi, ebx
  0063b	73 3a		 jae	 SHORT $LN123@inflateBac
  0063d	0f 1f 00	 npad	 3
$LL126@inflateBac:
  00640	85 ff		 test	 edi, edi
  00642	75 18		 jne	 SHORT $LN131@inflateBac
  00644	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00648	49 8b cd	 mov	 rcx, r13
  0064b	41 ff d4	 call	 r12
  0064e	8b f8		 mov	 edi, eax
  00650	85 c0		 test	 eax, eax
  00652	0f 84 b8 07 00
	00		 je	 $LN369@inflateBac
  00658	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  0065c	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00660	8b ce		 mov	 ecx, esi
  00662	d3 e0		 shl	 eax, cl
  00664	49 ff c0	 inc	 r8
  00667	44 03 f0	 add	 r14d, eax
  0066a	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0066e	ff cf		 dec	 edi
  00670	83 c6 08	 add	 esi, 8
  00673	3b f3		 cmp	 esi, ebx
  00675	72 c9		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 424  :                         DROPBITS(here.bits);

  00677	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  0067b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00680	41 d3 ee	 shr	 r14d, cl
  00683	2b c1		 sub	 eax, ecx
  00685	41 8b d6	 mov	 edx, r14d
  00688	03 f0		 add	 esi, eax
  0068a	83 e2 07	 and	 edx, 7
  0068d	41 c1 ee 03	 shr	 r14d, 3
  00691	83 c2 03	 add	 edx, 3
  00694	33 c0		 xor	 eax, eax
  00696	44 8b c8	 mov	 r9d, eax

; 428  :                     }

  00699	eb 61		 jmp	 SHORT $LN155@inflateBac
$LN142@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  0069b	83 c3 07	 add	 ebx, 7
  0069e	3b f3		 cmp	 esi, ebx
  006a0	73 37		 jae	 SHORT $LN140@inflateBac
$LL143@inflateBac:
  006a2	85 ff		 test	 edi, edi
  006a4	75 18		 jne	 SHORT $LN148@inflateBac
  006a6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006aa	49 8b cd	 mov	 rcx, r13
  006ad	41 ff d4	 call	 r12
  006b0	8b f8		 mov	 edi, eax
  006b2	85 c0		 test	 eax, eax
  006b4	0f 84 56 07 00
	00		 je	 $LN369@inflateBac
  006ba	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  006be	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  006c2	8b ce		 mov	 ecx, esi
  006c4	d3 e0		 shl	 eax, cl
  006c6	49 ff c0	 inc	 r8
  006c9	44 03 f0	 add	 r14d, eax
  006cc	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  006d0	ff cf		 dec	 edi
  006d2	83 c6 08	 add	 esi, 8
  006d5	3b f3		 cmp	 esi, ebx
  006d7	72 c9		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 431  :                         DROPBITS(here.bits);

  006d9	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006dd	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006e2	41 d3 ee	 shr	 r14d, cl
  006e5	2b c1		 sub	 eax, ecx
  006e7	41 8b d6	 mov	 edx, r14d
  006ea	03 f0		 add	 esi, eax
  006ec	83 e2 7f	 and	 edx, 127		; 0000007fH
  006ef	41 c1 ee 07	 shr	 r14d, 7
  006f3	83 c2 0b	 add	 edx, 11
  006f6	33 c0		 xor	 eax, eax
  006f8	44 0f b7 c8	 movzx	 r9d, ax
$LN155@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  006fc	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00703	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  0070a	03 ca		 add	 ecx, edx
  0070c	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00710	3b c8		 cmp	 ecx, eax
  00712	77 76		 ja	 SHORT $LN380@inflateBac
  00714	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL157@inflateBac:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)
; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00720	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00727	66 45 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r9w
  00730	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]
  00737	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  0073b	45 89 87 84 00
	00 00		 mov	 DWORD PTR [r15+132], r8d
  00742	83 c2 ff	 add	 edx, -1			; ffffffffH
  00745	75 d9		 jne	 SHORT $LL157@inflateBac

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  00747	49 8d 5f 70	 lea	 rbx, QWORD PTR [r15+112]
$LN406@inflateBac:

; 392  :                 state->mode = BAD;
; 393  :                 break;
; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0074b	41 8b 8f 80 00
	00 00		 mov	 ecx, DWORD PTR [r15+128]
  00752	41 8b 57 7c	 mov	 edx, DWORD PTR [r15+124]
  00756	03 ca		 add	 ecx, edx
  00758	44 3b c1	 cmp	 r8d, ecx
  0075b	0f 82 7f fd ff
	ff		 jb	 $LL92@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00761	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN93@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00765	41 81 7f 08 51
	3f 00 00	 cmp	 DWORD PTR [r15+8], 16209 ; 00003f51H
  0076d	0f 84 4e 03 00
	00		 je	 $LN566@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00773	66 41 83 bf 90
	02 00 00 00	 cmp	 WORD PTR [r15+656], 0
  0077c	75 1c		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  0077e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 452  :                 state->mode = BAD;
; 453  :                 break;

  00785	e9 15 fd ff ff	 jmp	 $LN589@inflateBac
$LN380@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  0078a	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  0078e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00795	e9 05 fd ff ff	 jmp	 $LN589@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  0079a	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;

  007a1	41 c7 47 70 09
	00 00 00	 mov	 DWORD PTR [r15+112], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  007a9	4d 8d 87 10 03
	00 00		 lea	 r8, QWORD PTR [r15+784]
  007b0	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  007b7	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  007bc	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  007c3	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007c7	44 8b c2	 mov	 r8d, edx
  007ca	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  007ce	b9 01 00 00 00	 mov	 ecx, 1
  007d3	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  007da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007df	e8 00 00 00 00	 call	 inflate_table

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  007e4	85 c0		 test	 eax, eax
  007e6	74 0c		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  007e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 466  :                 state->mode = BAD;
; 467  :                 break;

  007ef	e9 ab fc ff ff	 jmp	 $LN589@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);
; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  007f4	45 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [r15+128]
  007fb	49 8d 4f 74	 lea	 rcx, QWORD PTR [r15+116]
  007ff	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00806	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  0080c	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0080f	49 89 47 68	 mov	 QWORD PTR [r15+104], rax
  00813	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00817	48 83 c0 48	 add	 rax, 72			; 00000048H
  0081b	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  0081f	49 8d 87 10 03
	00 00		 lea	 rax, QWORD PTR [r15+784]
  00826	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0082b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00830	b9 02 00 00 00	 mov	 ecx, 2
  00835	e8 00 00 00 00	 call	 inflate_table

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {

  0083a	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  0083e	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00842	85 c0		 test	 eax, eax
  00844	74 18		 je	 SHORT $LN301@inflateBac

; 474  :                 strm->msg = (char *)"invalid distances set";

  00846	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  0084d	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 475  :                 state->mode = BAD;

  00851	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 476  :                 break;

  00859	e9 95 05 00 00	 jmp	 $LN545@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  0085e	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
  00866	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN302@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  0086c	83 ff 06	 cmp	 edi, 6
  0086f	0f 82 83 00 00
	00		 jb	 $LN303@inflateBac
  00875	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  0087c	72 7a		 jb	 SHORT $LN303@inflateBac

; 484  :                 RESTORE();

  0087e	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00882	49 89 00	 mov	 QWORD PTR [r8], rax
  00885	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  00889	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  0088d	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 485  :                 if (state->whave < state->wsize)

  00891	41 8b 57 34	 mov	 edx, DWORD PTR [r15+52]
  00895	45 89 77 48	 mov	 DWORD PTR [r15+72], r14d
  00899	41 89 77 4c	 mov	 DWORD PTR [r15+76], esi
  0089d	41 39 57 38	 cmp	 DWORD PTR [r15+56], edx
  008a1	73 09		 jae	 SHORT $LN304@inflateBac

; 486  :                     state->whave = state->wsize - left;

  008a3	8b c2		 mov	 eax, edx
  008a5	41 2b c1	 sub	 eax, r9d
  008a8	41 89 47 38	 mov	 DWORD PTR [r15+56], eax
$LN304@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  008ac	49 8b c8	 mov	 rcx, r8
  008af	e8 00 00 00 00	 call	 inflate_fast

; 488  :                 LOAD();

  008b4	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  008b8	49 8b 00	 mov	 rax, QWORD PTR [r8]
  008bb	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  008bf	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  008c3	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  008c7	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  008cb	45 8b 77 48	 mov	 r14d, DWORD PTR [r15+72]
  008cf	41 8b 77 4c	 mov	 esi, DWORD PTR [r15+76]
  008d3	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  008d7	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d

; 489  :                 break;

  008db	e9 13 05 00 00	 jmp	 $LN545@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  008e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  008e7	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 370  :                 state->mode = BAD;

  008eb	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 371  :                 break;

  008f3	e9 fb 04 00 00	 jmp	 $LN545@inflateBac
$LN303@inflateBac:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  008f8	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  008fc	41 8b c3	 mov	 eax, r11d
  008ff	4d 8b 4f 60	 mov	 r9, QWORD PTR [r15+96]
  00903	d3 e0		 shl	 eax, cl
  00905	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00908	41 8b c6	 mov	 eax, r14d
  0090b	48 23 c8	 and	 rcx, rax
  0090e	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00912	8b c8		 mov	 ecx, eax
  00914	c1 e9 08	 shr	 ecx, 8
  00917	0f b6 c9	 movzx	 ecx, cl

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  0091a	3b ce		 cmp	 ecx, esi
  0091c	76 5c		 jbe	 SHORT $LN382@inflateBac
  0091e	66 90		 npad	 2
$LL165@inflateBac:

; 496  :                 PULLBYTE();

  00920	85 ff		 test	 edi, edi
  00922	75 1a		 jne	 SHORT $LN171@inflateBac
  00924	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00928	49 8b cd	 mov	 rcx, r13
  0092b	41 ff d4	 call	 r12
  0092e	8b f8		 mov	 edi, eax
  00930	85 c0		 test	 eax, eax
  00932	0f 84 d8 04 00
	00		 je	 $LN369@inflateBac
  00938	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN171@inflateBac:
  0093e	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00942	8b ce		 mov	 ecx, esi
  00944	ff cf		 dec	 edi
  00946	83 c6 08	 add	 esi, 8
  00949	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0094c	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00950	4d 8b 4f 60	 mov	 r9, QWORD PTR [r15+96]
  00954	d3 e0		 shl	 eax, cl
  00956	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  0095a	44 03 f0	 add	 r14d, eax
  0095d	41 8b c3	 mov	 eax, r11d
  00960	41 8b d6	 mov	 edx, r14d
  00963	d3 e0		 shl	 eax, cl
  00965	ff c8		 dec	 eax
  00967	48 23 c2	 and	 rax, rdx
  0096a	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0096e	8b c8		 mov	 ecx, eax
  00970	c1 e9 08	 shr	 ecx, 8
  00973	0f b6 c9	 movzx	 ecx, cl
  00976	3b ce		 cmp	 ecx, esi
  00978	77 a6		 ja	 SHORT $LL165@inflateBac
$LN382@inflateBac:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  0097a	84 c0		 test	 al, al
  0097c	0f 84 c3 00 00
	00		 je	 $LN184@inflateBac
  00982	a8 f0		 test	 al, 240			; 000000f0H
  00984	0f 85 bb 00 00
	00		 jne	 $LN184@inflateBac

; 499  :                 last = here;

  0098a	8b c8		 mov	 ecx, eax
  0098c	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];
; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0098f	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR last$[rbp-119]
  00994	41 8b d3	 mov	 edx, r11d
  00997	c1 e9 08	 shr	 ecx, 8
  0099a	8b d8		 mov	 ebx, eax
  0099c	44 0f b6 c1	 movzx	 r8d, cl
  009a0	0f b6 c8	 movzx	 ecx, al
  009a3	41 03 c8	 add	 ecx, r8d
  009a6	c1 e8 10	 shr	 eax, 16
  009a9	d3 e2		 shl	 edx, cl
  009ab	41 8b c8	 mov	 ecx, r8d
  009ae	ff ca		 dec	 edx
  009b0	41 23 d6	 and	 edx, r14d
  009b3	d3 ea		 shr	 edx, cl
  009b5	03 d0		 add	 edx, eax
  009b7	41 8b 04 91	 mov	 eax, DWORD PTR [r9+rdx*4]
  009bb	8b c8		 mov	 ecx, eax
  009bd	c1 e9 08	 shr	 ecx, 8
  009c0	0f b6 d1	 movzx	 edx, cl
  009c3	41 03 d0	 add	 edx, r8d
  009c6	3b d6		 cmp	 edx, esi
  009c8	76 6e		 jbe	 SHORT $LN185@inflateBac
  009ca	44 0f b7 6d be	 movzx	 r13d, WORD PTR last$[rbp-118]
  009cf	90		 npad	 1
$LL174@inflateBac:

; 504  :                     PULLBYTE();

  009d0	85 ff		 test	 edi, edi
  009d2	75 1b		 jne	 SHORT $LN180@inflateBac
  009d4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009d8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009dc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009df	8b f8		 mov	 edi, eax
  009e1	85 c0		 test	 eax, eax
  009e3	0f 84 27 04 00
	00		 je	 $LN369@inflateBac
  009e9	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN180@inflateBac:
  009ef	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  009f3	8b ce		 mov	 ecx, esi
  009f5	41 8b d3	 mov	 edx, r11d
  009f8	ff cf		 dec	 edi
  009fa	83 c6 08	 add	 esi, 8
  009fd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a00	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00a04	d3 e0		 shl	 eax, cl
  00a06	44 03 f0	 add	 r14d, eax
  00a09	0f b6 cb	 movzx	 ecx, bl
  00a0c	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00a10	41 03 cc	 add	 ecx, r12d
  00a13	d3 e2		 shl	 edx, cl
  00a15	41 8b cc	 mov	 ecx, r12d
  00a18	ff ca		 dec	 edx
  00a1a	41 23 d6	 and	 edx, r14d
  00a1d	d3 ea		 shr	 edx, cl
  00a1f	41 03 d5	 add	 edx, r13d
  00a22	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a25	8b c8		 mov	 ecx, eax
  00a27	c1 e9 08	 shr	 ecx, 8
  00a2a	0f b6 d1	 movzx	 edx, cl
  00a2d	41 03 d4	 add	 edx, r12d
  00a30	3b d6		 cmp	 edx, esi
  00a32	77 9c		 ja	 SHORT $LL174@inflateBac
  00a34	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
$LN185@inflateBac:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  00a38	41 8b cc	 mov	 ecx, r12d
  00a3b	41 d3 ee	 shr	 r14d, cl
  00a3e	41 2b f4	 sub	 esi, r12d
  00a41	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
$LN184@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00a45	8b c8		 mov	 ecx, eax
  00a47	c1 e9 08	 shr	 ecx, 8
  00a4a	0f b6 c9	 movzx	 ecx, cl
  00a4d	41 d3 ee	 shr	 r14d, cl
  00a50	2b f1		 sub	 esi, ecx

; 509  :             state->length = (unsigned)here.val;

  00a52	8b c8		 mov	 ecx, eax
  00a54	c1 e9 10	 shr	 ecx, 16
  00a57	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00a5b	84 c0		 test	 al, al
  00a5d	75 52		 jne	 SHORT $LN312@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00a5f	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a63	45 85 e4	 test	 r12d, r12d
  00a66	75 23		 jne	 SHORT $LN565@inflateBac
  00a68	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00a6c	45 8b c4	 mov	 r8d, r12d
  00a6f	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00a73	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a77	48 8b d3	 mov	 rdx, rbx
  00a7a	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00a7e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00a81	85 c0		 test	 eax, eax
  00a83	0f 85 8d 03 00
	00		 jne	 $LN372@inflateBac
  00a89	eb 04		 jmp	 SHORT $LN189@inflateBac
$LN565@inflateBac:
  00a8b	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 517  :                 *put++ = (unsigned char)(state->length);

  00a8f	41 0f b6 47 50	 movzx	 eax, BYTE PTR [r15+80]
  00a94	88 03		 mov	 BYTE PTR [rbx], al
  00a96	48 ff c3	 inc	 rbx

; 518  :                 left--;

  00a99	41 ff cc	 dec	 r12d
  00a9c	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00aa0	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d

; 519  :                 state->mode = LEN;

  00aa4	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 520  :                 break;

  00aac	e9 3b 03 00 00	 jmp	 $LN567@inflateBac
$LN312@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00ab1	a8 20		 test	 al, 32			; 00000020H
  00ab3	74 15		 je	 SHORT $LN315@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;
; 527  :                 break;

  00ab5	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ab9	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
$LN566@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00ac1	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00ac5	e9 25 03 00 00	 jmp	 $LN583@inflateBac
$LN315@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00aca	a8 40		 test	 al, 64			; 00000040H
  00acc	74 10		 je	 SHORT $LN316@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00ace	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ad2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00ad9	e9 c1 f9 ff ff	 jmp	 $LN589@inflateBac
$LN316@inflateBac:

; 533  :                 state->mode = BAD;
; 534  :                 break;
; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00ade	0f b6 c8	 movzx	 ecx, al
  00ae1	83 e1 0f	 and	 ecx, 15
  00ae4	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 539  :             if (state->extra != 0) {

  00ae8	74 5b		 je	 SHORT $LN204@inflateBac

; 540  :                 NEEDBITS(state->extra);

  00aea	3b f1		 cmp	 esi, ecx
  00aec	73 44		 jae	 SHORT $LN192@inflateBac
  00aee	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL195@inflateBac:
  00af2	85 ff		 test	 edi, edi
  00af4	75 18		 jne	 SHORT $LN200@inflateBac
  00af6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00afa	49 8b cd	 mov	 rcx, r13
  00afd	41 ff d4	 call	 r12
  00b00	8b f8		 mov	 edi, eax
  00b02	85 c0		 test	 eax, eax
  00b04	0f 84 06 03 00
	00		 je	 $LN369@inflateBac
  00b0a	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b0e	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b11	8b ce		 mov	 ecx, esi
  00b13	d3 e0		 shl	 eax, cl
  00b15	48 ff c2	 inc	 rdx
  00b18	44 03 f0	 add	 r14d, eax
  00b1b	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b1f	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00b23	ff cf		 dec	 edi
  00b25	83 c6 08	 add	 esi, 8
  00b28	3b f1		 cmp	 esi, ecx
  00b2a	72 c6		 jb	 SHORT $LL195@inflateBac
  00b2c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN192@inflateBac:

; 541  :                 state->length += BITS(state->extra);

  00b32	41 8b c3	 mov	 eax, r11d
  00b35	d3 e0		 shl	 eax, cl
  00b37	ff c8		 dec	 eax
  00b39	41 23 c6	 and	 eax, r14d

; 542  :                 DROPBITS(state->extra);

  00b3c	41 d3 ee	 shr	 r14d, cl
  00b3f	41 01 47 50	 add	 DWORD PTR [r15+80], eax
  00b43	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00b45	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b49	41 8b c3	 mov	 eax, r11d
  00b4c	4d 8b 57 68	 mov	 r10, QWORD PTR [r15+104]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00b50	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
  00b54	d3 e0		 shl	 eax, cl
  00b56	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b59	41 8b c6	 mov	 eax, r14d
  00b5c	48 23 c8	 and	 rcx, rax
  00b5f	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00b63	8b c8		 mov	 ecx, eax
  00b65	c1 e9 08	 shr	 ecx, 8
  00b68	0f b6 c9	 movzx	 ecx, cl
  00b6b	3b ce		 cmp	 ecx, esi
  00b6d	76 5f		 jbe	 SHORT $LN387@inflateBac
  00b6f	90		 npad	 1
$LL206@inflateBac:

; 550  :                 PULLBYTE();

  00b70	85 ff		 test	 edi, edi
  00b72	75 1e		 jne	 SHORT $LN212@inflateBac
  00b74	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b78	49 8b cd	 mov	 rcx, r13
  00b7b	41 ff d4	 call	 r12
  00b7e	8b f8		 mov	 edi, eax
  00b80	85 c0		 test	 eax, eax
  00b82	0f 84 88 02 00
	00		 je	 $LN369@inflateBac
  00b88	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
  00b8c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN212@inflateBac:
  00b92	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00b96	8b ce		 mov	 ecx, esi
  00b98	d3 e0		 shl	 eax, cl
  00b9a	49 ff c1	 inc	 r9
  00b9d	44 03 f0	 add	 r14d, eax
  00ba0	4c 89 4d c0	 mov	 QWORD PTR next$[rbp-120], r9
  00ba4	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00ba8	41 8b c3	 mov	 eax, r11d
  00bab	4d 8b 57 68	 mov	 r10, QWORD PTR [r15+104]
  00baf	ff cf		 dec	 edi
  00bb1	d3 e0		 shl	 eax, cl
  00bb3	83 c6 08	 add	 esi, 8
  00bb6	ff c8		 dec	 eax
  00bb8	41 8b d6	 mov	 edx, r14d
  00bbb	48 23 c2	 and	 rax, rdx
  00bbe	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00bc2	8b c8		 mov	 ecx, eax
  00bc4	c1 e9 08	 shr	 ecx, 8
  00bc7	0f b6 c9	 movzx	 ecx, cl
  00bca	3b ce		 cmp	 ecx, esi
  00bcc	77 a2		 ja	 SHORT $LL206@inflateBac
$LN387@inflateBac:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00bce	a8 f0		 test	 al, 240			; 000000f0H
  00bd0	0f 85 bb 00 00
	00		 jne	 $LN225@inflateBac

; 553  :                 last = here;

  00bd6	8b c8		 mov	 ecx, eax
  00bd8	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];
; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bdb	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR last$[rbp-119]
  00be0	41 8b d3	 mov	 edx, r11d
  00be3	c1 e9 08	 shr	 ecx, 8
  00be6	8b d8		 mov	 ebx, eax
  00be8	44 0f b6 c1	 movzx	 r8d, cl
  00bec	0f b6 c8	 movzx	 ecx, al
  00bef	41 03 c8	 add	 ecx, r8d
  00bf2	c1 e8 10	 shr	 eax, 16
  00bf5	d3 e2		 shl	 edx, cl
  00bf7	41 8b c8	 mov	 ecx, r8d
  00bfa	ff ca		 dec	 edx
  00bfc	41 23 d6	 and	 edx, r14d
  00bff	d3 ea		 shr	 edx, cl
  00c01	03 d0		 add	 edx, eax
  00c03	41 8b 04 92	 mov	 eax, DWORD PTR [r10+rdx*4]
  00c07	8b c8		 mov	 ecx, eax
  00c09	c1 e9 08	 shr	 ecx, 8
  00c0c	0f b6 d1	 movzx	 edx, cl
  00c0f	41 03 d0	 add	 edx, r8d
  00c12	3b d6		 cmp	 edx, esi
  00c14	76 72		 jbe	 SHORT $LN226@inflateBac
  00c16	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
  00c1b	0f 1f 44 00 00	 npad	 5
$LL215@inflateBac:

; 558  :                     PULLBYTE();

  00c20	85 ff		 test	 edi, edi
  00c22	75 1f		 jne	 SHORT $LN221@inflateBac
  00c24	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c28	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c2c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c2f	8b f8		 mov	 edi, eax
  00c31	85 c0		 test	 eax, eax
  00c33	0f 84 d7 01 00
	00		 je	 $LN369@inflateBac
  00c39	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
  00c3d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN221@inflateBac:
  00c43	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00c47	8b ce		 mov	 ecx, esi
  00c49	d3 e0		 shl	 eax, cl
  00c4b	41 8b d3	 mov	 edx, r11d
  00c4e	44 03 f0	 add	 r14d, eax
  00c51	0f b6 cb	 movzx	 ecx, bl
  00c54	41 03 cd	 add	 ecx, r13d
  00c57	49 ff c1	 inc	 r9
  00c5a	d3 e2		 shl	 edx, cl
  00c5c	ff cf		 dec	 edi
  00c5e	ff ca		 dec	 edx
  00c60	4c 89 4d c0	 mov	 QWORD PTR next$[rbp-120], r9
  00c64	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00c68	41 23 d6	 and	 edx, r14d
  00c6b	41 8b cd	 mov	 ecx, r13d
  00c6e	83 c6 08	 add	 esi, 8
  00c71	d3 ea		 shr	 edx, cl
  00c73	41 03 d4	 add	 edx, r12d
  00c76	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00c79	8b c8		 mov	 ecx, eax
  00c7b	c1 e9 08	 shr	 ecx, 8
  00c7e	0f b6 d1	 movzx	 edx, cl
  00c81	41 03 d5	 add	 edx, r13d
  00c84	3b d6		 cmp	 edx, esi
  00c86	77 98		 ja	 SHORT $LL215@inflateBac
$LN226@inflateBac:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00c88	41 8b cd	 mov	 ecx, r13d
  00c8b	41 d3 ee	 shr	 r14d, cl
  00c8e	41 2b f5	 sub	 esi, r13d
$LN225@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00c91	8b c8		 mov	 ecx, eax
  00c93	c1 e9 08	 shr	 ecx, 8
  00c96	0f b6 c9	 movzx	 ecx, cl
  00c99	41 d3 ee	 shr	 r14d, cl
  00c9c	2b f1		 sub	 esi, ecx

; 563  :             if (here.op & 64) {

  00c9e	a8 40		 test	 al, 64			; 00000040H
  00ca0	74 10		 je	 SHORT $LN327@inflateBac

; 564  :                 strm->msg = (char *)"invalid distance code";

  00ca2	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ca6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00cad	e9 ed f7 ff ff	 jmp	 $LN589@inflateBac
$LN327@inflateBac:

; 565  :                 state->mode = BAD;
; 566  :                 break;
; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00cb2	8b d0		 mov	 edx, eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00cb4	0f b6 c8	 movzx	 ecx, al
  00cb7	c1 ea 10	 shr	 edx, 16
  00cba	83 e1 0f	 and	 ecx, 15
  00cbd	41 89 57 54	 mov	 DWORD PTR [r15+84], edx
  00cc1	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 572  :             if (state->extra != 0) {

  00cc5	74 61		 je	 SHORT $LN242@inflateBac

; 573  :                 NEEDBITS(state->extra);

  00cc7	3b f1		 cmp	 esi, ecx
  00cc9	73 46		 jae	 SHORT $LN230@inflateBac
  00ccb	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00ccf	90		 npad	 1
$LL233@inflateBac:
  00cd0	85 ff		 test	 edi, edi
  00cd2	75 19		 jne	 SHORT $LN238@inflateBac
  00cd4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cd8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00cdc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00cdf	8b f8		 mov	 edi, eax
  00ce1	85 c0		 test	 eax, eax
  00ce3	0f 84 27 01 00
	00		 je	 $LN369@inflateBac
  00ce9	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00ced	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00cf0	8b ce		 mov	 ecx, esi
  00cf2	d3 e0		 shl	 eax, cl
  00cf4	48 ff c2	 inc	 rdx
  00cf7	44 03 f0	 add	 r14d, eax
  00cfa	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00cfe	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00d02	ff cf		 dec	 edi
  00d04	83 c6 08	 add	 esi, 8
  00d07	3b f1		 cmp	 esi, ecx
  00d09	72 c5		 jb	 SHORT $LL233@inflateBac
  00d0b	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN230@inflateBac:

; 574  :                 state->offset += BITS(state->extra);

  00d11	41 8b c3	 mov	 eax, r11d
  00d14	d3 e0		 shl	 eax, cl
  00d16	ff c8		 dec	 eax
  00d18	41 23 c6	 and	 eax, r14d

; 575  :                 DROPBITS(state->extra);

  00d1b	41 d3 ee	 shr	 r14d, cl
  00d1e	41 01 47 54	 add	 DWORD PTR [r15+84], eax
  00d22	41 8b 57 54	 mov	 edx, DWORD PTR [r15+84]
  00d26	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00d28	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00d2c	33 c0		 xor	 eax, eax
  00d2e	41 39 4f 38	 cmp	 DWORD PTR [r15+56], ecx
  00d32	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00d36	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d3a	41 0f 42 c4	 cmovb	 eax, r12d
  00d3e	2b c8		 sub	 ecx, eax
  00d40	3b d1		 cmp	 edx, ecx
  00d42	76 1f		 jbe	 SHORT $LL246@inflateBac

; 578  :                                                 left : 0)) {
; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00d44	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00d48	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d4f	45 8b cc	 mov	 r9d, r12d
  00d52	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00d56	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00d5e	e9 90 00 00 00	 jmp	 $LN545@inflateBac
$LL246@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00d63	45 85 e4	 test	 r12d, r12d
  00d66	75 21		 jne	 SHORT $LN247@inflateBac
  00d68	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00d6c	45 8b c4	 mov	 r8d, r12d
  00d6f	49 8b 5f 40	 mov	 rbx, QWORD PTR [r15+64]
  00d73	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00d77	48 8b d3	 mov	 rdx, rbx
  00d7a	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00d7e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00d81	85 c0		 test	 eax, eax
  00d83	0f 85 8d 00 00
	00		 jne	 $LN372@inflateBac
$LN247@inflateBac:

; 588  :                 copy = state->wsize - state->offset;

  00d89	41 8b 4f 54	 mov	 ecx, DWORD PTR [r15+84]

; 589  :                 if (copy < left) {

  00d8d	45 8b c4	 mov	 r8d, r12d
  00d90	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00d94	2b c1		 sub	 eax, ecx
  00d96	41 3b c4	 cmp	 eax, r12d
  00d99	73 0a		 jae	 SHORT $LN334@inflateBac

; 590  :                     from = put + copy;

  00d9b	8b d0		 mov	 edx, eax
  00d9d	48 03 d3	 add	 rdx, rbx

; 591  :                     copy = left - copy;

  00da0	44 2b c0	 sub	 r8d, eax

; 592  :                 }

  00da3	eb 06		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 593  :                 else {
; 594  :                     from = put - state->offset;

  00da5	48 8b d3	 mov	 rdx, rbx
  00da8	48 2b d1	 sub	 rdx, rcx
$LN335@inflateBac:

; 595  :                     copy = left;
; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00dab	41 8b 47 50	 mov	 eax, DWORD PTR [r15+80]

; 598  :                 state->length -= copy;

  00daf	44 3b c0	 cmp	 r8d, eax
  00db2	8b c8		 mov	 ecx, eax
  00db4	41 0f 46 c8	 cmovbe	 ecx, r8d
  00db8	2b c1		 sub	 eax, ecx

; 599  :                 left -= copy;

  00dba	44 2b e1	 sub	 r12d, ecx
  00dbd	41 89 47 50	 mov	 DWORD PTR [r15+80], eax
  00dc1	48 2b d3	 sub	 rdx, rbx
  00dc4	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00dc8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL252@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00dd0	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00dd4	88 03		 mov	 BYTE PTR [rbx], al
  00dd6	48 ff c3	 inc	 rbx

; 602  :                 } while (--copy);

  00dd9	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00ddc	75 f2		 jne	 SHORT $LL252@inflateBac

; 603  :             } while (state->length != 0);

  00dde	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00de2	41 39 4f 50	 cmp	 DWORD PTR [r15+80], ecx
  00de6	0f 85 77 ff ff
	ff		 jne	 $LL246@inflateBac
$LN567@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00dec	45 8b cc	 mov	 r9d, r12d
$LN583@inflateBac:
  00def	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN545@inflateBac:
  00df3	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00df7	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00dfc	83 f8 12	 cmp	 eax, 18
  00dff	77 46		 ja	 SHORT $LN341@inflateBac
  00e01	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  00e05	33 d2		 xor	 edx, edx
  00e07	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00e0b	e9 8c f2 ff ff	 jmp	 $LN586@inflateBac
$LN369@inflateBac:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e10	33 c0		 xor	 eax, eax
  00e12	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
$LN372@inflateBac:
  00e16	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e1c	eb 2f		 jmp	 SHORT $inf_leave$592
$LN337@inflateBac:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00e1e	45 8b 47 34	 mov	 r8d, DWORD PTR [r15+52]
  00e22	45 3b c8	 cmp	 r9d, r8d
  00e25	73 26		 jae	 SHORT $inf_leave$592

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00e27	49 8b 57 40	 mov	 rdx, QWORD PTR [r15+64]
  00e2b	45 2b c1	 sub	 r8d, r9d
  00e2e	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e32	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00e35	85 c0		 test	 eax, eax
  00e37	75 dd		 jne	 SHORT $LN372@inflateBac
  00e39	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00e3d	eb 0e		 jmp	 SHORT $inf_leave$592
$LN340@inflateBac:

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;
; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00e3f	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 617  :             goto inf_leave;

  00e45	eb 06		 jmp	 SHORT $inf_leave$592
$LN341@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00e47	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$592:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e4d	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e51	48 8b 4d c0	 mov	 rcx, QWORD PTR next$[rbp-120]

; 627  :     strm->avail_in = have;
; 628  :     return ret;

  00e55	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e5a	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e5f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00e64	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00e67	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e6c	48 89 08	 mov	 QWORD PTR [rax], rcx
  00e6f	41 8b c3	 mov	 eax, r11d

; 629  : }

  00e72	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e76	41 5f		 pop	 r15
  00e78	41 5d		 pop	 r13
  00e7a	41 5c		 pop	 r12
  00e7c	5d		 pop	 rbp
  00e7d	c3		 ret	 0
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00e7e	b8 fe ff ff ff	 mov	 eax, -2

; 629  : }

  00e83	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e87	41 5f		 pop	 r15
  00e89	41 5d		 pop	 r13
  00e8b	41 5c		 pop	 r12
  00e8d	5d		 pop	 rbp
  00e8e	c3		 ret	 0
  00e8f	90		 npad	 1
$LN511@inflateBac:
  00e90	00 00 00 00	 DD	 $LN255@inflateBac
  00e94	00 00 00 00	 DD	 $LN341@inflateBac
  00e98	00 00 00 00	 DD	 $LN31@inflateBac
  00e9c	00 00 00 00	 DD	 $LN341@inflateBac
  00ea0	00 00 00 00	 DD	 $LN341@inflateBac
  00ea4	00 00 00 00	 DD	 $LN56@inflateBac
  00ea8	00 00 00 00	 DD	 $LN341@inflateBac
  00eac	00 00 00 00	 DD	 $LN341@inflateBac
  00eb0	00 00 00 00	 DD	 $LN341@inflateBac
  00eb4	00 00 00 00	 DD	 $LN302@inflateBac
  00eb8	00 00 00 00	 DD	 $LN341@inflateBac
  00ebc	00 00 00 00	 DD	 $LN341@inflateBac
  00ec0	00 00 00 00	 DD	 $LN341@inflateBac
  00ec4	00 00 00 00	 DD	 $LN341@inflateBac
  00ec8	00 00 00 00	 DD	 $LN341@inflateBac
  00ecc	00 00 00 00	 DD	 $LN341@inflateBac
  00ed0	00 00 00 00	 DD	 $LN341@inflateBac
  00ed4	00 00 00 00	 DD	 $LN337@inflateBac
  00ed8	00 00 00 00	 DD	 $LN340@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 637  :     strm->state = Z_NULL;
; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 640  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 640  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
