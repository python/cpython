; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN107
	DD	imagerel $LN107+1257
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
tv1161 = 0
dcode$1$ = 8
end$1$ = 16
last$1$ = 24
beg$1$ = 32
strm$ = 128
wsize$1$ = 136
start$ = 136
tv1160 = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 53   : {

$LN107:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);
; 84   :     out = strm->next_out;
; 85   :     beg = out - (start - strm->avail_out);
; 86   :     end = out + (strm->avail_out - 257);
; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;
; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;
; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;
; 97   :     dcode = state->distcode;
; 98   :     lmask = (1U << state->lenbits) - 1;

  00019	bd 01 00 00 00	 mov	 ebp, 1
  0001e	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00021	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00025	83 e8 05	 sub	 eax, 5
  00028	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  0002b	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0002e	48 03 c6	 add	 rax, rsi
  00031	4d 8b 4d 68	 mov	 r9, QWORD PTR [r13+104]
  00035	2b d1		 sub	 edx, ecx
  00037	45 8b 75 3c	 mov	 r14d, DWORD PTR [r13+60]
  0003b	4d 8b 7d 40	 mov	 r15, QWORD PTR [r13+64]
  0003f	41 8b 5d 48	 mov	 ebx, DWORD PTR [r13+72]
  00043	8d b9 ff fe ff
	ff		 lea	 edi, DWORD PTR [rcx-257]
  00049	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  0004d	49 03 f8	 add	 rdi, r8
  00050	45 8b 5d 4c	 mov	 r11d, DWORD PTR [r13+76]
  00054	4d 8b 65 60	 mov	 r12, QWORD PTR [r13+96]
  00058	48 89 44 24 18	 mov	 QWORD PTR last$1$[rsp], rax
  0005d	8b c2		 mov	 eax, edx
  0005f	49 8b d0	 mov	 rdx, r8
  00062	48 2b d0	 sub	 rdx, rax
  00065	48 89 7c 24 10	 mov	 QWORD PTR end$1$[rsp], rdi
  0006a	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  0006e	89 84 24 88 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00075	41 8b 45 38	 mov	 eax, DWORD PTR [r13+56]
  00079	48 89 54 24 20	 mov	 QWORD PTR beg$1$[rsp], rdx
  0007e	8b d5		 mov	 edx, ebp
  00080	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax

; 99   :     dmask = (1U << state->distbits) - 1;

  00087	8b c5		 mov	 eax, ebp
  00089	d3 e2		 shl	 edx, cl
  0008b	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  0008f	ff ca		 dec	 edx
  00091	d3 e0		 shl	 eax, cl
  00093	ff c8		 dec	 eax
  00095	4c 89 4c 24 08	 mov	 QWORD PTR dcode$1$[rsp], r9
  0009a	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv1160[rsp], eax
  000a1	89 14 24	 mov	 DWORD PTR tv1161[rsp], edx
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  000a4	41 83 fb 0f	 cmp	 r11d, 15
  000a8	73 1e		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  000aa	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000ad	41 8b cb	 mov	 ecx, r11d
  000b0	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  000b2	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  000b6	03 d8		 add	 ebx, eax
  000b8	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  000bc	d3 e0		 shl	 eax, cl
  000be	03 d8		 add	 ebx, eax
  000c0	48 83 c6 02	 add	 rsi, 2

; 108  :             bits += 8;

  000c4	41 83 c3 10	 add	 r11d, 16
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000c8	8b c3		 mov	 eax, ebx
  000ca	8b ca		 mov	 ecx, edx
  000cc	48 23 c8	 and	 rcx, rax
  000cf	41 8b 04 8c	 mov	 eax, DWORD PTR [r12+rcx*4]
  000d3	8b c8		 mov	 ecx, eax
  000d5	c1 e9 08	 shr	 ecx, 8
  000d8	0f b6 c9	 movzx	 ecx, cl

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);
; 113  :         hold >>= op;

  000db	d3 eb		 shr	 ebx, cl

; 114  :         bits -= op;

  000dd	44 2b d9	 sub	 r11d, ecx
  000e0	0f b6 d0	 movzx	 edx, al

; 115  :         op = (unsigned)(here.op);
; 116  :         if (op == 0) {                          /* literal */

  000e3	84 c0		 test	 al, al
  000e5	74 45		 je	 SHORT $LN72@inflate_fa

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000e7	44 8b d0	 mov	 r10d, eax
  000ea	41 c1 ea 10	 shr	 r10d, 16
  000ee	66 90		 npad	 2
$dolen$108:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  000f0	f6 c2 10	 test	 dl, 16
  000f3	75 45		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000f5	f6 c2 40	 test	 dl, 64			; 00000040H
  000f8	0f 85 21 03 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000fe	8b ca		 mov	 ecx, edx
  00100	c1 e8 10	 shr	 eax, 16
  00103	8b d5		 mov	 edx, ebp
  00105	d3 e2		 shl	 edx, cl
  00107	ff ca		 dec	 edx
  00109	23 d3		 and	 edx, ebx
  0010b	03 d0		 add	 edx, eax
  0010d	41 8b 04 94	 mov	 eax, DWORD PTR [r12+rdx*4]
  00111	8b c8		 mov	 ecx, eax
  00113	c1 e9 08	 shr	 ecx, 8
  00116	44 8b d0	 mov	 r10d, eax
  00119	0f b6 c9	 movzx	 ecx, cl
  0011c	d3 eb		 shr	 ebx, cl
  0011e	44 2b d9	 sub	 r11d, ecx
  00121	41 c1 ea 10	 shr	 r10d, 16
  00125	0f b6 d0	 movzx	 edx, al
  00128	84 c0		 test	 al, al
  0012a	75 c4		 jne	 SHORT $dolen$108
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  0012c	c1 e8 10	 shr	 eax, 16
  0012f	41 88 00	 mov	 BYTE PTR [r8], al
  00132	49 ff c0	 inc	 r8

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00135	e9 d1 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);
; 124  :             op &= 15;                           /* number of extra bits */

  0013a	83 e2 0f	 and	 edx, 15

; 125  :             if (op) {

  0013d	74 28		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  0013f	44 3b da	 cmp	 r11d, edx
  00142	73 11		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  00144	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00147	41 8b cb	 mov	 ecx, r11d
  0014a	d3 e0		 shl	 eax, cl
  0014c	48 ff c6	 inc	 rsi
  0014f	03 d8		 add	 ebx, eax

; 128  :                     bits += 8;

  00151	41 83 c3 08	 add	 r11d, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  00155	8b ca		 mov	 ecx, edx
  00157	8b c5		 mov	 eax, ebp
  00159	d3 e0		 shl	 eax, cl
  0015b	ff c8		 dec	 eax
  0015d	23 c3		 and	 eax, ebx

; 131  :                 hold >>= op;

  0015f	d3 eb		 shr	 ebx, cl
  00161	44 03 d0	 add	 r10d, eax

; 132  :                 bits -= op;

  00164	44 2b da	 sub	 r11d, edx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  00167	41 83 fb 0f	 cmp	 r11d, 15
  0016b	73 1e		 jae	 SHORT $LN29@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  0016d	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00170	41 8b cb	 mov	 ecx, r11d
  00173	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00175	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  00179	03 d8		 add	 ebx, eax
  0017b	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  0017f	d3 e0		 shl	 eax, cl
  00181	03 d8		 add	 ebx, eax
  00183	48 83 c6 02	 add	 rsi, 2

; 139  :                 bits += 8;

  00187	41 83 c3 10	 add	 r11d, 16
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  0018b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv1160[rsp]
  00192	8b c3		 mov	 eax, ebx
  00194	48 23 c8	 and	 rcx, rax
  00197	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  0019b	8b c8		 mov	 ecx, eax
  0019d	c1 e9 08	 shr	 ecx, 8
  001a0	44 8b c8	 mov	 r9d, eax
  001a3	0f b6 c9	 movzx	 ecx, cl

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);
; 144  :             hold >>= op;

  001a6	d3 eb		 shr	 ebx, cl

; 145  :             bits -= op;

  001a8	44 2b d9	 sub	 r11d, ecx
  001ab	0f b6 d0	 movzx	 edx, al
  001ae	41 c1 e9 10	 shr	 r9d, 16

; 146  :             op = (unsigned)(here.op);
; 147  :             if (op & 16) {                      /* distance base */

  001b2	f6 c2 10	 test	 dl, 16
  001b5	75 3c		 jne	 SHORT $LN74@inflate_fa
$dodist$109:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001b7	f6 c2 40	 test	 dl, 64			; 00000040H
  001ba	0f 85 8b 02 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001c0	8b ca		 mov	 ecx, edx
  001c2	c1 e8 10	 shr	 eax, 16
  001c5	8b d5		 mov	 edx, ebp
  001c7	d3 e2		 shl	 edx, cl
  001c9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dcode$1$[rsp]
  001ce	ff ca		 dec	 edx
  001d0	23 d3		 and	 edx, ebx
  001d2	03 d0		 add	 edx, eax
  001d4	8b 04 91	 mov	 eax, DWORD PTR [rcx+rdx*4]
  001d7	8b c8		 mov	 ecx, eax
  001d9	c1 e9 08	 shr	 ecx, 8
  001dc	44 8b c8	 mov	 r9d, eax
  001df	0f b6 c9	 movzx	 ecx, cl
  001e2	d3 eb		 shr	 ebx, cl
  001e4	44 2b d9	 sub	 r11d, ecx
  001e7	0f b6 d0	 movzx	 edx, al
  001ea	41 c1 e9 10	 shr	 r9d, 16
  001ee	f6 c2 10	 test	 dl, 16
  001f1	74 c4		 je	 SHORT $dodist$109
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);
; 149  :                 op &= 15;                       /* number of extra bits */

  001f3	83 e2 0f	 and	 edx, 15

; 150  :                 if (bits < op) {

  001f6	44 3b da	 cmp	 r11d, edx
  001f9	73 27		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  001fb	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  001fe	41 8b cb	 mov	 ecx, r11d
  00201	d3 e0		 shl	 eax, cl

; 152  :                     bits += 8;

  00203	41 83 c3 08	 add	 r11d, 8
  00207	03 d8		 add	 ebx, eax
  00209	48 ff c6	 inc	 rsi

; 153  :                     if (bits < op) {

  0020c	44 3b da	 cmp	 r11d, edx
  0020f	73 11		 jae	 SHORT $LN33@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  00211	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00214	41 8b cb	 mov	 ecx, r11d
  00217	d3 e0		 shl	 eax, cl
  00219	03 d8		 add	 ebx, eax
  0021b	48 ff c6	 inc	 rsi

; 155  :                         bits += 8;

  0021e	41 83 c3 08	 add	 r11d, 8
$LN33@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  00222	8b ca		 mov	 ecx, edx
  00224	8b fd		 mov	 edi, ebp
  00226	d3 e7		 shl	 edi, cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;
; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00228	41 8b c0	 mov	 eax, r8d
  0022b	2b 44 24 20	 sub	 eax, DWORD PTR beg$1$[rsp]
  0022f	ff cf		 dec	 edi
  00231	23 fb		 and	 edi, ebx
  00233	44 2b da	 sub	 r11d, edx
  00236	41 03 f9	 add	 edi, r9d
  00239	d3 eb		 shr	 ebx, cl

; 170  :                 if (dist > op) {                /* see if copy from window */

  0023b	3b f8		 cmp	 edi, eax
  0023d	0f 86 61 01 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  00243	8b cf		 mov	 ecx, edi
  00245	2b c8		 sub	 ecx, eax

; 172  :                     if (op > whave) {

  00247	3b 8c 24 98 00
	00 00		 cmp	 ecx, DWORD PTR whave$1$[rsp]
  0024e	76 0e		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  00250	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  00258	0f 85 0a 02 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;
; 200  :                     if (wnext == 0) {           /* very common case */

  0025e	45 85 f6	 test	 r14d, r14d
  00261	75 35		 jne	 SHORT $LN38@inflate_fa

; 201  :                         from += wsize - op;

  00263	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]
  0026b	44 2b c9	 sub	 r9d, ecx
  0026e	4d 03 cf	 add	 r9, r15

; 202  :                         if (op < len) {         /* some from window */

  00271	41 3b ca	 cmp	 ecx, r10d
  00274	0f 83 b1 00 00
	00		 jae	 $LN69@inflate_fa

; 203  :                             len -= op;

  0027a	44 2b d1	 sub	 r10d, ecx
  0027d	0f 1f 00	 npad	 3
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00280	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00284	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00288	41 88 00	 mov	 BYTE PTR [r8], al
  0028b	49 ff c0	 inc	 r8

; 206  :                             } while (--op);

  0028e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00291	75 ed		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  00293	e9 8b 00 00 00	 jmp	 $LN104@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */

  00298	41 8b c6	 mov	 eax, r14d
  0029b	2b c1		 sub	 eax, ecx
  0029d	44 3b f1	 cmp	 r14d, ecx
  002a0	73 53		 jae	 SHORT $LN41@inflate_fa

; 211  :                         from += wsize + wnext - op;

  002a2	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]

; 212  :                         op -= wnext;

  002aa	41 2b ce	 sub	 ecx, r14d
  002ad	44 03 c8	 add	 r9d, eax
  002b0	4d 03 cf	 add	 r9, r15

; 213  :                         if (op < len) {         /* some from end of window */

  002b3	41 3b ca	 cmp	 ecx, r10d
  002b6	73 73		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  002b8	44 2b d1	 sub	 r10d, ecx
  002bb	4d 2b c8	 sub	 r9, r8
  002be	66 90		 npad	 2
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  002c0	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  002c5	41 88 00	 mov	 BYTE PTR [r8], al
  002c8	49 ff c0	 inc	 r8

; 217  :                             } while (--op);

  002cb	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002ce	75 f0		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;

  002d0	4d 8b cf	 mov	 r9, r15

; 219  :                             if (wnext < len) {  /* some from start of window */

  002d3	45 3b f2	 cmp	 r14d, r10d
  002d6	73 53		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002d8	41 8b ce	 mov	 ecx, r14d

; 221  :                                 len -= op;

  002db	45 2b d6	 sub	 r10d, r14d
  002de	66 90		 npad	 2
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  002e0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  002e4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  002e8	41 88 00	 mov	 BYTE PTR [r8], al
  002eb	49 ff c0	 inc	 r8

; 224  :                                 } while (--op);

  002ee	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002f1	75 ed		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  002f3	eb 2e		 jmp	 SHORT $LN104@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;

  002f5	44 8b c8	 mov	 r9d, eax
  002f8	4d 03 cf	 add	 r9, r15

; 231  :                         if (op < len) {         /* some from window */

  002fb	41 3b ca	 cmp	 ecx, r10d
  002fe	73 2b		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  00300	44 2b d1	 sub	 r10d, ecx
  00303	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  00310	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00314	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00318	41 88 00	 mov	 BYTE PTR [r8], al
  0031b	49 ff c0	 inc	 r8

; 235  :                             } while (--op);

  0031e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00321	75 ed		 jne	 SHORT $LL16@inflate_fa
$LN104@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */
; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  00323	8b c7		 mov	 eax, edi
  00325	4d 8b c8	 mov	 r9, r8
  00328	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:
  0032b	41 83 fa 02	 cmp	 r10d, 2
  0032f	76 49		 jbe	 SHORT $LN18@inflate_fa
  00331	41 8d 4a fd	 lea	 ecx, DWORD PTR [r10-3]
  00335	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0033a	f7 e1		 mul	 ecx
  0033c	d1 ea		 shr	 edx, 1
  0033e	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00341	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  00350	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  00354	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  00358	41 88 00	 mov	 BYTE PTR [r8], al
  0035b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00360	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  00364	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00369	49 83 c1 03	 add	 r9, 3
  0036d	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  00371	49 83 c0 03	 add	 r8, 3
  00375	48 2b cd	 sub	 rcx, rbp
  00378	75 d6		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  0037a	45 85 d2	 test	 r10d, r10d
  0037d	0f 84 7e 00 00
	00		 je	 $LN101@inflate_fa

; 246  :                         *out++ = *from++;

  00383	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 247  :                         if (len > 1)

  00387	48 8b 7c 24 10	 mov	 rdi, QWORD PTR end$1$[rsp]
  0038c	41 88 00	 mov	 BYTE PTR [r8], al
  0038f	49 ff c0	 inc	 r8
  00392	44 3b d5	 cmp	 r10d, ebp
  00395	76 6f		 jbe	 SHORT $LN105@inflate_fa

; 248  :                             *out++ = *from++;

  00397	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  0039c	41 88 00	 mov	 BYTE PTR [r8], al
  0039f	49 ff c0	 inc	 r8

; 249  :                     }
; 250  :                 }

  003a2	eb 62		 jmp	 SHORT $LN105@inflate_fa
$LN34@inflate_fa:

; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  003a4	8b c7		 mov	 eax, edi
  003a6	49 8b c8	 mov	 rcx, r8
  003a9	48 2b c8	 sub	 rcx, rax
  003ac	0f 1f 40 00	 npad	 4
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  003b0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  003b3	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003b7	41 88 00	 mov	 BYTE PTR [r8], al

; 257  :                         len -= 3;

  003ba	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  003be	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  003c2	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  003c6	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  003ca	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  003ce	49 83 c0 03	 add	 r8, 3

; 258  :                     } while (len > 2);

  003d2	41 83 fa 02	 cmp	 r10d, 2
  003d6	77 d8		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  003d8	45 85 d2	 test	 r10d, r10d
  003db	74 24		 je	 SHORT $LN101@inflate_fa

; 260  :                         *out++ = *from++;

  003dd	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 261  :                         if (len > 1)

  003e0	48 8b 7c 24 10	 mov	 rdi, QWORD PTR end$1$[rsp]
  003e5	4c 8b 4c 24 08	 mov	 r9, QWORD PTR dcode$1$[rsp]
  003ea	41 88 00	 mov	 BYTE PTR [r8], al
  003ed	49 ff c0	 inc	 r8
  003f0	44 3b d5	 cmp	 r10d, ebp
  003f3	76 16		 jbe	 SHORT $LN2@inflate_fa

; 262  :                             *out++ = *from++;

  003f5	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  003f9	41 88 00	 mov	 BYTE PTR [r8], al
  003fc	49 ff c0	 inc	 r8
  003ff	eb 0a		 jmp	 SHORT $LN2@inflate_fa
$LN101@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00401	48 8b 7c 24 10	 mov	 rdi, QWORD PTR end$1$[rsp]
$LN105@inflate_fa:
  00406	4c 8b 4c 24 08	 mov	 r9, QWORD PTR dcode$1$[rsp]
$LN2@inflate_fa:
  0040b	48 3b 74 24 18	 cmp	 rsi, QWORD PTR last$1$[rsp]
  00410	73 73		 jae	 SHORT $LN103@inflate_fa
  00412	4c 3b c7	 cmp	 r8, rdi
  00415	73 6e		 jae	 SHORT $LN103@inflate_fa
  00417	8b 14 24	 mov	 edx, DWORD PTR tv1161[rsp]
  0041a	e9 85 fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */

  0041f	f6 c2 20	 test	 dl, 32			; 00000020H
  00422	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0042a	74 0a		 je	 SHORT $LN54@inflate_fa

; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  0042c	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 283  :             break;

  00434	eb 5c		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  00436	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  0043d	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 287  :             state->mode = BAD;

  00441	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00449	eb 47		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  0044b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00453	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  0045a	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 272  :                 state->mode = BAD;

  0045e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 273  :                 break;

  00466	eb 2a		 jmp	 SHORT $LN3@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  00468	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00470	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  00477	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;

  0047b	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00483	eb 08		 jmp	 SHORT $LN56@inflate_fa
$LN103@inflate_fa:
  00485	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
$LN56@inflate_fa:
  0048d	48 8b 7c 24 10	 mov	 rdi, QWORD PTR end$1$[rsp]
$LN3@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  00492	41 8b cb	 mov	 ecx, r11d

; 294  :     in -= len;
; 295  :     bits -= len << 3;
; 296  :     hold &= (1U << bits) - 1;
; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;
; 300  :     strm->next_out = out;

  00495	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8
  00499	c1 e9 03	 shr	 ecx, 3

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
; 302  :     strm->avail_out = (unsigned)(out < end ?

  0049c	41 2b f8	 sub	 edi, r8d
  0049f	8b c1		 mov	 eax, ecx
  004a1	81 c7 01 01 00
	00		 add	 edi, 257		; 00000101H
  004a7	48 2b f0	 sub	 rsi, rax
  004aa	89 7a 18	 mov	 DWORD PTR [rdx+24], edi
  004ad	48 89 32	 mov	 QWORD PTR [rdx], rsi
  004b0	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  004b7	44 2b d8	 sub	 r11d, eax
  004ba	48 8b 44 24 18	 mov	 rax, QWORD PTR last$1$[rsp]
  004bf	2b c6		 sub	 eax, esi
  004c1	41 8b cb	 mov	 ecx, r11d
  004c4	d3 e5		 shl	 ebp, cl
  004c6	83 c0 05	 add	 eax, 5
  004c9	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004cc	ff cd		 dec	 ebp
  004ce	23 eb		 and	 ebp, ebx

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;
; 305  :     state->bits = bits;

  004d0	45 89 5d 4c	 mov	 DWORD PTR [r13+76], r11d
  004d4	41 89 6d 48	 mov	 DWORD PTR [r13+72], ebp

; 306  :     return;
; 307  : }

  004d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004dc	41 5f		 pop	 r15
  004de	41 5e		 pop	 r14
  004e0	41 5d		 pop	 r13
  004e2	41 5c		 pop	 r12
  004e4	5f		 pop	 rdi
  004e5	5e		 pop	 rsi
  004e6	5d		 pop	 rbp
  004e7	5b		 pop	 rbx
  004e8	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
