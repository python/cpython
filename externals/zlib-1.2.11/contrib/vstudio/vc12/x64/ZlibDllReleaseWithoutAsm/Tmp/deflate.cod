; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

include listing.inc

INCLUDELIB OLDNAMES

?my_version@?1??deflateInit2_@@9@9 DB '1.2.11', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+9
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
PUBLIC	deflateCopy
PUBLIC	deflateBound
PUBLIC	deflateTune
PUBLIC	deflateParams
PUBLIC	deflatePrime
PUBLIC	deflatePending
PUBLIC	deflateSetHeader
PUBLIC	deflateReset
PUBLIC	deflateResetKeep
PUBLIC	deflateGetDictionary
PUBLIC	deflateSetDictionary
PUBLIC	deflateInit2_
PUBLIC	deflateInit_
PUBLIC	deflateEnd
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+456
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+787
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+1297
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+1043
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+17
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflate_stored DD imagerel deflate_stored+17
	DD	imagerel deflate_stored+25
	DD	imagerel $chain$0$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflate_stored DD imagerel deflate_stored+25
	DD	imagerel deflate_stored+429
	DD	imagerel $chain$3$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflate_stored DD imagerel deflate_stored+429
	DD	imagerel deflate_stored+632
	DD	imagerel $chain$4$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate_stored DD imagerel deflate_stored+632
	DD	imagerel deflate_stored+1045
	DD	imagerel $chain$5$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+531
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+451
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+176
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+160
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN12
	DD	imagerel $LN12+41
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateCopy DD imagerel $LN12+41
	DD	imagerel $LN12+148
	DD	imagerel $chain$1$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateCopy DD imagerel $LN12+148
	DD	imagerel $LN12+500
	DD	imagerel $chain$4$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateCopy DD imagerel $LN12+500
	DD	imagerel $LN12+515
	DD	imagerel $chain$6$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateCopy DD imagerel $LN12+515
	DD	imagerel $LN12+526
	DD	imagerel $chain$7$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+105
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN30
	DD	imagerel $LN30+274
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN18
	DD	imagerel $LN18+359
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN16
	DD	imagerel $LN16+175
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePending DD imagerel $LN7
	DD	imagerel $LN7+69
	DD	imagerel $unwind$deflatePending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetHeader DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$deflateSetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateResetKeep DD imagerel $LN11
	DD	imagerel $LN11+173
	DD	imagerel $unwind$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateGetDictionary DD imagerel $LN8
	DD	imagerel $LN8+122
	DD	imagerel $unwind$deflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN29
	DD	imagerel $LN29+89
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateSetDictionary DD imagerel $LN29+89
	DD	imagerel $LN29+492
	DD	imagerel $chain$2$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateSetDictionary DD imagerel $LN29+492
	DD	imagerel $LN29+508
	DD	imagerel $chain$3$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateInit2_ DD imagerel $LN24+73
	DD	imagerel $LN24+262
	DD	imagerel $chain$1$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateInit2_ DD imagerel $LN24+262
	DD	imagerel $LN24+562
	DD	imagerel $chain$2$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateInit2_ DD imagerel $LN24+562
	DD	imagerel $LN24+585
	DD	imagerel $chain$3$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateInit2_ DD imagerel $LN24+585
	DD	imagerel $LN24+618
	DD	imagerel $chain$5$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateInit2_ DD imagerel $LN24+618
	DD	imagerel $LN24+625
	DD	imagerel $chain$6$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateInit2_ DD imagerel $LN24+625
	DD	imagerel $LN24+643
	DD	imagerel $chain$7$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slide_hash DD imagerel slide_hash
	DD	imagerel slide_hash+117
	DD	imagerel $unwind$slide_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN155
	DD	imagerel $LN155+42
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflate DD imagerel $LN155+42
	DD	imagerel $LN155+278
	DD	imagerel $chain$4$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate DD imagerel $LN155+278
	DD	imagerel $LN155+2291
	DD	imagerel $chain$6$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflate DD imagerel $LN155+2291
	DD	imagerel $LN155+2320
	DD	imagerel $chain$7$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$deflate DD imagerel $LN155+2320
	DD	imagerel $LN155+2333
	DD	imagerel $chain$8$deflate
;	COMDAT xdata
xdata	SEGMENT
$chain$8$deflate DD 021H
	DD	imagerel $LN155
	DD	imagerel $LN155+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflate DD 020021H
	DD	083400H
	DD	imagerel $LN155
	DD	imagerel $LN155+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN155
	DD	imagerel $LN155+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflate DD 0a4d21H
	DD	04f44dH
	DD	0be448H
	DD	0a6443H
	DD	09543eH
	DD	083405H
	DD	imagerel $LN155
	DD	imagerel $LN155+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 030801H
	DD	0c0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 042601H
	DD	067426H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slide_hash DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateInit2_ DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateInit2_ DD 040021H
	DD	0cd400H
	DD	0a5400H
	DD	imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateInit2_ DD 060021H
	DD	0cd400H
	DD	0b7400H
	DD	0a5400H
	DD	imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateInit2_ DD 021H
	DD	imagerel $LN24+73
	DD	imagerel $LN24+262
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateInit2_ DD 020521H
	DD	0b7405H
	DD	imagerel $LN24+73
	DD	imagerel $LN24+262
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateInit2_ DD 040a21H
	DD	0cd40aH
	DD	0a5405H
	DD	imagerel $LN24
	DD	imagerel $LN24+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 060d01H
	DD	0f009320dH
	DD	0c005e007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateSetDictionary DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+89
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateSetDictionary DD 060f21H
	DD	0cf40fH
	DD	0bd40aH
	DD	0ac405H
	DD	imagerel $LN29
	DD	imagerel $LN29+89
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 060b01H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateGetDictionary DD 042c01H
	DD	06342cH
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateResetKeep DD 063201H
	DD	076432H
	DD	063429H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePending DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateCopy DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateCopy DD 060021H
	DD	08e400H
	DD	077400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateCopy DD 060b21H
	DD	08e40bH
	DD	077400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateCopy DD 041421H
	DD	077414H
	DD	066405H
	DD	imagerel $LN12
	DD	imagerel $LN12+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 084701H
	DD	065447H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate_stored DD 020021H
	DD	0c7400H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+17
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflate_stored DD 020021H
	DD	0c7400H
	DD	imagerel deflate_stored+17
	DD	imagerel deflate_stored+25
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflate_stored DD 061d21H
	DD	0c741dH
	DD	0b5414H
	DD	04d405H
	DD	imagerel deflate_stored+17
	DD	imagerel deflate_stored+25
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflate_stored DD 020521H
	DD	0dc405H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+17
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate
_TEXT	SEGMENT
strm$ = 64
flush$ = 72
deflate	PROC						; COMDAT

; 766  : {

$LN155:
  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	44 8b e2	 mov	 r12d, edx
  0000b	48 8b f9	 mov	 rdi, rcx

; 767  :     int old_flush; /* value of flush param for previous deflate call */
; 768  :     deflate_state *s;
; 769  : 
; 770  :     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {

  0000e	e8 00 00 00 00	 call	 deflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 f5 08 00
	00		 jne	 $LN29@deflate
  0001b	41 83 fc 05	 cmp	 r12d, 5
  0001f	0f 87 eb 08 00
	00		 ja	 $LN29@deflate

; 772  :     }
; 773  :     s = strm->state;
; 774  : 
; 775  :     if (strm->next_out == Z_NULL ||
; 776  :         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||

  00025	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  0002a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0002f	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  00033	0f 84 ba 08 00
	00		 je	 $LN31@deflate
  00039	39 47 08	 cmp	 DWORD PTR [rdi+8], eax
  0003c	74 0a		 je	 SHORT $LN32@deflate
  0003e	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  00042	0f 84 ab 08 00
	00		 je	 $LN31@deflate
$LN32@deflate:
  00048	44 8b 4b 08	 mov	 r9d, DWORD PTR [rbx+8]
  0004c	41 81 f9 9a 02
	00 00		 cmp	 r9d, 666		; 0000029aH
  00053	75 0a		 jne	 SHORT $LN30@deflate
  00055	41 83 fc 04	 cmp	 r12d, 4
  00059	0f 85 94 08 00
	00		 jne	 $LN31@deflate
$LN30@deflate:

; 779  :     }
; 780  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005f	83 7f 18 00	 cmp	 DWORD PTR [rdi+24], 0
  00063	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00068	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0006d	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00072	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00077	74 6c		 je	 SHORT $LN145@deflate

; 781  : 
; 782  :     old_flush = s->last_flush;

  00079	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]

; 783  :     s->last_flush = flush;
; 784  : 
; 785  :     /* Flush as much pending output as possible */
; 786  :     if (s->pending != 0) {

  0007c	33 f6		 xor	 esi, esi
  0007e	44 89 63 40	 mov	 DWORD PTR [rbx+64], r12d
  00082	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00085	74 17		 je	 SHORT $LN34@deflate

; 787  :         flush_pending(strm);

  00087	48 8b cf	 mov	 rcx, rdi
  0008a	e8 00 00 00 00	 call	 flush_pending

; 788  :         if (strm->avail_out == 0) {

  0008f	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  00092	0f 84 4d 08 00
	00		 je	 $LN144@deflate

; 789  :             /* Since avail_out is 0, deflate will be called again with
; 790  :              * more output space, but possibly with both pending and
; 791  :              * avail_in equal to zero. There won't be anything to do,
; 792  :              * but this is not an error situation so make sure we
; 793  :              * return OK instead of BUF_ERROR at next call of deflate:
; 794  :              */
; 795  :             s->last_flush = -1;
; 796  :             return Z_OK;
; 797  :         }

  00098	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  0009c	eb 35		 jmp	 SHORT $LN37@deflate
$LN34@deflate:

; 798  : 
; 799  :     /* Make sure there is something to do and avoid duplicate consecutive
; 800  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 801  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 802  :      */
; 803  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&

  0009e	45 8b c1	 mov	 r8d, r9d
  000a1	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000a4	75 2d		 jne	 SHORT $LN37@deflate
  000a6	83 fa 04	 cmp	 edx, 4
  000a9	41 ba 09 00 00
	00		 mov	 r10d, 9
  000af	8b c6		 mov	 eax, esi
  000b1	8b ce		 mov	 ecx, esi
  000b3	41 0f 4f c2	 cmovg	 eax, r10d
  000b7	03 d2		 add	 edx, edx
  000b9	2b d0		 sub	 edx, eax
  000bb	43 8d 04 24	 lea	 eax, DWORD PTR [r12+r12]
  000bf	41 83 fc 04	 cmp	 r12d, 4
  000c3	41 0f 4f ca	 cmovg	 ecx, r10d
  000c7	2b c1		 sub	 eax, ecx
  000c9	3b c2		 cmp	 eax, edx
  000cb	7f 06		 jg	 SHORT $LN37@deflate
  000cd	41 83 fc 04	 cmp	 r12d, 4
  000d1	75 12		 jne	 SHORT $LN145@deflate
$LN37@deflate:

; 804  :                flush != Z_FINISH) {
; 805  :         ERR_RETURN(strm, Z_BUF_ERROR);
; 806  :     }
; 807  : 
; 808  :     /* User must not provide more input after the first FINISH: */
; 809  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  000d3	41 81 f8 9a 02
	00 00		 cmp	 r8d, 666		; 0000029aH
  000da	75 3a		 jne	 SHORT $LN38@deflate
  000dc	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000df	0f 84 ef 00 00
	00		 je	 $LN124@deflate
$LN145@deflate:

; 810  :         ERR_RETURN(strm, Z_BUF_ERROR);

  000e5	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  000ec	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  000f0	b8 fb ff ff ff	 mov	 eax, -5
$LN152@deflate:
  000f5	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000fa	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ff	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00104	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00109	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1073 : }

  0010e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00112	41 5c		 pop	 r12
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
$LN38@deflate:

; 811  :     }
; 812  : 
; 813  :     /* Write the header */
; 814  :     if (s->status == INIT_STATE) {

  00116	41 83 f8 2a	 cmp	 r8d, 42			; 0000002aH
  0011a	0f 85 b4 00 00
	00		 jne	 $LN124@deflate

; 815  :         /* zlib header */
; 816  :         uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00120	8b 53 48	 mov	 edx, DWORD PTR [rbx+72]
  00123	c1 e2 0c	 shl	 edx, 12
  00126	81 c2 00 88 ff
	ff		 add	 edx, -30720		; ffff8800H

; 817  :         uInt level_flags;
; 818  : 
; 819  :         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  0012c	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00133	7d 2f		 jge	 SHORT $LN135@deflate
  00135	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  0013b	83 f8 02	 cmp	 eax, 2
  0013e	7c 24		 jl	 SHORT $LN135@deflate

; 821  :         else if (s->level < 6)

  00140	83 f8 06	 cmp	 eax, 6
  00143	7d 09		 jge	 SHORT $LN43@deflate

; 822  :             level_flags = 1;

  00145	41 8d 40 16	 lea	 eax, QWORD PTR [r8+22]
  00149	8d 48 20	 lea	 ecx, QWORD PTR [rax+32]
  0014c	eb 1d		 jmp	 SHORT $LN46@deflate
$LN43@deflate:

; 823  :         else if (s->level == 6)

  0014e	75 0a		 jne	 SHORT $LN45@deflate

; 824  :             level_flags = 2;

  00150	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00155	8d 48 20	 lea	 ecx, QWORD PTR [rax+32]
  00158	eb 11		 jmp	 SHORT $LN46@deflate
$LN45@deflate:

; 825  :         else
; 826  :             level_flags = 3;

  0015a	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  0015f	8d 48 20	 lea	 ecx, QWORD PTR [rax+32]
  00162	eb 07		 jmp	 SHORT $LN46@deflate
$LN135@deflate:

; 820  :             level_flags = 0;

  00164	8b c6		 mov	 eax, esi
  00166	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
$LN46@deflate:

; 827  :         header |= (level_flags << 6);
; 828  :         if (s->strstart != 0) header |= PRESET_DICT;
; 829  :         header += 31 - (header % 31);

  0016b	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  00171	0f 44 c8	 cmove	 ecx, eax
  00174	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00179	0b ca		 or	 ecx, edx
  0017b	f7 e1		 mul	 ecx
  0017d	2b ca		 sub	 ecx, edx
  0017f	d1 e9		 shr	 ecx, 1
  00181	03 ca		 add	 ecx, edx
  00183	c1 e9 04	 shr	 ecx, 4
  00186	ff c1		 inc	 ecx
  00188	6b d1 1f	 imul	 edx, ecx, 31

; 830  : 
; 831  :         putShortMSB(s, header);

  0018b	48 8b cb	 mov	 rcx, rbx
  0018e	e8 00 00 00 00	 call	 putShortMSB

; 832  : 
; 833  :         /* Save the adler32 of the preset dictionary: */
; 834  :         if (s->strstart != 0) {

  00193	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  00199	74 12		 je	 SHORT $LN48@deflate

; 835  :             putShortMSB(s, (uInt)(strm->adler >> 16));

  0019b	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  0019f	e8 00 00 00 00	 call	 putShortMSB

; 836  :             putShortMSB(s, (uInt)(strm->adler & 0xffff));

  001a4	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  001a8	e8 00 00 00 00	 call	 putShortMSB
$LN48@deflate:

; 837  :         }
; 838  :         strm->adler = adler32(0L, Z_NULL, 0);

  001ad	45 33 c0	 xor	 r8d, r8d
  001b0	33 d2		 xor	 edx, edx
  001b2	33 c9		 xor	 ecx, ecx
  001b4	e8 00 00 00 00	 call	 adler32
  001b9	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 839  :         s->status = BUSY_STATE;
; 840  : 
; 841  :         /* Compression must start with an empty pending buffer */
; 842  :         flush_pending(strm);

  001bc	48 8b cf	 mov	 rcx, rdi
  001bf	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  001c6	e8 00 00 00 00	 call	 flush_pending

; 843  :         if (s->pending != 0) {

  001cb	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  001ce	0f 85 11 07 00
	00		 jne	 $LN144@deflate
$LN124@deflate:

; 844  :             s->last_flush = -1;
; 845  :             return Z_OK;
; 846  :         }
; 847  :     }
; 848  : #ifdef GZIP
; 849  :     if (s->status == GZIP_STATE) {

  001d4	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  001d7	83 f8 39	 cmp	 eax, 57			; 00000039H
  001da	0f 85 e8 00 00
	00		 jne	 $LN52@deflate

; 850  :         /* gzip header */
; 851  :         strm->adler = crc32(0L, Z_NULL, 0);

  001e0	45 33 c0	 xor	 r8d, r8d
  001e3	33 d2		 xor	 edx, edx
  001e5	33 c9		 xor	 ecx, ecx
  001e7	e8 00 00 00 00	 call	 crc32
  001ec	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 852  :         put_byte(s, 31);

  001ef	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  001f2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001f6	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  001fa	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001fd	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 853  :         put_byte(s, 139);

  00200	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00204	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  00208	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0020b	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 854  :         put_byte(s, 8);

  0020e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00212	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  00216	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 855  :         if (s->gzhead == Z_NULL) {

  00219	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  0021d	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  00221	4d 85 c0	 test	 r8, r8
  00224	0f 85 98 01 00
	00		 jne	 $LN51@deflate

; 856  :             put_byte(s, 0);

  0022a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0022e	41 88 34 01	 mov	 BYTE PTR [r9+rax], sil
  00232	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00235	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 857  :             put_byte(s, 0);

  00238	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0023c	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00240	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00243	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 858  :             put_byte(s, 0);

  00246	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0024a	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  0024e	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00251	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 859  :             put_byte(s, 0);

  00254	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00258	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  0025c	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0025f	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 860  :             put_byte(s, 0);

  00262	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00266	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  0026a	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 861  :             put_byte(s, s->level == 9 ? 2 :

  0026d	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  00273	ff c1		 inc	 ecx
  00275	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx
  00278	83 f8 09	 cmp	 eax, 9
  0027b	75 04		 jne	 SHORT $LN100@deflate
  0027d	b2 02		 mov	 dl, 2
  0027f	eb 14		 jmp	 SHORT $LN99@deflate
$LN100@deflate:
  00281	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00288	7d 09		 jge	 SHORT $LN98@deflate
  0028a	83 f8 02	 cmp	 eax, 2
  0028d	7c 04		 jl	 SHORT $LN98@deflate
  0028f	32 d2		 xor	 dl, dl
  00291	eb 02		 jmp	 SHORT $LN99@deflate
$LN98@deflate:
  00293	b2 04		 mov	 dl, 4
$LN99@deflate:
  00295	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00299	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0029c	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0029f	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 862  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 863  :                       4 : 0));
; 864  :             put_byte(s, OS_CODE);

  002a2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002a6	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10

; 865  :             s->status = BUSY_STATE;
; 866  : 
; 867  :             /* Compression must start with an empty pending buffer */
; 868  :             flush_pending(strm);

  002aa	48 8b cf	 mov	 rcx, rdi
  002ad	ff 43 28	 inc	 DWORD PTR [rbx+40]
  002b0	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  002b7	e8 00 00 00 00	 call	 flush_pending

; 869  :             if (s->pending != 0) {

  002bc	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  002bf	0f 85 20 06 00
	00		 jne	 $LN144@deflate

; 870  :                 s->last_flush = -1;
; 871  :                 return Z_OK;
; 872  :             }
; 873  :         }

  002c5	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
$LN52@deflate:

; 898  :         }
; 899  :     }
; 900  :     if (s->status == EXTRA_STATE) {

  002c8	83 f8 45	 cmp	 eax, 69			; 00000045H
  002cb	0f 85 35 02 00
	00		 jne	 $LN138@deflate
$LN143@deflate:

; 901  :         if (s->gzhead->extra != Z_NULL) {

  002d1	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  002d5	48 39 71 10	 cmp	 QWORD PTR [rcx+16], rsi
  002d9	0f 84 d7 00 00
	00		 je	 $LN136@deflate

; 902  :             ulg beg = s->pending;   /* start of bytes to update crc */
; 903  :             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;

  002df	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  002e2	44 0f b7 79 18	 movzx	 r15d, WORD PTR [rcx+24]
  002e7	44 8b 73 28	 mov	 r14d, DWORD PTR [rbx+40]
  002eb	44 2b fa	 sub	 r15d, edx

; 904  :             while (s->pending + left > s->pending_buf_size) {

  002ee	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]
  002f1	43 8d 04 3e	 lea	 eax, DWORD PTR [r14+r15]
  002f5	3b c5		 cmp	 eax, ebp
  002f7	76 76		 jbe	 SHORT $LN3@deflate
  002f9	41 8b ce	 mov	 ecx, r14d
  002fc	0f 1f 40 00	 npad	 4
$LL2@deflate:

; 905  :                 uInt copy = s->pending_buf_size - s->pending;
; 906  :                 zmemcpy(s->pending_buf + s->pending,

  00300	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00304	2b e9		 sub	 ebp, ecx
  00306	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  00309	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  0030d	44 8b c5	 mov	 r8d, ebp
  00310	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00314	e8 00 00 00 00	 call	 memcpy

; 907  :                         s->gzhead->extra + s->gzindex, copy);
; 908  :                 s->pending = s->pending_buf_size;
; 909  :                 HCRC_UPDATE(beg);

  00319	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0031d	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  00321	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  00325	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00328	74 1a		 je	 SHORT $LN4@deflate
  0032a	45 3b c6	 cmp	 r8d, r14d
  0032d	76 15		 jbe	 SHORT $LN4@deflate
  0032f	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00332	45 2b c6	 sub	 r8d, r14d
  00335	41 8b d6	 mov	 edx, r14d
  00338	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0033c	e8 00 00 00 00	 call	 crc32
  00341	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN4@deflate:

; 910  :                 s->gzindex += copy;

  00344	01 6b 38	 add	 DWORD PTR [rbx+56], ebp

; 911  :                 flush_pending(strm);

  00347	48 8b cf	 mov	 rcx, rdi
  0034a	e8 00 00 00 00	 call	 flush_pending

; 912  :                 if (s->pending != 0) {

  0034f	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00352	0f 85 8d 05 00
	00		 jne	 $LN144@deflate

; 913  :                     s->last_flush = -1;
; 914  :                     return Z_OK;
; 915  :                 }
; 916  :                 beg = 0;
; 917  :                 left -= copy;

  00358	44 2b fd	 sub	 r15d, ebp
  0035b	8b ce		 mov	 ecx, esi
  0035d	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]
  00360	44 8b f6	 mov	 r14d, esi
  00363	44 3b fd	 cmp	 r15d, ebp
  00366	77 98		 ja	 SHORT $LL2@deflate

; 965  :             } while (val != 0);

  00368	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0036c	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
$LN3@deflate:

; 918  :             }
; 919  :             zmemcpy(s->pending_buf + s->pending,

  0036f	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
  00373	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00377	41 8b ee	 mov	 ebp, r14d
  0037a	48 03 cd	 add	 rcx, rbp
  0037d	45 8b c7	 mov	 r8d, r15d
  00380	e8 00 00 00 00	 call	 memcpy

; 920  :                     s->gzhead->extra + s->gzindex, left);
; 921  :             s->pending += left;

  00385	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]

; 922  :             HCRC_UPDATE(beg);

  00389	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0038d	45 03 c7	 add	 r8d, r15d
  00390	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  00394	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00397	74 1a		 je	 SHORT $LN7@deflate
  00399	45 3b c6	 cmp	 r8d, r14d
  0039c	76 15		 jbe	 SHORT $LN7@deflate
  0039e	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  003a2	45 2b c6	 sub	 r8d, r14d
  003a5	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  003a8	48 03 d5	 add	 rdx, rbp
  003ab	e8 00 00 00 00	 call	 crc32
  003b0	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN7@deflate:

; 923  :             s->gzindex = 0;

  003b3	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN136@deflate:

; 924  :         }
; 925  :         s->status = NAME_STATE;

  003b6	c7 43 08 49 00
	00 00		 mov	 DWORD PTR [rbx+8], 73	; 00000049H
  003bd	e9 4d 01 00 00	 jmp	 $LN142@deflate
$LN51@deflate:

; 874  :         else {
; 875  :             put_byte(s, (s->gzhead->text ? 1 : 0) +

  003c2	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  003c6	48 f7 d8	 neg	 rax
  003c9	41 8b 40 3c	 mov	 eax, DWORD PTR [r8+60]
  003cd	1a d2		 sbb	 dl, dl
  003cf	80 e2 10	 and	 dl, 16
  003d2	f7 d8		 neg	 eax
  003d4	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  003d8	1a c9		 sbb	 cl, cl
  003da	80 e1 02	 and	 cl, 2
  003dd	02 d1		 add	 dl, cl
  003df	48 f7 d8	 neg	 rax
  003e2	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  003e6	1a c9		 sbb	 cl, cl
  003e8	80 e1 08	 and	 cl, 8
  003eb	02 d1		 add	 dl, cl
  003ed	48 f7 d8	 neg	 rax
  003f0	1a c9		 sbb	 cl, cl
  003f2	80 e1 04	 and	 cl, 4
  003f5	02 d1		 add	 dl, cl
  003f7	41 39 30	 cmp	 DWORD PTR [r8], esi
  003fa	0f 95 c0	 setne	 al
  003fd	02 d0		 add	 dl, al
  003ff	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00403	41 88 14 01	 mov	 BYTE PTR [r9+rax], dl
  00407	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0040a	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 876  :                      (s->gzhead->hcrc ? 2 : 0) +
; 877  :                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 878  :                      (s->gzhead->name == Z_NULL ? 0 : 8) +
; 879  :                      (s->gzhead->comment == Z_NULL ? 0 : 16)
; 880  :                      );
; 881  :             put_byte(s, (Byte)(s->gzhead->time & 0xff));

  0040d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00411	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00415	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00419	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0041c	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0041f	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 882  :             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00422	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00426	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0042a	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0042e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00431	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00434	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 883  :             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  00437	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0043b	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0043f	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00443	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00446	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 884  :             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  00449	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0044d	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00450	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00454	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00458	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0045b	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 885  :             put_byte(s, s->level == 9 ? 2 :

  0045e	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  00464	ff c1		 inc	 ecx
  00466	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx
  00469	83 f8 09	 cmp	 eax, 9
  0046c	75 04		 jne	 SHORT $LN104@deflate
  0046e	b2 02		 mov	 dl, 2
  00470	eb 14		 jmp	 SHORT $LN103@deflate
$LN104@deflate:
  00472	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00479	7d 09		 jge	 SHORT $LN102@deflate
  0047b	83 f8 02	 cmp	 eax, 2
  0047e	7c 04		 jl	 SHORT $LN102@deflate
  00480	32 d2		 xor	 dl, dl
  00482	eb 02		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  00484	b2 04		 mov	 dl, 4
$LN103@deflate:
  00486	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0048a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0048d	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 886  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 887  :                       4 : 0));
; 888  :             put_byte(s, s->gzhead->os & 0xff);

  00490	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00494	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00497	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0049b	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  0049f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004a2	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 889  :             if (s->gzhead->extra != Z_NULL) {

  004a5	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004a9	ff c1		 inc	 ecx
  004ab	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx
  004ae	48 39 70 10	 cmp	 QWORD PTR [rax+16], rsi
  004b2	74 2c		 je	 SHORT $LN54@deflate

; 890  :                 put_byte(s, s->gzhead->extra_len & 0xff);

  004b4	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  004b8	8b d1		 mov	 edx, ecx
  004ba	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  004be	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004c1	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 891  :                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  004c4	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004c8	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  004cb	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  004cf	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  004d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004d6	ff 43 28	 inc	 DWORD PTR [rbx+40]
  004d9	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  004dc	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
$LN54@deflate:

; 892  :             }
; 893  :             if (s->gzhead->hcrc)

  004e0	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  004e3	74 12		 je	 SHORT $LN55@deflate

; 894  :                 strm->adler = crc32(strm->adler, s->pending_buf,

  004e5	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  004e9	44 8b c1	 mov	 r8d, ecx
  004ec	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  004ef	e8 00 00 00 00	 call	 crc32
  004f4	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN55@deflate:

; 895  :                                     s->pending);
; 896  :             s->gzindex = 0;

  004f7	89 73 38	 mov	 DWORD PTR [rbx+56], esi

; 897  :             s->status = EXTRA_STATE;

  004fa	c7 43 08 45 00
	00 00		 mov	 DWORD PTR [rbx+8], 69	; 00000045H

; 969  :     }
; 970  :     if (s->status == HCRC_STATE) {

  00501	e9 cb fd ff ff	 jmp	 $LN143@deflate
$LN138@deflate:

; 926  :     }
; 927  :     if (s->status == NAME_STATE) {

  00506	83 f8 49	 cmp	 eax, 73			; 00000049H
  00509	0f 85 b2 00 00
	00		 jne	 $LN139@deflate
$LN142@deflate:

; 928  :         if (s->gzhead->name != Z_NULL) {

  0050f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00513	48 39 70 20	 cmp	 QWORD PTR [rax+32], rsi
  00517	0f 84 9b 00 00
	00		 je	 $LN137@deflate

; 929  :             ulg beg = s->pending;   /* start of bytes to update crc */

  0051d	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  00521	45 8b c1	 mov	 r8d, r9d
$LL12@deflate:

; 930  :             int val;
; 931  :             do {
; 932  :                 if (s->pending == s->pending_buf_size) {

  00524	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00528	75 3a		 jne	 SHORT $LN63@deflate

; 933  :                     HCRC_UPDATE(beg);

  0052a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0052e	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00531	74 1a		 je	 SHORT $LN13@deflate
  00533	45 3b c1	 cmp	 r8d, r9d
  00536	76 15		 jbe	 SHORT $LN13@deflate
  00538	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0053b	45 2b c1	 sub	 r8d, r9d
  0053e	41 8b d1	 mov	 edx, r9d
  00541	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00545	e8 00 00 00 00	 call	 crc32
  0054a	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN13@deflate:

; 934  :                     flush_pending(strm);

  0054d	48 8b cf	 mov	 rcx, rdi
  00550	e8 00 00 00 00	 call	 flush_pending

; 935  :                     if (s->pending != 0) {

  00555	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00558	0f 85 87 03 00
	00		 jne	 $LN144@deflate

; 936  :                         s->last_flush = -1;
; 937  :                         return Z_OK;
; 938  :                     }
; 939  :                     beg = 0;

  0055e	44 8b ce	 mov	 r9d, esi
  00561	44 8b c6	 mov	 r8d, esi
$LN63@deflate:

; 940  :                 }
; 941  :                 val = s->gzhead->name[s->gzindex++];

  00564	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00567	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0056b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0056f	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00573	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 942  :                 put_byte(s, val);

  00576	41 8b c8	 mov	 ecx, r8d
  00579	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  0057c	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00580	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00583	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00587	41 ff c0	 inc	 r8d
  0058a	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d

; 943  :             } while (val != 0);

  0058e	84 d2		 test	 dl, dl
  00590	75 92		 jne	 SHORT $LL12@deflate

; 944  :             HCRC_UPDATE(beg);

  00592	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00596	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00599	74 1a		 je	 SHORT $LN16@deflate
  0059b	45 3b c1	 cmp	 r8d, r9d
  0059e	76 15		 jbe	 SHORT $LN16@deflate
  005a0	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  005a3	45 2b c1	 sub	 r8d, r9d
  005a6	41 8b d1	 mov	 edx, r9d
  005a9	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  005ad	e8 00 00 00 00	 call	 crc32
  005b2	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN16@deflate:

; 945  :             s->gzindex = 0;

  005b5	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN137@deflate:

; 946  :         }
; 947  :         s->status = COMMENT_STATE;

  005b8	c7 43 08 5b 00
	00 00		 mov	 DWORD PTR [rbx+8], 91	; 0000005bH
  005bf	eb 09		 jmp	 SHORT $LN141@deflate
$LN139@deflate:

; 948  :     }
; 949  :     if (s->status == COMMENT_STATE) {

  005c1	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  005c4	0f 85 b0 00 00
	00		 jne	 $LN67@deflate
$LN141@deflate:

; 950  :         if (s->gzhead->comment != Z_NULL) {

  005ca	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005ce	48 39 70 30	 cmp	 QWORD PTR [rax+48], rsi
  005d2	0f 84 99 00 00
	00		 je	 $LN26@deflate

; 951  :             ulg beg = s->pending;   /* start of bytes to update crc */

  005d8	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  005dc	45 8b c1	 mov	 r8d, r9d
  005df	90		 npad	 1
$LL21@deflate:

; 952  :             int val;
; 953  :             do {
; 954  :                 if (s->pending == s->pending_buf_size) {

  005e0	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  005e4	75 3a		 jne	 SHORT $LN69@deflate

; 955  :                     HCRC_UPDATE(beg);

  005e6	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005ea	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  005ed	74 1a		 je	 SHORT $LN22@deflate
  005ef	45 3b c1	 cmp	 r8d, r9d
  005f2	76 15		 jbe	 SHORT $LN22@deflate
  005f4	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  005f7	45 2b c1	 sub	 r8d, r9d
  005fa	41 8b d1	 mov	 edx, r9d
  005fd	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00601	e8 00 00 00 00	 call	 crc32
  00606	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN22@deflate:

; 956  :                     flush_pending(strm);

  00609	48 8b cf	 mov	 rcx, rdi
  0060c	e8 00 00 00 00	 call	 flush_pending

; 957  :                     if (s->pending != 0) {

  00611	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00614	0f 85 cb 02 00
	00		 jne	 $LN144@deflate

; 958  :                         s->last_flush = -1;
; 959  :                         return Z_OK;
; 960  :                     }
; 961  :                     beg = 0;

  0061a	44 8b ce	 mov	 r9d, esi
  0061d	44 8b c6	 mov	 r8d, esi
$LN69@deflate:

; 962  :                 }
; 963  :                 val = s->gzhead->comment[s->gzindex++];

  00620	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00623	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00627	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0062b	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0062f	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 964  :                 put_byte(s, val);

  00632	41 8b c8	 mov	 ecx, r8d
  00635	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  00638	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0063c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0063f	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00643	41 ff c0	 inc	 r8d
  00646	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d

; 965  :             } while (val != 0);

  0064a	84 d2		 test	 dl, dl
  0064c	75 92		 jne	 SHORT $LL21@deflate

; 966  :             HCRC_UPDATE(beg);

  0064e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00652	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00655	74 1a		 je	 SHORT $LN26@deflate
  00657	45 3b c1	 cmp	 r8d, r9d
  0065a	76 15		 jbe	 SHORT $LN26@deflate
  0065c	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0065f	45 2b c1	 sub	 r8d, r9d
  00662	41 8b d1	 mov	 edx, r9d
  00665	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00669	e8 00 00 00 00	 call	 crc32
  0066e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN26@deflate:

; 967  :         }
; 968  :         s->status = HCRC_STATE;

  00671	c7 43 08 67 00
	00 00		 mov	 DWORD PTR [rbx+8], 103	; 00000067H

; 969  :     }
; 970  :     if (s->status == HCRC_STATE) {

  00678	eb 05		 jmp	 SHORT $LN134@deflate
$LN67@deflate:
  0067a	83 f8 67	 cmp	 eax, 103		; 00000067H
  0067d	75 6f		 jne	 SHORT $LN130@deflate
$LN134@deflate:

; 971  :         if (s->gzhead->hcrc) {

  0067f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00683	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00686	74 4e		 je	 SHORT $LN74@deflate

; 972  :             if (s->pending + 2 > s->pending_buf_size) {

  00688	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0068b	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  0068e	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  00691	76 13		 jbe	 SHORT $LN129@deflate

; 973  :                 flush_pending(strm);

  00693	48 8b cf	 mov	 rcx, rdi
  00696	e8 00 00 00 00	 call	 flush_pending

; 974  :                 if (s->pending != 0) {

  0069b	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0069e	85 c9		 test	 ecx, ecx
  006a0	0f 85 3f 02 00
	00		 jne	 $LN144@deflate
$LN129@deflate:

; 975  :                     s->last_flush = -1;
; 976  :                     return Z_OK;
; 977  :                 }
; 978  :             }
; 979  :             put_byte(s, (Byte)(strm->adler & 0xff));

  006a6	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]

; 980  :             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
; 981  :             strm->adler = crc32(0L, Z_NULL, 0);

  006aa	45 33 c0	 xor	 r8d, r8d
  006ad	8b d1		 mov	 edx, ecx
  006af	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  006b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006b6	ff 43 28	 inc	 DWORD PTR [rbx+40]
  006b9	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  006bc	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  006c0	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  006c4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006c7	33 d2		 xor	 edx, edx
  006c9	ff 43 28	 inc	 DWORD PTR [rbx+40]
  006cc	33 c9		 xor	 ecx, ecx
  006ce	e8 00 00 00 00	 call	 crc32
  006d3	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN74@deflate:

; 982  :         }
; 983  :         s->status = BUSY_STATE;
; 984  : 
; 985  :         /* Compression must start with an empty pending buffer */
; 986  :         flush_pending(strm);

  006d6	48 8b cf	 mov	 rcx, rdi
  006d9	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  006e0	e8 00 00 00 00	 call	 flush_pending

; 987  :         if (s->pending != 0) {

  006e5	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  006e8	0f 85 f7 01 00
	00		 jne	 $LN144@deflate
$LN130@deflate:

; 988  :             s->last_flush = -1;
; 989  :             return Z_OK;
; 990  :         }
; 991  :     }
; 992  : #endif
; 993  : 
; 994  :     /* Start a new block or continue the current one.
; 995  :      */
; 996  :     if (strm->avail_in != 0 || s->lookahead != 0 ||

  006ee	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  006f1	75 1e		 jne	 SHORT $LN79@deflate
  006f3	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  006f9	75 16		 jne	 SHORT $LN79@deflate
  006fb	45 85 e4	 test	 r12d, r12d
  006fe	0f 84 e8 01 00
	00		 je	 $LN84@deflate
  00704	81 7b 08 9a 02
	00 00		 cmp	 DWORD PTR [rbx+8], 666	; 0000029aH
  0070b	0f 84 ea 00 00
	00		 je	 $LN91@deflate
$LN79@deflate:

; 997  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 998  :         block_state bstate;
; 999  : 
; 1000 :         bstate = s->level == 0 ? deflate_stored(s, flush) :

  00711	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00718	41 8b d4	 mov	 edx, r12d
  0071b	85 c9		 test	 ecx, ecx
  0071d	75 0a		 jne	 SHORT $LN110@deflate
  0071f	48 8b cb	 mov	 rcx, rbx
  00722	e8 00 00 00 00	 call	 deflate_stored
  00727	eb 38		 jmp	 SHORT $LN153@deflate
$LN110@deflate:
  00729	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [rbx+176]
  0072f	83 f8 02	 cmp	 eax, 2
  00732	75 0a		 jne	 SHORT $LN108@deflate
  00734	48 8b cb	 mov	 rcx, rbx
  00737	e8 00 00 00 00	 call	 deflate_huff
  0073c	eb 23		 jmp	 SHORT $LN153@deflate
$LN108@deflate:
  0073e	83 f8 03	 cmp	 eax, 3
  00741	75 0a		 jne	 SHORT $LN106@deflate
  00743	48 8b cb	 mov	 rcx, rbx
  00746	e8 00 00 00 00	 call	 deflate_rle
  0074b	eb 14		 jmp	 SHORT $LN153@deflate
$LN106@deflate:
  0074d	48 8b c1	 mov	 rax, rcx
  00750	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_table+8
  00757	48 03 c0	 add	 rax, rax
  0075a	48 8b cb	 mov	 rcx, rbx
  0075d	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
$LN153@deflate:

; 1001 :                  s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 1002 :                  s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 1003 :                  (*(configuration_table[s->level].func))(s, flush);
; 1004 : 
; 1005 :         if (bstate == finish_started || bstate == finish_done) {

  00761	8b c8		 mov	 ecx, eax
  00763	8d 40 fe	 lea	 eax, DWORD PTR [rax-2]
  00766	83 f8 01	 cmp	 eax, 1
  00769	77 07		 ja	 SHORT $LN80@deflate

; 1006 :             s->status = FINISH_STATE;

  0076b	c7 43 08 9a 02
	00 00		 mov	 DWORD PTR [rbx+8], 666	; 0000029aH
$LN80@deflate:

; 1007 :         }
; 1008 :         if (bstate == need_more || bstate == finish_started) {

  00772	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  00778	0f 84 62 01 00
	00		 je	 $LN83@deflate

; 1013 :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 1014 :              * of deflate should use the same flush parameter to make sure
; 1015 :              * that the flush is complete. So we don't have to output an
; 1016 :              * empty block here, this will be done at next call. This also
; 1017 :              * ensures that for a very small output buffer, we emit at most
; 1018 :              * one empty block.
; 1019 :              */
; 1020 :         }
; 1021 :         if (bstate == block_done) {

  0077e	83 f9 01	 cmp	 ecx, 1
  00781	75 78		 jne	 SHORT $LN91@deflate

; 1022 :             if (flush == Z_PARTIAL_FLUSH) {

  00783	44 3b e1	 cmp	 r12d, ecx
  00786	75 0a		 jne	 SHORT $LN86@deflate

; 1023 :                 _tr_align(s);

  00788	48 8b cb	 mov	 rcx, rbx
  0078b	e8 00 00 00 00	 call	 _tr_align
  00790	eb 58		 jmp	 SHORT $LN90@deflate
$LN86@deflate:

; 1024 :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  00792	41 83 fc 05	 cmp	 r12d, 5
  00796	74 52		 je	 SHORT $LN90@deflate

; 1025 :                 _tr_stored_block(s, (char*)0, 0L, 0);

  00798	45 33 c9	 xor	 r9d, r9d
  0079b	45 33 c0	 xor	 r8d, r8d
  0079e	33 d2		 xor	 edx, edx
  007a0	48 8b cb	 mov	 rcx, rbx
  007a3	e8 00 00 00 00	 call	 _tr_stored_block

; 1026 :                 /* For a full flush, this empty block will be recognized
; 1027 :                  * as a special marker by inflate_sync().
; 1028 :                  */
; 1029 :                 if (flush == Z_FULL_FLUSH) {

  007a8	41 83 fc 03	 cmp	 r12d, 3
  007ac	75 3c		 jne	 SHORT $LN90@deflate

; 1030 :                     CLEAR_HASH(s);             /* forget history */

  007ae	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  007b1	33 d2		 xor	 edx, edx
  007b3	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  007b7	ff c9		 dec	 ecx
  007b9	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
  007bd	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  007c1	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  007c5	41 ff c8	 dec	 r8d
  007c8	4d 03 c0	 add	 r8, r8
  007cb	e8 00 00 00 00	 call	 memset

; 1031 :                     if (s->lookahead == 0) {

  007d0	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  007d6	75 12		 jne	 SHORT $LN90@deflate

; 1032 :                         s->strstart = 0;

  007d8	89 b3 94 00 00
	00		 mov	 DWORD PTR [rbx+148], esi

; 1033 :                         s->block_start = 0L;

  007de	89 b3 84 00 00
	00		 mov	 DWORD PTR [rbx+132], esi

; 1034 :                         s->insert = 0;

  007e4	89 b3 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], esi
$LN90@deflate:

; 1035 :                     }
; 1036 :                 }
; 1037 :             }
; 1038 :             flush_pending(strm);

  007ea	48 8b cf	 mov	 rcx, rdi
  007ed	e8 00 00 00 00	 call	 flush_pending

; 1039 :             if (strm->avail_out == 0) {

  007f2	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  007f5	0f 84 ea 00 00
	00		 je	 $LN144@deflate
$LN91@deflate:

; 1040 :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 1041 :               return Z_OK;
; 1042 :             }
; 1043 :         }
; 1044 :     }
; 1045 : 
; 1046 :     if (flush != Z_FINISH) return Z_OK;

  007fb	41 83 fc 04	 cmp	 r12d, 4
  007ff	0f 85 e7 00 00
	00		 jne	 $LN84@deflate

; 1047 :     if (s->wrap <= 0) return Z_STREAM_END;

  00805	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00808	85 c0		 test	 eax, eax
  0080a	7f 0a		 jg	 SHORT $LN93@deflate
  0080c	41 8d 44 24 fd	 lea	 eax, QWORD PTR [r12-3]
  00811	e9 df f8 ff ff	 jmp	 $LN152@deflate
$LN93@deflate:

; 1048 : 
; 1049 :     /* Write the trailer */
; 1050 : #ifdef GZIP
; 1051 :     if (s->wrap == 2) {

  00816	83 f8 02	 cmp	 eax, 2
  00819	0f 85 8a 00 00
	00		 jne	 $LN94@deflate

; 1052 :         put_byte(s, (Byte)(strm->adler & 0xff));

  0081f	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00822	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  00826	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0082a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0082d	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00830	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1053 :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00833	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  00837	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0083b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0083e	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00841	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1054 :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  00844	0f b6 47 4e	 movzx	 eax, BYTE PTR [rdi+78]
  00848	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0084c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0084f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00852	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1055 :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  00855	0f b6 47 4f	 movzx	 eax, BYTE PTR [rdi+79]
  00859	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0085d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00860	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00863	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1056 :         put_byte(s, (Byte)(strm->total_in & 0xff));

  00866	0f b6 47 0c	 movzx	 eax, BYTE PTR [rdi+12]
  0086a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0086e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00871	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00874	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1057 :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  00877	0f b6 47 0d	 movzx	 eax, BYTE PTR [rdi+13]
  0087b	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0087f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00882	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00885	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1058 :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  00888	0f b6 47 0e	 movzx	 eax, BYTE PTR [rdi+14]
  0088c	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00890	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00893	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00896	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 1059 :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  00899	0f b6 47 0f	 movzx	 eax, BYTE PTR [rdi+15]
  0089d	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008a1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008a4	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 1060 :     }

  008a7	eb 15		 jmp	 SHORT $LN95@deflate
$LN94@deflate:

; 1061 :     else
; 1062 : #endif
; 1063 :     {
; 1064 :         putShortMSB(s, (uInt)(strm->adler >> 16));

  008a9	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  008ad	48 8b cb	 mov	 rcx, rbx
  008b0	e8 00 00 00 00	 call	 putShortMSB

; 1065 :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  008b5	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  008b9	e8 00 00 00 00	 call	 putShortMSB
$LN95@deflate:

; 1066 :     }
; 1067 :     flush_pending(strm);

  008be	48 8b cf	 mov	 rcx, rdi
  008c1	e8 00 00 00 00	 call	 flush_pending

; 1068 :     /* If avail_out is zero, the application will call deflate again
; 1069 :      * to flush the rest.
; 1070 :      */
; 1071 :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  008c6	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  008c9	85 c0		 test	 eax, eax
  008cb	7e 05		 jle	 SHORT $LN96@deflate
  008cd	f7 d8		 neg	 eax
  008cf	89 43 2c	 mov	 DWORD PTR [rbx+44], eax
$LN96@deflate:

; 1072 :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  008d2	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  008d5	40 0f 94 c6	 sete	 sil
  008d9	8b c6		 mov	 eax, esi
  008db	e9 15 f8 ff ff	 jmp	 $LN152@deflate
$LN83@deflate:

; 1009 :             if (strm->avail_out == 0) {

  008e0	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  008e3	75 07		 jne	 SHORT $LN84@deflate
$LN144@deflate:

; 1010 :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  008e5	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
$LN84@deflate:

; 1011 :             }
; 1012 :             return Z_OK;

  008ec	33 c0		 xor	 eax, eax
  008ee	e9 02 f8 ff ff	 jmp	 $LN152@deflate
$LN31@deflate:

; 777  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {
; 778  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  008f3	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  008fa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  008ff	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00903	b8 fe ff ff ff	 mov	 eax, -2

; 1073 : }

  00908	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0090c	41 5c		 pop	 r12
  0090e	5f		 pop	 rdi
  0090f	c3		 ret	 0
$LN29@deflate:

; 771  :         return Z_STREAM_ERROR;

  00910	b8 fe ff ff ff	 mov	 eax, -2

; 1073 : }

  00915	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00919	41 5c		 pop	 r12
  0091b	5f		 pop	 rdi
  0091c	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateEnd
_TEXT	SEGMENT
strm$ = 48
deflateEnd PROC						; COMDAT

; 1078 : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1079 :     int status;
; 1080 : 
; 1081 :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateEnd
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1095 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@deflateEnd:

; 1082 : 
; 1083 :     status = strm->state->status;

  0001d	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00021	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1084 : 
; 1085 :     /* Deallocate in reverse order of allocations: */
; 1086 :     TRY_FREE(strm, strm->state->pending_buf);

  00026	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0002a	8b 7a 08	 mov	 edi, DWORD PTR [rdx+8]
  0002d	48 85 c0	 test	 rax, rax
  00030	74 0e		 je	 SHORT $LN3@deflateEnd
  00032	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00036	48 8b d0	 mov	 rdx, rax
  00039	ff 53 38	 call	 QWORD PTR [rbx+56]
  0003c	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN3@deflateEnd:

; 1087 :     TRY_FREE(strm, strm->state->head);

  00040	48 8b 42 68	 mov	 rax, QWORD PTR [rdx+104]
  00044	48 85 c0	 test	 rax, rax
  00047	74 0e		 je	 SHORT $LN4@deflateEnd
  00049	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004d	48 8b d0	 mov	 rdx, rax
  00050	ff 53 38	 call	 QWORD PTR [rbx+56]
  00053	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN4@deflateEnd:

; 1088 :     TRY_FREE(strm, strm->state->prev);

  00057	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  0005b	48 85 c0	 test	 rax, rax
  0005e	74 0e		 je	 SHORT $LN5@deflateEnd
  00060	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00064	48 8b d0	 mov	 rdx, rax
  00067	ff 53 38	 call	 QWORD PTR [rbx+56]
  0006a	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN5@deflateEnd:

; 1089 :     TRY_FREE(strm, strm->state->window);

  0006e	48 8b 42 50	 mov	 rax, QWORD PTR [rdx+80]
  00072	48 85 c0	 test	 rax, rax
  00075	74 0e		 je	 SHORT $LN6@deflateEnd
  00077	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	ff 53 38	 call	 QWORD PTR [rbx+56]
  00081	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
$LN6@deflateEnd:

; 1090 : 
; 1091 :     ZFREE(strm, strm->state);

  00085	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00089	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1092 :     strm->state = Z_NULL;

  0008c	33 c0		 xor	 eax, eax

; 1093 : 
; 1094 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  0008e	b9 fd ff ff ff	 mov	 ecx, -3
  00093	83 ff 71	 cmp	 edi, 113		; 00000071H
  00096	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  0009a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0009f	0f 44 c1	 cmove	 eax, ecx

; 1095 : }

  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5b		 pop	 rbx
  000a7	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 233  : {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 234  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,

  00004	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00009	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0000f	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  00014	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0001c	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00024	45 8d 41 f9	 lea	 r8d, QWORD PTR [r9-7]
  00028	e8 00 00 00 00	 call	 deflateInit2_

; 235  :                          Z_DEFAULT_STRATEGY, version, stream_size);
; 236  :     /* To do: ignore strm->next_in if we use it as window */
; 237  : }

  0002d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00031	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT slide_hash
_TEXT	SEGMENT
s$ = 8
slide_hash PROC						; COMDAT

; 203  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 204  :     unsigned n, m;
; 205  :     Posf *p;
; 206  :     uInt wsize = s->w_size;
; 207  : 
; 208  :     n = s->hash_size;

  00005	44 8b 51 74	 mov	 r10d, DWORD PTR [rcx+116]

; 209  :     p = &s->head[n];

  00009	33 db		 xor	 ebx, ebx
  0000b	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000f	44 8b 41 44	 mov	 r8d, DWORD PTR [rcx+68]
  00013	4e 8d 0c 50	 lea	 r9, QWORD PTR [rax+r10*2]
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@slide_hash:

; 210  :     do {
; 211  :         m = *--p;

  00020	41 0f b7 51 fe	 movzx	 edx, WORD PTR [r9-2]
  00025	4d 8d 49 fe	 lea	 r9, QWORD PTR [r9-2]

; 212  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00029	0f b7 c2	 movzx	 eax, dx
  0002c	66 41 2b c0	 sub	 ax, r8w
  00030	41 3b d0	 cmp	 edx, r8d
  00033	66 0f 42 c3	 cmovb	 ax, bx
  00037	66 41 89 01	 mov	 WORD PTR [r9], ax

; 213  :     } while (--n);

  0003b	41 83 c2 ff	 add	 r10d, -1		; ffffffffH
  0003f	75 df		 jne	 SHORT $LL4@slide_hash

; 214  :     n = wsize;
; 215  : #ifndef FASTEST
; 216  :     p = &s->prev[n];

  00041	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00045	45 8b c8	 mov	 r9d, r8d
  00048	4a 8d 14 40	 lea	 rdx, QWORD PTR [rax+r8*2]
  0004c	0f 1f 40 00	 npad	 4
$LL7@slide_hash:

; 217  :     do {
; 218  :         m = *--p;

  00050	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00054	48 8d 52 fe	 lea	 rdx, QWORD PTR [rdx-2]

; 219  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00058	0f b7 c1	 movzx	 eax, cx
  0005b	66 41 2b c0	 sub	 ax, r8w
  0005f	41 3b c8	 cmp	 ecx, r8d
  00062	66 0f 42 c3	 cmovb	 ax, bx
  00066	66 89 02	 mov	 WORD PTR [rdx], ax

; 220  :         /* If n is not on any hash chain, prev[n] is garbage but
; 221  :          * its value will never be used.
; 222  :          */
; 223  :     } while (--n);

  00069	41 83 c1 ff	 add	 r9d, -1			; ffffffffH
  0006d	75 e1		 jne	 SHORT $LL7@slide_hash

; 224  : #endif
; 225  : }

  0006f	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00074	c3		 ret	 0
slide_hash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit2_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 250  : {

$LN24:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 251  :     deflate_state *s;
; 252  :     int wrap = 1;
; 253  :     static const char my_version[] = ZLIB_VERSION;
; 254  : 
; 255  :     ushf *overlay;
; 256  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 257  :      * output size for (length,distance) codes is <= 24 bits.
; 258  :      */
; 259  : 
; 260  :     if (version == Z_NULL || version[0] != my_version[0] ||

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00015	41 bf 01 00 00
	00		 mov	 r15d, 1
  0001b	44 8b 64 24 78	 mov	 r12d, DWORD PTR strategy$[rsp]
  00020	41 8b f1	 mov	 esi, r9d
  00023	48 8b d9	 mov	 rbx, rcx
  00026	45 8b f7	 mov	 r14d, r15d
  00029	48 85 c0	 test	 rax, rax
  0002c	0f 84 3f 02 00
	00		 je	 $LN3@deflateIni
  00032	80 38 31	 cmp	 BYTE PTR [rax], 49	; 00000031H
  00035	0f 85 36 02 00
	00		 jne	 $LN3@deflateIni
  0003b	83 bc 24 88 00
	00 00 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00043	0f 85 28 02 00
	00		 jne	 $LN3@deflateIni

; 263  :     }
; 264  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00049	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0004e	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00053	48 85 c9	 test	 rcx, rcx
  00056	0f 84 0e 02 00
	00		 je	 $LN12@deflateIni

; 265  : 
; 266  :     strm->msg = Z_NULL;

  0005c	33 c9		 xor	 ecx, ecx
  0005e	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 267  :     if (strm->zalloc == (alloc_func)0) {

  00062	48 39 4b 30	 cmp	 QWORD PTR [rbx+48], rcx
  00066	75 0f		 jne	 SHORT $LN5@deflateIni

; 268  : #ifdef Z_SOLO
; 269  :         return Z_STREAM_ERROR;
; 270  : #else
; 271  :         strm->zalloc = zcalloc;

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 272  :         strm->opaque = (voidpf)0;

  0006f	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  00073	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
$LN5@deflateIni:

; 273  : #endif
; 274  :     }
; 275  :     if (strm->zfree == (free_func)0)

  00077	48 39 4b 38	 cmp	 QWORD PTR [rbx+56], rcx
  0007b	75 0b		 jne	 SHORT $LN6@deflateIni

; 276  : #ifdef Z_SOLO
; 277  :         return Z_STREAM_ERROR;
; 278  : #else
; 279  :         strm->zfree = zcfree;

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00084	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
$LN6@deflateIni:

; 280  : #endif
; 281  : 
; 282  : #ifdef FASTEST
; 283  :     if (level != 0) level = 1;
; 284  : #else
; 285  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 286  : #endif
; 287  : 
; 288  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00088	83 fa ff	 cmp	 edx, -1
  0008b	bd 06 00 00 00	 mov	 ebp, 6
  00090	0f 45 ea	 cmovne	 ebp, edx
  00093	85 f6		 test	 esi, esi
  00095	79 07		 jns	 SHORT $LN8@deflateIni

; 289  :         wrap = 0;

  00097	44 8b f1	 mov	 r14d, ecx

; 290  :         windowBits = -windowBits;

  0009a	f7 de		 neg	 esi

; 291  :     }

  0009c	eb 0e		 jmp	 SHORT $LN10@deflateIni
$LN8@deflateIni:

; 292  : #ifdef GZIP
; 293  :     else if (windowBits > 15) {

  0009e	83 fe 0f	 cmp	 esi, 15
  000a1	7e 09		 jle	 SHORT $LN10@deflateIni

; 294  :         wrap = 2;       /* write gzip wrapper instead */

  000a3	41 be 02 00 00
	00		 mov	 r14d, 2

; 295  :         windowBits -= 16;

  000a9	83 ee 10	 sub	 esi, 16
$LN10@deflateIni:

; 296  :     }
; 297  : #endif
; 298  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 299  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 300  :         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {

  000ac	44 8b 6c 24 70	 mov	 r13d, DWORD PTR memLevel$[rsp]
  000b1	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000b5	83 f8 08	 cmp	 eax, 8
  000b8	0f 87 ac 01 00
	00		 ja	 $LN12@deflateIni
  000be	41 83 f8 08	 cmp	 r8d, 8
  000c2	0f 85 a2 01 00
	00		 jne	 $LN12@deflateIni
  000c8	8d 46 f8	 lea	 eax, DWORD PTR [rsi-8]
  000cb	83 f8 07	 cmp	 eax, 7
  000ce	0f 87 96 01 00
	00		 ja	 $LN12@deflateIni
  000d4	83 fd 09	 cmp	 ebp, 9
  000d7	0f 87 8d 01 00
	00		 ja	 $LN12@deflateIni
  000dd	41 83 fc 04	 cmp	 r12d, 4
  000e1	0f 87 83 01 00
	00		 ja	 $LN12@deflateIni
  000e7	41 3b f0	 cmp	 esi, r8d
  000ea	75 0d		 jne	 SHORT $LN13@deflateIni
  000ec	45 3b f7	 cmp	 r14d, r15d
  000ef	0f 85 75 01 00
	00		 jne	 $LN12@deflateIni

; 302  :     }
; 303  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  000f5	41 8d 70 01	 lea	 esi, QWORD PTR [r8+1]
$LN13@deflateIni:

; 304  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000f9	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000fd	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00103	41 8b d7	 mov	 edx, r15d
  00106	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0010b	ff 53 30	 call	 QWORD PTR [rbx+48]
  0010e	48 8b f8	 mov	 rdi, rax

; 305  :     if (s == Z_NULL) return Z_MEM_ERROR;

  00111	48 85 c0	 test	 rax, rax
  00114	0f 84 49 01 00
	00		 je	 $LN22@deflateIni

; 306  :     strm->state = (struct internal_state FAR *)s;

  0011a	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 307  :     s->strm = strm;
; 308  :     s->status = INIT_STATE;     /* to pass state test in deflateReset() */
; 309  : 
; 310  :     s->wrap = wrap;
; 311  :     s->gzhead = Z_NULL;
; 312  :     s->w_bits = (uInt)windowBits;
; 313  :     s->w_size = 1 << s->w_bits;

  0011e	8b ce		 mov	 ecx, esi
  00120	44 89 70 2c	 mov	 DWORD PTR [rax+44], r14d
  00124	45 8b cf	 mov	 r9d, r15d
  00127	41 d3 e1	 shl	 r9d, cl
  0012a	45 33 f6	 xor	 r14d, r14d
  0012d	48 89 18	 mov	 QWORD PTR [rax], rbx

; 314  :     s->w_mask = s->w_size - 1;
; 315  : 
; 316  :     s->hash_bits = (uInt)memLevel + 7;

  00130	41 8d 4d 07	 lea	 ecx, DWORD PTR [r13+7]
  00134	c7 40 08 2a 00
	00 00		 mov	 DWORD PTR [rax+8], 42	; 0000002aH
  0013b	4c 89 70 30	 mov	 QWORD PTR [rax+48], r14
  0013f	89 70 48	 mov	 DWORD PTR [rax+72], esi

; 317  :     s->hash_size = 1 << s->hash_bits;
; 318  :     s->hash_mask = s->hash_size - 1;
; 319  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
; 320  : 
; 321  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00142	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00146	44 89 48 44	 mov	 DWORD PTR [rax+68], r9d
  0014a	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  0014e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
  00151	41 8b c7	 mov	 eax, r15d
  00154	d3 e0		 shl	 eax, cl
  00156	89 47 74	 mov	 DWORD PTR [rdi+116], eax
  00159	ff c8		 dec	 eax
  0015b	89 47 7c	 mov	 DWORD PTR [rdi+124], eax
  0015e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00163	89 4f 78	 mov	 DWORD PTR [rdi+120], ecx
  00166	83 c1 02	 add	 ecx, 2
  00169	f7 e1		 mul	 ecx
  0016b	d1 ea		 shr	 edx, 1
  0016d	89 97 80 00 00
	00		 mov	 DWORD PTR [rdi+128], edx
  00173	41 8b d1	 mov	 edx, r9d
  00176	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0017a	ff 53 30	 call	 QWORD PTR [rbx+48]

; 322  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0017d	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00180	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00184	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  00188	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0018c	ff 53 30	 call	 QWORD PTR [rbx+48]

; 323  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  0018f	8b 57 74	 mov	 edx, DWORD PTR [rdi+116]
  00192	45 8d 46 02	 lea	 r8d, QWORD PTR [r14+2]
  00196	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  0019a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0019e	ff 53 30	 call	 QWORD PTR [rbx+48]

; 324  : 
; 325  :     s->high_water = 0;      /* nothing written to s->window yet */
; 326  : 
; 327  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  001a1	41 8d 4d 06	 lea	 ecx, DWORD PTR [r13+6]
  001a5	44 89 b7 18 17
	00 00		 mov	 DWORD PTR [rdi+5912], r14d
  001ac	41 d3 e7	 shl	 r15d, cl

; 328  : 
; 329  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  001af	45 8d 46 04	 lea	 r8d, QWORD PTR [r14+4]
  001b3	44 89 bf f0 16
	00 00		 mov	 DWORD PTR [rdi+5872], r15d
  001ba	41 8b d7	 mov	 edx, r15d
  001bd	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  001c1	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001c5	ff 53 30	 call	 QWORD PTR [rbx+48]
  001c8	48 8b d0	 mov	 rdx, rax

; 330  :     s->pending_buf = (uchf *) overlay;

  001cb	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 331  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  001cf	8b 87 f0 16 00
	00		 mov	 eax, DWORD PTR [rdi+5872]
  001d5	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [rax*4]
  001dc	89 4f 18	 mov	 DWORD PTR [rdi+24], ecx

; 332  : 
; 333  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||

  001df	4c 39 77 50	 cmp	 QWORD PTR [rdi+80], r14
  001e3	74 64		 je	 SHORT $LN16@deflateIni
  001e5	4c 39 77 60	 cmp	 QWORD PTR [rdi+96], r14
  001e9	74 5e		 je	 SHORT $LN16@deflateIni
  001eb	4c 39 77 68	 cmp	 QWORD PTR [rdi+104], r14
  001ef	74 58		 je	 SHORT $LN16@deflateIni
  001f1	48 85 d2	 test	 rdx, rdx
  001f4	74 53		 je	 SHORT $LN16@deflateIni

; 339  :     }
; 340  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001f6	8b c8		 mov	 ecx, eax

; 341  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 342  : 
; 343  :     s->level = level;

  001f8	89 af ac 00 00
	00		 mov	 DWORD PTR [rdi+172], ebp
  001fe	48 d1 e8	 shr	 rax, 1

; 344  :     s->strategy = strategy;

  00201	44 89 a7 b0 00
	00 00		 mov	 DWORD PTR [rdi+176], r12d

; 345  :     s->method = (Byte)method;

  00208	c6 47 3c 08	 mov	 BYTE PTR [rdi+60], 8
  0020c	48 8d 04 42	 lea	 rax, QWORD PTR [rdx+rax*2]
  00210	48 89 87 f8 16
	00 00		 mov	 QWORD PTR [rdi+5880], rax
  00217	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  0021b	48 03 c8	 add	 rcx, rax
  0021e	48 89 8f e8 16
	00 00		 mov	 QWORD PTR [rdi+5864], rcx

; 346  : 
; 347  :     return deflateReset(strm);

  00225	48 8b cb	 mov	 rcx, rbx
  00228	e8 00 00 00 00	 call	 deflateReset
$LN21@deflateIni:
  0022d	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
$LN20@deflateIni:
  00232	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00237	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 348  : }

  0023c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00240	41 5f		 pop	 r15
  00242	41 5e		 pop	 r14
  00244	41 5c		 pop	 r12
  00246	5e		 pop	 rsi
  00247	5b		 pop	 rbx
  00248	c3		 ret	 0
$LN16@deflateIni:

; 334  :         s->pending_buf == Z_NULL) {
; 335  :         s->status = FINISH_STATE;
; 336  :         strm->msg = ERR_MSG(Z_MEM_ERROR);

  00249	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48

; 337  :         deflateEnd (strm);

  00250	48 8b cb	 mov	 rcx, rbx
  00253	c7 47 08 9a 02
	00 00		 mov	 DWORD PTR [rdi+8], 666	; 0000029aH
  0025a	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0025e	e8 00 00 00 00	 call	 deflateEnd
$LN22@deflateIni:

; 338  :         return Z_MEM_ERROR;

  00263	b8 fc ff ff ff	 mov	 eax, -4
  00268	eb c3		 jmp	 SHORT $LN21@deflateIni
$LN12@deflateIni:

; 301  :         return Z_STREAM_ERROR;

  0026a	b8 fe ff ff ff	 mov	 eax, -2
  0026f	eb c1		 jmp	 SHORT $LN20@deflateIni
$LN3@deflateIni:

; 261  :         stream_size != sizeof(z_stream)) {
; 262  :         return Z_VERSION_ERROR;

  00271	b8 fa ff ff ff	 mov	 eax, -6

; 348  : }

  00276	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027a	41 5f		 pop	 r15
  0027c	41 5e		 pop	 r14
  0027e	41 5c		 pop	 r12
  00280	5e		 pop	 rsi
  00281	5b		 pop	 rbx
  00282	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateStateCheck
_TEXT	SEGMENT
strm$ = 8
deflateStateCheck PROC					; COMDAT

; 356  :     deflate_state *s;
; 357  :     if (strm == Z_NULL ||
; 358  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN3@deflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 40		 je	 SHORT $LN3@deflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 39		 je	 SHORT $LN3@deflateSta

; 360  :     s = strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 361  :     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&

  00017	48 85 c0	 test	 rax, rax
  0001a	74 30		 je	 SHORT $LN3@deflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 2b		 jne	 SHORT $LN3@deflateSta
  00021	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00024	8d 41 d6	 lea	 eax, DWORD PTR [rcx-42]
  00027	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0002a	77 10		 ja	 SHORT $LN7@deflateSta
  0002c	48 ba 01 80 00
	88 00 00 02 20	 mov	 rdx, 2306405961448849409 ; 2002000088008001H
  00036	48 0f a3 c2	 bt	 rdx, rax
  0003a	72 0d		 jb	 SHORT $LN4@deflateSta
$LN7@deflateSta:
  0003c	83 f9 71	 cmp	 ecx, 113		; 00000071H
  0003f	74 08		 je	 SHORT $LN4@deflateSta
  00041	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  00047	75 03		 jne	 SHORT $LN3@deflateSta
$LN4@deflateSta:

; 362  : #ifdef GZIP
; 363  :                                            s->status != GZIP_STATE &&
; 364  : #endif
; 365  :                                            s->status != EXTRA_STATE &&
; 366  :                                            s->status != NAME_STATE &&
; 367  :                                            s->status != COMMENT_STATE &&
; 368  :                                            s->status != HCRC_STATE &&
; 369  :                                            s->status != BUSY_STATE &&
; 370  :                                            s->status != FINISH_STATE))
; 371  :         return 1;
; 372  :     return 0;

  00049	33 c0		 xor	 eax, eax

; 373  : }

  0004b	c3		 ret	 0
$LN3@deflateSta:

; 359  :         return 1;

  0004c	b8 01 00 00 00	 mov	 eax, 1

; 373  : }

  00051	c3		 ret	 0
deflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 380  : {

$LN29:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	41 8b f8	 mov	 edi, r8d
  0000e	48 8b ea	 mov	 rbp, rdx
  00011	48 8b f1	 mov	 rsi, rcx

; 381  :     deflate_state *s;
; 382  :     uInt str, n;
; 383  :     int wrap;
; 384  :     unsigned avail;
; 385  :     z_const unsigned char *next;
; 386  : 
; 387  :     if (deflateStateCheck(strm) || dictionary == Z_NULL)

  00014	e8 00 00 00 00	 call	 deflateStateCheck
  00019	85 c0		 test	 eax, eax
  0001b	0f 85 cb 01 00
	00		 jne	 $LN8@deflateSet
  00021	48 85 ed	 test	 rbp, rbp
  00024	0f 84 c2 01 00
	00		 je	 $LN8@deflateSet

; 389  :     s = strm->state;

  0002a	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]

; 390  :     wrap = s->wrap;

  0002e	44 8b 73 2c	 mov	 r14d, DWORD PTR [rbx+44]

; 391  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  00032	41 83 fe 02	 cmp	 r14d, 2
  00036	0f 84 b0 01 00
	00		 je	 $LN8@deflateSet
  0003c	41 83 fe 01	 cmp	 r14d, 1
  00040	75 0a		 jne	 SHORT $LN11@deflateSet
  00042	83 7b 08 2a	 cmp	 DWORD PTR [rbx+8], 42	; 0000002aH
  00046	0f 85 a0 01 00
	00		 jne	 $LN8@deflateSet
$LN11@deflateSet:
  0004c	83 bb 9c 00 00
	00 00		 cmp	 DWORD PTR [rbx+156], 0
  00053	0f 85 93 01 00
	00		 jne	 $LN8@deflateSet

; 392  :         return Z_STREAM_ERROR;
; 393  : 
; 394  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 395  :     if (wrap == 1)

  00059	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0005e	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00063	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  00068	41 83 fe 01	 cmp	 r14d, 1
  0006c	75 0e		 jne	 SHORT $LN12@deflateSet

; 396  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0006e	8b 4e 4c	 mov	 ecx, DWORD PTR [rsi+76]
  00071	48 8b d5	 mov	 rdx, rbp
  00074	e8 00 00 00 00	 call	 adler32
  00079	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
$LN12@deflateSet:

; 397  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
; 398  : 
; 399  :     /* if dictionary would fill window, just replace the history */
; 400  :     if (dictLength >= s->w_size) {

  0007c	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  0007f	45 33 ed	 xor	 r13d, r13d
  00082	44 89 6b 2c	 mov	 DWORD PTR [rbx+44], r13d
  00086	3b f9		 cmp	 edi, ecx
  00088	72 49		 jb	 SHORT $LN27@deflateSet

; 401  :         if (wrap == 0) {            /* already empty otherwise */

  0008a	45 85 f6	 test	 r14d, r14d
  0008d	75 3b		 jne	 SHORT $LN26@deflateSet

; 402  :             CLEAR_HASH(s);

  0008f	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00092	33 d2		 xor	 edx, edx
  00094	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00098	ff c9		 dec	 ecx
  0009a	66 44 89 2c 48	 mov	 WORD PTR [rax+rcx*2], r13w
  0009f	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000a3	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000a7	41 ff c8	 dec	 r8d
  000aa	4d 03 c0	 add	 r8, r8
  000ad	e8 00 00 00 00	 call	 memset

; 403  :             s->strstart = 0;
; 404  :             s->block_start = 0L;
; 405  :             s->insert = 0;

  000b2	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  000b5	44 89 ab 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r13d
  000bc	44 89 ab 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r13d
  000c3	44 89 ab 0c 17
	00 00		 mov	 DWORD PTR [rbx+5900], r13d
$LN26@deflateSet:

; 406  :         }
; 407  :         dictionary += dictLength - s->w_size;  /* use the tail */

  000ca	2b f9		 sub	 edi, ecx
  000cc	8b c7		 mov	 eax, edi

; 408  :         dictLength = s->w_size;

  000ce	8b f9		 mov	 edi, ecx
  000d0	48 03 e8	 add	 rbp, rax
$LN27@deflateSet:

; 409  :     }
; 410  : 
; 411  :     /* insert dictionary into window and hash */
; 412  :     avail = strm->avail_in;

  000d3	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]

; 413  :     next = strm->next_in;
; 414  :     strm->avail_in = dictLength;
; 415  :     strm->next_in = (z_const Bytef *)dictionary;
; 416  :     fill_window(s);

  000d7	48 8b cb	 mov	 rcx, rbx
  000da	4c 8b 26	 mov	 r12, QWORD PTR [rsi]
  000dd	89 7e 08	 mov	 DWORD PTR [rsi+8], edi
  000e0	48 89 2e	 mov	 QWORD PTR [rsi], rbp
  000e3	e8 00 00 00 00	 call	 fill_window

; 417  :     while (s->lookahead >= MIN_MATCH) {

  000e8	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  000ee	83 f9 03	 cmp	 ecx, 3
  000f1	0f 82 94 00 00
	00		 jb	 $LN3@deflateSet
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@deflateSet:

; 418  :         str = s->strstart;

  00100	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 419  :         n = s->lookahead - (MIN_MATCH-1);

  00107	8d 79 fe	 lea	 edi, DWORD PTR [rcx-2]
  0010a	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
  0010e	66 90		 npad	 2
$LL6@deflateSet:

; 420  :         do {
; 421  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00110	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00114	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 422  : #ifndef FASTEST
; 423  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  0011a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0011e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00122	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]

; 424  : #endif
; 425  :             s->head[s->ins_h] = (Pos)str;
; 426  :             str++;

  00127	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  0012b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0012e	d3 e0		 shl	 eax, cl
  00130	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00134	44 33 c8	 xor	 r9d, eax
  00137	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0013b	41 8b c2	 mov	 eax, r10d
  0013e	4c 23 c0	 and	 r8, rax
  00141	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00145	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  0014a	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0014f	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00152	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00156	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0015b	41 ff c2	 inc	 r10d

; 427  :         } while (--n);

  0015e	83 c7 ff	 add	 edi, -1			; ffffffffH
  00161	75 ad		 jne	 SHORT $LL6@deflateSet

; 428  :         s->strstart = str;
; 429  :         s->lookahead = MIN_MATCH-1;
; 430  :         fill_window(s);

  00163	48 8b cb	 mov	 rcx, rbx
  00166	44 89 93 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r10d
  0016d	c7 83 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+156], 2
  00177	e8 00 00 00 00	 call	 fill_window
  0017c	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  00182	83 f9 03	 cmp	 ecx, 3
  00185	0f 83 75 ff ff
	ff		 jae	 $LL2@deflateSet
$LN3@deflateSet:

; 431  :     }
; 432  :     s->strstart += s->lookahead;

  0018b	01 8b 94 00 00
	00		 add	 DWORD PTR [rbx+148], ecx
  00191	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]

; 433  :     s->block_start = (long)s->strstart;

  00197	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax

; 434  :     s->insert = s->lookahead;
; 435  :     s->lookahead = 0;
; 436  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 437  :     s->match_available = 0;
; 438  :     strm->next_in = next;
; 439  :     strm->avail_in = avail;
; 440  :     s->wrap = wrap;
; 441  :     return Z_OK;

  0019d	33 c0		 xor	 eax, eax
  0019f	44 89 ab 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r13d
  001a6	44 89 ab 90 00
	00 00		 mov	 DWORD PTR [rbx+144], r13d
  001ad	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  001b2	89 8b 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ecx
  001b8	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  001c2	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2
  001cc	4c 89 26	 mov	 QWORD PTR [rsi], r12
  001cf	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  001d4	44 89 7e 08	 mov	 DWORD PTR [rsi+8], r15d
  001d8	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]
  001dd	44 89 73 2c	 mov	 DWORD PTR [rbx+44], r14d

; 442  : }

  001e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e5	41 5e		 pop	 r14
  001e7	5f		 pop	 rdi
  001e8	5e		 pop	 rsi
  001e9	5d		 pop	 rbp
  001ea	5b		 pop	 rbx
  001eb	c3		 ret	 0
$LN8@deflateSet:

; 388  :         return Z_STREAM_ERROR;

  001ec	b8 fe ff ff ff	 mov	 eax, -2

; 442  : }

  001f1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f5	41 5e		 pop	 r14
  001f7	5f		 pop	 rdi
  001f8	5e		 pop	 rsi
  001f9	5d		 pop	 rbp
  001fa	5b		 pop	 rbx
  001fb	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
deflateGetDictionary PROC				; COMDAT

; 449  : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b f8	 mov	 rdi, r8
  00009	4c 8b ca	 mov	 r9, rdx
  0000c	4c 8b c1	 mov	 r8, rcx

; 450  :     deflate_state *s;
; 451  :     uInt len;
; 452  : 
; 453  :     if (deflateStateCheck(strm))

  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	74 0b		 je	 SHORT $LN2@deflateGet

; 454  :         return Z_STREAM_ERROR;

  00018	b8 fe ff ff ff	 mov	 eax, -2

; 464  : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
$LN2@deflateGet:

; 455  :     s = strm->state;

  00023	49 8b 50 28	 mov	 rdx, QWORD PTR [r8+40]
  00027	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 456  :     len = s->strstart + s->lookahead;
; 457  :     if (len > s->w_size)

  0002c	8b 5a 44	 mov	 ebx, DWORD PTR [rdx+68]
  0002f	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [rdx+156]
  00035	44 8b 92 94 00
	00 00		 mov	 r10d, DWORD PTR [rdx+148]
  0003c	41 8d 04 0a	 lea	 eax, DWORD PTR [r10+rcx]

; 458  :         len = s->w_size;
; 459  :     if (dictionary != Z_NULL && len)

  00040	3b c3		 cmp	 eax, ebx
  00042	0f 46 d8	 cmovbe	 ebx, eax
  00045	4d 85 c9	 test	 r9, r9
  00048	74 1c		 je	 SHORT $LN4@deflateGet
  0004a	85 db		 test	 ebx, ebx
  0004c	74 18		 je	 SHORT $LN4@deflateGet

; 460  :         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);

  0004e	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00052	44 8b c3	 mov	 r8d, ebx
  00055	49 2b d0	 sub	 rdx, r8
  00058	49 03 d2	 add	 rdx, r10
  0005b	48 03 d1	 add	 rdx, rcx
  0005e	49 8b c9	 mov	 rcx, r9
  00061	e8 00 00 00 00	 call	 memcpy
$LN4@deflateGet:

; 461  :     if (dictLength != Z_NULL)

  00066	48 85 ff	 test	 rdi, rdi
  00069	74 02		 je	 SHORT $LN5@deflateGet

; 462  :         *dictLength = len;

  0006b	89 1f		 mov	 DWORD PTR [rdi], ebx
$LN5@deflateGet:

; 463  :     return Z_OK;

  0006d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00072	33 c0		 xor	 eax, eax

; 464  : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
deflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateResetKeep
_TEXT	SEGMENT
strm$ = 48
deflateResetKeep PROC					; COMDAT

; 469  : {

$LN11:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 470  :     deflate_state *s;
; 471  : 
; 472  :     if (deflateStateCheck(strm)) {

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateRes

; 473  :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 502  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN2@deflateRes:

; 474  :     }
; 475  : 
; 476  :     strm->total_in = strm->total_out = 0;
; 477  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
; 478  :     strm->data_type = Z_UNKNOWN;

  0001d	c7 47 48 02 00
	00 00		 mov	 DWORD PTR [rdi+72], 2
  00024	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 479  : 
; 480  :     s = (deflate_state *)strm->state;

  00029	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  0002d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00032	33 f6		 xor	 esi, esi
  00034	89 77 1c	 mov	 DWORD PTR [rdi+28], esi
  00037	89 77 0c	 mov	 DWORD PTR [rdi+12], esi
  0003a	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi

; 481  :     s->pending = 0;
; 482  :     s->pending_out = s->pending_buf;

  0003e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 483  : 
; 484  :     if (s->wrap < 0) {

  00042	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00045	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00049	89 73 28	 mov	 DWORD PTR [rbx+40], esi
  0004c	85 c9		 test	 ecx, ecx
  0004e	79 05		 jns	 SHORT $LN3@deflateRes

; 485  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  00050	f7 d9		 neg	 ecx
  00052	89 4b 2c	 mov	 DWORD PTR [rbx+44], ecx
$LN3@deflateRes:

; 486  :     }
; 487  :     s->status =

  00055	83 f9 02	 cmp	 ecx, 2
  00058	75 15		 jne	 SHORT $LN5@deflateRes

; 488  : #ifdef GZIP
; 489  :         s->wrap == 2 ? GZIP_STATE :
; 490  : #endif
; 491  :         s->wrap ? INIT_STATE : BUSY_STATE;
; 492  :     strm->adler =

  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	c7 43 08 39 00
	00 00		 mov	 DWORD PTR [rbx+8], 57	; 00000039H
  00064	33 d2		 xor	 edx, edx
  00066	33 c9		 xor	 ecx, ecx
  00068	e8 00 00 00 00	 call	 crc32
  0006d	eb 1e		 jmp	 SHORT $LN8@deflateRes
$LN5@deflateRes:

; 486  :     }
; 487  :     s->status =

  0006f	85 c9		 test	 ecx, ecx
  00071	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  00076	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  0007b	0f 45 c2	 cmovne	 eax, edx

; 488  : #ifdef GZIP
; 489  :         s->wrap == 2 ? GZIP_STATE :
; 490  : #endif
; 491  :         s->wrap ? INIT_STATE : BUSY_STATE;
; 492  :     strm->adler =

  0007e	45 33 c0	 xor	 r8d, r8d
  00081	33 d2		 xor	 edx, edx
  00083	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00086	33 c9		 xor	 ecx, ecx
  00088	e8 00 00 00 00	 call	 adler32
$LN8@deflateRes:
  0008d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 493  : #ifdef GZIP
; 494  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 495  : #endif
; 496  :         adler32(0L, Z_NULL, 0);
; 497  :     s->last_flush = Z_NO_FLUSH;
; 498  : 
; 499  :     _tr_init(s);

  00090	48 8b cb	 mov	 rcx, rbx
  00093	89 73 40	 mov	 DWORD PTR [rbx+64], esi
  00096	e8 00 00 00 00	 call	 _tr_init

; 500  : 
; 501  :     return Z_OK;

  0009b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a0	33 c0		 xor	 eax, eax
  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 502  : }

  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
deflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateReset
_TEXT	SEGMENT
strm$ = 48
deflateReset PROC					; COMDAT

; 507  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 508  :     int ret;
; 509  : 
; 510  :     ret = deflateResetKeep(strm);

  0000d	e8 00 00 00 00	 call	 deflateResetKeep
  00012	8b d8		 mov	 ebx, eax

; 511  :     if (ret == Z_OK)

  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@deflateRes

; 512  :         lm_init(strm->state);

  00018	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0001c	e8 00 00 00 00	 call	 lm_init

; 513  :     return ret;

  00021	8b c3		 mov	 eax, ebx
$LN2@deflateRes:

; 514  : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
deflateSetHeader PROC					; COMDAT

; 520  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx
  00007	4c 8b c1	 mov	 r8, rcx

; 521  :     if (deflateStateCheck(strm) || strm->state->wrap != 2)

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 15		 jne	 SHORT $LN3@deflateSet
  00013	49 8b 40 28	 mov	 rax, QWORD PTR [r8+40]
  00017	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0001b	75 0b		 jne	 SHORT $LN3@deflateSet

; 523  :     strm->state->gzhead = head;

  0001d	4c 89 48 30	 mov	 QWORD PTR [rax+48], r9

; 524  :     return Z_OK;

  00021	33 c0		 xor	 eax, eax

; 525  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN3@deflateSet:

; 522  :         return Z_STREAM_ERROR;

  00028	b8 fe ff ff ff	 mov	 eax, -2

; 525  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePending
_TEXT	SEGMENT
strm$ = 48
pending$ = 56
bits$ = 64
deflatePending PROC					; COMDAT

; 532  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b d2	 mov	 r10, rdx
  00007	4c 8b c9	 mov	 r9, rcx

; 533  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflatePen
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 539  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflatePen:

; 534  :     if (pending != Z_NULL)

  0001d	4d 85 d2	 test	 r10, r10
  00020	74 0a		 je	 SHORT $LN3@deflatePen

; 535  :         *pending = strm->state->pending;

  00022	49 8b 41 28	 mov	 rax, QWORD PTR [r9+40]
  00026	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00029	41 89 0a	 mov	 DWORD PTR [r10], ecx
$LN3@deflatePen:

; 536  :     if (bits != Z_NULL)

  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 0d		 je	 SHORT $LN4@deflatePen

; 537  :         *bits = strm->state->bi_valid;

  00031	49 8b 41 28	 mov	 rax, QWORD PTR [r9+40]
  00035	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  0003b	41 89 08	 mov	 DWORD PTR [r8], ecx
$LN4@deflatePen:

; 538  :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax

; 539  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
deflatePending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
deflatePrime PROC					; COMDAT

; 546  : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b f8	 mov	 edi, r8d
  0000d	8b da		 mov	 ebx, edx
  0000f	4c 8b d1	 mov	 r10, rcx

; 547  :     deflate_state *s;
; 548  :     int put;
; 549  : 
; 550  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00012	e8 00 00 00 00	 call	 deflateStateCheck
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN5@deflatePri
  0001b	b8 fe ff ff ff	 mov	 eax, -2

; 564  :     return Z_OK;
; 565  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN5@deflatePri:

; 551  :     s = strm->state;

  0002b	4d 8b 52 28	 mov	 r10, QWORD PTR [r10+40]

; 552  :     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))

  0002f	49 8b 42 20	 mov	 rax, QWORD PTR [r10+32]
  00033	48 83 c0 02	 add	 rax, 2
  00037	49 39 82 f8 16
	00 00		 cmp	 QWORD PTR [r10+5880], rax
  0003e	73 10		 jae	 SHORT $LL4@deflatePri

; 553  :         return Z_BUF_ERROR;

  00040	b8 fb ff ff ff	 mov	 eax, -5

; 564  :     return Z_OK;
; 565  : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LL4@deflatePri:

; 554  :     do {
; 555  :         put = Buf_size - s->bi_valid;

  00050	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  00057	b8 10 00 00 00	 mov	 eax, 16
  0005c	2b c2		 sub	 eax, edx

; 556  :         if (put > bits)
; 557  :             put = bits;
; 558  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  0005e	44 8b db	 mov	 r11d, ebx
  00061	3b c3		 cmp	 eax, ebx
  00063	44 0f 4e d8	 cmovle	 r11d, eax
  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	41 8b cb	 mov	 ecx, r11d
  0006f	66 d3 e0	 shl	 ax, cl
  00072	8b ca		 mov	 ecx, edx
  00074	66 ff c8	 dec	 ax
  00077	66 23 c7	 and	 ax, di
  0007a	66 d3 e0	 shl	 ax, cl

; 559  :         s->bi_valid += put;
; 560  :         _tr_flush_bits(s);

  0007d	49 8b ca	 mov	 rcx, r10
  00080	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00088	41 8d 04 13	 lea	 eax, DWORD PTR [r11+rdx]
  0008c	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
  00093	e8 00 00 00 00	 call	 _tr_flush_bits

; 561  :         value >>= put;

  00098	41 8b cb	 mov	 ecx, r11d
  0009b	d3 ff		 sar	 edi, cl

; 562  :         bits -= put;

  0009d	41 2b db	 sub	 ebx, r11d

; 563  :     } while (bits);

  000a0	75 ae		 jne	 SHORT $LL4@deflatePri

; 564  :     return Z_OK;
; 565  : }

  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a7	33 c0		 xor	 eax, eax
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateParams
_TEXT	SEGMENT
strm$ = 48
level$ = 56
strategy$ = 64
deflateParams PROC					; COMDAT

; 572  : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	44 8b c2	 mov	 r8d, edx

; 573  :     deflate_state *s;
; 574  :     compress_func func;
; 575  : 
; 576  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00023	e8 00 00 00 00	 call	 deflateStateCheck
  00028	85 c0		 test	 eax, eax
  0002a	0f 85 17 01 00
	00		 jne	 $LN5@deflatePar

; 577  :     s = strm->state;

  00030	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]

; 578  : 
; 579  : #ifdef FASTEST
; 580  :     if (level != 0) level = 1;
; 581  : #else
; 582  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 583  : #endif
; 584  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00034	41 83 f8 ff	 cmp	 r8d, -1
  00038	bf 06 00 00 00	 mov	 edi, 6
  0003d	41 0f 45 f8	 cmovne	 edi, r8d
  00041	83 ff 09	 cmp	 edi, 9
  00044	0f 87 fd 00 00
	00		 ja	 $LN5@deflatePar
  0004a	83 fd 04	 cmp	 ebp, 4
  0004d	0f 87 f4 00 00
	00		 ja	 $LN5@deflatePar

; 586  :     }
; 587  :     func = configuration_table[s->level].func;
; 588  : 
; 589  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&

  00053	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:configuration_table
  0005a	3b ab b0 00 00
	00		 cmp	 ebp, DWORD PTR [rbx+176]
  00060	75 1c		 jne	 SHORT $LN16@deflatePar
  00062	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00069	48 63 c7	 movsxd	 rax, edi
  0006c	48 03 c9	 add	 rcx, rcx
  0006f	48 03 c0	 add	 rax, rax
  00072	49 8b 44 c6 08	 mov	 rax, QWORD PTR [r14+rax*8+8]
  00077	49 39 44 ce 08	 cmp	 QWORD PTR [r14+rcx*8+8], rax
  0007c	74 2f		 je	 SHORT $LN9@deflatePar
$LN16@deflatePar:
  0007e	83 bb 18 17 00
	00 00		 cmp	 DWORD PTR [rbx+5912], 0
  00085	74 26		 je	 SHORT $LN9@deflatePar

; 590  :         s->high_water) {
; 591  :         /* Flush the last buffer: */
; 592  :         int err = deflate(strm, Z_BLOCK);

  00087	ba 05 00 00 00	 mov	 edx, 5
  0008c	48 8b ce	 mov	 rcx, rsi
  0008f	e8 00 00 00 00	 call	 deflate

; 593  :         if (err == Z_STREAM_ERROR)

  00094	83 f8 fe	 cmp	 eax, -2
  00097	0f 84 aa 00 00
	00		 je	 $LN5@deflatePar

; 594  :             return err;
; 595  :         if (strm->avail_out == 0)

  0009d	83 7e 18 00	 cmp	 DWORD PTR [rsi+24], 0
  000a1	75 0a		 jne	 SHORT $LN9@deflatePar

; 596  :             return Z_BUF_ERROR;

  000a3	b8 fb ff ff ff	 mov	 eax, -5
  000a8	e9 9f 00 00 00	 jmp	 $LN1@deflatePar
$LN9@deflatePar:

; 597  :     }
; 598  :     if (s->level != level) {

  000ad	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  000b3	3b c7		 cmp	 eax, edi
  000b5	0f 84 82 00 00
	00		 je	 $LN10@deflatePar

; 599  :         if (s->level == 0 && s->matches != 0) {

  000bb	85 c0		 test	 eax, eax
  000bd	75 43		 jne	 SHORT $LN11@deflatePar
  000bf	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  000c5	85 c0		 test	 eax, eax
  000c7	74 39		 je	 SHORT $LN11@deflatePar

; 600  :             if (s->matches == 1)

  000c9	33 f6		 xor	 esi, esi
  000cb	83 f8 01	 cmp	 eax, 1
  000ce	75 0a		 jne	 SHORT $LN12@deflatePar

; 601  :                 slide_hash(s);

  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	e8 00 00 00 00	 call	 slide_hash
  000d8	eb 0d		 jmp	 SHORT $LN13@deflatePar
$LN12@deflatePar:

; 602  :             else
; 603  :                 CLEAR_HASH(s);

  000da	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  000dd	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000e1	ff c9		 dec	 ecx
  000e3	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
$LN13@deflatePar:
  000e7	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000eb	33 d2		 xor	 edx, edx
  000ed	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000f1	41 ff c8	 dec	 r8d
  000f4	4d 03 c0	 add	 r8, r8
  000f7	e8 00 00 00 00	 call	 memset

; 604  :             s->matches = 0;

  000fc	89 b3 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], esi
$LN11@deflatePar:

; 605  :         }
; 606  :         s->level = level;

  00102	89 bb ac 00 00
	00		 mov	 DWORD PTR [rbx+172], edi

; 607  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  00108	48 63 cf	 movsxd	 rcx, edi
  0010b	48 03 c9	 add	 rcx, rcx
  0010e	41 0f b7 44 ce
	02		 movzx	 eax, WORD PTR [r14+rcx*8+2]
  00114	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 608  :         s->good_match       = configuration_table[level].good_length;

  0011a	41 0f b7 04 ce	 movzx	 eax, WORD PTR [r14+rcx*8]
  0011f	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 609  :         s->nice_match       = configuration_table[level].nice_length;

  00125	41 0f b7 44 ce
	04		 movzx	 eax, WORD PTR [r14+rcx*8+4]
  0012b	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 610  :         s->max_chain_length = configuration_table[level].max_chain;

  00131	41 0f b7 44 ce
	06		 movzx	 eax, WORD PTR [r14+rcx*8+6]
  00137	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
$LN10@deflatePar:

; 611  :     }
; 612  :     s->strategy = strategy;

  0013d	89 ab b0 00 00
	00		 mov	 DWORD PTR [rbx+176], ebp

; 613  :     return Z_OK;

  00143	33 c0		 xor	 eax, eax
  00145	eb 05		 jmp	 SHORT $LN1@deflatePar
$LN5@deflatePar:

; 585  :         return Z_STREAM_ERROR;

  00147	b8 fe ff ff ff	 mov	 eax, -2
$LN1@deflatePar:

; 614  : }

  0014c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00151	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00156	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0015b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00160	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00164	41 5e		 pop	 r14
  00166	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateTune
_TEXT	SEGMENT
strm$ = 48
good_length$ = 56
max_lazy$ = 64
nice_length$ = 72
max_chain$ = 80
deflateTune PROC					; COMDAT

; 623  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 8b da	 mov	 r11d, edx
  00007	4c 8b d1	 mov	 r10, rcx

; 624  :     deflate_state *s;
; 625  : 
; 626  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflateTun
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 633  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflateTun:

; 627  :     s = strm->state;

  0001d	49 8b 4a 28	 mov	 rcx, QWORD PTR [r10+40]

; 628  :     s->good_match = (uInt)good_length;
; 629  :     s->max_lazy_match = (uInt)max_lazy;
; 630  :     s->nice_match = nice_length;
; 631  :     s->max_chain_length = (uInt)max_chain;

  00021	8b 44 24 50	 mov	 eax, DWORD PTR max_chain$[rsp]
  00025	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 632  :     return Z_OK;

  0002b	33 c0		 xor	 eax, eax
  0002d	44 89 99 b4 00
	00 00		 mov	 DWORD PTR [rcx+180], r11d
  00034	44 89 81 a8 00
	00 00		 mov	 DWORD PTR [rcx+168], r8d
  0003b	44 89 89 b8 00
	00 00		 mov	 DWORD PTR [rcx+184], r9d

; 633  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateBound
_TEXT	SEGMENT
strm$ = 48
sourceLen$ = 56
deflateBound PROC					; COMDAT

; 655  : {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 656  :     deflate_state *s;
; 657  :     uLong complen, wraplen;
; 658  : 
; 659  :     /* conservative upper bound for compressed data */
; 660  :     complen = sourceLen +

  00004	44 8d 5a 3f	 lea	 r11d, DWORD PTR [rdx+63]
  00008	44 8b ca	 mov	 r9d, edx
  0000b	44 8d 42 07	 lea	 r8d, DWORD PTR [rdx+7]
  0000f	41 c1 eb 06	 shr	 r11d, 6
  00013	44 03 da	 add	 r11d, edx
  00016	41 c1 e8 03	 shr	 r8d, 3
  0001a	41 83 c0 05	 add	 r8d, 5
  0001e	4c 8b d1	 mov	 r10, rcx
  00021	45 03 d8	 add	 r11d, r8d

; 661  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
; 662  : 
; 663  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 664  :     if (deflateStateCheck(strm))

  00024	e8 00 00 00 00	 call	 deflateStateCheck
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN10@deflateBou

; 665  :         return complen + 6;

  0002d	41 8d 43 06	 lea	 eax, DWORD PTR [r11+6]

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
$LN10@deflateBou:

; 666  : 
; 667  :     /* compute wrapper length */
; 668  :     s = strm->state;

  00036	49 8b 52 28	 mov	 rdx, QWORD PTR [r10+40]

; 669  :     switch (s->wrap) {

  0003a	8b 4a 2c	 mov	 ecx, DWORD PTR [rdx+44]
  0003d	85 c9		 test	 ecx, ecx
  0003f	0f 84 91 00 00
	00		 je	 $LN11@deflateBou
  00045	83 e9 01	 sub	 ecx, 1
  00048	74 74		 je	 SHORT $LN12@deflateBou
  0004a	83 f9 01	 cmp	 ecx, 1
  0004d	74 0b		 je	 SHORT $LN13@deflateBou

; 697  : #endif
; 698  :     default:                                /* for compiler happiness */
; 699  :         wraplen = 6;

  0004f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00055	e9 7f 00 00 00	 jmp	 $LN2@deflateBou
$LN13@deflateBou:

; 676  : #ifdef GZIP
; 677  :     case 2:                                 /* gzip wrapper */
; 678  :         wraplen = 18;
; 679  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  0005a	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  0005e	41 b8 12 00 00
	00		 mov	 r8d, 18
  00064	48 85 c0	 test	 rax, rax
  00067	74 70		 je	 SHORT $LN2@deflateBou

; 680  :             Bytef *str;
; 681  :             if (s->gzhead->extra != Z_NULL)

  00069	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006e	74 08		 je	 SHORT $LN15@deflateBou

; 682  :                 wraplen += 2 + s->gzhead->extra_len;

  00070	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00074	41 83 c0 14	 add	 r8d, 20
$LN15@deflateBou:

; 683  :             str = s->gzhead->name;

  00078	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]

; 684  :             if (str != Z_NULL)

  0007c	48 85 c9	 test	 rcx, rcx
  0007f	74 12		 je	 SHORT $LN5@deflateBou
$LL6@deflateBou:

; 685  :                 do {
; 686  :                     wraplen++;
; 687  :                 } while (*str++);

  00081	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00084	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00088	41 ff c0	 inc	 r8d
  0008b	84 c0		 test	 al, al
  0008d	75 f2		 jne	 SHORT $LL6@deflateBou
  0008f	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
$LN5@deflateBou:

; 688  :             str = s->gzhead->comment;

  00093	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]

; 689  :             if (str != Z_NULL)

  00097	48 85 c9	 test	 rcx, rcx
  0009a	74 16		 je	 SHORT $LN8@deflateBou
  0009c	0f 1f 40 00	 npad	 4
$LL9@deflateBou:

; 690  :                 do {
; 691  :                     wraplen++;
; 692  :                 } while (*str++);

  000a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000a3	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  000a7	41 ff c0	 inc	 r8d
  000aa	84 c0		 test	 al, al
  000ac	75 f2		 jne	 SHORT $LL9@deflateBou
  000ae	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
$LN8@deflateBou:

; 693  :             if (s->gzhead->hcrc)

  000b2	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  000b6	74 21		 je	 SHORT $LN2@deflateBou

; 694  :                 wraplen += 2;

  000b8	41 83 c0 02	 add	 r8d, 2

; 695  :         }
; 696  :         break;

  000bc	eb 1b		 jmp	 SHORT $LN2@deflateBou
$LN12@deflateBou:

; 672  :         break;
; 673  :     case 1:                                 /* zlib wrapper */
; 674  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000be	83 ba 94 00 00
	00 00		 cmp	 DWORD PTR [rdx+148], 0
  000c5	b8 0a 00 00 00	 mov	 eax, 10
  000ca	41 b8 06 00 00
	00		 mov	 r8d, 6
  000d0	44 0f 45 c0	 cmovne	 r8d, eax

; 675  :         break;

  000d4	eb 03		 jmp	 SHORT $LN2@deflateBou
$LN11@deflateBou:

; 670  :     case 0:                                 /* raw deflate */
; 671  :         wraplen = 0;

  000d6	45 33 c0	 xor	 r8d, r8d
$LN2@deflateBou:

; 700  :     }
; 701  : 
; 702  :     /* if not default parameters, return conservative bound */
; 703  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000d9	83 7a 48 0f	 cmp	 DWORD PTR [rdx+72], 15
  000dd	75 2a		 jne	 SHORT $LN21@deflateBou
  000df	83 7a 78 0f	 cmp	 DWORD PTR [rdx+120], 15
  000e3	75 24		 jne	 SHORT $LN21@deflateBou

; 705  : 
; 706  :     /* default settings: return tight bound for that case */
; 707  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +

  000e5	41 8b d1	 mov	 edx, r9d
  000e8	41 8b c9	 mov	 ecx, r9d
  000eb	c1 ea 0e	 shr	 edx, 14
  000ee	41 8b c1	 mov	 eax, r9d
  000f1	c1 e8 0c	 shr	 eax, 12
  000f4	41 03 d0	 add	 edx, r8d
  000f7	c1 e9 19	 shr	 ecx, 25
  000fa	83 c0 07	 add	 eax, 7
  000fd	03 d1		 add	 edx, ecx
  000ff	03 c2		 add	 eax, edx
  00101	41 03 c1	 add	 eax, r9d

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  00104	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00108	c3		 ret	 0
$LN21@deflateBou:

; 704  :         return complen + wraplen;

  00109	43 8d 04 18	 lea	 eax, DWORD PTR [r8+r11]

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  0010d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00111	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 720  :     put_byte(s, (Byte)(b >> 8));

  00000	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00004	44 8b ca	 mov	 r9d, edx
  00007	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0000b	41 c1 e9 08	 shr	 r9d, 8
  0000f	45 88 0c 00	 mov	 BYTE PTR [r8+rax], r9b
  00013	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00016	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]

; 721  :     put_byte(s, (Byte)(b & 0xff));

  0001a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001e	41 88 14 00	 mov	 BYTE PTR [r8+rax], dl
  00022	ff 41 28	 inc	 DWORD PTR [rcx+40]

; 722  : }

  00025	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT flush_pending
_TEXT	SEGMENT
strm$ = 48
flush_pending PROC					; COMDAT

; 732  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 733  :     unsigned len;
; 734  :     deflate_state *s = strm->state;

  0000f	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00013	48 8b f1	 mov	 rsi, rcx

; 735  : 
; 736  :     _tr_flush_bits(s);

  00016	48 8b cb	 mov	 rcx, rbx
  00019	e8 00 00 00 00	 call	 _tr_flush_bits

; 737  :     len = s->pending;
; 738  :     if (len > strm->avail_out) len = strm->avail_out;

  0001e	8b 7e 18	 mov	 edi, DWORD PTR [rsi+24]

; 739  :     if (len == 0) return;

  00021	39 7b 28	 cmp	 DWORD PTR [rbx+40], edi
  00024	0f 46 7b 28	 cmovbe	 edi, DWORD PTR [rbx+40]
  00028	85 ff		 test	 edi, edi
  0002a	74 2d		 je	 SHORT $LN4@flush_pend

; 740  : 
; 741  :     zmemcpy(strm->next_out, s->pending_out, len);

  0002c	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00030	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00034	44 8b c7	 mov	 r8d, edi
  00037	e8 00 00 00 00	 call	 memcpy

; 742  :     strm->next_out  += len;

  0003c	8b c7		 mov	 eax, edi
  0003e	48 01 46 10	 add	 QWORD PTR [rsi+16], rax

; 743  :     s->pending_out  += len;

  00042	48 01 43 20	 add	 QWORD PTR [rbx+32], rax

; 744  :     strm->total_out += len;

  00046	01 7e 1c	 add	 DWORD PTR [rsi+28], edi

; 745  :     strm->avail_out -= len;

  00049	29 7e 18	 sub	 DWORD PTR [rsi+24], edi

; 746  :     s->pending      -= len;

  0004c	29 7b 28	 sub	 DWORD PTR [rbx+40], edi

; 747  :     if (s->pending == 0) {

  0004f	75 08		 jne	 SHORT $LN4@flush_pend

; 748  :         s->pending_out = s->pending_buf;

  00051	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00055	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
$LN4@flush_pend:

; 749  :     }
; 750  : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateCopy
_TEXT	SEGMENT
dest$ = 48
source$ = 56
deflateCopy PROC					; COMDAT

; 1105 : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	4c 8b c2	 mov	 r8, rdx

; 1106 : #ifdef MAXSEG_64K
; 1107 :     return Z_STREAM_ERROR;
; 1108 : #else
; 1109 :     deflate_state *ds;
; 1110 :     deflate_state *ss;
; 1111 :     ushf *overlay;
; 1112 : 
; 1113 : 
; 1114 :     if (deflateStateCheck(source) || dest == Z_NULL) {

  0000c	48 8b ca	 mov	 rcx, rdx
  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	0f 85 e7 01 00
	00		 jne	 $LN3@deflateCop
  0001c	48 85 db	 test	 rbx, rbx
  0001f	0f 84 de 01 00
	00		 je	 $LN3@deflateCop

; 1116 :     }
; 1117 : 
; 1118 :     ss = source->state;
; 1119 : 
; 1120 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00025	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00029	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 1121 : 
; 1122 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0002e	8d 50 01	 lea	 edx, QWORD PTR [rax+1]
  00031	49 8b 70 28	 mov	 rsi, QWORD PTR [r8+40]
  00035	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00038	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003d	41 0f 10 48 10	 movups	 xmm1, XMMWORD PTR [r8+16]
  00042	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
  00046	41 0f 10 40 20	 movups	 xmm0, XMMWORD PTR [r8+32]
  0004b	0f 11 43 20	 movups	 XMMWORD PTR [rbx+32], xmm0
  0004f	41 0f 10 48 30	 movups	 xmm1, XMMWORD PTR [r8+48]
  00054	0f 11 4b 30	 movups	 XMMWORD PTR [rbx+48], xmm1
  00058	41 0f 10 40 40	 movups	 xmm0, XMMWORD PTR [r8+64]
  0005d	0f 11 43 40	 movups	 XMMWORD PTR [rbx+64], xmm0
  00061	f2 41 0f 10 48
	50		 movsd	 xmm1, QWORD PTR [r8+80]
  00067	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0006d	f2 0f 11 4b 50	 movsd	 QWORD PTR [rbx+80], xmm1
  00072	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00076	ff 53 30	 call	 QWORD PTR [rbx+48]
  00079	48 8b f8	 mov	 rdi, rax

; 1123 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  0007c	48 85 c0	 test	 rax, rax
  0007f	75 13		 jne	 SHORT $LN4@deflateCop
  00081	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00086	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
  00089	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
$LN4@deflateCop:

; 1124 :     dest->state = (struct internal_state FAR *) ds;
; 1125 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  00094	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0009a	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0009f	48 8b d6	 mov	 rdx, rsi
  000a2	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi
  000a6	48 8b cf	 mov	 rcx, rdi
  000a9	e8 00 00 00 00	 call	 memcpy

; 1126 :     ds->strm = dest;
; 1127 : 
; 1128 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000ae	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  000b1	41 b8 02 00 00
	00		 mov	 r8d, 2
  000b7	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000ba	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000be	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1129 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000c1	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  000c4	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ca	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  000ce	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d2	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1130 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  000d5	8b 57 74	 mov	 edx, DWORD PTR [rdi+116]
  000d8	41 b8 02 00 00
	00		 mov	 r8d, 2
  000de	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  000e2	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000e6	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1131 :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  000e9	8b 97 f0 16 00
	00		 mov	 edx, DWORD PTR [rdi+5872]
  000ef	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f5	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  000f9	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000fd	ff 53 30	 call	 QWORD PTR [rbx+48]

; 1132 :     ds->pending_buf = (uchf *) overlay;
; 1133 : 
; 1134 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||

  00100	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00104	4c 8b f0	 mov	 r14, rax
  00107	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0010b	48 85 c9	 test	 rcx, rcx
  0010e	0f 84 e0 00 00
	00		 je	 $LN6@deflateCop
  00114	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  00119	0f 84 d5 00 00
	00		 je	 $LN6@deflateCop
  0011f	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  00124	0f 84 ca 00 00
	00		 je	 $LN6@deflateCop
  0012a	48 85 c0	 test	 rax, rax
  0012d	0f 84 c1 00 00
	00		 je	 $LN6@deflateCop

; 1138 :     }
; 1139 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1140 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  00133	8b 47 44	 mov	 eax, DWORD PTR [rdi+68]
  00136	48 8b 56 50	 mov	 rdx, QWORD PTR [rsi+80]
  0013a	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  0013e	e8 00 00 00 00	 call	 memcpy

; 1141 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  00143	44 8b 47 44	 mov	 r8d, DWORD PTR [rdi+68]
  00147	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  0014b	4d 03 c0	 add	 r8, r8
  0014e	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00152	e8 00 00 00 00	 call	 memcpy

; 1142 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  00157	44 8b 47 74	 mov	 r8d, DWORD PTR [rdi+116]
  0015b	48 8b 56 68	 mov	 rdx, QWORD PTR [rsi+104]
  0015f	4d 03 c0	 add	 r8, r8
  00162	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00166	e8 00 00 00 00	 call	 memcpy

; 1143 :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0016b	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  0016f	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  00173	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00177	e8 00 00 00 00	 call	 memcpy

; 1144 : 
; 1145 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0017c	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00180	48 2b 46 10	 sub	 rax, QWORD PTR [rsi+16]

; 1146 :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00184	8b 8f f0 16 00
	00		 mov	 ecx, DWORD PTR [rdi+5872]
  0018a	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0018e	48 03 c2	 add	 rax, rdx
  00191	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00195	8b c1		 mov	 eax, ecx
  00197	48 d1 e8	 shr	 rax, 1
  0019a	49 8d 04 46	 lea	 rax, QWORD PTR [r14+rax*2]
  0019e	48 89 87 f8 16
	00 00		 mov	 QWORD PTR [rdi+5880], rax

; 1147 :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  001a5	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  001a9	48 03 c8	 add	 rcx, rax

; 1148 : 
; 1149 :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  001ac	48 8d 87 bc 00
	00 00		 lea	 rax, QWORD PTR [rdi+188]
  001b3	48 89 87 40 0b
	00 00		 mov	 QWORD PTR [rdi+2880], rax

; 1150 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  001ba	48 8d 87 b0 09
	00 00		 lea	 rax, QWORD PTR [rdi+2480]
  001c1	48 89 87 58 0b
	00 00		 mov	 QWORD PTR [rdi+2904], rax

; 1151 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  001c8	48 8d 87 a4 0a
	00 00		 lea	 rax, QWORD PTR [rdi+2724]
  001cf	48 89 87 70 0b
	00 00		 mov	 QWORD PTR [rdi+2928], rax

; 1152 : 
; 1153 :     return Z_OK;

  001d6	33 c0		 xor	 eax, eax
  001d8	48 89 8f e8 16
	00 00		 mov	 QWORD PTR [rdi+5864], rcx
$LN10@deflateCop:
  001df	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  001e4	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  001e9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  001ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f2	5b		 pop	 rbx
  001f3	c3		 ret	 0
$LN6@deflateCop:

; 1135 :         ds->pending_buf == Z_NULL) {
; 1136 :         deflateEnd (dest);

  001f4	48 8b cb	 mov	 rcx, rbx
  001f7	e8 00 00 00 00	 call	 deflateEnd

; 1137 :         return Z_MEM_ERROR;

  001fc	b8 fc ff ff ff	 mov	 eax, -4
  00201	eb dc		 jmp	 SHORT $LN10@deflateCop
$LN3@deflateCop:

; 1115 :         return Z_STREAM_ERROR;

  00203	b8 fe ff ff ff	 mov	 eax, -2

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  00208	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0020c	5b		 pop	 rbx
  0020d	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT read_buf
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
size$ = 64
read_buf PROC						; COMDAT

; 1168 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1169 :     unsigned len = strm->avail_in;

  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	48 8b f2	 mov	 rsi, rdx

; 1170 : 
; 1171 :     if (len > size) len = size;

  00015	41 3b c0	 cmp	 eax, r8d
  00018	8b f8		 mov	 edi, eax
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 0f 47 f8	 cmova	 edi, r8d

; 1172 :     if (len == 0) return 0;

  00021	85 ff		 test	 edi, edi
  00023	75 12		 jne	 SHORT $LN3@read_buf
  00025	33 c0		 xor	 eax, eax

; 1189 : }

  00027	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN3@read_buf:

; 1173 : 
; 1174 :     strm->avail_in  -= len;
; 1175 : 
; 1176 :     zmemcpy(buf, strm->next_in, len);

  00037	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0003a	2b c7		 sub	 eax, edi
  0003c	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00047	44 8b c7	 mov	 r8d, edi
  0004a	8b ef		 mov	 ebp, edi
  0004c	e8 00 00 00 00	 call	 memcpy

; 1177 :     if (strm->state->wrap == 1) {

  00051	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00055	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00058	83 f9 01	 cmp	 ecx, 1
  0005b	75 10		 jne	 SHORT $LN4@read_buf

; 1178 :         strm->adler = adler32(strm->adler, buf, len);

  0005d	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00060	44 8b c7	 mov	 r8d, edi
  00063	48 8b d6	 mov	 rdx, rsi
  00066	e8 00 00 00 00	 call	 adler32

; 1179 :     }

  0006b	eb 13		 jmp	 SHORT $LN8@read_buf
$LN4@read_buf:

; 1180 : #ifdef GZIP
; 1181 :     else if (strm->state->wrap == 2) {

  0006d	83 f9 02	 cmp	 ecx, 2
  00070	75 11		 jne	 SHORT $LN6@read_buf

; 1182 :         strm->adler = crc32(strm->adler, buf, len);

  00072	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00075	44 8b c7	 mov	 r8d, edi
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	e8 00 00 00 00	 call	 crc32
$LN8@read_buf:

; 1183 :     }
; 1184 : #endif
; 1185 :     strm->next_in  += len;

  00080	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN6@read_buf:
  00083	48 01 2b	 add	 QWORD PTR [rbx], rbp

; 1186 :     strm->total_in += len;
; 1187 : 
; 1188 :     return len;

  00086	8b c7		 mov	 eax, edi
  00088	01 7b 0c	 add	 DWORD PTR [rbx+12], edi

; 1189 : }

  0008b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00090	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1196 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1197 :     s->window_size = (ulg)2L*s->w_size;

  0000a	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]
  0000d	48 8b d9	 mov	 rbx, rcx

; 1198 : 
; 1199 :     CLEAR_HASH(s);

  00010	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00013	03 c0		 add	 eax, eax
  00015	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  00018	ff ca		 dec	 edx
  0001a	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0001e	33 ff		 xor	 edi, edi
  00020	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00024	33 d2		 xor	 edx, edx
  00026	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  0002a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0002e	41 ff c8	 dec	 r8d
  00031	4d 03 c0	 add	 r8, r8
  00034	e8 00 00 00 00	 call	 memset

; 1200 : 
; 1201 :     /* Set the default configuration parameters:
; 1202 :      */
; 1203 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00039	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:configuration_table
  00047	48 03 c9	 add	 rcx, rcx
  0004a	0f b7 44 ca 02	 movzx	 eax, WORD PTR [rdx+rcx*8+2]
  0004f	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 1204 :     s->good_match       = configuration_table[s->level].good_length;

  00055	0f b7 04 ca	 movzx	 eax, WORD PTR [rdx+rcx*8]
  00059	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 1205 :     s->nice_match       = configuration_table[s->level].nice_length;

  0005f	0f b7 44 ca 04	 movzx	 eax, WORD PTR [rdx+rcx*8+4]
  00064	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 1206 :     s->max_chain_length = configuration_table[s->level].max_chain;

  0006a	0f b7 44 ca 06	 movzx	 eax, WORD PTR [rdx+rcx*8+6]
  0006f	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax

; 1207 : 
; 1208 :     s->strstart = 0;
; 1209 :     s->block_start = 0L;
; 1210 :     s->lookahead = 0;
; 1211 :     s->insert = 0;
; 1212 :     s->match_length = s->prev_length = MIN_MATCH-1;
; 1213 :     s->match_available = 0;

  00075	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  0007c	89 bb 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edi
  00082	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  00088	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi
  0008e	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  00098	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2

; 1214 :     s->ins_h = 0;

  000a2	89 7b 70	 mov	 DWORD PTR [rbx+112], edi

; 1215 : #ifndef FASTEST
; 1216 : #ifdef ASMV
; 1217 :     match_init(); /* initialize the asm code */
; 1218 : #endif
; 1219 : #endif
; 1220 : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT longest_match
_TEXT	SEGMENT
s$ = 40
cur_match$ = 48
longest_match PROC					; COMDAT

; 1239 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 1240 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */
; 1241 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	44 8b 89 94 00
	00 00		 mov	 r9d, DWORD PTR [rcx+148]
  00023	48 8b e9	 mov	 rbp, rcx
  00026	44 8b 91 a4 00
	00 00		 mov	 r10d, DWORD PTR [rcx+164]

; 1242 :     register Bytef *match;                      /* matched string */
; 1243 :     register int len;                           /* length of current match */
; 1244 :     int best_len = (int)s->prev_length;         /* best match length so far */
; 1245 :     int nice_match = s->nice_match;             /* stop if match long enough */
; 1246 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?

  0002d	45 33 ff	 xor	 r15d, r15d
  00030	48 63 99 a0 00
	00 00		 movsxd	 rbx, DWORD PTR [rcx+160]
  00037	44 8b da	 mov	 r11d, edx
  0003a	44 8b b1 b8 00
	00 00		 mov	 r14d, DWORD PTR [rcx+184]
  00041	4c 8b 61 50	 mov	 r12, QWORD PTR [rcx+80]
  00045	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]
  00048	41 8b c9	 mov	 ecx, r9d
  0004b	2b c8		 sub	 ecx, eax
  0004d	81 c1 06 01 00
	00		 add	 ecx, 262		; 00000106H
  00053	4f 8d 2c 21	 lea	 r13, QWORD PTR [r9+r12]

; 1247 :         s->strstart - (IPos)MAX_DIST(s) : NIL;
; 1248 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1249 :      * we prevent matches with the string of window index 0.
; 1250 :      */
; 1251 :     Posf *prev = s->prev;
; 1252 :     uInt wmask = s->w_mask;
; 1253 : 
; 1254 : #ifdef UNALIGNED_OK
; 1255 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1256 :      * Try with and without -DUNALIGNED_OK to check.
; 1257 :      */
; 1258 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1259 :     register ush scan_start = *(ushf*)scan;
; 1260 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1261 : #else
; 1262 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
; 1263 :     register Byte scan_end1  = scan[best_len-1];

  00057	42 0f b6 7c 2b
	ff		 movzx	 edi, BYTE PTR [rbx+r13-1]
  0005d	8d 90 fa fe ff
	ff		 lea	 edx, DWORD PTR [rax-262]

; 1264 :     register Byte scan_end   = scan[best_len];

  00063	42 0f b6 34 2b	 movzx	 esi, BYTE PTR [rbx+r13]
  00068	44 3b ca	 cmp	 r9d, edx

; 1265 : #endif
; 1266 : 
; 1267 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1268 :      * It is easy to get rid of this optimization if necessary.
; 1269 :      */
; 1270 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1271 : 
; 1272 :     /* Do not waste too much time if we already have a good match: */
; 1273 :     if (s->prev_length >= s->good_match) {
; 1274 :         chain_length >>= 2;
; 1275 :     }
; 1276 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1277 :      * to make deflate deterministic.
; 1278 :      */
; 1279 :     if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;

  0006b	45 8b ca	 mov	 r9d, r10d
  0006e	49 8d 95 02 01
	00 00		 lea	 rdx, QWORD PTR [r13+258]
  00075	44 0f 47 f9	 cmova	 r15d, ecx
  00079	4d 8b c5	 mov	 r8, r13
  0007c	41 c1 e9 02	 shr	 r9d, 2
  00080	3b 9d b4 00 00
	00		 cmp	 ebx, DWORD PTR [rbp+180]
  00086	45 0f 42 ca	 cmovb	 r9d, r10d
  0008a	44 8b 95 9c 00
	00 00		 mov	 r10d, DWORD PTR [rbp+156]
  00091	45 3b f2	 cmp	 r14d, r10d
  00094	45 0f 47 f2	 cmova	 r14d, r10d
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@longest_ma:

; 1280 : 
; 1281 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1282 : 
; 1283 :     do {
; 1284 :         Assert(cur_match < s->strstart, "no future");
; 1285 :         match = s->window + cur_match;

  000a0	41 8b cb	 mov	 ecx, r11d
  000a3	49 03 cc	 add	 rcx, r12

; 1286 : 
; 1287 :         /* Skip to next match if the match length cannot increase
; 1288 :          * or if the match length is less than 2.  Note that the checks below
; 1289 :          * for insufficient lookahead only occur occasionally for performance
; 1290 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1291 :          * conditional jumps will be made that depend on those values.
; 1292 :          * However the length of the match is limited to the lookahead, so
; 1293 :          * the output of deflate is not affected by the uninitialized values.
; 1294 :          */
; 1295 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1296 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1297 :          * UNALIGNED_OK if your compiler uses a different size.
; 1298 :          */
; 1299 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1300 :             *(ushf*)match != scan_start) continue;
; 1301 : 
; 1302 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1303 :          * always equal when the other bytes match, given that the hash keys
; 1304 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1305 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1306 :          * lookahead only every 4th comparison; the 128th check will be made
; 1307 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1308 :          * necessary to put more guard bytes at the end of the window, or
; 1309 :          * to check more often for insufficient lookahead.
; 1310 :          */
; 1311 :         Assert(scan[2] == match[2], "scan[2]?");
; 1312 :         scan++, match++;
; 1313 :         do {
; 1314 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1315 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1316 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1317 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1318 :                  scan < strend);
; 1319 :         /* The funny "do {}" generates better code on most compilers */
; 1320 : 
; 1321 :         /* Here, scan <= window+strstart+257 */
; 1322 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1323 :         if (*scan == *match) scan++;
; 1324 : 
; 1325 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1326 :         scan = strend - (MAX_MATCH-1);
; 1327 : 
; 1328 : #else /* UNALIGNED_OK */
; 1329 : 
; 1330 :         if (match[best_len]   != scan_end  ||
; 1331 :             match[best_len-1] != scan_end1 ||
; 1332 :             *match            != *scan     ||

  000a6	48 63 c3	 movsxd	 rax, ebx
  000a9	40 38 34 08	 cmp	 BYTE PTR [rax+rcx], sil
  000ad	0f 85 c8 00 00
	00		 jne	 $LN2@longest_ma
  000b3	40 38 7c 01 ff	 cmp	 BYTE PTR [rcx+rax-1], dil
  000b8	0f 85 bd 00 00
	00		 jne	 $LN2@longest_ma
  000be	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000c2	38 01		 cmp	 BYTE PTR [rcx], al
  000c4	0f 85 b1 00 00
	00		 jne	 $LN2@longest_ma
  000ca	41 0f b6 40 01	 movzx	 eax, BYTE PTR [r8+1]
  000cf	38 41 01	 cmp	 BYTE PTR [rcx+1], al
  000d2	0f 85 a3 00 00
	00		 jne	 $LN2@longest_ma

; 1333 :             *++match          != scan[1])      continue;
; 1334 : 
; 1335 :         /* The check at best_len-1 can be removed because it will be made
; 1336 :          * again later. (This heuristic is not always a win.)
; 1337 :          * It is not necessary to compare scan[2] and match[2] since they
; 1338 :          * are always equal when the other bytes match, given that
; 1339 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1340 :          */
; 1341 :         scan += 2, match++;

  000d8	49 83 c0 02	 add	 r8, 2
  000dc	48 83 c1 02	 add	 rcx, 2
$LL7@longest_ma:

; 1342 :         Assert(*scan == *match, "match[2]?");
; 1343 : 
; 1344 :         /* We check for insufficient lookahead only every 8th comparison;
; 1345 :          * the 256th check will be made at strstart+258.
; 1346 :          */
; 1347 :         do {
; 1348 :         } while (*++scan == *++match && *++scan == *++match &&
; 1349 :                  *++scan == *++match && *++scan == *++match &&
; 1350 :                  *++scan == *++match && *++scan == *++match &&
; 1351 :                  *++scan == *++match && *++scan == *++match &&

  000e0	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000e4	49 ff c0	 inc	 r8
  000e7	41 38 00	 cmp	 BYTE PTR [r8], al
  000ea	75 5d		 jne	 SHORT $LN12@longest_ma
  000ec	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  000f0	49 ff c0	 inc	 r8
  000f3	41 38 00	 cmp	 BYTE PTR [r8], al
  000f6	75 51		 jne	 SHORT $LN12@longest_ma
  000f8	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  000fc	49 ff c0	 inc	 r8
  000ff	41 38 00	 cmp	 BYTE PTR [r8], al
  00102	75 45		 jne	 SHORT $LN12@longest_ma
  00104	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  00108	49 ff c0	 inc	 r8
  0010b	41 38 00	 cmp	 BYTE PTR [r8], al
  0010e	75 39		 jne	 SHORT $LN12@longest_ma
  00110	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  00114	49 ff c0	 inc	 r8
  00117	41 38 00	 cmp	 BYTE PTR [r8], al
  0011a	75 2d		 jne	 SHORT $LN12@longest_ma
  0011c	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]
  00120	49 ff c0	 inc	 r8
  00123	41 38 00	 cmp	 BYTE PTR [r8], al
  00126	75 21		 jne	 SHORT $LN12@longest_ma
  00128	0f b6 41 07	 movzx	 eax, BYTE PTR [rcx+7]
  0012c	49 ff c0	 inc	 r8
  0012f	41 38 00	 cmp	 BYTE PTR [r8], al
  00132	75 15		 jne	 SHORT $LN12@longest_ma
  00134	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]
  00138	48 83 c1 08	 add	 rcx, 8
  0013c	49 ff c0	 inc	 r8
  0013f	41 38 00	 cmp	 BYTE PTR [r8], al
  00142	75 05		 jne	 SHORT $LN12@longest_ma
  00144	4c 3b c2	 cmp	 r8, rdx
  00147	72 97		 jb	 SHORT $LL7@longest_ma
$LN12@longest_ma:

; 1352 :                  scan < strend);
; 1353 : 
; 1354 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1355 : 
; 1356 :         len = MAX_MATCH - (int)(strend - scan);

  00149	44 2b c2	 sub	 r8d, edx
  0014c	49 63 c0	 movsxd	 rax, r8d
  0014f	41 8d 88 02 01
	00 00		 lea	 ecx, DWORD PTR [r8+258]

; 1357 :         scan = strend - MAX_MATCH;

  00156	4d 8b c5	 mov	 r8, r13

; 1358 : 
; 1359 : #endif /* UNALIGNED_OK */
; 1360 : 
; 1361 :         if (len > best_len) {

  00159	3b cb		 cmp	 ecx, ebx
  0015b	7e 1e		 jle	 SHORT $LN2@longest_ma

; 1362 :             s->match_start = cur_match;

  0015d	44 89 9d 98 00
	00 00		 mov	 DWORD PTR [rbp+152], r11d

; 1363 :             best_len = len;

  00164	8b d9		 mov	 ebx, ecx

; 1364 :             if (len >= nice_match) break;

  00166	41 3b ce	 cmp	 ecx, r14d
  00169	7d 31		 jge	 SHORT $LN3@longest_ma

; 1365 : #ifdef UNALIGNED_OK
; 1366 :             scan_end = *(ushf*)(scan+best_len-1);
; 1367 : #else
; 1368 :             scan_end1  = scan[best_len-1];

  0016b	0f b6 7c 10 ff	 movzx	 edi, BYTE PTR [rax+rdx-1]

; 1369 :             scan_end   = scan[best_len];

  00170	48 63 c1	 movsxd	 rax, ecx
  00173	0f b6 b4 10 fe
	fe ff ff	 movzx	 esi, BYTE PTR [rax+rdx-258]
$LN2@longest_ma:

; 1370 : #endif
; 1371 :         }
; 1372 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1373 :              && --chain_length != 0);

  0017b	8b 4d 4c	 mov	 ecx, DWORD PTR [rbp+76]
  0017e	41 8b c3	 mov	 eax, r11d
  00181	48 23 c8	 and	 rcx, rax
  00184	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  00188	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
  0018d	45 3b df	 cmp	 r11d, r15d
  00190	76 0a		 jbe	 SHORT $LN3@longest_ma
  00192	41 83 c1 ff	 add	 r9d, -1			; ffffffffH
  00196	0f 85 04 ff ff
	ff		 jne	 $LL4@longest_ma
$LN3@longest_ma:

; 1374 : 
; 1375 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
; 1376 :     return s->lookahead;
; 1377 : }

  0019c	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001a1	41 3b da	 cmp	 ebx, r10d
  001a4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001a9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001ae	44 0f 46 d3	 cmovbe	 r10d, ebx
  001b2	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  001b7	41 8b c2	 mov	 eax, r10d
  001ba	41 5f		 pop	 r15
  001bc	41 5e		 pop	 r14
  001be	41 5d		 pop	 r13
  001c0	41 5c		 pop	 r12
  001c2	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT fill_window
_TEXT	SEGMENT
s$ = 48
fill_window PROC					; COMDAT

; 1484 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1485 :     unsigned n;
; 1486 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1487 :     uInt wsize = s->w_size;

  0000f	8b 71 44	 mov	 esi, DWORD PTR [rcx+68]
  00012	48 8b d9	 mov	 rbx, rcx
  00015	44 8b 89 9c 00
	00 00		 mov	 r9d, DWORD PTR [rcx+156]
  0001c	0f 1f 40 00	 npad	 4
$LL4@fill_windo:

; 1488 : 
; 1489 :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 1490 : 
; 1491 :     do {
; 1492 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00020	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00026	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]

; 1493 : 
; 1494 :         /* Deal with !@#$% 64K limit: */
; 1495 :         if (sizeof(int) <= 2) {
; 1496 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1497 :                 more = wsize;
; 1498 : 
; 1499 :             } else if (more == (unsigned)(-1)) {
; 1500 :                 /* Very unlikely, but possible on 16 bit machine if
; 1501 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1502 :                  */
; 1503 :                 more--;
; 1504 :             }
; 1505 :         }
; 1506 : 
; 1507 :         /* If the window is almost full and there is insufficient lookahead,
; 1508 :          * move the upper half to the lower one to make room in the upper half.
; 1509 :          */
; 1510 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  00029	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  0002c	2b fa		 sub	 edi, edx
  0002e	81 c1 fa fe ff
	ff		 add	 ecx, -262		; fffffefaH
  00034	41 2b f9	 sub	 edi, r9d
  00037	03 ce		 add	 ecx, esi
  00039	3b d1		 cmp	 edx, ecx
  0003b	72 2f		 jb	 SHORT $LN11@fill_windo

; 1511 : 
; 1512 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);

  0003d	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00041	44 8b c6	 mov	 r8d, esi
  00044	44 2b c7	 sub	 r8d, edi
  00047	48 8d 14 31	 lea	 rdx, QWORD PTR [rcx+rsi]
  0004b	e8 00 00 00 00	 call	 memcpy

; 1513 :             s->match_start -= wsize;

  00050	29 b3 98 00 00
	00		 sub	 DWORD PTR [rbx+152], esi

; 1514 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1515 :             s->block_start -= (long) wsize;
; 1516 :             slide_hash(s);

  00056	48 8b cb	 mov	 rcx, rbx
  00059	29 b3 94 00 00
	00		 sub	 DWORD PTR [rbx+148], esi
  0005f	29 b3 84 00 00
	00		 sub	 DWORD PTR [rbx+132], esi
  00065	e8 00 00 00 00	 call	 slide_hash

; 1517 :             more += wsize;

  0006a	03 fe		 add	 edi, esi
$LN11@fill_windo:

; 1518 :         }
; 1519 :         if (s->strm->avail_in == 0) break;

  0006c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006f	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00073	0f 84 0b 01 00
	00		 je	 $LN3@fill_windo

; 1520 : 
; 1521 :         /* If there was no sliding:
; 1522 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1523 :          *    more == window_size - lookahead - strstart
; 1524 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1525 :          * => more >= window_size - 2*WSIZE + 2
; 1526 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1527 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1528 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1529 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1530 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1531 :          */
; 1532 :         Assert(more >= 2, "more < 2");
; 1533 : 
; 1534 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  00079	8b 93 9c 00 00
	00		 mov	 edx, DWORD PTR [rbx+156]
  0007f	44 8b c7	 mov	 r8d, edi
  00082	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00088	48 03 d0	 add	 rdx, rax
  0008b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0008f	e8 00 00 00 00	 call	 read_buf

; 1535 :         s->lookahead += n;

  00094	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]

; 1536 : 
; 1537 :         /* Initialize the hash value now that we have some input: */
; 1538 :         if (s->lookahead + s->insert >= MIN_MATCH) {

  0009b	44 8b 9b 0c 17
	00 00		 mov	 r11d, DWORD PTR [rbx+5900]
  000a2	44 03 c8	 add	 r9d, eax
  000a5	44 89 8b 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r9d
  000ac	43 8d 04 0b	 lea	 eax, DWORD PTR [r11+r9]
  000b0	83 f8 03	 cmp	 eax, 3
  000b3	0f 82 b5 00 00
	00		 jb	 $LN2@fill_windo

; 1539 :             uInt str = s->strstart - s->insert;

  000b9	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 1540 :             s->ins_h = s->window[str];

  000c0	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  000c4	45 2b d3	 sub	 r10d, r11d

; 1541 :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  000c7	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000cd	45 0f b6 04 12	 movzx	 r8d, BYTE PTR [r10+rdx]
  000d2	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000d6	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000da	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000de	41 d3 e0	 shl	 r8d, cl
  000e1	41 33 c0	 xor	 eax, r8d
  000e4	23 43 7c	 and	 eax, DWORD PTR [rbx+124]
  000e7	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 1542 : #if MIN_MATCH != 3
; 1543 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1544 : #endif
; 1545 :             while (s->insert) {

  000ea	45 85 db	 test	 r11d, r11d
  000ed	74 7f		 je	 SHORT $LN2@fill_windo

; 1539 :             uInt str = s->strstart - s->insert;

  000ef	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
  000f3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@fill_windo:

; 1546 :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00100	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00104	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 1547 : #ifndef FASTEST
; 1548 :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  0010a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0010e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00112	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]

; 1549 : #endif
; 1550 :                 s->head[s->ins_h] = (Pos)str;
; 1551 :                 str++;

  00117	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  0011b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0011e	d3 e0		 shl	 eax, cl
  00120	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00124	44 33 c8	 xor	 r9d, eax
  00127	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0012b	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  0012f	41 8b c2	 mov	 eax, r10d
  00132	4c 23 c0	 and	 r8, rax
  00135	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  0013a	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0013f	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00142	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00146	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0014b	41 ff c2	 inc	 r10d

; 1552 :                 s->insert--;

  0014e	ff 8b 0c 17 00
	00		 dec	 DWORD PTR [rbx+5900]
  00154	8b 8b 0c 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5900]

; 1553 :                 if (s->lookahead + s->insert < MIN_MATCH)

  0015a	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]
  00161	42 8d 04 09	 lea	 eax, DWORD PTR [rcx+r9]
  00165	83 f8 03	 cmp	 eax, 3
  00168	72 04		 jb	 SHORT $LN2@fill_windo

; 1542 : #if MIN_MATCH != 3
; 1543 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1544 : #endif
; 1545 :             while (s->insert) {

  0016a	85 c9		 test	 ecx, ecx
  0016c	75 92		 jne	 SHORT $LL5@fill_windo
$LN2@fill_windo:

; 1554 :                     break;
; 1555 :             }
; 1556 :         }
; 1557 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1558 :          * but this is not important since only literal bytes will be emitted.
; 1559 :          */
; 1560 : 
; 1561 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  0016e	41 81 f9 06 01
	00 00		 cmp	 r9d, 262		; 00000106H
  00175	73 0d		 jae	 SHORT $LN3@fill_windo
  00177	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0017a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0017e	0f 85 9c fe ff
	ff		 jne	 $LL4@fill_windo
$LN3@fill_windo:

; 1562 : 
; 1563 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1564 :      * written, then zero those bytes in order to avoid memory check reports of
; 1565 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1566 :      * the longest match routines.  Update the high water mark for the next
; 1567 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1568 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1569 :      */
; 1570 :     if (s->high_water < s->window_size) {

  00184	8b 8b 18 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5912]
  0018a	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  0018d	3b cf		 cmp	 ecx, edi
  0018f	73 72		 jae	 SHORT $LN20@fill_windo

; 1571 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  00191	8b b3 9c 00 00
	00		 mov	 esi, DWORD PTR [rbx+156]
  00197	03 b3 94 00 00
	00		 add	 esi, DWORD PTR [rbx+148]

; 1572 :         ulg init;
; 1573 : 
; 1574 :         if (s->high_water < curr) {

  0019d	3b ce		 cmp	 ecx, esi
  0019f	73 35		 jae	 SHORT $LN17@fill_windo

; 1575 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1576 :              * bytes or up to end of window, whichever is less.
; 1577 :              */
; 1578 :             init = s->window_size - curr;

  001a1	2b fe		 sub	 edi, esi

; 1579 :             if (init > WIN_INIT)
; 1580 :                 init = WIN_INIT;
; 1581 :             zmemzero(s->window + curr, (unsigned)init);

  001a3	8b ce		 mov	 ecx, esi
  001a5	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  001aa	3b f8		 cmp	 edi, eax
  001ac	0f 47 f8	 cmova	 edi, eax
  001af	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001b3	44 8b c7	 mov	 r8d, edi
  001b6	33 d2		 xor	 edx, edx
  001b8	e8 00 00 00 00	 call	 memset

; 1582 :             s->high_water = curr + init;

  001bd	8d 04 37	 lea	 eax, DWORD PTR [rdi+rsi]
  001c0	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax

; 1594 :         }
; 1595 :     }
; 1596 : 
; 1597 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1598 :            "not enough room for search");
; 1599 : }

  001c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001cb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d4	5f		 pop	 rdi
  001d5	c3		 ret	 0
$LN17@fill_windo:

; 1583 :         }
; 1584 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  001d6	8d 86 02 01 00
	00		 lea	 eax, DWORD PTR [rsi+258]
  001dc	3b c8		 cmp	 ecx, eax
  001de	73 23		 jae	 SHORT $LN20@fill_windo

; 1585 :             /* High water mark at or above current data, but below current data
; 1586 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1587 :              * to end of window, whichever is less.
; 1588 :              */
; 1589 :             init = (ulg)curr + WIN_INIT - s->high_water;
; 1590 :             if (init > s->window_size - s->high_water)

  001e0	2b f9		 sub	 edi, ecx
  001e2	2b f1		 sub	 esi, ecx
  001e4	8d 86 02 01 00
	00		 lea	 eax, DWORD PTR [rsi+258]

; 1591 :                 init = s->window_size - s->high_water;
; 1592 :             zmemzero(s->window + s->high_water, (unsigned)init);

  001ea	3b c7		 cmp	 eax, edi
  001ec	0f 46 f8	 cmovbe	 edi, eax
  001ef	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001f3	44 8b c7	 mov	 r8d, edi
  001f6	33 d2		 xor	 edx, edx
  001f8	e8 00 00 00 00	 call	 memset

; 1593 :             s->high_water += init;

  001fd	01 bb 18 17 00
	00		 add	 DWORD PTR [rbx+5912], edi
$LN20@fill_windo:

; 1594 :         }
; 1595 :     }
; 1596 : 
; 1597 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1598 :            "not enough room for search");
; 1599 : }

  00203	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00208	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0020d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00211	5f		 pop	 rdi
  00212	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_stored
_TEXT	SEGMENT
used$2$ = 80
s$ = 80
flush$ = 88
deflate_stored PROC					; COMDAT

; 1646 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1647 :     /* Smallest worthy block size when not flushing or finishing. By default
; 1648 :      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
; 1649 :      * large input and output buffers, the stored block size will be larger.
; 1650 :      */
; 1651 :     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);

  0000b	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000e	44 8b fa	 mov	 r15d, edx
  00011	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00016	83 c0 fb	 add	 eax, -5			; fffffffbH
  00019	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	44 8b 69 44	 mov	 r13d, DWORD PTR [rcx+68]

; 1652 : 
; 1653 :     /* Copy as many min_block or larger stored blocks directly to next_out as
; 1654 :      * possible. If flushing, copy the remaining available input to next_out as
; 1655 :      * stored blocks, if there is enough space.
; 1656 :      */
; 1657 :     unsigned len, left, have, last = 0;

  00025	41 3b c5	 cmp	 eax, r13d

; 1658 :     unsigned used = s->strm->avail_in;

  00028	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0002d	44 0f 46 e8	 cmovbe	 r13d, eax
  00031	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00036	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00039	45 33 f6	 xor	 r14d, r14d
  0003c	44 8b 60 08	 mov	 r12d, DWORD PTR [rax+8]
  00040	44 89 64 24 50	 mov	 DWORD PTR used$2$[rsp], r12d
  00045	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  0004b	0f 1f 44 00 00	 npad	 5
$LL4@deflate_st:

; 1659 :     do {
; 1660 :         /* Set len to the maximum size block that we can copy directly with the
; 1661 :          * available input data and output space. Set left to how much of that
; 1662 :          * would be copied from what's left in the window.
; 1663 :          */
; 1664 :         len = MAX_STORED;       /* maximum deflate stored block length */
; 1665 :         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00050	8b 83 14 17 00
	00		 mov	 eax, DWORD PTR [rbx+5908]

; 1666 :         if (s->strm->avail_out < have)          /* need room for header */

  00056	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00059	83 c0 2a	 add	 eax, 42			; 0000002aH
  0005c	c1 f8 03	 sar	 eax, 3
  0005f	8b 71 18	 mov	 esi, DWORD PTR [rcx+24]
  00062	3b f0		 cmp	 esi, eax
  00064	0f 82 27 01 00
	00		 jb	 $LN3@deflate_st

; 1667 :             break;
; 1668 :             /* maximum stored block length that will fit in avail_out: */
; 1669 :         have = s->strm->avail_out - have;
; 1670 :         left = s->strstart - s->block_start;    /* bytes left in window */

  0006a	8b ab 94 00 00
	00		 mov	 ebp, DWORD PTR [rbx+148]
  00070	2b f0		 sub	 esi, eax
  00072	2b ab 84 00 00
	00		 sub	 ebp, DWORD PTR [rbx+132]

; 1671 :         if (len > (ulg)left + s->strm->avail_in)

  00078	41 8b c4	 mov	 eax, r12d
  0007b	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0007e	03 cd		 add	 ecx, ebp
  00080	41 3b cc	 cmp	 ecx, r12d
  00083	0f 42 c1	 cmovb	 eax, ecx

; 1672 :             len = left + s->strm->avail_in;     /* limit len to the input */
; 1673 :         if (len > have)
; 1674 :             len = have;                         /* limit len to the output */
; 1675 : 
; 1676 :         /* If the stored block would be less than min_block in length, or if
; 1677 :          * unable to copy all of the available input when flushing, then try
; 1678 :          * copying to the window and the pending buffer instead. Also don't
; 1679 :          * write an empty block when flushing -- deflate() does that.
; 1680 :          */
; 1681 :         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||

  00086	3b c6		 cmp	 eax, esi
  00088	0f 46 f0	 cmovbe	 esi, eax
  0008b	41 3b f5	 cmp	 esi, r13d
  0008e	73 1f		 jae	 SHORT $LN47@deflate_st
  00090	85 f6		 test	 esi, esi
  00092	75 0a		 jne	 SHORT $LN10@deflate_st
  00094	41 83 ff 04	 cmp	 r15d, 4
  00098	0f 85 f3 00 00
	00		 jne	 $LN3@deflate_st
$LN10@deflate_st:
  0009e	45 85 ff	 test	 r15d, r15d
  000a1	0f 84 ea 00 00
	00		 je	 $LN3@deflate_st
  000a7	3b f1		 cmp	 esi, ecx
  000a9	0f 85 e2 00 00
	00		 jne	 $LN3@deflate_st
$LN47@deflate_st:

; 1682 :                                 flush == Z_NO_FLUSH ||
; 1683 :                                 len != left + s->strm->avail_in))
; 1684 :             break;
; 1685 : 
; 1686 :         /* Make a dummy stored block in pending to get the header bytes,
; 1687 :          * including any pending bits. This also updates the debugging counts.
; 1688 :          */
; 1689 :         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;

  000af	41 83 ff 04	 cmp	 r15d, 4
  000b3	75 0a		 jne	 SHORT $LN48@deflate_st
  000b5	3b f1		 cmp	 esi, ecx
  000b7	75 06		 jne	 SHORT $LN48@deflate_st
  000b9	45 8d 77 fd	 lea	 r14d, QWORD PTR [r15-3]
  000bd	eb 03		 jmp	 SHORT $LN34@deflate_st
$LN48@deflate_st:
  000bf	45 33 f6	 xor	 r14d, r14d
$LN34@deflate_st:

; 1690 :         _tr_stored_block(s, (char *)0, 0L, last);

  000c2	45 8b ce	 mov	 r9d, r14d
  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 _tr_stored_block

; 1691 : 
; 1692 :         /* Replace the lengths in the dummy stored block with len. */
; 1693 :         s->pending_buf[s->pending - 4] = len;

  000d2	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 1694 :         s->pending_buf[s->pending - 3] = len >> 8;

  000d5	8b d6		 mov	 edx, esi
  000d7	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000db	83 e9 04	 sub	 ecx, 4
  000de	c1 ea 08	 shr	 edx, 8
  000e1	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  000e5	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000e8	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ec	83 e9 03	 sub	 ecx, 3
  000ef	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1695 :         s->pending_buf[s->pending - 2] = ~len;

  000f2	40 0f b6 d6	 movzx	 edx, sil
  000f6	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000f9	f6 d2		 not	 dl
  000fb	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ff	83 e9 02	 sub	 ecx, 2
  00102	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1696 :         s->pending_buf[s->pending - 1] = ~len >> 8;

  00105	8b d6		 mov	 edx, esi
  00107	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0010a	f7 d2		 not	 edx
  0010c	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00110	ff c9		 dec	 ecx
  00112	c1 ea 08	 shr	 edx, 8
  00115	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1697 : 
; 1698 :         /* Write the stored block header bytes. */
; 1699 :         flush_pending(s->strm);

  00118	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0011b	e8 00 00 00 00	 call	 flush_pending

; 1700 : 
; 1701 : #ifdef ZLIB_DEBUG
; 1702 :         /* Update debugging counts for the data about to be copied. */
; 1703 :         s->compressed_len += len << 3;
; 1704 :         s->bits_sent += len << 3;
; 1705 : #endif
; 1706 : 
; 1707 :         /* Copy uncompressed bytes from the window to next_out. */
; 1708 :         if (left) {

  00120	85 ed		 test	 ebp, ebp
  00122	74 3c		 je	 SHORT $LN46@deflate_st

; 1709 :             if (left > len)
; 1710 :                 left = len;
; 1711 :             zmemcpy(s->strm->next_out, s->window + s->block_start, left);

  00124	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00127	3b ee		 cmp	 ebp, esi
  00129	48 63 93 84 00
	00 00		 movsxd	 rdx, DWORD PTR [rbx+132]
  00130	0f 47 ee	 cmova	 ebp, esi
  00133	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00137	44 8b c5	 mov	 r8d, ebp
  0013a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0013e	8b fd		 mov	 edi, ebp
  00140	e8 00 00 00 00	 call	 memcpy

; 1712 :             s->strm->next_out += left;

  00145	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00148	48 01 78 10	 add	 QWORD PTR [rax+16], rdi

; 1713 :             s->strm->avail_out -= left;

  0014c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0014f	29 68 18	 sub	 DWORD PTR [rax+24], ebp

; 1714 :             s->strm->total_out += left;

  00152	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00155	01 68 1c	 add	 DWORD PTR [rax+28], ebp

; 1715 :             s->block_start += left;

  00158	01 ab 84 00 00
	00		 add	 DWORD PTR [rbx+132], ebp

; 1716 :             len -= left;

  0015e	2b f5		 sub	 esi, ebp
$LN46@deflate_st:

; 1717 :         }
; 1718 : 
; 1719 :         /* Copy uncompressed bytes directly from next_in to next_out, updating
; 1720 :          * the check value.
; 1721 :          */
; 1722 :         if (len) {

  00160	85 f6		 test	 esi, esi
  00162	74 24		 je	 SHORT $LN2@deflate_st

; 1723 :             read_buf(s->strm, s->strm->next_out, len);

  00164	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00167	44 8b c6	 mov	 r8d, esi
  0016a	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0016e	e8 00 00 00 00	 call	 read_buf

; 1724 :             s->strm->next_out += len;

  00173	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00176	8b c6		 mov	 eax, esi
  00178	48 01 41 10	 add	 QWORD PTR [rcx+16], rax

; 1725 :             s->strm->avail_out -= len;

  0017c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0017f	29 70 18	 sub	 DWORD PTR [rax+24], esi

; 1726 :             s->strm->total_out += len;

  00182	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00185	01 70 1c	 add	 DWORD PTR [rax+28], esi
$LN2@deflate_st:

; 1727 :         }
; 1728 :     } while (last == 0);

  00188	45 85 f6	 test	 r14d, r14d
  0018b	0f 84 bf fe ff
	ff		 je	 $LL4@deflate_st
$LN3@deflate_st:

; 1729 : 
; 1730 :     /* Update the sliding window with the last s->w_size bytes of the copied
; 1731 :      * data, or append all of the copied data to the existing window if less
; 1732 :      * than s->w_size bytes were copied. Also update the number of bytes to
; 1733 :      * insert in the hash tables, in the event that deflateParams() switches to
; 1734 :      * a non-zero compression level.
; 1735 :      */
; 1736 :     used -= s->strm->avail_in;      /* number of input bytes directly copied */

  00191	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00194	44 8b 64 24 50	 mov	 r12d, DWORD PTR used$2$[rsp]
  00199	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  0019e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001a3	44 2b 60 08	 sub	 r12d, DWORD PTR [rax+8]

; 1737 :     if (used) {

  001a7	0f 84 b8 00 00
	00		 je	 $LN52@deflate_st

; 1738 :         /* If any input was used, then no unused input remains in the window,
; 1739 :          * therefore s->block_start == s->strstart.
; 1740 :          */
; 1741 :         if (used >= s->w_size) {    /* supplant the previous history */

  001ad	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]
  001b0	44 3b e2	 cmp	 r12d, edx
  001b3	72 29		 jb	 SHORT $LN15@deflate_st

; 1742 :             s->matches = 2;         /* clear hash */
; 1743 :             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);

  001b5	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001b9	44 8b c2	 mov	 r8d, edx
  001bc	c7 83 08 17 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+5896], 2
  001c6	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001c9	49 2b d0	 sub	 rdx, r8
  001cc	e8 00 00 00 00	 call	 memcpy

; 1744 :             s->strstart = s->w_size;

  001d1	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  001d4	8b c8		 mov	 ecx, eax
  001d6	89 83 94 00 00
	00		 mov	 DWORD PTR [rbx+148], eax

; 1745 :         }

  001dc	eb 66		 jmp	 SHORT $LN55@deflate_st
$LN15@deflate_st:

; 1746 :         else {
; 1747 :             if (s->window_size - s->strstart <= used) {

  001de	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  001e1	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001e7	2b c1		 sub	 eax, ecx
  001e9	41 3b c4	 cmp	 eax, r12d
  001ec	77 2b		 ja	 SHORT $LN18@deflate_st

; 1748 :                 /* Slide the window down. */
; 1749 :                 s->strstart -= s->w_size;

  001ee	2b ca		 sub	 ecx, edx
  001f0	44 8b c1	 mov	 r8d, ecx

; 1750 :                 zmemcpy(s->window, s->window + s->w_size, s->strstart);

  001f3	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001f7	48 03 d1	 add	 rdx, rcx
  001fa	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00201	e8 00 00 00 00	 call	 memcpy

; 1751 :                 if (s->matches < 2)

  00206	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  0020c	83 f8 02	 cmp	 eax, 2
  0020f	73 08		 jae	 SHORT $LN18@deflate_st

; 1752 :                     s->matches++;   /* add a pending slide_hash() */

  00211	ff c0		 inc	 eax
  00213	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN18@deflate_st:

; 1753 :             }
; 1754 :             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);

  00219	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0021c	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00222	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  00226	45 8b c4	 mov	 r8d, r12d
  00229	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0022c	49 2b d0	 sub	 rdx, r8
  0022f	e8 00 00 00 00	 call	 memcpy

; 1755 :             s->strstart += used;

  00234	44 01 a3 94 00
	00 00		 add	 DWORD PTR [rbx+148], r12d
  0023b	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00241	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
$LN55@deflate_st:

; 1756 :         }
; 1757 :         s->block_start = s->strstart;

  00244	8b d0		 mov	 edx, eax
  00246	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax

; 1758 :         s->insert += MIN(used, s->w_size - s->insert);

  0024c	8b 83 0c 17 00
	00		 mov	 eax, DWORD PTR [rbx+5900]
  00252	2b c8		 sub	 ecx, eax
  00254	44 3b e1	 cmp	 r12d, ecx
  00257	41 0f 46 cc	 cmovbe	 ecx, r12d
  0025b	03 c8		 add	 ecx, eax
  0025d	89 8b 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], ecx
  00263	eb 06		 jmp	 SHORT $LN49@deflate_st
$LN52@deflate_st:
  00265	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
$LN49@deflate_st:
  0026b	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]

; 1759 :     }
; 1760 :     if (s->high_water < s->strstart)

  00270	39 93 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], edx
  00276	73 06		 jae	 SHORT $LN19@deflate_st

; 1761 :         s->high_water = s->strstart;

  00278	89 93 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], edx
$LN19@deflate_st:

; 1762 : 
; 1763 :     /* If the last block was written to next_out, then done. */
; 1764 :     if (last)

  0027e	45 85 f6	 test	 r14d, r14d
  00281	74 15		 je	 SHORT $LN20@deflate_st

; 1765 :         return finish_done;

  00283	b8 03 00 00 00	 mov	 eax, 3
  00288	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 1815 : }

  0028d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00291	41 5f		 pop	 r15
  00293	41 5e		 pop	 r14
  00295	5e		 pop	 rsi
  00296	5b		 pop	 rbx
  00297	c3		 ret	 0
$LN20@deflate_st:

; 1766 : 
; 1767 :     /* If flushing and all input has been consumed, then done. */
; 1768 :     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
; 1769 :         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)

  00298	41 f7 c7 fb ff
	ff ff		 test	 r15d, -5		; fffffffbH
  0029f	74 26		 je	 SHORT $LN21@deflate_st
  002a1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002a4	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  002a8	75 1d		 jne	 SHORT $LN21@deflate_st
  002aa	3b 93 84 00 00
	00		 cmp	 edx, DWORD PTR [rbx+132]
  002b0	75 15		 jne	 SHORT $LN21@deflate_st

; 1770 :         return block_done;

  002b2	b8 01 00 00 00	 mov	 eax, 1
  002b7	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 1815 : }

  002bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  002c0	41 5f		 pop	 r15
  002c2	41 5e		 pop	 r14
  002c4	5e		 pop	 rsi
  002c5	5b		 pop	 rbx
  002c6	c3		 ret	 0
$LN21@deflate_st:

; 1771 : 
; 1772 :     /* Fill the window with any remaining input. */
; 1773 :     have = s->window_size - s->strstart - 1;

  002c7	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]

; 1774 :     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {

  002ca	8b ca		 mov	 ecx, edx
  002cc	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002cf	2b fa		 sub	 edi, edx
  002d1	ff cf		 dec	 edi
  002d3	44 8b c2	 mov	 r8d, edx
  002d6	39 78 08	 cmp	 DWORD PTR [rax+8], edi
  002d9	76 57		 jbe	 SHORT $LN22@deflate_st
  002db	44 8b 4b 44	 mov	 r9d, DWORD PTR [rbx+68]
  002df	44 8b 93 84 00
	00 00		 mov	 r10d, DWORD PTR [rbx+132]
  002e6	45 3b d1	 cmp	 r10d, r9d
  002e9	7c 47		 jl	 SHORT $LN22@deflate_st

; 1775 :         /* Slide the window down. */
; 1776 :         s->block_start -= s->w_size;
; 1777 :         s->strstart -= s->w_size;
; 1778 :         zmemcpy(s->window, s->window + s->w_size, s->strstart);

  002eb	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  002ef	41 2b d1	 sub	 edx, r9d
  002f2	44 8b c2	 mov	 r8d, edx
  002f5	45 2b d1	 sub	 r10d, r9d
  002f8	44 89 93 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r10d
  002ff	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00306	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
  0030a	e8 00 00 00 00	 call	 memcpy

; 1779 :         if (s->matches < 2)

  0030f	8b 83 08 17 00
	00		 mov	 eax, DWORD PTR [rbx+5896]
  00315	83 f8 02	 cmp	 eax, 2
  00318	73 08		 jae	 SHORT $LN23@deflate_st

; 1780 :             s->matches++;           /* add a pending slide_hash() */

  0031a	ff c0		 inc	 eax
  0031c	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN23@deflate_st:

; 1781 :         have += s->w_size;          /* more space now */

  00322	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00329	41 8b c8	 mov	 ecx, r8d
  0032c	03 7b 44	 add	 edi, DWORD PTR [rbx+68]
  0032f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN22@deflate_st:

; 1782 :     }
; 1783 :     if (have > s->strm->avail_in)

  00332	8b 70 08	 mov	 esi, DWORD PTR [rax+8]

; 1784 :         have = s->strm->avail_in;
; 1785 :     if (have) {

  00335	3b fe		 cmp	 edi, esi
  00337	0f 46 f7	 cmovbe	 esi, edi
  0033a	85 f6		 test	 esi, esi
  0033c	74 1e		 je	 SHORT $LN25@deflate_st

; 1786 :         read_buf(s->strm, s->window + s->strstart, have);

  0033e	41 8b d0	 mov	 edx, r8d
  00341	48 8b c8	 mov	 rcx, rax
  00344	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00348	44 8b c6	 mov	 r8d, esi
  0034b	e8 00 00 00 00	 call	 read_buf

; 1787 :         s->strstart += have;

  00350	01 b3 94 00 00
	00		 add	 DWORD PTR [rbx+148], esi
  00356	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
$LN25@deflate_st:

; 1788 :     }
; 1789 :     if (s->high_water < s->strstart)

  0035c	39 8b 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], ecx
  00362	73 06		 jae	 SHORT $LN26@deflate_st

; 1790 :         s->high_water = s->strstart;

  00364	89 8b 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], ecx
$LN26@deflate_st:

; 1791 : 
; 1792 :     /* There was not enough avail_out to write a complete worthy or flushed
; 1793 :      * stored block to next_out. Write a stored block to pending instead, if we
; 1794 :      * have enough input for a worthy block, or if flushing and there is enough
; 1795 :      * room for the remaining input as a stored block in the pending buffer.
; 1796 :      */
; 1797 :     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  0036a	8b 83 14 17 00
	00		 mov	 eax, DWORD PTR [rbx+5908]

; 1798 :         /* maximum stored block length that will fit in pending: */
; 1799 :     have = MIN(s->pending_buf_size - have, MAX_STORED);

  00370	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  00373	83 c0 2a	 add	 eax, 42			; 0000002aH

; 1800 :     min_block = MIN(have, s->w_size);
; 1801 :     left = s->strstart - s->block_start;

  00376	4c 63 83 84 00
	00 00		 movsxd	 r8, DWORD PTR [rbx+132]
  0037d	c1 f8 03	 sar	 eax, 3
  00380	2b d0		 sub	 edx, eax
  00382	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00387	3b d0		 cmp	 edx, eax
  00389	0f 47 d0	 cmova	 edx, eax
  0038c	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  0038f	41 2b c8	 sub	 ecx, r8d
  00392	3b d0		 cmp	 edx, eax
  00394	0f 46 c2	 cmovbe	 eax, edx

; 1802 :     if (left >= min_block ||

  00397	3b c8		 cmp	 ecx, eax
  00399	73 1c		 jae	 SHORT $LN53@deflate_st
  0039b	85 c9		 test	 ecx, ecx
  0039d	75 06		 jne	 SHORT $LN29@deflate_st
  0039f	41 83 ff 04	 cmp	 r15d, 4
  003a3	75 58		 jne	 SHORT $LN27@deflate_st
$LN29@deflate_st:
  003a5	45 85 ff	 test	 r15d, r15d
  003a8	74 53		 je	 SHORT $LN27@deflate_st
  003aa	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ad	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003b1	75 4a		 jne	 SHORT $LN27@deflate_st
  003b3	3b ca		 cmp	 ecx, edx
  003b5	77 46		 ja	 SHORT $LN27@deflate_st
$LN53@deflate_st:

; 1803 :         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
; 1804 :          s->strm->avail_in == 0 && left <= have)) {
; 1805 :         len = MIN(left, have);

  003b7	3b ca		 cmp	 ecx, edx
  003b9	8b f9		 mov	 edi, ecx
  003bb	0f 47 fa	 cmova	 edi, edx

; 1806 :         last = flush == Z_FINISH && s->strm->avail_in == 0 &&

  003be	41 83 ff 04	 cmp	 r15d, 4
  003c2	75 13		 jne	 SHORT $LN41@deflate_st
  003c4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003c7	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003cb	75 0a		 jne	 SHORT $LN41@deflate_st
  003cd	3b f9		 cmp	 edi, ecx
  003cf	75 06		 jne	 SHORT $LN41@deflate_st
  003d1	45 8d 77 fd	 lea	 r14d, QWORD PTR [r15-3]
  003d5	eb 03		 jmp	 SHORT $LN42@deflate_st
$LN41@deflate_st:
  003d7	45 33 f6	 xor	 r14d, r14d
$LN42@deflate_st:

; 1807 :                len == left ? 1 : 0;
; 1808 :         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);

  003da	49 8b d0	 mov	 rdx, r8
  003dd	45 8b ce	 mov	 r9d, r14d
  003e0	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003e4	44 8b c7	 mov	 r8d, edi
  003e7	48 8b cb	 mov	 rcx, rbx
  003ea	e8 00 00 00 00	 call	 _tr_stored_block

; 1809 :         s->block_start += len;
; 1810 :         flush_pending(s->strm);

  003ef	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003f2	01 bb 84 00 00
	00		 add	 DWORD PTR [rbx+132], edi
  003f8	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate_st:

; 1811 :     }
; 1812 : 
; 1813 :     /* We've done all we can with the available input and output. */
; 1814 :     return last ? finish_started : need_more;

  003fd	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00402	41 f7 de	 neg	 r14d
  00405	1b c0		 sbb	 eax, eax
  00407	83 e0 02	 and	 eax, 2

; 1815 : }

  0040a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0040e	41 5f		 pop	 r15
  00410	41 5e		 pop	 r14
  00412	5e		 pop	 rsi
  00413	5b		 pop	 rbx
  00414	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_fast
_TEXT	SEGMENT
s$ = 80
flush$ = 88
deflate_fast PROC					; COMDAT

; 1827 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	8b f2		 mov	 esi, edx
  0001e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_length_code
  00025	48 8b d9	 mov	 rbx, rcx
  00028	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_dist_code
  0002f	41 bf ff ff 00
	00		 mov	 r15d, 65535		; 0000ffffH
  00035	4c 8d 35 00 01
	00 00		 lea	 r14, OFFSET FLAT:_dist_code+256
  0003c	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
  00042	33 ff		 xor	 edi, edi
  00044	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@deflate_fa:

; 1828 :     IPos hash_head;       /* head of the hash chain */
; 1829 :     int bflush;           /* set if current block must be flushed */
; 1830 : 
; 1831 :     for (;;) {
; 1832 :         /* Make sure that we always have enough lookahead, except
; 1833 :          * at the end of the input file. We need MAX_MATCH bytes
; 1834 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1835 :          * string following the next match.
; 1836 :          */
; 1837 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00050	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00056	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0005b	73 25		 jae	 SHORT $LN10@deflate_fa

; 1838 :             fill_window(s);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 fill_window

; 1839 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00065	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0006b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00070	73 08		 jae	 SHORT $LN9@deflate_fa
  00072	85 f6		 test	 esi, esi
  00074	0f 84 bb 02 00
	00		 je	 $LN39@deflate_fa
$LN9@deflate_fa:

; 1840 :                 return need_more;
; 1841 :             }
; 1842 :             if (s->lookahead == 0) break; /* flush the current block */

  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 d2 02 00
	00		 je	 $LN38@deflate_fa
$LN10@deflate_fa:

; 1843 :         }
; 1844 : 
; 1845 :         /* Insert the string window[strstart .. strstart+2] in the
; 1846 :          * dictionary, and set hash_head to the head of the hash chain:
; 1847 :          */
; 1848 :         hash_head = NIL;
; 1849 :         if (s->lookahead >= MIN_MATCH) {

  00082	83 f8 03	 cmp	 eax, 3
  00085	0f 82 8c 00 00
	00		 jb	 $LN12@deflate_fa

; 1850 :             INSERT_STRING(s, s->strstart, hash_head);

  0008b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0008f	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00096	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0009a	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0009e	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  000a3	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000a6	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000ac	d3 e0		 shl	 eax, cl
  000ae	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000b2	44 33 c0	 xor	 r8d, eax
  000b5	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000b9	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000bc	4c 23 c8	 and	 r9, rax
  000bf	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000c3	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000c8	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000cd	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000d0	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  000d7	41 8b c8	 mov	 ecx, r8d
  000da	48 23 c8	 and	 rcx, rax
  000dd	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000e1	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  000e5	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000e8	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000ec	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w

; 1851 :         }
; 1852 : 
; 1853 :         /* Find the longest match, discarding those <= prev_length.
; 1854 :          * At this point we have always match_length < MIN_MATCH
; 1855 :          */
; 1856 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  000f1	85 d2		 test	 edx, edx
  000f3	74 22		 je	 SHORT $LN12@deflate_fa
  000f5	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000fb	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000fe	2b ca		 sub	 ecx, edx
  00100	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00105	3b c8		 cmp	 ecx, eax
  00107	77 0e		 ja	 SHORT $LN12@deflate_fa

; 1857 :             /* To simplify the code, we prevent matches with the string
; 1858 :              * of window index 0 (in particular we have to avoid a match
; 1859 :              * of the string with itself at the start of the input file).
; 1860 :              */
; 1861 :             s->match_length = longest_match (s, hash_head);

  00109	48 8b cb	 mov	 rcx, rbx
  0010c	e8 00 00 00 00	 call	 longest_match
  00111	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LN12@deflate_fa:

; 1862 :             /* longest_match() sets match_start */
; 1863 :         }
; 1864 :         if (s->match_length >= MIN_MATCH) {

  00117	44 8b 83 88 00
	00 00		 mov	 r8d, DWORD PTR [rbx+136]
  0011e	41 83 f8 03	 cmp	 r8d, 3
  00122	0f 82 5b 01 00
	00		 jb	 $LN13@deflate_fa

; 1865 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1866 : 
; 1867 :             _tr_tally_dist(s, s->strstart - s->match_start,

  00128	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0012e	41 80 e8 03	 sub	 r8b, 3
  00132	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00139	0f b7 93 94 00
	00 00		 movzx	 edx, WORD PTR [rbx+148]
  00140	66 2b 93 98 00
	00 00		 sub	 dx, WORD PTR [rbx+152]
  00147	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  0014b	66 41 03 d7	 add	 dx, r15w
  0014f	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00155	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0015c	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  00160	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00166	41 0f b6 c0	 movzx	 eax, r8b
  0016a	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  0016f	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00177	0f b7 c2	 movzx	 eax, dx
  0017a	66 41 3b d5	 cmp	 dx, r13w
  0017e	73 05		 jae	 SHORT $LN24@deflate_fa
  00180	48 03 c5	 add	 rax, rbp
  00183	eb 07		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00185	48 c1 e8 07	 shr	 rax, 7
  00189	49 03 c6	 add	 rax, r14
$LN25@deflate_fa:
  0018c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018f	44 8b d7	 mov	 r10d, edi
  00192	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1868 :                            s->match_length - MIN_MATCH, bflush);
; 1869 : 
; 1870 :             s->lookahead -= s->match_length;

  0019a	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  001a0	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  001a6	ff c8		 dec	 eax
  001a8	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  001ae	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  001b4	41 0f 94 c2	 sete	 r10b
  001b8	2b c1		 sub	 eax, ecx
  001ba	89 83 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], eax

; 1871 : 
; 1872 :             /* Insert new strings in the hash table only if the match length
; 1873 :              * is not too large. This saves time but degrades compression.
; 1874 :              */
; 1875 : #ifndef FASTEST
; 1876 :             if (s->match_length <= s->max_insert_length &&

  001c0	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  001c6	77 76		 ja	 SHORT $LN45@deflate_fa
  001c8	83 f8 03	 cmp	 eax, 3
  001cb	72 71		 jb	 SHORT $LN45@deflate_fa

; 1877 :                 s->lookahead >= MIN_MATCH) {
; 1878 :                 s->match_length--; /* string at strstart already in table */

  001cd	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  001d0	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LL7@deflate_fa:

; 1879 :                 do {
; 1880 :                     s->strstart++;

  001d6	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1881 :                     INSERT_STRING(s, s->strstart, hash_head);

  001dc	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001e0	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  001e7	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  001eb	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  001ef	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  001f4	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001f7	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  001fd	d3 e0		 shl	 eax, cl
  001ff	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00203	44 33 c0	 xor	 r8d, eax
  00206	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0020a	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  0020d	4c 23 c8	 and	 r9, rax
  00210	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  00214	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  00219	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  0021e	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00221	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00225	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  0022c	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1882 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1883 :                      * always MIN_MATCH bytes ahead.
; 1884 :                      */
; 1885 :                 } while (--s->match_length != 0);

  00230	83 83 88 00 00
	00 ff		 add	 DWORD PTR [rbx+136], -1	; ffffffffH
  00237	75 9d		 jne	 SHORT $LL7@deflate_fa

; 1886 :                 s->strstart++;
; 1887 :             } else

  00239	e9 9d 00 00 00	 jmp	 $LN47@deflate_fa
$LN45@deflate_fa:

; 1888 : #endif
; 1889 :             {
; 1890 :                 s->strstart += s->match_length;

  0023e	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]

; 1891 :                 s->match_length = 0;
; 1892 :                 s->ins_h = s->window[s->strstart];

  00245	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  00249	44 03 c9	 add	 r9d, ecx

; 1893 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  0024c	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00252	44 89 8b 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r9d
  00259	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  0025f	45 0f b6 04 11	 movzx	 r8d, BYTE PTR [r9+rdx]
  00264	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  00268	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0026c	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00270	41 d3 e0	 shl	 r8d, cl
  00273	44 33 c0	 xor	 r8d, eax
  00276	41 8b c1	 mov	 eax, r9d
  00279	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0027d	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d

; 1894 : #if MIN_MATCH != 3
; 1895 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1896 : #endif
; 1897 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1898 :                  * matter since it will be recomputed at next deflate call.
; 1899 :                  */
; 1900 :             }
; 1901 :         } else {

  00281	eb 64		 jmp	 SHORT $LN14@deflate_fa
$LN13@deflate_fa:

; 1902 :             /* No match, output a literal byte */
; 1903 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1904 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00283	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00289	44 8b d7	 mov	 r10d, edi
  0028c	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00290	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00294	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0029a	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  002a1	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  002a5	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  002ab	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  002b2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  002b5	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  002bb	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  002c3	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  002c9	ff c8		 dec	 eax
  002cb	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  002d1	41 0f 94 c2	 sete	 r10b

; 1905 :             s->lookahead--;

  002d5	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
$LN47@deflate_fa:

; 1906 :             s->strstart++;
; 1907 :         }
; 1908 :         if (bflush) FLUSH_BLOCK(s, 0);

  002db	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  002e1	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
$LN14@deflate_fa:
  002e7	45 85 d2	 test	 r10d, r10d
  002ea	0f 84 60 fd ff
	ff		 je	 $LL2@deflate_fa
  002f0	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  002f6	85 c9		 test	 ecx, ecx
  002f8	78 08		 js	 SHORT $LN26@deflate_fa
  002fa	8b d1		 mov	 edx, ecx
  002fc	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00300	eb 03		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  00302	48 8b d7	 mov	 rdx, rdi
$LN27@deflate_fa:
  00305	2b c1		 sub	 eax, ecx
  00307	45 33 c9	 xor	 r9d, r9d
  0030a	44 8b c0	 mov	 r8d, eax
  0030d	48 8b cb	 mov	 rcx, rbx
  00310	e8 00 00 00 00	 call	 _tr_flush_block
  00315	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0031b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0031e	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00324	e8 00 00 00 00	 call	 flush_pending
  00329	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0032c	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0032f	0f 85 1b fd ff
	ff		 jne	 $LL2@deflate_fa
$LN39@deflate_fa:
  00335	33 c0		 xor	 eax, eax
$LN1@deflate_fa:

; 1918 : }

  00337	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0033c	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00341	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00346	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0034a	41 5f		 pop	 r15
  0034c	41 5e		 pop	 r14
  0034e	41 5d		 pop	 r13
  00350	41 5c		 pop	 r12
  00352	5f		 pop	 rdi
  00353	c3		 ret	 0
$LN38@deflate_fa:

; 1909 :     }
; 1910 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00354	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0035a	b8 02 00 00 00	 mov	 eax, 2
  0035f	3b c8		 cmp	 ecx, eax
  00361	0f 42 c1	 cmovb	 eax, ecx
  00364	89 83 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], eax

; 1911 :     if (flush == Z_FINISH) {

  0036a	83 fe 04	 cmp	 esi, 4
  0036d	75 4e		 jne	 SHORT $LN19@deflate_fa

; 1912 :         FLUSH_BLOCK(s, 1);

  0036f	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00375	85 c0		 test	 eax, eax
  00377	78 08		 js	 SHORT $LN30@deflate_fa
  00379	8b d0		 mov	 edx, eax
  0037b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0037f	eb 03		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  00381	48 8b d7	 mov	 rdx, rdi
$LN31@deflate_fa:
  00384	2b c8		 sub	 ecx, eax
  00386	41 b9 01 00 00
	00		 mov	 r9d, 1
  0038c	44 8b c1	 mov	 r8d, ecx
  0038f	48 8b cb	 mov	 rcx, rbx
  00392	e8 00 00 00 00	 call	 _tr_flush_block
  00397	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0039d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003a0	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003a6	e8 00 00 00 00	 call	 flush_pending
  003ab	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ae	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  003b1	40 0f 95 c7	 setne	 dil
  003b5	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 1913 :         return finish_done;

  003b8	e9 7a ff ff ff	 jmp	 $LN1@deflate_fa
$LN19@deflate_fa:

; 1914 :     }
; 1915 :     if (s->last_lit)

  003bd	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  003c3	74 44		 je	 SHORT $LN22@deflate_fa

; 1916 :         FLUSH_BLOCK(s, 0);

  003c5	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003cb	85 c0		 test	 eax, eax
  003cd	78 06		 js	 SHORT $LN32@deflate_fa
  003cf	8b f8		 mov	 edi, eax
  003d1	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN32@deflate_fa:
  003d5	2b c8		 sub	 ecx, eax
  003d7	45 33 c9	 xor	 r9d, r9d
  003da	44 8b c1	 mov	 r8d, ecx
  003dd	48 8b d7	 mov	 rdx, rdi
  003e0	48 8b cb	 mov	 rcx, rbx
  003e3	e8 00 00 00 00	 call	 _tr_flush_block
  003e8	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003ee	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003f1	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003f7	e8 00 00 00 00	 call	 flush_pending
  003fc	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ff	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00403	0f 84 2c ff ff
	ff		 je	 $LN39@deflate_fa
$LN22@deflate_fa:

; 1917 :     return block_done;

  00409	b8 01 00 00 00	 mov	 eax, 1
  0040e	e9 24 ff ff ff	 jmp	 $LN1@deflate_fa
deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_slow
_TEXT	SEGMENT
s$ = 80
flush$ = 88
deflate_slow PROC					; COMDAT

; 1929 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	33 ff		 xor	 edi, edi
  0001e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_dist_code
  00025	44 8b fa	 mov	 r15d, edx
  00028	4c 8d 2d 00 01
	00 00		 lea	 r13, OFFSET FLAT:_dist_code+256
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00037	8d 77 02	 lea	 esi, QWORD PTR [rdi+2]
$LN58@deflate_sl:

; 1930 :     IPos hash_head;          /* head of hash chain */
; 1931 :     int bflush;              /* set if current block must be flushed */
; 1932 : 
; 1933 :     /* Process the input block. */
; 1934 :     for (;;) {
; 1935 :         /* Make sure that we always have enough lookahead, except
; 1936 :          * at the end of the input file. We need MAX_MATCH bytes
; 1937 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1938 :          * string following the next match.
; 1939 :          */
; 1940 :         if (s->lookahead < MIN_LOOKAHEAD) {

  0003a	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_length_code
$LL2@deflate_sl:
  00041	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00047	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004c	73 26		 jae	 SHORT $LN10@deflate_sl

; 1941 :             fill_window(s);

  0004e	48 8b cb	 mov	 rcx, rbx
  00051	e8 00 00 00 00	 call	 fill_window

; 1942 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00056	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005c	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00061	73 09		 jae	 SHORT $LN9@deflate_sl
  00063	45 85 ff	 test	 r15d, r15d
  00066	0f 84 aa 02 00
	00		 je	 $LN48@deflate_sl
$LN9@deflate_sl:

; 1943 :                 return need_more;
; 1944 :             }
; 1945 :             if (s->lookahead == 0) break; /* flush the current block */

  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 95 03 00
	00		 je	 $LN46@deflate_sl
$LN10@deflate_sl:

; 1946 :         }
; 1947 : 
; 1948 :         /* Insert the string window[strstart .. strstart+2] in the
; 1949 :          * dictionary, and set hash_head to the head of the hash chain:
; 1950 :          */
; 1951 :         hash_head = NIL;

  00074	44 8b c7	 mov	 r8d, edi

; 1952 :         if (s->lookahead >= MIN_MATCH) {

  00077	83 f8 03	 cmp	 eax, 3
  0007a	72 64		 jb	 SHORT $LN11@deflate_sl

; 1953 :             INSERT_STRING(s, s->strstart, hash_head);

  0007c	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00080	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00087	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0008b	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0008f	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00094	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00097	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0009d	d3 e0		 shl	 eax, cl
  0009f	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000a3	44 33 c0	 xor	 r8d, eax
  000a6	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000aa	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000ad	4c 23 c8	 and	 r9, rax
  000b0	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000b4	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000b9	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000be	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000c1	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  000c7	8b ca		 mov	 ecx, edx
  000c9	48 23 c8	 and	 rcx, rax
  000cc	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d0	44 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+rcx*2]
  000d5	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000d8	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000dc	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
$LN11@deflate_sl:

; 1954 :         }
; 1955 : 
; 1956 :         /* Find the longest match, discarding those <= prev_length.
; 1957 :          */
; 1958 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  000e0	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]

; 1959 :         s->match_length = MIN_MATCH-1;

  000e6	8b d6		 mov	 edx, esi
  000e8	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [rbx+152]
  000ee	89 8b a0 00 00
	00		 mov	 DWORD PTR [rbx+160], ecx
  000f4	89 83 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], eax
  000fa	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi

; 1960 : 
; 1961 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&

  00100	45 85 c0	 test	 r8d, r8d
  00103	74 5e		 je	 SHORT $LN13@deflate_sl
  00105	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  0010b	73 56		 jae	 SHORT $LN13@deflate_sl
  0010d	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00113	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00116	41 2b c8	 sub	 ecx, r8d
  00119	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0011e	3b c8		 cmp	 ecx, eax
  00120	77 41		 ja	 SHORT $LN13@deflate_sl

; 1962 :             s->strstart - hash_head <= MAX_DIST(s)) {
; 1963 :             /* To simplify the code, we prevent matches with the string
; 1964 :              * of window index 0 (in particular we have to avoid a match
; 1965 :              * of the string with itself at the start of the input file).
; 1966 :              */
; 1967 :             s->match_length = longest_match (s, hash_head);

  00122	41 8b d0	 mov	 edx, r8d
  00125	48 8b cb	 mov	 rcx, rbx
  00128	e8 00 00 00 00	 call	 longest_match
  0012d	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1968 :             /* longest_match() sets match_start */
; 1969 : 
; 1970 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED

  00133	8b d0		 mov	 edx, eax
  00135	83 f8 05	 cmp	 eax, 5
  00138	77 29		 ja	 SHORT $LN13@deflate_sl
  0013a	83 bb b0 00 00
	00 01		 cmp	 DWORD PTR [rbx+176], 1
  00141	74 18		 je	 SHORT $LN14@deflate_sl
  00143	83 f8 03	 cmp	 eax, 3
  00146	75 1b		 jne	 SHORT $LN13@deflate_sl
  00148	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0014e	2b 83 98 00 00
	00		 sub	 eax, DWORD PTR [rbx+152]
  00154	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00159	76 08		 jbe	 SHORT $LN13@deflate_sl
$LN14@deflate_sl:

; 1971 : #if TOO_FAR <= 32767
; 1972 :                 || (s->match_length == MIN_MATCH &&
; 1973 :                     s->strstart - s->match_start > TOO_FAR)
; 1974 : #endif
; 1975 :                 )) {
; 1976 : 
; 1977 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1978 :                  * but we will ignore the current match anyway.
; 1979 :                  */
; 1980 :                 s->match_length = MIN_MATCH-1;

  0015b	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi
  00161	8b d6		 mov	 edx, esi
$LN13@deflate_sl:

; 1981 :             }
; 1982 :         }
; 1983 :         /* If there was a match at the previous step and the current
; 1984 :          * match is not better, output the previous match:
; 1985 :          */
; 1986 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00163	44 8b 83 a0 00
	00 00		 mov	 r8d, DWORD PTR [rbx+160]
  0016a	41 83 f8 03	 cmp	 r8d, 3
  0016e	0f 82 c1 01 00
	00		 jb	 $LN51@deflate_sl
  00174	41 3b d0	 cmp	 edx, r8d
  00177	0f 87 b8 01 00
	00		 ja	 $LN51@deflate_sl

; 1987 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0017d	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]

; 1988 :             /* Do not insert strings in hash table beyond this. */
; 1989 : 
; 1990 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1991 : 
; 1992 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,

  00183	41 80 e8 03	 sub	 r8b, 3
  00187	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0018d	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  00194	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0019b	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  0019f	44 03 da	 add	 r11d, edx
  001a2	66 2b 93 8c 00
	00 00		 sub	 dx, WORD PTR [rbx+140]
  001a9	66 ff ca	 dec	 dx
  001ac	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  001b0	66 03 d5	 add	 dx, bp
  001b3	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001b9	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001c0	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  001c4	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001ca	41 0f b6 c0	 movzx	 eax, r8b
  001ce	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  001d3	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  001db	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001e0	66 3b d0	 cmp	 dx, ax
  001e3	0f b7 c2	 movzx	 eax, dx
  001e6	73 05		 jae	 SHORT $LN30@deflate_sl
  001e8	49 03 c4	 add	 rax, r12
  001eb	eb 07		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  001ed	48 c1 e8 07	 shr	 rax, 7
  001f1	49 03 c5	 add	 rax, r13
$LN31@deflate_sl:
  001f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f7	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1993 :                            s->prev_length - MIN_MATCH, bflush);
; 1994 : 
; 1995 :             /* Insert in hash table all strings up to the end of the match.
; 1996 :              * strstart-1 and strstart are already inserted. If there is not
; 1997 :              * enough lookahead, the last two strings are not inserted in
; 1998 :              * the hash table.
; 1999 :              */
; 2000 :             s->lookahead -= s->prev_length-1;

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+160]
  0020a	2b c1		 sub	 eax, ecx
  0020c	8b ab f0 16 00
	00		 mov	 ebp, DWORD PTR [rbx+5872]
  00212	44 8b b3 f4 16
	00 00		 mov	 r14d, DWORD PTR [rbx+5876]
  00219	ff cd		 dec	 ebp
  0021b	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax

; 2001 :             s->prev_length -= 2;

  00221	8d 41 fe	 lea	 eax, DWORD PTR [rcx-2]
  00224	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
  0022a	66 0f 1f 44 00
	00		 npad	 6
$LL7@deflate_sl:

; 2002 :             do {
; 2003 :                 if (++s->strstart <= max_insert) {

  00230	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]
  00237	41 ff c2	 inc	 r10d
  0023a	44 89 93 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r10d
  00241	45 3b d3	 cmp	 r10d, r11d
  00244	77 58		 ja	 SHORT $LN5@deflate_sl

; 2004 :                     INSERT_STRING(s, s->strstart, hash_head);

  00246	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0024a	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  0024e	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  00252	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00256	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  0025b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0025e	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00264	d3 e0		 shl	 eax, cl
  00266	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0026a	44 33 c8	 xor	 r9d, eax
  0026d	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  00271	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00275	41 8b c2	 mov	 eax, r10d
  00278	4c 23 c0	 and	 r8, rax
  0027b	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00280	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  00285	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00288	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0028c	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  00293	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00297	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]
$LN5@deflate_sl:

; 2005 :                 }
; 2006 :             } while (--s->prev_length != 0);

  0029e	83 83 a0 00 00
	00 ff		 add	 DWORD PTR [rbx+160], -1	; ffffffffH
  002a5	75 89		 jne	 SHORT $LL7@deflate_sl

; 2007 :             s->match_available = 0;
; 2008 :             s->match_length = MIN_MATCH-1;
; 2009 :             s->strstart++;
; 2010 : 
; 2011 :             if (bflush) FLUSH_BLOCK(s, 0);

  002a7	44 3b f5	 cmp	 r14d, ebp
  002aa	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
  002b0	45 8d 42 01	 lea	 r8d, DWORD PTR [r10+1]
  002b4	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi
  002ba	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  002c1	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_length_code
  002c8	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  002cd	0f 85 6e fd ff
	ff		 jne	 $LL2@deflate_sl
  002d3	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002d9	85 c0		 test	 eax, eax
  002db	78 08		 js	 SHORT $LN32@deflate_sl
  002dd	8b d0		 mov	 edx, eax
  002df	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e3	eb 03		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  002e5	48 8b d7	 mov	 rdx, rdi
$LN33@deflate_sl:
  002e8	44 2b c0	 sub	 r8d, eax
  002eb	45 33 c9	 xor	 r9d, r9d
  002ee	48 8b cb	 mov	 rcx, rbx
  002f1	e8 00 00 00 00	 call	 _tr_flush_block
  002f6	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  002fc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002ff	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00305	e8 00 00 00 00	 call	 flush_pending
  0030a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0030d	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00310	0f 85 24 fd ff
	ff		 jne	 $LN58@deflate_sl
$LN48@deflate_sl:

; 2022 :             }
; 2023 :             s->strstart++;
; 2024 :             s->lookahead--;
; 2025 :             if (s->strm->avail_out == 0) return need_more;

  00316	33 c0		 xor	 eax, eax
$LN1@deflate_sl:

; 2049 : }

  00318	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0031d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00322	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00327	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0032b	41 5f		 pop	 r15
  0032d	41 5e		 pop	 r14
  0032f	41 5d		 pop	 r13
  00331	41 5c		 pop	 r12
  00333	5f		 pop	 rdi
  00334	c3		 ret	 0
$LN51@deflate_sl:

; 2012 : 
; 2013 :         } else if (s->match_available) {

  00335	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0033b	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00341	0f 84 a5 00 00
	00		 je	 $LN20@deflate_sl

; 2014 :             /* If there was no match at the previous position, output a
; 2015 :              * single literal. If there was a match but the current match
; 2016 :              * is longer, truncate the previous match to a single literal.
; 2017 :              */
; 2018 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2019 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00347	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0034a	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0034e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00352	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00358	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0035f	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00363	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00369	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00370	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00373	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00379	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  00381	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00387	ff c8		 dec	 eax
  00389	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2020 :             if (bflush) {

  0038f	75 3e		 jne	 SHORT $LN22@deflate_sl

; 2021 :                 FLUSH_BLOCK_ONLY(s, 0);

  00391	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00397	85 c0		 test	 eax, eax
  00399	78 08		 js	 SHORT $LN34@deflate_sl
  0039b	8b d0		 mov	 edx, eax
  0039d	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003a1	eb 03		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  003a3	48 8b d7	 mov	 rdx, rdi
$LN35@deflate_sl:
  003a6	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  003ad	45 33 c9	 xor	 r9d, r9d
  003b0	44 2b c0	 sub	 r8d, eax
  003b3	48 8b cb	 mov	 rcx, rbx
  003b6	e8 00 00 00 00	 call	 _tr_flush_block
  003bb	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003c1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003c4	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003ca	e8 00 00 00 00	 call	 flush_pending
$LN22@deflate_sl:

; 2022 :             }
; 2023 :             s->strstart++;
; 2024 :             s->lookahead--;
; 2025 :             if (s->strm->avail_out == 0) return need_more;

  003cf	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003d2	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  003d8	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003de	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  003e1	0f 85 5a fc ff
	ff		 jne	 $LL2@deflate_sl

; 2026 :         } else {

  003e7	e9 2a ff ff ff	 jmp	 $LN48@deflate_sl
$LN20@deflate_sl:

; 2027 :             /* There is no previous match to compare with, wait for
; 2028 :              * the next step to decide.
; 2029 :              */
; 2030 :             s->match_available = 1;
; 2031 :             s->strstart++;

  003ec	ff c0		 inc	 eax
  003ee	c7 83 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+144], 1

; 2032 :             s->lookahead--;

  003f8	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003fe	89 83 94 00 00
	00		 mov	 DWORD PTR [rbx+148], eax

; 2033 :         }
; 2034 :     }

  00404	e9 38 fc ff ff	 jmp	 $LL2@deflate_sl
$LN46@deflate_sl:

; 2035 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 2036 :     if (s->match_available) {

  00409	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  0040f	74 45		 je	 SHORT $LN24@deflate_sl

; 2037 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2038 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00411	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00417	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0041b	ff c9		 dec	 ecx
  0041d	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00421	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00427	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0042e	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00432	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00438	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0043f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00442	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00448	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2039 :         s->match_available = 0;

  00450	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
$LN24@deflate_sl:

; 2040 :     }
; 2041 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00456	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0045c	3b c6		 cmp	 eax, esi
  0045e	0f 42 f0	 cmovb	 esi, eax
  00461	89 b3 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], esi

; 2042 :     if (flush == Z_FINISH) {

  00467	41 83 ff 04	 cmp	 r15d, 4
  0046b	75 4e		 jne	 SHORT $LN25@deflate_sl

; 2043 :         FLUSH_BLOCK(s, 1);

  0046d	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  00473	85 c9		 test	 ecx, ecx
  00475	78 08		 js	 SHORT $LN38@deflate_sl
  00477	8b d1		 mov	 edx, ecx
  00479	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0047d	eb 03		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  0047f	48 8b d7	 mov	 rdx, rdi
$LN39@deflate_sl:
  00482	2b c1		 sub	 eax, ecx
  00484	41 b9 01 00 00
	00		 mov	 r9d, 1
  0048a	44 8b c0	 mov	 r8d, eax
  0048d	48 8b cb	 mov	 rcx, rbx
  00490	e8 00 00 00 00	 call	 _tr_flush_block
  00495	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0049b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0049e	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004a4	e8 00 00 00 00	 call	 flush_pending
  004a9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004ac	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  004af	40 0f 95 c7	 setne	 dil
  004b3	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2044 :         return finish_done;

  004b6	e9 5d fe ff ff	 jmp	 $LN1@deflate_sl
$LN25@deflate_sl:

; 2045 :     }
; 2046 :     if (s->last_lit)

  004bb	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  004c1	74 44		 je	 SHORT $LN28@deflate_sl

; 2047 :         FLUSH_BLOCK(s, 0);

  004c3	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  004c9	85 c9		 test	 ecx, ecx
  004cb	78 06		 js	 SHORT $LN40@deflate_sl
  004cd	8b f9		 mov	 edi, ecx
  004cf	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN40@deflate_sl:
  004d3	2b c1		 sub	 eax, ecx
  004d5	45 33 c9	 xor	 r9d, r9d
  004d8	44 8b c0	 mov	 r8d, eax
  004db	48 8b d7	 mov	 rdx, rdi
  004de	48 8b cb	 mov	 rcx, rbx
  004e1	e8 00 00 00 00	 call	 _tr_flush_block
  004e6	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  004ec	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  004ef	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004f5	e8 00 00 00 00	 call	 flush_pending
  004fa	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004fd	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00501	0f 84 0f fe ff
	ff		 je	 $LN48@deflate_sl
$LN28@deflate_sl:

; 2048 :     return block_done;

  00507	b8 01 00 00 00	 mov	 eax, 1
  0050c	e9 07 fe ff ff	 jmp	 $LN1@deflate_sl
deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_rle
_TEXT	SEGMENT
s$ = 64
flush$ = 72
deflate_rle PROC					; COMDAT

; 2060 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	33 ff		 xor	 edi, edi
  0001a	48 8d b1 94 00
	00 00		 lea	 rsi, QWORD PTR [rcx+148]
  00021	8b ea		 mov	 ebp, edx
  00023	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_length_code
  0002a	48 8b d9	 mov	 rbx, rcx
  0002d	44 8d 77 01	 lea	 r14d, QWORD PTR [rdi+1]
$LL2@deflate_rl:

; 2061 :     int bflush;             /* set if current block must be flushed */
; 2062 :     uInt prev;              /* byte at distance one to match */
; 2063 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 2064 : 
; 2065 :     for (;;) {
; 2066 :         /* Make sure that we always have enough lookahead, except
; 2067 :          * at the end of the input file. We need MAX_MATCH bytes
; 2068 :          * for the longest run, plus one for the unrolled loop.
; 2069 :          */
; 2070 :         if (s->lookahead <= MAX_MATCH) {

  00031	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]
  00038	41 8b c1	 mov	 eax, r9d
  0003b	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00042	77 2c		 ja	 SHORT $LN10@deflate_rl

; 2071 :             fill_window(s);

  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 fill_window

; 2072 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  0004c	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]
  00053	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  0005a	77 08		 ja	 SHORT $LN9@deflate_rl
  0005c	85 ed		 test	 ebp, ebp
  0005e	0f 84 94 02 00
	00		 je	 $LN37@deflate_rl
$LN9@deflate_rl:

; 2073 :                 return need_more;
; 2074 :             }
; 2075 :             if (s->lookahead == 0) break; /* flush the current block */

  00064	41 8b c1	 mov	 eax, r9d
  00067	45 85 c9	 test	 r9d, r9d
  0006a	0f 84 de 01 00
	00		 je	 $LN36@deflate_rl
$LN10@deflate_rl:

; 2076 :         }
; 2077 : 
; 2078 :         /* See how many times the previous byte repeats */
; 2079 :         s->match_length = 0;

  00070	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00076	44 8b c7	 mov	 r8d, edi

; 2080 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  00079	83 f8 03	 cmp	 eax, 3
  0007c	0f 82 9e 00 00
	00		 jb	 $LN14@deflate_rl
  00082	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00088	85 c0		 test	 eax, eax
  0008a	0f 84 90 00 00
	00		 je	 $LN14@deflate_rl

; 2081 :             scan = s->window + s->strstart - 1;

  00090	4c 8b 53 50	 mov	 r10, QWORD PTR [rbx+80]
  00094	4c 03 d0	 add	 r10, rax
  00097	41 0f b6 52 ff	 movzx	 edx, BYTE PTR [r10-1]

; 2082 :             prev = *scan;
; 2083 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  0009c	41 3a 12	 cmp	 dl, BYTE PTR [r10]
  0009f	75 7f		 jne	 SHORT $LN14@deflate_rl
  000a1	41 3a 52 01	 cmp	 dl, BYTE PTR [r10+1]
  000a5	75 79		 jne	 SHORT $LN14@deflate_rl
  000a7	41 3a 52 02	 cmp	 dl, BYTE PTR [r10+2]
  000ab	49 8d 42 02	 lea	 rax, QWORD PTR [r10+2]
  000af	75 6f		 jne	 SHORT $LN14@deflate_rl

; 2084 :                 strend = s->window + s->strstart + MAX_MATCH;

  000b1	49 81 c2 02 01
	00 00		 add	 r10, 258		; 00000102H
$LL7@deflate_rl:

; 2085 :                 do {
; 2086 :                 } while (prev == *++scan && prev == *++scan &&
; 2087 :                          prev == *++scan && prev == *++scan &&
; 2088 :                          prev == *++scan && prev == *++scan &&
; 2089 :                          prev == *++scan && prev == *++scan &&

  000b8	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]
  000bb	3a 50 01	 cmp	 dl, BYTE PTR [rax+1]
  000be	75 40		 jne	 SHORT $LN13@deflate_rl
  000c0	48 8d 48 02	 lea	 rcx, QWORD PTR [rax+2]
  000c4	3a 50 02	 cmp	 dl, BYTE PTR [rax+2]
  000c7	75 37		 jne	 SHORT $LN13@deflate_rl
  000c9	8d 48 03	 lea	 ecx, DWORD PTR [rax+3]
  000cc	3a 50 03	 cmp	 dl, BYTE PTR [rax+3]
  000cf	75 2f		 jne	 SHORT $LN13@deflate_rl
  000d1	8d 48 04	 lea	 ecx, DWORD PTR [rax+4]
  000d4	3a 50 04	 cmp	 dl, BYTE PTR [rax+4]
  000d7	75 27		 jne	 SHORT $LN13@deflate_rl
  000d9	8d 48 05	 lea	 ecx, DWORD PTR [rax+5]
  000dc	3a 50 05	 cmp	 dl, BYTE PTR [rax+5]
  000df	75 1f		 jne	 SHORT $LN13@deflate_rl
  000e1	8d 48 06	 lea	 ecx, DWORD PTR [rax+6]
  000e4	3a 50 06	 cmp	 dl, BYTE PTR [rax+6]
  000e7	75 17		 jne	 SHORT $LN13@deflate_rl
  000e9	8d 48 07	 lea	 ecx, DWORD PTR [rax+7]
  000ec	3a 50 07	 cmp	 dl, BYTE PTR [rax+7]
  000ef	75 0f		 jne	 SHORT $LN13@deflate_rl
  000f1	48 83 c0 08	 add	 rax, 8
  000f5	8b c8		 mov	 ecx, eax
  000f7	3a 10		 cmp	 dl, BYTE PTR [rax]
  000f9	75 05		 jne	 SHORT $LN13@deflate_rl
  000fb	49 3b c2	 cmp	 rax, r10
  000fe	72 b8		 jb	 SHORT $LL7@deflate_rl
$LN13@deflate_rl:

; 2090 :                          scan < strend);
; 2091 :                 s->match_length = MAX_MATCH - (uInt)(strend - scan);

  00100	41 2b ca	 sub	 ecx, r10d
  00103	44 8d 81 02 01
	00 00		 lea	 r8d, DWORD PTR [rcx+258]
  0010a	44 89 83 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r8d

; 2092 :                 if (s->match_length > s->lookahead)

  00111	45 3b c1	 cmp	 r8d, r9d
  00114	76 0a		 jbe	 SHORT $LN14@deflate_rl

; 2093 :                     s->match_length = s->lookahead;

  00116	44 89 8b 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r9d
  0011d	45 8b c1	 mov	 r8d, r9d
$LN14@deflate_rl:

; 2094 :             }
; 2095 :             Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
; 2096 :         }
; 2097 : 
; 2098 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 2099 :         if (s->match_length >= MIN_MATCH) {

  00120	41 83 f8 03	 cmp	 r8d, 3
  00124	72 72		 jb	 SHORT $LN15@deflate_rl

; 2100 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 2101 : 
; 2102 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  00126	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0012c	41 80 e8 03	 sub	 r8b, 3
  00130	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00137	66 44 89 34 48	 mov	 WORD PTR [rax+rcx*2], r14w
  0013c	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00142	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00149	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  0014d	8b cf		 mov	 ecx, edi
  0014f	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00155	41 0f b6 c0	 movzx	 eax, r8b
  00159	42 0f b6 04 38	 movzx	 eax, BYTE PTR [rax+r15]
  0015e	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00166	66 ff 83 b0 09
	00 00		 inc	 WORD PTR [rbx+2480]
  0016d	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00173	ff c8		 dec	 eax
  00175	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2103 : 
; 2104 :             s->lookahead -= s->match_length;

  0017b	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  00181	0f 94 c1	 sete	 cl

; 2105 :             s->strstart += s->match_length;
; 2106 :             s->match_length = 0;

  00184	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  0018a	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax
  00190	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 2107 :         } else {

  00196	eb 5c		 jmp	 SHORT $LN47@deflate_rl
$LN15@deflate_rl:

; 2108 :             /* No match, output a literal byte */
; 2109 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 2110 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00198	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  0019e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001a2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001a6	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001ac	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001b3	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  001b7	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001bd	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001c4	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001c7	8b cf		 mov	 ecx, edi
  001c9	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001cf	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  001d7	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  001dd	ff c8		 dec	 eax
  001df	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  001e5	0f 94 c1	 sete	 cl

; 2111 :             s->lookahead--;

  001e8	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 2112 :             s->strstart++;

  001ee	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN47@deflate_rl:

; 2113 :         }
; 2114 :         if (bflush) FLUSH_BLOCK(s, 0);

  001f4	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  001fb	85 c9		 test	 ecx, ecx
  001fd	0f 84 2e fe ff
	ff		 je	 $LL2@deflate_rl
  00203	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00209	85 c0		 test	 eax, eax
  0020b	78 08		 js	 SHORT $LN26@deflate_rl
  0020d	8b d0		 mov	 edx, eax
  0020f	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00213	eb 03		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  00215	48 8b d7	 mov	 rdx, rdi
$LN27@deflate_rl:
  00218	44 2b c0	 sub	 r8d, eax
  0021b	45 33 c9	 xor	 r9d, r9d
  0021e	48 8b cb	 mov	 rcx, rbx
  00221	e8 00 00 00 00	 call	 _tr_flush_block
  00226	8b 06		 mov	 eax, DWORD PTR [rsi]
  00228	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0022b	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00231	e8 00 00 00 00	 call	 flush_pending
  00236	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00239	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0023c	0f 84 b6 00 00
	00		 je	 $LN37@deflate_rl
  00242	48 8d b3 94 00
	00 00		 lea	 rsi, QWORD PTR [rbx+148]

; 2115 :     }

  00249	e9 e3 fd ff ff	 jmp	 $LL2@deflate_rl
$LN36@deflate_rl:

; 2116 :     s->insert = 0;

  0024e	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 2117 :     if (flush == Z_FINISH) {

  00254	83 fd 04	 cmp	 ebp, 4
  00257	75 4d		 jne	 SHORT $LN19@deflate_rl

; 2118 :         FLUSH_BLOCK(s, 1);

  00259	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0025f	85 c0		 test	 eax, eax
  00261	78 08		 js	 SHORT $LN28@deflate_rl
  00263	8b d0		 mov	 edx, eax
  00265	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00269	eb 03		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  0026b	48 8b d7	 mov	 rdx, rdi
$LN29@deflate_rl:
  0026e	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00275	45 8b ce	 mov	 r9d, r14d
  00278	44 2b c0	 sub	 r8d, eax
  0027b	48 8b cb	 mov	 rcx, rbx
  0027e	e8 00 00 00 00	 call	 _tr_flush_block
  00283	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00289	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0028c	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00292	e8 00 00 00 00	 call	 flush_pending
  00297	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0029a	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0029d	40 0f 95 c7	 setne	 dil
  002a1	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2119 :         return finish_done;

  002a4	eb 54		 jmp	 SHORT $LN1@deflate_rl
$LN19@deflate_rl:

; 2120 :     }
; 2121 :     if (s->last_lit)

  002a6	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  002ac	74 45		 je	 SHORT $LN22@deflate_rl

; 2122 :         FLUSH_BLOCK(s, 0);

  002ae	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002b4	85 c0		 test	 eax, eax
  002b6	78 06		 js	 SHORT $LN30@deflate_rl
  002b8	8b f8		 mov	 edi, eax
  002ba	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN30@deflate_rl:
  002be	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002c5	45 33 c9	 xor	 r9d, r9d
  002c8	44 2b c0	 sub	 r8d, eax
  002cb	48 8b d7	 mov	 rdx, rdi
  002ce	48 8b cb	 mov	 rcx, rbx
  002d1	e8 00 00 00 00	 call	 _tr_flush_block
  002d6	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  002dc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002df	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  002e5	e8 00 00 00 00	 call	 flush_pending
  002ea	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002ed	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002f1	74 05		 je	 SHORT $LN37@deflate_rl
$LN22@deflate_rl:

; 2123 :     return block_done;

  002f3	41 8b c6	 mov	 eax, r14d
  002f6	eb 02		 jmp	 SHORT $LN1@deflate_rl
$LN37@deflate_rl:

; 2113 :         }
; 2114 :         if (bflush) FLUSH_BLOCK(s, 0);

  002f8	33 c0		 xor	 eax, eax
$LN1@deflate_rl:

; 2124 : }

  002fa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  002ff	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00304	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00309	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0030d	41 5f		 pop	 r15
  0030f	41 5e		 pop	 r14
  00311	5f		 pop	 rdi
  00312	c3		 ret	 0
deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\CPython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_huff
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_huff PROC					; COMDAT

; 2133 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	33 ff		 xor	 edi, edi
$LL2@deflate_hu:

; 2134 :     int bflush;             /* set if current block must be flushed */
; 2135 : 
; 2136 :     for (;;) {
; 2137 :         /* Make sure that we have a literal to write. */
; 2138 :         if (s->lookahead == 0) {

  00016	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0001c	75 14		 jne	 SHORT $LN6@deflate_hu

; 2139 :             fill_window(s);

  0001e	48 8b cb	 mov	 rcx, rbx
  00021	e8 00 00 00 00	 call	 fill_window

; 2140 :             if (s->lookahead == 0) {

  00026	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0002c	0f 84 c3 00 00
	00		 je	 $LN23@deflate_hu
$LN6@deflate_hu:

; 2142 :                     return need_more;
; 2143 :                 break;      /* flush the current block */
; 2144 :             }
; 2145 :         }
; 2146 : 
; 2147 :         /* Output a literal byte */
; 2148 :         s->match_length = 0;
; 2149 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 2150 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00032	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00038	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0003c	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00042	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00046	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0004c	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00053	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00057	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0005d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0006d	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2151 :         s->lookahead--;
; 2152 :         s->strstart++;

  00075	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0007c	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00082	41 ff c0	 inc	 r8d
  00085	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  0008b	ff c8		 dec	 eax
  0008d	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00094	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2153 :         if (bflush) FLUSH_BLOCK(s, 0);

  0009a	0f 85 76 ff ff
	ff		 jne	 $LL2@deflate_hu
  000a0	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000a6	85 c0		 test	 eax, eax
  000a8	78 08		 js	 SHORT $LN15@deflate_hu
  000aa	8b d0		 mov	 edx, eax
  000ac	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000b0	eb 03		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  000b2	48 8b d7	 mov	 rdx, rdi
$LN16@deflate_hu:
  000b5	44 2b c0	 sub	 r8d, eax
  000b8	45 33 c9	 xor	 r9d, r9d
  000bb	48 8b cb	 mov	 rcx, rbx
  000be	e8 00 00 00 00	 call	 _tr_flush_block
  000c3	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000c9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000cc	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  000d2	e8 00 00 00 00	 call	 flush_pending
  000d7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000da	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  000dd	0f 85 33 ff ff
	ff		 jne	 $LL2@deflate_hu
$LN24@deflate_hu:
  000e3	33 c0		 xor	 eax, eax

; 2162 :     return block_done;
; 2163 : }

  000e5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ea	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ef	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
$LN23@deflate_hu:

; 2141 :                 if (flush == Z_NO_FLUSH)

  000f5	85 f6		 test	 esi, esi
  000f7	74 ea		 je	 SHORT $LN24@deflate_hu

; 2154 :     }
; 2155 :     s->insert = 0;

  000f9	89 bb 0c 17 00
	00		 mov	 DWORD PTR [rbx+5900], edi

; 2156 :     if (flush == Z_FINISH) {

  000ff	83 fe 04	 cmp	 esi, 4
  00102	75 5e		 jne	 SHORT $LN10@deflate_hu

; 2157 :         FLUSH_BLOCK(s, 1);

  00104	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0010a	85 c0		 test	 eax, eax
  0010c	78 08		 js	 SHORT $LN17@deflate_hu
  0010e	8b d0		 mov	 edx, eax
  00110	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00114	eb 03		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  00116	48 8b d7	 mov	 rdx, rdi
$LN18@deflate_hu:
  00119	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00120	41 b9 01 00 00
	00		 mov	 r9d, 1
  00126	44 2b c0	 sub	 r8d, eax
  00129	48 8b cb	 mov	 rcx, rbx
  0012c	e8 00 00 00 00	 call	 _tr_flush_block
  00131	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00137	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0013a	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00140	e8 00 00 00 00	 call	 flush_pending
  00145	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00148	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  0014b	40 0f 95 c7	 setne	 dil
  0014f	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2162 :     return block_done;
; 2163 : }

  00152	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00157	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0015c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00160	5f		 pop	 rdi
  00161	c3		 ret	 0
$LN10@deflate_hu:

; 2158 :         return finish_done;
; 2159 :     }
; 2160 :     if (s->last_lit)

  00162	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  00168	74 49		 je	 SHORT $LN13@deflate_hu

; 2161 :         FLUSH_BLOCK(s, 0);

  0016a	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00170	85 c0		 test	 eax, eax
  00172	78 06		 js	 SHORT $LN19@deflate_hu
  00174	8b f8		 mov	 edi, eax
  00176	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN19@deflate_hu:
  0017a	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00181	45 33 c9	 xor	 r9d, r9d
  00184	44 2b c0	 sub	 r8d, eax
  00187	48 8b d7	 mov	 rdx, rdi
  0018a	48 8b cb	 mov	 rcx, rbx
  0018d	e8 00 00 00 00	 call	 _tr_flush_block
  00192	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00198	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0019b	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  001a1	e8 00 00 00 00	 call	 flush_pending
  001a6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a9	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001ad	0f 84 30 ff ff
	ff		 je	 $LN24@deflate_hu
$LN13@deflate_hu:

; 2162 :     return block_done;
; 2163 : }

  001b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c6	5f		 pop	 rdi
  001c7	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
